var ve = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Oi(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function p2(t) {
  if (t.__esModule)
    return t;
  var e = t.default;
  if (typeof e == "function") {
    var r = function n() {
      if (this instanceof n) {
        var i = [null];
        i.push.apply(i, arguments);
        var a = Function.bind.apply(e, i);
        return new a();
      }
      return e.apply(this, arguments);
    };
    r.prototype = e.prototype;
  } else
    r = {};
  return Object.defineProperty(r, "__esModule", { value: !0 }), Object.keys(t).forEach(function(n) {
    var i = Object.getOwnPropertyDescriptor(t, n);
    Object.defineProperty(r, n, i.get ? i : {
      enumerable: !0,
      get: function() {
        return t[n];
      }
    });
  }), r;
}
var lm = { exports: {} }, pm = { exports: {} };
/*!
 * depd
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var tr = I8;
function I8(t) {
  if (!t)
    throw new TypeError("argument namespace is required");
  function e(r) {
  }
  return e._file = void 0, e._ignored = !0, e._namespace = t, e._traced = !1, e._warned = /* @__PURE__ */ Object.create(null), e.function = k8, e.property = R8, e;
}
function k8(t, e) {
  if (typeof t != "function")
    throw new TypeError("argument fn must be a function");
  return t;
}
function R8(t, e, r) {
  if (!t || typeof t != "object" && typeof t != "function")
    throw new TypeError("argument obj must be object");
  var n = Object.getOwnPropertyDescriptor(t, e);
  if (!n)
    throw new TypeError("must call property on owner object");
  if (!n.configurable)
    throw new TypeError("property must be configurable");
}
var Xi = { exports: {} };
/*!
 * bytes
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015 Jed Watson
 * MIT Licensed
 */
var ky;
function vr() {
  if (ky)
    return Xi.exports;
  ky = 1, Xi.exports = i, Xi.exports.format = a, Xi.exports.parse = s;
  var t = /\B(?=(\d{3})+(?!\d))/g, e = /(?:\.0*|(\.[^0]+)0+)$/, r = {
    b: 1,
    kb: 1024,
    mb: 1 << 20,
    gb: 1 << 30,
    tb: Math.pow(1024, 4),
    pb: Math.pow(1024, 5)
  }, n = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
  function i(o, c) {
    return typeof o == "string" ? s(o) : typeof o == "number" ? a(o, c) : null;
  }
  function a(o, c) {
    if (!Number.isFinite(o))
      return null;
    var f = Math.abs(o), u = c && c.thousandsSeparator || "", l = c && c.unitSeparator || "", p = c && c.decimalPlaces !== void 0 ? c.decimalPlaces : 2, m = !!(c && c.fixedDecimals), h = c && c.unit || "";
    (!h || !r[h.toLowerCase()]) && (f >= r.pb ? h = "PB" : f >= r.tb ? h = "TB" : f >= r.gb ? h = "GB" : f >= r.mb ? h = "MB" : f >= r.kb ? h = "KB" : h = "B");
    var g = o / r[h.toLowerCase()], v = g.toFixed(p);
    return m || (v = v.replace(e, "$1")), u && (v = v.split(".").map(function(d, y) {
      return y === 0 ? d.replace(t, u) : d;
    }).join(".")), v + l + h;
  }
  function s(o) {
    if (typeof o == "number" && !isNaN(o))
      return o;
    if (typeof o != "string")
      return null;
    var c = n.exec(o), f, u = "b";
    return c ? (f = parseFloat(c[1]), u = c[4].toLowerCase()) : (f = parseInt(o, 10), u = "b"), isNaN(f) ? null : Math.floor(r[u] * f);
  }
  return Xi.exports;
}
var $s = {};
/*!
 * content-type
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var Ry;
function An() {
  if (Ry)
    return $s;
  Ry = 1;
  var t = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g, e = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/, r = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/, n = /\\([\u000b\u0020-\u00ff])/g, i = /([\\"])/g, a = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
  $s.format = s, $s.parse = o;
  function s(l) {
    if (!l || typeof l != "object")
      throw new TypeError("argument obj is required");
    var p = l.parameters, m = l.type;
    if (!m || !a.test(m))
      throw new TypeError("invalid type");
    var h = m;
    if (p && typeof p == "object")
      for (var g, v = Object.keys(p).sort(), d = 0; d < v.length; d++) {
        if (g = v[d], !r.test(g))
          throw new TypeError("invalid parameter name");
        h += "; " + g + "=" + f(p[g]);
      }
    return h;
  }
  function o(l) {
    if (!l)
      throw new TypeError("argument string is required");
    var p = typeof l == "object" ? c(l) : l;
    if (typeof p != "string")
      throw new TypeError("argument string is required to be a string");
    var m = p.indexOf(";"), h = m !== -1 ? p.slice(0, m).trim() : p.trim();
    if (!a.test(h))
      throw new TypeError("invalid media type");
    var g = new u(h.toLowerCase());
    if (m !== -1) {
      var v, d, y;
      for (t.lastIndex = m; d = t.exec(p); ) {
        if (d.index !== m)
          throw new TypeError("invalid parameter format");
        m += d[0].length, v = d[1].toLowerCase(), y = d[2], y.charCodeAt(0) === 34 && (y = y.slice(1, -1), y.indexOf("\\") !== -1 && (y = y.replace(n, "$1"))), g.parameters[v] = y;
      }
      if (m !== p.length)
        throw new TypeError("invalid parameter format");
    }
    return g;
  }
  function c(l) {
    var p;
    if (typeof l.getHeader == "function" ? p = l.getHeader("content-type") : typeof l.headers == "object" && (p = l.headers && l.headers["content-type"]), typeof p != "string")
      throw new TypeError("content-type header is missing from object");
    return p;
  }
  function f(l) {
    var p = String(l);
    if (r.test(p))
      return p;
    if (p.length > 0 && !e.test(p))
      throw new TypeError("invalid parameter value");
    return '"' + p.replace(i, "\\$1") + '"';
  }
  function u(l) {
    this.parameters = /* @__PURE__ */ Object.create(null), this.type = l;
  }
  return $s;
}
var qu = { exports: {} }, vc = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? N8 : L8);
function N8(t, e) {
  return t.__proto__ = e, t;
}
function L8(t, e) {
  for (var r in e)
    Object.prototype.hasOwnProperty.call(t, r) || (t[r] = e[r]);
  return t;
}
const P8 = {
  100: "Continue",
  101: "Switching Protocols",
  102: "Processing",
  103: "Early Hints",
  200: "OK",
  201: "Created",
  202: "Accepted",
  203: "Non-Authoritative Information",
  204: "No Content",
  205: "Reset Content",
  206: "Partial Content",
  207: "Multi-Status",
  208: "Already Reported",
  226: "IM Used",
  300: "Multiple Choices",
  301: "Moved Permanently",
  302: "Found",
  303: "See Other",
  304: "Not Modified",
  305: "Use Proxy",
  307: "Temporary Redirect",
  308: "Permanent Redirect",
  400: "Bad Request",
  401: "Unauthorized",
  402: "Payment Required",
  403: "Forbidden",
  404: "Not Found",
  405: "Method Not Allowed",
  406: "Not Acceptable",
  407: "Proxy Authentication Required",
  408: "Request Timeout",
  409: "Conflict",
  410: "Gone",
  411: "Length Required",
  412: "Precondition Failed",
  413: "Payload Too Large",
  414: "URI Too Long",
  415: "Unsupported Media Type",
  416: "Range Not Satisfiable",
  417: "Expectation Failed",
  418: "I'm a Teapot",
  421: "Misdirected Request",
  422: "Unprocessable Entity",
  423: "Locked",
  424: "Failed Dependency",
  425: "Too Early",
  426: "Upgrade Required",
  428: "Precondition Required",
  429: "Too Many Requests",
  431: "Request Header Fields Too Large",
  451: "Unavailable For Legal Reasons",
  500: "Internal Server Error",
  501: "Not Implemented",
  502: "Bad Gateway",
  503: "Service Unavailable",
  504: "Gateway Timeout",
  505: "HTTP Version Not Supported",
  506: "Variant Also Negotiates",
  507: "Insufficient Storage",
  508: "Loop Detected",
  509: "Bandwidth Limit Exceeded",
  510: "Not Extended",
  511: "Network Authentication Required"
};
/*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var bg = P8, yc = Zt;
Zt.message = bg;
Zt.code = D8(bg);
Zt.codes = M8(bg);
Zt.redirect = {
  300: !0,
  301: !0,
  302: !0,
  303: !0,
  305: !0,
  307: !0,
  308: !0
};
Zt.empty = {
  204: !0,
  205: !0,
  304: !0
};
Zt.retry = {
  502: !0,
  503: !0,
  504: !0
};
function D8(t) {
  var e = {};
  return Object.keys(t).forEach(function(n) {
    var i = t[n], a = Number(n);
    e[i.toLowerCase()] = a;
  }), e;
}
function M8(t) {
  return Object.keys(t).map(function(r) {
    return Number(r);
  });
}
function q8(t) {
  var e = t.toLowerCase();
  if (!Object.prototype.hasOwnProperty.call(Zt.code, e))
    throw new Error('invalid status message: "' + t + '"');
  return Zt.code[e];
}
function Ny(t) {
  if (!Object.prototype.hasOwnProperty.call(Zt.message, t))
    throw new Error("invalid status code: " + t);
  return Zt.message[t];
}
function Zt(t) {
  if (typeof t == "number")
    return Ny(t);
  if (typeof t != "string")
    throw new TypeError("code must be a number or string");
  var e = parseInt(t, 10);
  return isNaN(e) ? q8(t) : Ny(e);
}
var Is = { exports: {} }, Ly;
function ct() {
  return Ly || (Ly = 1, typeof Object.create == "function" ? Is.exports = function(e, r) {
    r && (e.super_ = r, e.prototype = Object.create(r.prototype, {
      constructor: {
        value: e,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : Is.exports = function(e, r) {
    if (r) {
      e.super_ = r;
      var n = function() {
      };
      n.prototype = r.prototype, e.prototype = new n(), e.prototype.constructor = e;
    }
  }), Is.exports;
}
/*!
 * toidentifier
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var ju, Py;
function j8() {
  if (Py)
    return ju;
  Py = 1, ju = t;
  function t(e) {
    return e.split(" ").map(function(r) {
      return r.slice(0, 1).toUpperCase() + r.slice(1);
    }).join("").replace(/[^ _0-9a-z]/gi, "");
  }
  return ju;
}
/*!
 * http-errors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var Dy;
function yr() {
  return Dy || (Dy = 1, function(t) {
    tr("http-errors");
    var e = vc, r = yc, n = ct(), i = j8();
    t.exports = s, t.exports.HttpError = o(), t.exports.isHttpError = f(t.exports.HttpError), p(t.exports, r.codes, t.exports.HttpError);
    function a(h) {
      return +(String(h).charAt(0) + "00");
    }
    function s() {
      for (var h, g, v = 500, d = {}, y = 0; y < arguments.length; y++) {
        var x = arguments[y], b = typeof x;
        if (b === "object" && x instanceof Error)
          h = x, v = h.status || h.statusCode || v;
        else if (b === "number" && y === 0)
          v = x;
        else if (b === "string")
          g = x;
        else if (b === "object")
          d = x;
        else
          throw new TypeError("argument #" + (y + 1) + " unsupported type " + b);
      }
      (typeof v != "number" || !r.message[v] && (v < 400 || v >= 600)) && (v = 500);
      var w = s[v] || s[a(v)];
      h || (h = w ? new w(g) : new Error(g || r.message[v]), Error.captureStackTrace(h, s)), (!w || !(h instanceof w) || h.status !== v) && (h.expose = v < 500, h.status = h.statusCode = v);
      for (var S in d)
        S !== "status" && S !== "statusCode" && (h[S] = d[S]);
      return h;
    }
    function o() {
      function h() {
        throw new TypeError("cannot construct abstract class");
      }
      return n(h, Error), h;
    }
    function c(h, g, v) {
      var d = m(g);
      function y(x) {
        var b = x ?? r.message[v], w = new Error(b);
        return Error.captureStackTrace(w, y), e(w, y.prototype), Object.defineProperty(w, "message", {
          enumerable: !0,
          configurable: !0,
          value: b,
          writable: !0
        }), Object.defineProperty(w, "name", {
          enumerable: !1,
          configurable: !0,
          value: d,
          writable: !0
        }), w;
      }
      return n(y, h), l(y, d), y.prototype.status = v, y.prototype.statusCode = v, y.prototype.expose = !0, y;
    }
    function f(h) {
      return function(v) {
        return !v || typeof v != "object" ? !1 : v instanceof h ? !0 : v instanceof Error && typeof v.expose == "boolean" && typeof v.statusCode == "number" && v.status === v.statusCode;
      };
    }
    function u(h, g, v) {
      var d = m(g);
      function y(x) {
        var b = x ?? r.message[v], w = new Error(b);
        return Error.captureStackTrace(w, y), e(w, y.prototype), Object.defineProperty(w, "message", {
          enumerable: !0,
          configurable: !0,
          value: b,
          writable: !0
        }), Object.defineProperty(w, "name", {
          enumerable: !1,
          configurable: !0,
          value: d,
          writable: !0
        }), w;
      }
      return n(y, h), l(y, d), y.prototype.status = v, y.prototype.statusCode = v, y.prototype.expose = !1, y;
    }
    function l(h, g) {
      var v = Object.getOwnPropertyDescriptor(h, "name");
      v && v.configurable && (v.value = g, Object.defineProperty(h, "name", v));
    }
    function p(h, g, v) {
      g.forEach(function(y) {
        var x, b = i(r.message[y]);
        switch (a(y)) {
          case 400:
            x = c(v, b, y);
            break;
          case 500:
            x = u(v, b, y);
            break;
        }
        x && (h[y] = x, h[b] = x);
      });
    }
    function m(h) {
      return h.substr(-5) !== "Error" ? h + "Error" : h;
    }
  }(qu)), qu.exports;
}
var fm = { exports: {} }, hm = { exports: {} }, xa = 1e3, _a = xa * 60, Ea = _a * 60, Sa = Ea * 24, F8 = Sa * 365.25, B8 = function(t, e) {
  e = e || {};
  var r = typeof t;
  if (r === "string" && t.length > 0)
    return U8(t);
  if (r === "number" && isNaN(t) === !1)
    return e.long ? H8(t) : z8(t);
  throw new Error(
    "val is not a non-empty string or a valid number. val=" + JSON.stringify(t)
  );
};
function U8(t) {
  if (t = String(t), !(t.length > 100)) {
    var e = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
      t
    );
    if (e) {
      var r = parseFloat(e[1]), n = (e[2] || "ms").toLowerCase();
      switch (n) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return r * F8;
        case "days":
        case "day":
        case "d":
          return r * Sa;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return r * Ea;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return r * _a;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return r * xa;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return r;
        default:
          return;
      }
    }
  }
}
function z8(t) {
  return t >= Sa ? Math.round(t / Sa) + "d" : t >= Ea ? Math.round(t / Ea) + "h" : t >= _a ? Math.round(t / _a) + "m" : t >= xa ? Math.round(t / xa) + "s" : t + "ms";
}
function H8(t) {
  return ks(t, Sa, "day") || ks(t, Ea, "hour") || ks(t, _a, "minute") || ks(t, xa, "second") || t + " ms";
}
function ks(t, e, r) {
  if (!(t < e))
    return t < e * 1.5 ? Math.floor(t / e) + " " + r : Math.ceil(t / e) + " " + r + "s";
}
(function(t, e) {
  e = t.exports = i.debug = i.default = i, e.coerce = c, e.disable = s, e.enable = a, e.enabled = o, e.humanize = B8, e.names = [], e.skips = [], e.formatters = {};
  var r;
  function n(f) {
    var u = 0, l;
    for (l in f)
      u = (u << 5) - u + f.charCodeAt(l), u |= 0;
    return e.colors[Math.abs(u) % e.colors.length];
  }
  function i(f) {
    function u() {
      if (u.enabled) {
        var l = u, p = +/* @__PURE__ */ new Date(), m = p - (r || p);
        l.diff = m, l.prev = r, l.curr = p, r = p;
        for (var h = new Array(arguments.length), g = 0; g < h.length; g++)
          h[g] = arguments[g];
        h[0] = e.coerce(h[0]), typeof h[0] != "string" && h.unshift("%O");
        var v = 0;
        h[0] = h[0].replace(/%([a-zA-Z%])/g, function(y, x) {
          if (y === "%%")
            return y;
          v++;
          var b = e.formatters[x];
          if (typeof b == "function") {
            var w = h[v];
            y = b.call(l, w), h.splice(v, 1), v--;
          }
          return y;
        }), e.formatArgs.call(l, h);
        var d = u.log || e.log || console.log.bind(console);
        d.apply(l, h);
      }
    }
    return u.namespace = f, u.enabled = e.enabled(f), u.useColors = e.useColors(), u.color = n(f), typeof e.init == "function" && e.init(u), u;
  }
  function a(f) {
    e.save(f), e.names = [], e.skips = [];
    for (var u = (typeof f == "string" ? f : "").split(/[\s,]+/), l = u.length, p = 0; p < l; p++)
      u[p] && (f = u[p].replace(/\*/g, ".*?"), f[0] === "-" ? e.skips.push(new RegExp("^" + f.substr(1) + "$")) : e.names.push(new RegExp("^" + f + "$")));
  }
  function s() {
    e.enable("");
  }
  function o(f) {
    var u, l;
    for (u = 0, l = e.skips.length; u < l; u++)
      if (e.skips[u].test(f))
        return !1;
    for (u = 0, l = e.names.length; u < l; u++)
      if (e.names[u].test(f))
        return !0;
    return !1;
  }
  function c(f) {
    return f instanceof Error ? f.stack || f.message : f;
  }
})(hm, hm.exports);
var W8 = hm.exports;
(function(t, e) {
  e = t.exports = W8, e.log = i, e.formatArgs = n, e.save = a, e.load = s, e.useColors = r, e.storage = typeof chrome < "u" && typeof chrome.storage < "u" ? chrome.storage.local : o(), e.colors = [
    "lightseagreen",
    "forestgreen",
    "goldenrod",
    "dodgerblue",
    "darkorchid",
    "crimson"
  ];
  function r() {
    return typeof window < "u" && window.process && window.process.type === "renderer" ? !0 : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  e.formatters.j = function(c) {
    try {
      return JSON.stringify(c);
    } catch (f) {
      return "[UnexpectedJSONParseError]: " + f.message;
    }
  };
  function n(c) {
    var f = this.useColors;
    if (c[0] = (f ? "%c" : "") + this.namespace + (f ? " %c" : " ") + c[0] + (f ? "%c " : " ") + "+" + e.humanize(this.diff), !!f) {
      var u = "color: " + this.color;
      c.splice(1, 0, u, "color: inherit");
      var l = 0, p = 0;
      c[0].replace(/%[a-zA-Z%]/g, function(m) {
        m !== "%%" && (l++, m === "%c" && (p = l));
      }), c.splice(p, 0, u);
    }
  }
  function i() {
    return typeof console == "object" && console.log && Function.prototype.apply.call(console.log, console, arguments);
  }
  function a(c) {
    try {
      c == null ? e.storage.removeItem("debug") : e.storage.debug = c;
    } catch {
    }
  }
  function s() {
    var c;
    try {
      c = e.storage.debug;
    } catch {
    }
    return !c && typeof process < "u" && "env" in process && (c = process.env.DEBUG), c;
  }
  e.enable(s());
  function o() {
    try {
      return window.localStorage;
    } catch {
    }
  }
})(fm, fm.exports);
var Mr = fm.exports, wg = { exports: {} }, li = typeof Reflect == "object" ? Reflect : null, My = li && typeof li.apply == "function" ? li.apply : function(e, r, n) {
  return Function.prototype.apply.call(e, r, n);
}, vo;
li && typeof li.ownKeys == "function" ? vo = li.ownKeys : Object.getOwnPropertySymbols ? vo = function(e) {
  return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
} : vo = function(e) {
  return Object.getOwnPropertyNames(e);
};
function G8(t) {
  console && console.warn && console.warn(t);
}
var f2 = Number.isNaN || function(e) {
  return e !== e;
};
function qe() {
  qe.init.call(this);
}
wg.exports = qe;
wg.exports.once = J8;
qe.EventEmitter = qe;
qe.prototype._events = void 0;
qe.prototype._eventsCount = 0;
qe.prototype._maxListeners = void 0;
var qy = 10;
function bc(t) {
  if (typeof t != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t);
}
Object.defineProperty(qe, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return qy;
  },
  set: function(t) {
    if (typeof t != "number" || t < 0 || f2(t))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + ".");
    qy = t;
  }
});
qe.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
qe.prototype.setMaxListeners = function(e) {
  if (typeof e != "number" || e < 0 || f2(e))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
  return this._maxListeners = e, this;
};
function h2(t) {
  return t._maxListeners === void 0 ? qe.defaultMaxListeners : t._maxListeners;
}
qe.prototype.getMaxListeners = function() {
  return h2(this);
};
qe.prototype.emit = function(e) {
  for (var r = [], n = 1; n < arguments.length; n++)
    r.push(arguments[n]);
  var i = e === "error", a = this._events;
  if (a !== void 0)
    i = i && a.error === void 0;
  else if (!i)
    return !1;
  if (i) {
    var s;
    if (r.length > 0 && (s = r[0]), s instanceof Error)
      throw s;
    var o = new Error("Unhandled error." + (s ? " (" + s.message + ")" : ""));
    throw o.context = s, o;
  }
  var c = a[e];
  if (c === void 0)
    return !1;
  if (typeof c == "function")
    My(c, this, r);
  else
    for (var f = c.length, u = y2(c, f), n = 0; n < f; ++n)
      My(u[n], this, r);
  return !0;
};
function d2(t, e, r, n) {
  var i, a, s;
  if (bc(r), a = t._events, a === void 0 ? (a = t._events = /* @__PURE__ */ Object.create(null), t._eventsCount = 0) : (a.newListener !== void 0 && (t.emit(
    "newListener",
    e,
    r.listener ? r.listener : r
  ), a = t._events), s = a[e]), s === void 0)
    s = a[e] = r, ++t._eventsCount;
  else if (typeof s == "function" ? s = a[e] = n ? [r, s] : [s, r] : n ? s.unshift(r) : s.push(r), i = h2(t), i > 0 && s.length > i && !s.warned) {
    s.warned = !0;
    var o = new Error("Possible EventEmitter memory leak detected. " + s.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    o.name = "MaxListenersExceededWarning", o.emitter = t, o.type = e, o.count = s.length, G8(o);
  }
  return t;
}
qe.prototype.addListener = function(e, r) {
  return d2(this, e, r, !1);
};
qe.prototype.on = qe.prototype.addListener;
qe.prototype.prependListener = function(e, r) {
  return d2(this, e, r, !0);
};
function Q8() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function m2(t, e, r) {
  var n = { fired: !1, wrapFn: void 0, target: t, type: e, listener: r }, i = Q8.bind(n);
  return i.listener = r, n.wrapFn = i, i;
}
qe.prototype.once = function(e, r) {
  return bc(r), this.on(e, m2(this, e, r)), this;
};
qe.prototype.prependOnceListener = function(e, r) {
  return bc(r), this.prependListener(e, m2(this, e, r)), this;
};
qe.prototype.removeListener = function(e, r) {
  var n, i, a, s, o;
  if (bc(r), i = this._events, i === void 0)
    return this;
  if (n = i[e], n === void 0)
    return this;
  if (n === r || n.listener === r)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete i[e], i.removeListener && this.emit("removeListener", e, n.listener || r));
  else if (typeof n != "function") {
    for (a = -1, s = n.length - 1; s >= 0; s--)
      if (n[s] === r || n[s].listener === r) {
        o = n[s].listener, a = s;
        break;
      }
    if (a < 0)
      return this;
    a === 0 ? n.shift() : V8(n, a), n.length === 1 && (i[e] = n[0]), i.removeListener !== void 0 && this.emit("removeListener", e, o || r);
  }
  return this;
};
qe.prototype.off = qe.prototype.removeListener;
qe.prototype.removeAllListeners = function(e) {
  var r, n, i;
  if (n = this._events, n === void 0)
    return this;
  if (n.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : n[e] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete n[e]), this;
  if (arguments.length === 0) {
    var a = Object.keys(n), s;
    for (i = 0; i < a.length; ++i)
      s = a[i], s !== "removeListener" && this.removeAllListeners(s);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (r = n[e], typeof r == "function")
    this.removeListener(e, r);
  else if (r !== void 0)
    for (i = r.length - 1; i >= 0; i--)
      this.removeListener(e, r[i]);
  return this;
};
function g2(t, e, r) {
  var n = t._events;
  if (n === void 0)
    return [];
  var i = n[e];
  return i === void 0 ? [] : typeof i == "function" ? r ? [i.listener || i] : [i] : r ? K8(i) : y2(i, i.length);
}
qe.prototype.listeners = function(e) {
  return g2(this, e, !0);
};
qe.prototype.rawListeners = function(e) {
  return g2(this, e, !1);
};
qe.listenerCount = function(t, e) {
  return typeof t.listenerCount == "function" ? t.listenerCount(e) : v2.call(t, e);
};
qe.prototype.listenerCount = v2;
function v2(t) {
  var e = this._events;
  if (e !== void 0) {
    var r = e[t];
    if (typeof r == "function")
      return 1;
    if (r !== void 0)
      return r.length;
  }
  return 0;
}
qe.prototype.eventNames = function() {
  return this._eventsCount > 0 ? vo(this._events) : [];
};
function y2(t, e) {
  for (var r = new Array(e), n = 0; n < e; ++n)
    r[n] = t[n];
  return r;
}
function V8(t, e) {
  for (; e + 1 < t.length; e++)
    t[e] = t[e + 1];
  t.pop();
}
function K8(t) {
  for (var e = new Array(t.length), r = 0; r < e.length; ++r)
    e[r] = t[r].listener || t[r];
  return e;
}
function J8(t, e) {
  return new Promise(function(r, n) {
    function i(s) {
      t.removeListener(e, a), n(s);
    }
    function a() {
      typeof t.removeListener == "function" && t.removeListener("error", i), r([].slice.call(arguments));
    }
    b2(t, e, a, { once: !0 }), e !== "error" && X8(t, i, { once: !0 });
  });
}
function X8(t, e, r) {
  typeof t.on == "function" && b2(t, "error", e, r);
}
function b2(t, e, r, n) {
  if (typeof t.on == "function")
    n.once ? t.once(e, r) : t.on(e, r);
  else if (typeof t.addEventListener == "function")
    t.addEventListener(e, function i(a) {
      n.once && t.removeEventListener(e, i), r(a);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t);
}
var bt = wg.exports;
const mr = {}, Z8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: mr
}, Symbol.toStringTag, { value: "Module" })), se = /* @__PURE__ */ p2(Z8);
/*!
 * destroy
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var Fu, jy;
function xg() {
  if (jy)
    return Fu;
  jy = 1;
  var t = bt.EventEmitter, e = se.ReadStream, r = se, n = se;
  Fu = i;
  function i(g, v) {
    return u(g) ? a(g) : l(g) ? o(g) : c(g) && g.destroy(), f(g) && v && (g.removeAllListeners("error"), g.addListener("error", p)), g;
  }
  function a(g) {
    g.destroy(), typeof g.close == "function" && g.on("open", h);
  }
  function s(g) {
    if (g._hadError === !0) {
      var v = g._binding === null ? "_binding" : "_handle";
      g[v] = {
        close: function() {
          this[v] = null;
        }
      };
    }
    g.close();
  }
  function o(g) {
    typeof g.destroy == "function" ? g._binding ? (g.destroy(), g._processing ? (g._needDrain = !0, g.once("drain", m)) : g._binding.clear()) : g._destroy && g._destroy !== r.Transform.prototype._destroy ? g.destroy() : g._destroy && typeof g.close == "function" ? (g.destroyed = !0, g.close()) : g.destroy() : typeof g.close == "function" && s(g);
  }
  function c(g) {
    return g instanceof r && typeof g.destroy == "function";
  }
  function f(g) {
    return g instanceof t;
  }
  function u(g) {
    return g instanceof e;
  }
  function l(g) {
    return g instanceof n.Gzip || g instanceof n.Gunzip || g instanceof n.Deflate || g instanceof n.DeflateRaw || g instanceof n.Inflate || g instanceof n.InflateRaw || g instanceof n.Unzip;
  }
  function p() {
  }
  function m() {
    this._binding.clear();
  }
  function h() {
    typeof this.fd == "number" && this.close();
  }
  return Fu;
}
var Bu = { exports: {} }, rr = {}, wc = {};
wc.byteLength = tI;
wc.toByteArray = nI;
wc.fromByteArray = sI;
var hr = [], jt = [], Y8 = typeof Uint8Array < "u" ? Uint8Array : Array, Uu = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var Yn = 0, eI = Uu.length; Yn < eI; ++Yn)
  hr[Yn] = Uu[Yn], jt[Uu.charCodeAt(Yn)] = Yn;
jt["-".charCodeAt(0)] = 62;
jt["_".charCodeAt(0)] = 63;
function w2(t) {
  var e = t.length;
  if (e % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var r = t.indexOf("=");
  r === -1 && (r = e);
  var n = r === e ? 0 : 4 - r % 4;
  return [r, n];
}
function tI(t) {
  var e = w2(t), r = e[0], n = e[1];
  return (r + n) * 3 / 4 - n;
}
function rI(t, e, r) {
  return (e + r) * 3 / 4 - r;
}
function nI(t) {
  var e, r = w2(t), n = r[0], i = r[1], a = new Y8(rI(t, n, i)), s = 0, o = i > 0 ? n - 4 : n, c;
  for (c = 0; c < o; c += 4)
    e = jt[t.charCodeAt(c)] << 18 | jt[t.charCodeAt(c + 1)] << 12 | jt[t.charCodeAt(c + 2)] << 6 | jt[t.charCodeAt(c + 3)], a[s++] = e >> 16 & 255, a[s++] = e >> 8 & 255, a[s++] = e & 255;
  return i === 2 && (e = jt[t.charCodeAt(c)] << 2 | jt[t.charCodeAt(c + 1)] >> 4, a[s++] = e & 255), i === 1 && (e = jt[t.charCodeAt(c)] << 10 | jt[t.charCodeAt(c + 1)] << 4 | jt[t.charCodeAt(c + 2)] >> 2, a[s++] = e >> 8 & 255, a[s++] = e & 255), a;
}
function iI(t) {
  return hr[t >> 18 & 63] + hr[t >> 12 & 63] + hr[t >> 6 & 63] + hr[t & 63];
}
function aI(t, e, r) {
  for (var n, i = [], a = e; a < r; a += 3)
    n = (t[a] << 16 & 16711680) + (t[a + 1] << 8 & 65280) + (t[a + 2] & 255), i.push(iI(n));
  return i.join("");
}
function sI(t) {
  for (var e, r = t.length, n = r % 3, i = [], a = 16383, s = 0, o = r - n; s < o; s += a)
    i.push(aI(t, s, s + a > o ? o : s + a));
  return n === 1 ? (e = t[r - 1], i.push(
    hr[e >> 2] + hr[e << 4 & 63] + "=="
  )) : n === 2 && (e = (t[r - 2] << 8) + t[r - 1], i.push(
    hr[e >> 10] + hr[e >> 4 & 63] + hr[e << 2 & 63] + "="
  )), i.join("");
}
var _g = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
_g.read = function(t, e, r, n, i) {
  var a, s, o = i * 8 - n - 1, c = (1 << o) - 1, f = c >> 1, u = -7, l = r ? i - 1 : 0, p = r ? -1 : 1, m = t[e + l];
  for (l += p, a = m & (1 << -u) - 1, m >>= -u, u += o; u > 0; a = a * 256 + t[e + l], l += p, u -= 8)
    ;
  for (s = a & (1 << -u) - 1, a >>= -u, u += n; u > 0; s = s * 256 + t[e + l], l += p, u -= 8)
    ;
  if (a === 0)
    a = 1 - f;
  else {
    if (a === c)
      return s ? NaN : (m ? -1 : 1) * (1 / 0);
    s = s + Math.pow(2, n), a = a - f;
  }
  return (m ? -1 : 1) * s * Math.pow(2, a - n);
};
_g.write = function(t, e, r, n, i, a) {
  var s, o, c, f = a * 8 - i - 1, u = (1 << f) - 1, l = u >> 1, p = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, m = n ? 0 : a - 1, h = n ? 1 : -1, g = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
  for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (o = isNaN(e) ? 1 : 0, s = u) : (s = Math.floor(Math.log(e) / Math.LN2), e * (c = Math.pow(2, -s)) < 1 && (s--, c *= 2), s + l >= 1 ? e += p / c : e += p * Math.pow(2, 1 - l), e * c >= 2 && (s++, c /= 2), s + l >= u ? (o = 0, s = u) : s + l >= 1 ? (o = (e * c - 1) * Math.pow(2, i), s = s + l) : (o = e * Math.pow(2, l - 1) * Math.pow(2, i), s = 0)); i >= 8; t[r + m] = o & 255, m += h, o /= 256, i -= 8)
    ;
  for (s = s << i | o, f += i; f > 0; t[r + m] = s & 255, m += h, s /= 256, f -= 8)
    ;
  t[r + m - h] |= g * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(t) {
  var e = wc, r = _g, n = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  t.Buffer = o, t.SlowBuffer = y, t.INSPECT_MAX_BYTES = 50;
  var i = 2147483647;
  t.kMaxLength = i, o.TYPED_ARRAY_SUPPORT = a(), !o.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function a() {
    try {
      var j = new Uint8Array(1), k = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(k, Uint8Array.prototype), Object.setPrototypeOf(j, k), j.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(o.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (o.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(o.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (o.isBuffer(this))
        return this.byteOffset;
    }
  });
  function s(j) {
    if (j > i)
      throw new RangeError('The value "' + j + '" is invalid for option "size"');
    var k = new Uint8Array(j);
    return Object.setPrototypeOf(k, o.prototype), k;
  }
  function o(j, k, N) {
    if (typeof j == "number") {
      if (typeof k == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return l(j);
    }
    return c(j, k, N);
  }
  o.poolSize = 8192;
  function c(j, k, N) {
    if (typeof j == "string")
      return p(j, k);
    if (ArrayBuffer.isView(j))
      return h(j);
    if (j == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof j
      );
    if (Z(j, ArrayBuffer) || j && Z(j.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (Z(j, SharedArrayBuffer) || j && Z(j.buffer, SharedArrayBuffer)))
      return g(j, k, N);
    if (typeof j == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    var U = j.valueOf && j.valueOf();
    if (U != null && U !== j)
      return o.from(U, k, N);
    var ee = v(j);
    if (ee)
      return ee;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof j[Symbol.toPrimitive] == "function")
      return o.from(
        j[Symbol.toPrimitive]("string"),
        k,
        N
      );
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof j
    );
  }
  o.from = function(j, k, N) {
    return c(j, k, N);
  }, Object.setPrototypeOf(o.prototype, Uint8Array.prototype), Object.setPrototypeOf(o, Uint8Array);
  function f(j) {
    if (typeof j != "number")
      throw new TypeError('"size" argument must be of type number');
    if (j < 0)
      throw new RangeError('The value "' + j + '" is invalid for option "size"');
  }
  function u(j, k, N) {
    return f(j), j <= 0 ? s(j) : k !== void 0 ? typeof N == "string" ? s(j).fill(k, N) : s(j).fill(k) : s(j);
  }
  o.alloc = function(j, k, N) {
    return u(j, k, N);
  };
  function l(j) {
    return f(j), s(j < 0 ? 0 : d(j) | 0);
  }
  o.allocUnsafe = function(j) {
    return l(j);
  }, o.allocUnsafeSlow = function(j) {
    return l(j);
  };
  function p(j, k) {
    if ((typeof k != "string" || k === "") && (k = "utf8"), !o.isEncoding(k))
      throw new TypeError("Unknown encoding: " + k);
    var N = x(j, k) | 0, U = s(N), ee = U.write(j, k);
    return ee !== N && (U = U.slice(0, ee)), U;
  }
  function m(j) {
    for (var k = j.length < 0 ? 0 : d(j.length) | 0, N = s(k), U = 0; U < k; U += 1)
      N[U] = j[U] & 255;
    return N;
  }
  function h(j) {
    if (Z(j, Uint8Array)) {
      var k = new Uint8Array(j);
      return g(k.buffer, k.byteOffset, k.byteLength);
    }
    return m(j);
  }
  function g(j, k, N) {
    if (k < 0 || j.byteLength < k)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (j.byteLength < k + (N || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    var U;
    return k === void 0 && N === void 0 ? U = new Uint8Array(j) : N === void 0 ? U = new Uint8Array(j, k) : U = new Uint8Array(j, k, N), Object.setPrototypeOf(U, o.prototype), U;
  }
  function v(j) {
    if (o.isBuffer(j)) {
      var k = d(j.length) | 0, N = s(k);
      return N.length === 0 || j.copy(N, 0, 0, k), N;
    }
    if (j.length !== void 0)
      return typeof j.length != "number" || B(j.length) ? s(0) : m(j);
    if (j.type === "Buffer" && Array.isArray(j.data))
      return m(j.data);
  }
  function d(j) {
    if (j >= i)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes");
    return j | 0;
  }
  function y(j) {
    return +j != j && (j = 0), o.alloc(+j);
  }
  o.isBuffer = function(k) {
    return k != null && k._isBuffer === !0 && k !== o.prototype;
  }, o.compare = function(k, N) {
    if (Z(k, Uint8Array) && (k = o.from(k, k.offset, k.byteLength)), Z(N, Uint8Array) && (N = o.from(N, N.offset, N.byteLength)), !o.isBuffer(k) || !o.isBuffer(N))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (k === N)
      return 0;
    for (var U = k.length, ee = N.length, pe = 0, he = Math.min(U, ee); pe < he; ++pe)
      if (k[pe] !== N[pe]) {
        U = k[pe], ee = N[pe];
        break;
      }
    return U < ee ? -1 : ee < U ? 1 : 0;
  }, o.isEncoding = function(k) {
    switch (String(k).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, o.concat = function(k, N) {
    if (!Array.isArray(k))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (k.length === 0)
      return o.alloc(0);
    var U;
    if (N === void 0)
      for (N = 0, U = 0; U < k.length; ++U)
        N += k[U].length;
    var ee = o.allocUnsafe(N), pe = 0;
    for (U = 0; U < k.length; ++U) {
      var he = k[U];
      if (Z(he, Uint8Array))
        pe + he.length > ee.length ? o.from(he).copy(ee, pe) : Uint8Array.prototype.set.call(
          ee,
          he,
          pe
        );
      else if (o.isBuffer(he))
        he.copy(ee, pe);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      pe += he.length;
    }
    return ee;
  };
  function x(j, k) {
    if (o.isBuffer(j))
      return j.length;
    if (ArrayBuffer.isView(j) || Z(j, ArrayBuffer))
      return j.byteLength;
    if (typeof j != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof j
      );
    var N = j.length, U = arguments.length > 2 && arguments[2] === !0;
    if (!U && N === 0)
      return 0;
    for (var ee = !1; ; )
      switch (k) {
        case "ascii":
        case "latin1":
        case "binary":
          return N;
        case "utf8":
        case "utf-8":
          return I(j).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return N * 2;
        case "hex":
          return N >>> 1;
        case "base64":
          return q(j).length;
        default:
          if (ee)
            return U ? -1 : I(j).length;
          k = ("" + k).toLowerCase(), ee = !0;
      }
  }
  o.byteLength = x;
  function b(j, k, N) {
    var U = !1;
    if ((k === void 0 || k < 0) && (k = 0), k > this.length || ((N === void 0 || N > this.length) && (N = this.length), N <= 0) || (N >>>= 0, k >>>= 0, N <= k))
      return "";
    for (j || (j = "utf8"); ; )
      switch (j) {
        case "hex":
          return P(this, k, N);
        case "utf8":
        case "utf-8":
          return K(this, k, N);
        case "ascii":
          return $(this, k, N);
        case "latin1":
        case "binary":
          return L(this, k, N);
        case "base64":
          return F(this, k, N);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return H(this, k, N);
        default:
          if (U)
            throw new TypeError("Unknown encoding: " + j);
          j = (j + "").toLowerCase(), U = !0;
      }
  }
  o.prototype._isBuffer = !0;
  function w(j, k, N) {
    var U = j[k];
    j[k] = j[N], j[N] = U;
  }
  o.prototype.swap16 = function() {
    var k = this.length;
    if (k % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (var N = 0; N < k; N += 2)
      w(this, N, N + 1);
    return this;
  }, o.prototype.swap32 = function() {
    var k = this.length;
    if (k % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (var N = 0; N < k; N += 4)
      w(this, N, N + 3), w(this, N + 1, N + 2);
    return this;
  }, o.prototype.swap64 = function() {
    var k = this.length;
    if (k % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (var N = 0; N < k; N += 8)
      w(this, N, N + 7), w(this, N + 1, N + 6), w(this, N + 2, N + 5), w(this, N + 3, N + 4);
    return this;
  }, o.prototype.toString = function() {
    var k = this.length;
    return k === 0 ? "" : arguments.length === 0 ? K(this, 0, k) : b.apply(this, arguments);
  }, o.prototype.toLocaleString = o.prototype.toString, o.prototype.equals = function(k) {
    if (!o.isBuffer(k))
      throw new TypeError("Argument must be a Buffer");
    return this === k ? !0 : o.compare(this, k) === 0;
  }, o.prototype.inspect = function() {
    var k = "", N = t.INSPECT_MAX_BYTES;
    return k = this.toString("hex", 0, N).replace(/(.{2})/g, "$1 ").trim(), this.length > N && (k += " ... "), "<Buffer " + k + ">";
  }, n && (o.prototype[n] = o.prototype.inspect), o.prototype.compare = function(k, N, U, ee, pe) {
    if (Z(k, Uint8Array) && (k = o.from(k, k.offset, k.byteLength)), !o.isBuffer(k))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof k
      );
    if (N === void 0 && (N = 0), U === void 0 && (U = k ? k.length : 0), ee === void 0 && (ee = 0), pe === void 0 && (pe = this.length), N < 0 || U > k.length || ee < 0 || pe > this.length)
      throw new RangeError("out of range index");
    if (ee >= pe && N >= U)
      return 0;
    if (ee >= pe)
      return -1;
    if (N >= U)
      return 1;
    if (N >>>= 0, U >>>= 0, ee >>>= 0, pe >>>= 0, this === k)
      return 0;
    for (var he = pe - ee, be = U - N, ye = Math.min(he, be), Ee = this.slice(ee, pe), $e = k.slice(N, U), Ce = 0; Ce < ye; ++Ce)
      if (Ee[Ce] !== $e[Ce]) {
        he = Ee[Ce], be = $e[Ce];
        break;
      }
    return he < be ? -1 : be < he ? 1 : 0;
  };
  function S(j, k, N, U, ee) {
    if (j.length === 0)
      return -1;
    if (typeof N == "string" ? (U = N, N = 0) : N > 2147483647 ? N = 2147483647 : N < -2147483648 && (N = -2147483648), N = +N, B(N) && (N = ee ? 0 : j.length - 1), N < 0 && (N = j.length + N), N >= j.length) {
      if (ee)
        return -1;
      N = j.length - 1;
    } else if (N < 0)
      if (ee)
        N = 0;
      else
        return -1;
    if (typeof k == "string" && (k = o.from(k, U)), o.isBuffer(k))
      return k.length === 0 ? -1 : T(j, k, N, U, ee);
    if (typeof k == "number")
      return k = k & 255, typeof Uint8Array.prototype.indexOf == "function" ? ee ? Uint8Array.prototype.indexOf.call(j, k, N) : Uint8Array.prototype.lastIndexOf.call(j, k, N) : T(j, [k], N, U, ee);
    throw new TypeError("val must be string, number or Buffer");
  }
  function T(j, k, N, U, ee) {
    var pe = 1, he = j.length, be = k.length;
    if (U !== void 0 && (U = String(U).toLowerCase(), U === "ucs2" || U === "ucs-2" || U === "utf16le" || U === "utf-16le")) {
      if (j.length < 2 || k.length < 2)
        return -1;
      pe = 2, he /= 2, be /= 2, N /= 2;
    }
    function ye(W, Se) {
      return pe === 1 ? W[Se] : W.readUInt16BE(Se * pe);
    }
    var Ee;
    if (ee) {
      var $e = -1;
      for (Ee = N; Ee < he; Ee++)
        if (ye(j, Ee) === ye(k, $e === -1 ? 0 : Ee - $e)) {
          if ($e === -1 && ($e = Ee), Ee - $e + 1 === be)
            return $e * pe;
        } else
          $e !== -1 && (Ee -= Ee - $e), $e = -1;
    } else
      for (N + be > he && (N = he - be), Ee = N; Ee >= 0; Ee--) {
        for (var Ce = !0, le = 0; le < be; le++)
          if (ye(j, Ee + le) !== ye(k, le)) {
            Ce = !1;
            break;
          }
        if (Ce)
          return Ee;
      }
    return -1;
  }
  o.prototype.includes = function(k, N, U) {
    return this.indexOf(k, N, U) !== -1;
  }, o.prototype.indexOf = function(k, N, U) {
    return S(this, k, N, U, !0);
  }, o.prototype.lastIndexOf = function(k, N, U) {
    return S(this, k, N, U, !1);
  };
  function E(j, k, N, U) {
    N = Number(N) || 0;
    var ee = j.length - N;
    U ? (U = Number(U), U > ee && (U = ee)) : U = ee;
    var pe = k.length;
    U > pe / 2 && (U = pe / 2);
    for (var he = 0; he < U; ++he) {
      var be = parseInt(k.substr(he * 2, 2), 16);
      if (B(be))
        return he;
      j[N + he] = be;
    }
    return he;
  }
  function C(j, k, N, U) {
    return M(I(k, j.length - N), j, N, U);
  }
  function A(j, k, N, U) {
    return M(z(k), j, N, U);
  }
  function R(j, k, N, U) {
    return M(q(k), j, N, U);
  }
  function D(j, k, N, U) {
    return M(G(k, j.length - N), j, N, U);
  }
  o.prototype.write = function(k, N, U, ee) {
    if (N === void 0)
      ee = "utf8", U = this.length, N = 0;
    else if (U === void 0 && typeof N == "string")
      ee = N, U = this.length, N = 0;
    else if (isFinite(N))
      N = N >>> 0, isFinite(U) ? (U = U >>> 0, ee === void 0 && (ee = "utf8")) : (ee = U, U = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    var pe = this.length - N;
    if ((U === void 0 || U > pe) && (U = pe), k.length > 0 && (U < 0 || N < 0) || N > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    ee || (ee = "utf8");
    for (var he = !1; ; )
      switch (ee) {
        case "hex":
          return E(this, k, N, U);
        case "utf8":
        case "utf-8":
          return C(this, k, N, U);
        case "ascii":
        case "latin1":
        case "binary":
          return A(this, k, N, U);
        case "base64":
          return R(this, k, N, U);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return D(this, k, N, U);
        default:
          if (he)
            throw new TypeError("Unknown encoding: " + ee);
          ee = ("" + ee).toLowerCase(), he = !0;
      }
  }, o.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function F(j, k, N) {
    return k === 0 && N === j.length ? e.fromByteArray(j) : e.fromByteArray(j.slice(k, N));
  }
  function K(j, k, N) {
    N = Math.min(j.length, N);
    for (var U = [], ee = k; ee < N; ) {
      var pe = j[ee], he = null, be = pe > 239 ? 4 : pe > 223 ? 3 : pe > 191 ? 2 : 1;
      if (ee + be <= N) {
        var ye, Ee, $e, Ce;
        switch (be) {
          case 1:
            pe < 128 && (he = pe);
            break;
          case 2:
            ye = j[ee + 1], (ye & 192) === 128 && (Ce = (pe & 31) << 6 | ye & 63, Ce > 127 && (he = Ce));
            break;
          case 3:
            ye = j[ee + 1], Ee = j[ee + 2], (ye & 192) === 128 && (Ee & 192) === 128 && (Ce = (pe & 15) << 12 | (ye & 63) << 6 | Ee & 63, Ce > 2047 && (Ce < 55296 || Ce > 57343) && (he = Ce));
            break;
          case 4:
            ye = j[ee + 1], Ee = j[ee + 2], $e = j[ee + 3], (ye & 192) === 128 && (Ee & 192) === 128 && ($e & 192) === 128 && (Ce = (pe & 15) << 18 | (ye & 63) << 12 | (Ee & 63) << 6 | $e & 63, Ce > 65535 && Ce < 1114112 && (he = Ce));
        }
      }
      he === null ? (he = 65533, be = 1) : he > 65535 && (he -= 65536, U.push(he >>> 10 & 1023 | 55296), he = 56320 | he & 1023), U.push(he), ee += be;
    }
    return ne(U);
  }
  var V = 4096;
  function ne(j) {
    var k = j.length;
    if (k <= V)
      return String.fromCharCode.apply(String, j);
    for (var N = "", U = 0; U < k; )
      N += String.fromCharCode.apply(
        String,
        j.slice(U, U += V)
      );
    return N;
  }
  function $(j, k, N) {
    var U = "";
    N = Math.min(j.length, N);
    for (var ee = k; ee < N; ++ee)
      U += String.fromCharCode(j[ee] & 127);
    return U;
  }
  function L(j, k, N) {
    var U = "";
    N = Math.min(j.length, N);
    for (var ee = k; ee < N; ++ee)
      U += String.fromCharCode(j[ee]);
    return U;
  }
  function P(j, k, N) {
    var U = j.length;
    (!k || k < 0) && (k = 0), (!N || N < 0 || N > U) && (N = U);
    for (var ee = "", pe = k; pe < N; ++pe)
      ee += re[j[pe]];
    return ee;
  }
  function H(j, k, N) {
    for (var U = j.slice(k, N), ee = "", pe = 0; pe < U.length - 1; pe += 2)
      ee += String.fromCharCode(U[pe] + U[pe + 1] * 256);
    return ee;
  }
  o.prototype.slice = function(k, N) {
    var U = this.length;
    k = ~~k, N = N === void 0 ? U : ~~N, k < 0 ? (k += U, k < 0 && (k = 0)) : k > U && (k = U), N < 0 ? (N += U, N < 0 && (N = 0)) : N > U && (N = U), N < k && (N = k);
    var ee = this.subarray(k, N);
    return Object.setPrototypeOf(ee, o.prototype), ee;
  };
  function Q(j, k, N) {
    if (j % 1 !== 0 || j < 0)
      throw new RangeError("offset is not uint");
    if (j + k > N)
      throw new RangeError("Trying to access beyond buffer length");
  }
  o.prototype.readUintLE = o.prototype.readUIntLE = function(k, N, U) {
    k = k >>> 0, N = N >>> 0, U || Q(k, N, this.length);
    for (var ee = this[k], pe = 1, he = 0; ++he < N && (pe *= 256); )
      ee += this[k + he] * pe;
    return ee;
  }, o.prototype.readUintBE = o.prototype.readUIntBE = function(k, N, U) {
    k = k >>> 0, N = N >>> 0, U || Q(k, N, this.length);
    for (var ee = this[k + --N], pe = 1; N > 0 && (pe *= 256); )
      ee += this[k + --N] * pe;
    return ee;
  }, o.prototype.readUint8 = o.prototype.readUInt8 = function(k, N) {
    return k = k >>> 0, N || Q(k, 1, this.length), this[k];
  }, o.prototype.readUint16LE = o.prototype.readUInt16LE = function(k, N) {
    return k = k >>> 0, N || Q(k, 2, this.length), this[k] | this[k + 1] << 8;
  }, o.prototype.readUint16BE = o.prototype.readUInt16BE = function(k, N) {
    return k = k >>> 0, N || Q(k, 2, this.length), this[k] << 8 | this[k + 1];
  }, o.prototype.readUint32LE = o.prototype.readUInt32LE = function(k, N) {
    return k = k >>> 0, N || Q(k, 4, this.length), (this[k] | this[k + 1] << 8 | this[k + 2] << 16) + this[k + 3] * 16777216;
  }, o.prototype.readUint32BE = o.prototype.readUInt32BE = function(k, N) {
    return k = k >>> 0, N || Q(k, 4, this.length), this[k] * 16777216 + (this[k + 1] << 16 | this[k + 2] << 8 | this[k + 3]);
  }, o.prototype.readIntLE = function(k, N, U) {
    k = k >>> 0, N = N >>> 0, U || Q(k, N, this.length);
    for (var ee = this[k], pe = 1, he = 0; ++he < N && (pe *= 256); )
      ee += this[k + he] * pe;
    return pe *= 128, ee >= pe && (ee -= Math.pow(2, 8 * N)), ee;
  }, o.prototype.readIntBE = function(k, N, U) {
    k = k >>> 0, N = N >>> 0, U || Q(k, N, this.length);
    for (var ee = N, pe = 1, he = this[k + --ee]; ee > 0 && (pe *= 256); )
      he += this[k + --ee] * pe;
    return pe *= 128, he >= pe && (he -= Math.pow(2, 8 * N)), he;
  }, o.prototype.readInt8 = function(k, N) {
    return k = k >>> 0, N || Q(k, 1, this.length), this[k] & 128 ? (255 - this[k] + 1) * -1 : this[k];
  }, o.prototype.readInt16LE = function(k, N) {
    k = k >>> 0, N || Q(k, 2, this.length);
    var U = this[k] | this[k + 1] << 8;
    return U & 32768 ? U | 4294901760 : U;
  }, o.prototype.readInt16BE = function(k, N) {
    k = k >>> 0, N || Q(k, 2, this.length);
    var U = this[k + 1] | this[k] << 8;
    return U & 32768 ? U | 4294901760 : U;
  }, o.prototype.readInt32LE = function(k, N) {
    return k = k >>> 0, N || Q(k, 4, this.length), this[k] | this[k + 1] << 8 | this[k + 2] << 16 | this[k + 3] << 24;
  }, o.prototype.readInt32BE = function(k, N) {
    return k = k >>> 0, N || Q(k, 4, this.length), this[k] << 24 | this[k + 1] << 16 | this[k + 2] << 8 | this[k + 3];
  }, o.prototype.readFloatLE = function(k, N) {
    return k = k >>> 0, N || Q(k, 4, this.length), r.read(this, k, !0, 23, 4);
  }, o.prototype.readFloatBE = function(k, N) {
    return k = k >>> 0, N || Q(k, 4, this.length), r.read(this, k, !1, 23, 4);
  }, o.prototype.readDoubleLE = function(k, N) {
    return k = k >>> 0, N || Q(k, 8, this.length), r.read(this, k, !0, 52, 8);
  }, o.prototype.readDoubleBE = function(k, N) {
    return k = k >>> 0, N || Q(k, 8, this.length), r.read(this, k, !1, 52, 8);
  };
  function Y(j, k, N, U, ee, pe) {
    if (!o.isBuffer(j))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (k > ee || k < pe)
      throw new RangeError('"value" argument is out of bounds');
    if (N + U > j.length)
      throw new RangeError("Index out of range");
  }
  o.prototype.writeUintLE = o.prototype.writeUIntLE = function(k, N, U, ee) {
    if (k = +k, N = N >>> 0, U = U >>> 0, !ee) {
      var pe = Math.pow(2, 8 * U) - 1;
      Y(this, k, N, U, pe, 0);
    }
    var he = 1, be = 0;
    for (this[N] = k & 255; ++be < U && (he *= 256); )
      this[N + be] = k / he & 255;
    return N + U;
  }, o.prototype.writeUintBE = o.prototype.writeUIntBE = function(k, N, U, ee) {
    if (k = +k, N = N >>> 0, U = U >>> 0, !ee) {
      var pe = Math.pow(2, 8 * U) - 1;
      Y(this, k, N, U, pe, 0);
    }
    var he = U - 1, be = 1;
    for (this[N + he] = k & 255; --he >= 0 && (be *= 256); )
      this[N + he] = k / be & 255;
    return N + U;
  }, o.prototype.writeUint8 = o.prototype.writeUInt8 = function(k, N, U) {
    return k = +k, N = N >>> 0, U || Y(this, k, N, 1, 255, 0), this[N] = k & 255, N + 1;
  }, o.prototype.writeUint16LE = o.prototype.writeUInt16LE = function(k, N, U) {
    return k = +k, N = N >>> 0, U || Y(this, k, N, 2, 65535, 0), this[N] = k & 255, this[N + 1] = k >>> 8, N + 2;
  }, o.prototype.writeUint16BE = o.prototype.writeUInt16BE = function(k, N, U) {
    return k = +k, N = N >>> 0, U || Y(this, k, N, 2, 65535, 0), this[N] = k >>> 8, this[N + 1] = k & 255, N + 2;
  }, o.prototype.writeUint32LE = o.prototype.writeUInt32LE = function(k, N, U) {
    return k = +k, N = N >>> 0, U || Y(this, k, N, 4, 4294967295, 0), this[N + 3] = k >>> 24, this[N + 2] = k >>> 16, this[N + 1] = k >>> 8, this[N] = k & 255, N + 4;
  }, o.prototype.writeUint32BE = o.prototype.writeUInt32BE = function(k, N, U) {
    return k = +k, N = N >>> 0, U || Y(this, k, N, 4, 4294967295, 0), this[N] = k >>> 24, this[N + 1] = k >>> 16, this[N + 2] = k >>> 8, this[N + 3] = k & 255, N + 4;
  }, o.prototype.writeIntLE = function(k, N, U, ee) {
    if (k = +k, N = N >>> 0, !ee) {
      var pe = Math.pow(2, 8 * U - 1);
      Y(this, k, N, U, pe - 1, -pe);
    }
    var he = 0, be = 1, ye = 0;
    for (this[N] = k & 255; ++he < U && (be *= 256); )
      k < 0 && ye === 0 && this[N + he - 1] !== 0 && (ye = 1), this[N + he] = (k / be >> 0) - ye & 255;
    return N + U;
  }, o.prototype.writeIntBE = function(k, N, U, ee) {
    if (k = +k, N = N >>> 0, !ee) {
      var pe = Math.pow(2, 8 * U - 1);
      Y(this, k, N, U, pe - 1, -pe);
    }
    var he = U - 1, be = 1, ye = 0;
    for (this[N + he] = k & 255; --he >= 0 && (be *= 256); )
      k < 0 && ye === 0 && this[N + he + 1] !== 0 && (ye = 1), this[N + he] = (k / be >> 0) - ye & 255;
    return N + U;
  }, o.prototype.writeInt8 = function(k, N, U) {
    return k = +k, N = N >>> 0, U || Y(this, k, N, 1, 127, -128), k < 0 && (k = 255 + k + 1), this[N] = k & 255, N + 1;
  }, o.prototype.writeInt16LE = function(k, N, U) {
    return k = +k, N = N >>> 0, U || Y(this, k, N, 2, 32767, -32768), this[N] = k & 255, this[N + 1] = k >>> 8, N + 2;
  }, o.prototype.writeInt16BE = function(k, N, U) {
    return k = +k, N = N >>> 0, U || Y(this, k, N, 2, 32767, -32768), this[N] = k >>> 8, this[N + 1] = k & 255, N + 2;
  }, o.prototype.writeInt32LE = function(k, N, U) {
    return k = +k, N = N >>> 0, U || Y(this, k, N, 4, 2147483647, -2147483648), this[N] = k & 255, this[N + 1] = k >>> 8, this[N + 2] = k >>> 16, this[N + 3] = k >>> 24, N + 4;
  }, o.prototype.writeInt32BE = function(k, N, U) {
    return k = +k, N = N >>> 0, U || Y(this, k, N, 4, 2147483647, -2147483648), k < 0 && (k = 4294967295 + k + 1), this[N] = k >>> 24, this[N + 1] = k >>> 16, this[N + 2] = k >>> 8, this[N + 3] = k & 255, N + 4;
  };
  function ce(j, k, N, U, ee, pe) {
    if (N + U > j.length)
      throw new RangeError("Index out of range");
    if (N < 0)
      throw new RangeError("Index out of range");
  }
  function ue(j, k, N, U, ee) {
    return k = +k, N = N >>> 0, ee || ce(j, k, N, 4), r.write(j, k, N, U, 23, 4), N + 4;
  }
  o.prototype.writeFloatLE = function(k, N, U) {
    return ue(this, k, N, !0, U);
  }, o.prototype.writeFloatBE = function(k, N, U) {
    return ue(this, k, N, !1, U);
  };
  function me(j, k, N, U, ee) {
    return k = +k, N = N >>> 0, ee || ce(j, k, N, 8), r.write(j, k, N, U, 52, 8), N + 8;
  }
  o.prototype.writeDoubleLE = function(k, N, U) {
    return me(this, k, N, !0, U);
  }, o.prototype.writeDoubleBE = function(k, N, U) {
    return me(this, k, N, !1, U);
  }, o.prototype.copy = function(k, N, U, ee) {
    if (!o.isBuffer(k))
      throw new TypeError("argument should be a Buffer");
    if (U || (U = 0), !ee && ee !== 0 && (ee = this.length), N >= k.length && (N = k.length), N || (N = 0), ee > 0 && ee < U && (ee = U), ee === U || k.length === 0 || this.length === 0)
      return 0;
    if (N < 0)
      throw new RangeError("targetStart out of bounds");
    if (U < 0 || U >= this.length)
      throw new RangeError("Index out of range");
    if (ee < 0)
      throw new RangeError("sourceEnd out of bounds");
    ee > this.length && (ee = this.length), k.length - N < ee - U && (ee = k.length - N + U);
    var pe = ee - U;
    return this === k && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(N, U, ee) : Uint8Array.prototype.set.call(
      k,
      this.subarray(U, ee),
      N
    ), pe;
  }, o.prototype.fill = function(k, N, U, ee) {
    if (typeof k == "string") {
      if (typeof N == "string" ? (ee = N, N = 0, U = this.length) : typeof U == "string" && (ee = U, U = this.length), ee !== void 0 && typeof ee != "string")
        throw new TypeError("encoding must be a string");
      if (typeof ee == "string" && !o.isEncoding(ee))
        throw new TypeError("Unknown encoding: " + ee);
      if (k.length === 1) {
        var pe = k.charCodeAt(0);
        (ee === "utf8" && pe < 128 || ee === "latin1") && (k = pe);
      }
    } else
      typeof k == "number" ? k = k & 255 : typeof k == "boolean" && (k = Number(k));
    if (N < 0 || this.length < N || this.length < U)
      throw new RangeError("Out of range index");
    if (U <= N)
      return this;
    N = N >>> 0, U = U === void 0 ? this.length : U >>> 0, k || (k = 0);
    var he;
    if (typeof k == "number")
      for (he = N; he < U; ++he)
        this[he] = k;
    else {
      var be = o.isBuffer(k) ? k : o.from(k, ee), ye = be.length;
      if (ye === 0)
        throw new TypeError('The value "' + k + '" is invalid for argument "value"');
      for (he = 0; he < U - N; ++he)
        this[he + N] = be[he % ye];
    }
    return this;
  };
  var J = /[^+/0-9A-Za-z-_]/g;
  function O(j) {
    if (j = j.split("=")[0], j = j.trim().replace(J, ""), j.length < 2)
      return "";
    for (; j.length % 4 !== 0; )
      j = j + "=";
    return j;
  }
  function I(j, k) {
    k = k || 1 / 0;
    for (var N, U = j.length, ee = null, pe = [], he = 0; he < U; ++he) {
      if (N = j.charCodeAt(he), N > 55295 && N < 57344) {
        if (!ee) {
          if (N > 56319) {
            (k -= 3) > -1 && pe.push(239, 191, 189);
            continue;
          } else if (he + 1 === U) {
            (k -= 3) > -1 && pe.push(239, 191, 189);
            continue;
          }
          ee = N;
          continue;
        }
        if (N < 56320) {
          (k -= 3) > -1 && pe.push(239, 191, 189), ee = N;
          continue;
        }
        N = (ee - 55296 << 10 | N - 56320) + 65536;
      } else
        ee && (k -= 3) > -1 && pe.push(239, 191, 189);
      if (ee = null, N < 128) {
        if ((k -= 1) < 0)
          break;
        pe.push(N);
      } else if (N < 2048) {
        if ((k -= 2) < 0)
          break;
        pe.push(
          N >> 6 | 192,
          N & 63 | 128
        );
      } else if (N < 65536) {
        if ((k -= 3) < 0)
          break;
        pe.push(
          N >> 12 | 224,
          N >> 6 & 63 | 128,
          N & 63 | 128
        );
      } else if (N < 1114112) {
        if ((k -= 4) < 0)
          break;
        pe.push(
          N >> 18 | 240,
          N >> 12 & 63 | 128,
          N >> 6 & 63 | 128,
          N & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return pe;
  }
  function z(j) {
    for (var k = [], N = 0; N < j.length; ++N)
      k.push(j.charCodeAt(N) & 255);
    return k;
  }
  function G(j, k) {
    for (var N, U, ee, pe = [], he = 0; he < j.length && !((k -= 2) < 0); ++he)
      N = j.charCodeAt(he), U = N >> 8, ee = N % 256, pe.push(ee), pe.push(U);
    return pe;
  }
  function q(j) {
    return e.toByteArray(O(j));
  }
  function M(j, k, N, U) {
    for (var ee = 0; ee < U && !(ee + N >= k.length || ee >= j.length); ++ee)
      k[ee + N] = j[ee];
    return ee;
  }
  function Z(j, k) {
    return j instanceof k || j != null && j.constructor != null && j.constructor.name != null && j.constructor.name === k.name;
  }
  function B(j) {
    return j !== j;
  }
  var re = function() {
    for (var j = "0123456789abcdef", k = new Array(256), N = 0; N < 16; ++N)
      for (var U = N * 16, ee = 0; ee < 16; ++ee)
        k[U + ee] = j[N] + j[ee];
    return k;
  }();
})(rr);
var zu, Fy;
function Ai() {
  if (Fy)
    return zu;
  Fy = 1;
  var t = rr, e = t.Buffer, r = {}, n;
  for (n in t)
    t.hasOwnProperty(n) && (n === "SlowBuffer" || n === "Buffer" || (r[n] = t[n]));
  var i = r.Buffer = {};
  for (n in e)
    e.hasOwnProperty(n) && (n === "allocUnsafe" || n === "allocUnsafeSlow" || (i[n] = e[n]));
  if (r.Buffer.prototype = e.prototype, (!i.from || i.from === Uint8Array.from) && (i.from = function(a, s, o) {
    if (typeof a == "number")
      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof a);
    if (a && typeof a.length > "u")
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof a);
    return e(a, s, o);
  }), i.alloc || (i.alloc = function(a, s, o) {
    if (typeof a != "number")
      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof a);
    if (a < 0 || a >= 2 * (1 << 30))
      throw new RangeError('The value "' + a + '" is invalid for option "size"');
    var c = e(a);
    return !s || s.length === 0 ? c.fill(0) : typeof o == "string" ? c.fill(s, o) : c.fill(s), c;
  }), !r.kStringMaxLength)
    try {
      r.kStringMaxLength = process.binding("buffer").kStringMaxLength;
    } catch {
    }
  return r.constants || (r.constants = {
    MAX_LENGTH: r.kMaxLength
  }, r.kStringMaxLength && (r.constants.MAX_STRING_LENGTH = r.kStringMaxLength)), zu = r, zu;
}
var Rs = {}, By;
function oI() {
  if (By)
    return Rs;
  By = 1;
  var t = "\uFEFF";
  Rs.PrependBOM = e;
  function e(n, i) {
    this.encoder = n, this.addBOM = !0;
  }
  e.prototype.write = function(n) {
    return this.addBOM && (n = t + n, this.addBOM = !1), this.encoder.write(n);
  }, e.prototype.end = function() {
    return this.encoder.end();
  }, Rs.StripBOM = r;
  function r(n, i) {
    this.decoder = n, this.pass = !1, this.options = i || {};
  }
  return r.prototype.write = function(n) {
    var i = this.decoder.write(n);
    return this.pass || !i || (i[0] === t && (i = i.slice(1), typeof this.options.stripBOM == "function" && this.options.stripBOM()), this.pass = !0), i;
  }, r.prototype.end = function() {
    return this.decoder.end();
  }, Rs;
}
var Hu = {}, Wu = {}, dm = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(t, e) {
  var r = rr, n = r.Buffer;
  function i(s, o) {
    for (var c in s)
      o[c] = s[c];
  }
  n.from && n.alloc && n.allocUnsafe && n.allocUnsafeSlow ? t.exports = r : (i(r, e), e.Buffer = a);
  function a(s, o, c) {
    return n(s, o, c);
  }
  a.prototype = Object.create(n.prototype), i(n, a), a.from = function(s, o, c) {
    if (typeof s == "number")
      throw new TypeError("Argument must not be a number");
    return n(s, o, c);
  }, a.alloc = function(s, o, c) {
    if (typeof s != "number")
      throw new TypeError("Argument must be a number");
    var f = n(s);
    return o !== void 0 ? typeof c == "string" ? f.fill(o, c) : f.fill(o) : f.fill(0), f;
  }, a.allocUnsafe = function(s) {
    if (typeof s != "number")
      throw new TypeError("Argument must be a number");
    return n(s);
  }, a.allocUnsafeSlow = function(s) {
    if (typeof s != "number")
      throw new TypeError("Argument must be a number");
    return r.SlowBuffer(s);
  };
})(dm, dm.exports);
var xc = dm.exports, Uy;
function No() {
  if (Uy)
    return Wu;
  Uy = 1;
  var t = xc.Buffer, e = t.isEncoding || function(d) {
    switch (d = "" + d, d && d.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function r(d) {
    if (!d)
      return "utf8";
    for (var y; ; )
      switch (d) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return d;
        default:
          if (y)
            return;
          d = ("" + d).toLowerCase(), y = !0;
      }
  }
  function n(d) {
    var y = r(d);
    if (typeof y != "string" && (t.isEncoding === e || !e(d)))
      throw new Error("Unknown encoding: " + d);
    return y || d;
  }
  Wu.StringDecoder = i;
  function i(d) {
    this.encoding = n(d);
    var y;
    switch (this.encoding) {
      case "utf16le":
        this.text = l, this.end = p, y = 4;
        break;
      case "utf8":
        this.fillLast = c, y = 4;
        break;
      case "base64":
        this.text = m, this.end = h, y = 3;
        break;
      default:
        this.write = g, this.end = v;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = t.allocUnsafe(y);
  }
  i.prototype.write = function(d) {
    if (d.length === 0)
      return "";
    var y, x;
    if (this.lastNeed) {
      if (y = this.fillLast(d), y === void 0)
        return "";
      x = this.lastNeed, this.lastNeed = 0;
    } else
      x = 0;
    return x < d.length ? y ? y + this.text(d, x) : this.text(d, x) : y || "";
  }, i.prototype.end = u, i.prototype.text = f, i.prototype.fillLast = function(d) {
    if (this.lastNeed <= d.length)
      return d.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    d.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, d.length), this.lastNeed -= d.length;
  };
  function a(d) {
    return d <= 127 ? 0 : d >> 5 === 6 ? 2 : d >> 4 === 14 ? 3 : d >> 3 === 30 ? 4 : d >> 6 === 2 ? -1 : -2;
  }
  function s(d, y, x) {
    var b = y.length - 1;
    if (b < x)
      return 0;
    var w = a(y[b]);
    return w >= 0 ? (w > 0 && (d.lastNeed = w - 1), w) : --b < x || w === -2 ? 0 : (w = a(y[b]), w >= 0 ? (w > 0 && (d.lastNeed = w - 2), w) : --b < x || w === -2 ? 0 : (w = a(y[b]), w >= 0 ? (w > 0 && (w === 2 ? w = 0 : d.lastNeed = w - 3), w) : 0));
  }
  function o(d, y, x) {
    if ((y[0] & 192) !== 128)
      return d.lastNeed = 0, "";
    if (d.lastNeed > 1 && y.length > 1) {
      if ((y[1] & 192) !== 128)
        return d.lastNeed = 1, "";
      if (d.lastNeed > 2 && y.length > 2 && (y[2] & 192) !== 128)
        return d.lastNeed = 2, "";
    }
  }
  function c(d) {
    var y = this.lastTotal - this.lastNeed, x = o(this, d);
    if (x !== void 0)
      return x;
    if (this.lastNeed <= d.length)
      return d.copy(this.lastChar, y, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    d.copy(this.lastChar, y, 0, d.length), this.lastNeed -= d.length;
  }
  function f(d, y) {
    var x = s(this, d, y);
    if (!this.lastNeed)
      return d.toString("utf8", y);
    this.lastTotal = x;
    var b = d.length - (x - this.lastNeed);
    return d.copy(this.lastChar, 0, b), d.toString("utf8", y, b);
  }
  function u(d) {
    var y = d && d.length ? this.write(d) : "";
    return this.lastNeed ? y + "" : y;
  }
  function l(d, y) {
    if ((d.length - y) % 2 === 0) {
      var x = d.toString("utf16le", y);
      if (x) {
        var b = x.charCodeAt(x.length - 1);
        if (b >= 55296 && b <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = d[d.length - 2], this.lastChar[1] = d[d.length - 1], x.slice(0, -1);
      }
      return x;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = d[d.length - 1], d.toString("utf16le", y, d.length - 1);
  }
  function p(d) {
    var y = d && d.length ? this.write(d) : "";
    if (this.lastNeed) {
      var x = this.lastTotal - this.lastNeed;
      return y + this.lastChar.toString("utf16le", 0, x);
    }
    return y;
  }
  function m(d, y) {
    var x = (d.length - y) % 3;
    return x === 0 ? d.toString("base64", y) : (this.lastNeed = 3 - x, this.lastTotal = 3, x === 1 ? this.lastChar[0] = d[d.length - 1] : (this.lastChar[0] = d[d.length - 2], this.lastChar[1] = d[d.length - 1]), d.toString("base64", y, d.length - x));
  }
  function h(d) {
    var y = d && d.length ? this.write(d) : "";
    return this.lastNeed ? y + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : y;
  }
  function g(d) {
    return d.toString(this.encoding);
  }
  function v(d) {
    return d && d.length ? this.write(d) : "";
  }
  return Wu;
}
var Gu, zy;
function cI() {
  if (zy)
    return Gu;
  zy = 1;
  var t = Ai().Buffer;
  Gu = {
    // Encodings
    utf8: { type: "_internal", bomAware: !0 },
    cesu8: { type: "_internal", bomAware: !0 },
    unicode11utf8: "utf8",
    ucs2: { type: "_internal", bomAware: !0 },
    utf16le: "ucs2",
    binary: { type: "_internal" },
    base64: { type: "_internal" },
    hex: { type: "_internal" },
    // Codec.
    _internal: e
  };
  function e(c, f) {
    this.enc = c.encodingName, this.bomAware = c.bomAware, this.enc === "base64" ? this.encoder = a : this.enc === "cesu8" && (this.enc = "utf8", this.encoder = s, t.from("eda0bdedb2a9", "hex").toString() !== "" && (this.decoder = o, this.defaultCharUnicode = f.defaultCharUnicode));
  }
  e.prototype.encoder = i, e.prototype.decoder = n;
  var r = No().StringDecoder;
  r.prototype.end || (r.prototype.end = function() {
  });
  function n(c, f) {
    r.call(this, f.enc);
  }
  n.prototype = r.prototype;
  function i(c, f) {
    this.enc = f.enc;
  }
  i.prototype.write = function(c) {
    return t.from(c, this.enc);
  }, i.prototype.end = function() {
  };
  function a(c, f) {
    this.prevStr = "";
  }
  a.prototype.write = function(c) {
    c = this.prevStr + c;
    var f = c.length - c.length % 4;
    return this.prevStr = c.slice(f), c = c.slice(0, f), t.from(c, "base64");
  }, a.prototype.end = function() {
    return t.from(this.prevStr, "base64");
  };
  function s(c, f) {
  }
  s.prototype.write = function(c) {
    for (var f = t.alloc(c.length * 3), u = 0, l = 0; l < c.length; l++) {
      var p = c.charCodeAt(l);
      p < 128 ? f[u++] = p : p < 2048 ? (f[u++] = 192 + (p >>> 6), f[u++] = 128 + (p & 63)) : (f[u++] = 224 + (p >>> 12), f[u++] = 128 + (p >>> 6 & 63), f[u++] = 128 + (p & 63));
    }
    return f.slice(0, u);
  }, s.prototype.end = function() {
  };
  function o(c, f) {
    this.acc = 0, this.contBytes = 0, this.accBytes = 0, this.defaultCharUnicode = f.defaultCharUnicode;
  }
  return o.prototype.write = function(c) {
    for (var f = this.acc, u = this.contBytes, l = this.accBytes, p = "", m = 0; m < c.length; m++) {
      var h = c[m];
      (h & 192) !== 128 ? (u > 0 && (p += this.defaultCharUnicode, u = 0), h < 128 ? p += String.fromCharCode(h) : h < 224 ? (f = h & 31, u = 1, l = 1) : h < 240 ? (f = h & 15, u = 2, l = 1) : p += this.defaultCharUnicode) : u > 0 ? (f = f << 6 | h & 63, u--, l++, u === 0 && (l === 2 && f < 128 && f > 0 ? p += this.defaultCharUnicode : l === 3 && f < 2048 ? p += this.defaultCharUnicode : p += String.fromCharCode(f))) : p += this.defaultCharUnicode;
    }
    return this.acc = f, this.contBytes = u, this.accBytes = l, p;
  }, o.prototype.end = function() {
    var c = 0;
    return this.contBytes > 0 && (c += this.defaultCharUnicode), c;
  }, Gu;
}
var Ns = {}, Hy;
function uI() {
  if (Hy)
    return Ns;
  Hy = 1;
  var t = Ai().Buffer;
  Ns.utf16be = e;
  function e() {
  }
  e.prototype.encoder = r, e.prototype.decoder = n, e.prototype.bomAware = !0;
  function r() {
  }
  r.prototype.write = function(c) {
    for (var f = t.from(c, "ucs2"), u = 0; u < f.length; u += 2) {
      var l = f[u];
      f[u] = f[u + 1], f[u + 1] = l;
    }
    return f;
  }, r.prototype.end = function() {
  };
  function n() {
    this.overflowByte = -1;
  }
  n.prototype.write = function(c) {
    if (c.length == 0)
      return "";
    var f = t.alloc(c.length + 1), u = 0, l = 0;
    for (this.overflowByte !== -1 && (f[0] = c[0], f[1] = this.overflowByte, u = 1, l = 2); u < c.length - 1; u += 2, l += 2)
      f[l] = c[u + 1], f[l + 1] = c[u];
    return this.overflowByte = u == c.length - 1 ? c[c.length - 1] : -1, f.slice(0, l).toString("ucs2");
  }, n.prototype.end = function() {
  }, Ns.utf16 = i;
  function i(c, f) {
    this.iconv = f;
  }
  i.prototype.encoder = a, i.prototype.decoder = s;
  function a(c, f) {
    c = c || {}, c.addBOM === void 0 && (c.addBOM = !0), this.encoder = f.iconv.getEncoder("utf-16le", c);
  }
  a.prototype.write = function(c) {
    return this.encoder.write(c);
  }, a.prototype.end = function() {
    return this.encoder.end();
  };
  function s(c, f) {
    this.decoder = null, this.initialBytes = [], this.initialBytesLen = 0, this.options = c || {}, this.iconv = f.iconv;
  }
  s.prototype.write = function(c) {
    if (!this.decoder) {
      if (this.initialBytes.push(c), this.initialBytesLen += c.length, this.initialBytesLen < 16)
        return "";
      var c = t.concat(this.initialBytes), f = o(c, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(f, this.options), this.initialBytes.length = this.initialBytesLen = 0;
    }
    return this.decoder.write(c);
  }, s.prototype.end = function() {
    if (!this.decoder) {
      var c = t.concat(this.initialBytes), f = o(c, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(f, this.options);
      var u = this.decoder.write(c), l = this.decoder.end();
      return l ? u + l : u;
    }
    return this.decoder.end();
  };
  function o(c, f) {
    var u = f || "utf-16le";
    if (c.length >= 2)
      if (c[0] == 254 && c[1] == 255)
        u = "utf-16be";
      else if (c[0] == 255 && c[1] == 254)
        u = "utf-16le";
      else {
        for (var l = 0, p = 0, m = Math.min(c.length - c.length % 2, 64), h = 0; h < m; h += 2)
          c[h] === 0 && c[h + 1] !== 0 && p++, c[h] !== 0 && c[h + 1] === 0 && l++;
        p > l ? u = "utf-16be" : p < l && (u = "utf-16le");
      }
    return u;
  }
  return Ns;
}
var Zi = {}, Wy;
function lI() {
  if (Wy)
    return Zi;
  Wy = 1;
  var t = Ai().Buffer;
  Zi.utf7 = e, Zi.unicode11utf7 = "utf7";
  function e(g, v) {
    this.iconv = v;
  }
  e.prototype.encoder = n, e.prototype.decoder = i, e.prototype.bomAware = !0;
  var r = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
  function n(g, v) {
    this.iconv = v.iconv;
  }
  n.prototype.write = function(g) {
    return t.from(g.replace(r, function(v) {
      return "+" + (v === "+" ? "" : this.iconv.encode(v, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
    }.bind(this)));
  }, n.prototype.end = function() {
  };
  function i(g, v) {
    this.iconv = v.iconv, this.inBase64 = !1, this.base64Accum = "";
  }
  for (var a = /[A-Za-z0-9\/+]/, s = [], o = 0; o < 256; o++)
    s[o] = a.test(String.fromCharCode(o));
  var c = "+".charCodeAt(0), f = "-".charCodeAt(0), u = "&".charCodeAt(0);
  i.prototype.write = function(g) {
    for (var v = "", d = 0, y = this.inBase64, x = this.base64Accum, b = 0; b < g.length; b++)
      if (!y)
        g[b] == c && (v += this.iconv.decode(g.slice(d, b), "ascii"), d = b + 1, y = !0);
      else if (!s[g[b]]) {
        if (b == d && g[b] == f)
          v += "+";
        else {
          var w = x + g.slice(d, b).toString();
          v += this.iconv.decode(t.from(w, "base64"), "utf16-be");
        }
        g[b] != f && b--, d = b + 1, y = !1, x = "";
      }
    if (!y)
      v += this.iconv.decode(g.slice(d), "ascii");
    else {
      var w = x + g.slice(d).toString(), S = w.length - w.length % 8;
      x = w.slice(S), w = w.slice(0, S), v += this.iconv.decode(t.from(w, "base64"), "utf16-be");
    }
    return this.inBase64 = y, this.base64Accum = x, v;
  }, i.prototype.end = function() {
    var g = "";
    return this.inBase64 && this.base64Accum.length > 0 && (g = this.iconv.decode(t.from(this.base64Accum, "base64"), "utf16-be")), this.inBase64 = !1, this.base64Accum = "", g;
  }, Zi.utf7imap = l;
  function l(g, v) {
    this.iconv = v;
  }
  l.prototype.encoder = p, l.prototype.decoder = m, l.prototype.bomAware = !0;
  function p(g, v) {
    this.iconv = v.iconv, this.inBase64 = !1, this.base64Accum = t.alloc(6), this.base64AccumIdx = 0;
  }
  p.prototype.write = function(g) {
    for (var v = this.inBase64, d = this.base64Accum, y = this.base64AccumIdx, x = t.alloc(g.length * 5 + 10), b = 0, w = 0; w < g.length; w++) {
      var S = g.charCodeAt(w);
      32 <= S && S <= 126 ? (v && (y > 0 && (b += x.write(d.slice(0, y).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), b), y = 0), x[b++] = f, v = !1), v || (x[b++] = S, S === u && (x[b++] = f))) : (v || (x[b++] = u, v = !0), v && (d[y++] = S >> 8, d[y++] = S & 255, y == d.length && (b += x.write(d.toString("base64").replace(/\//g, ","), b), y = 0)));
    }
    return this.inBase64 = v, this.base64AccumIdx = y, x.slice(0, b);
  }, p.prototype.end = function() {
    var g = t.alloc(10), v = 0;
    return this.inBase64 && (this.base64AccumIdx > 0 && (v += g.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), v), this.base64AccumIdx = 0), g[v++] = f, this.inBase64 = !1), g.slice(0, v);
  };
  function m(g, v) {
    this.iconv = v.iconv, this.inBase64 = !1, this.base64Accum = "";
  }
  var h = s.slice();
  return h[",".charCodeAt(0)] = !0, m.prototype.write = function(g) {
    for (var v = "", d = 0, y = this.inBase64, x = this.base64Accum, b = 0; b < g.length; b++)
      if (!y)
        g[b] == u && (v += this.iconv.decode(g.slice(d, b), "ascii"), d = b + 1, y = !0);
      else if (!h[g[b]]) {
        if (b == d && g[b] == f)
          v += "&";
        else {
          var w = x + g.slice(d, b).toString().replace(/,/g, "/");
          v += this.iconv.decode(t.from(w, "base64"), "utf16-be");
        }
        g[b] != f && b--, d = b + 1, y = !1, x = "";
      }
    if (!y)
      v += this.iconv.decode(g.slice(d), "ascii");
    else {
      var w = x + g.slice(d).toString().replace(/,/g, "/"), S = w.length - w.length % 8;
      x = w.slice(S), w = w.slice(0, S), v += this.iconv.decode(t.from(w, "base64"), "utf16-be");
    }
    return this.inBase64 = y, this.base64Accum = x, v;
  }, m.prototype.end = function() {
    var g = "";
    return this.inBase64 && this.base64Accum.length > 0 && (g = this.iconv.decode(t.from(this.base64Accum, "base64"), "utf16-be")), this.inBase64 = !1, this.base64Accum = "", g;
  }, Zi;
}
var Qu = {}, Gy;
function pI() {
  if (Gy)
    return Qu;
  Gy = 1;
  var t = Ai().Buffer;
  Qu._sbcs = e;
  function e(i, a) {
    if (!i)
      throw new Error("SBCS codec is called without the data.");
    if (!i.chars || i.chars.length !== 128 && i.chars.length !== 256)
      throw new Error("Encoding '" + i.type + "' has incorrect 'chars' (must be of len 128 or 256)");
    if (i.chars.length === 128) {
      for (var s = "", o = 0; o < 128; o++)
        s += String.fromCharCode(o);
      i.chars = s + i.chars;
    }
    this.decodeBuf = t.from(i.chars, "ucs2");
    for (var c = t.alloc(65536, a.defaultCharSingleByte.charCodeAt(0)), o = 0; o < i.chars.length; o++)
      c[i.chars.charCodeAt(o)] = o;
    this.encodeBuf = c;
  }
  e.prototype.encoder = r, e.prototype.decoder = n;
  function r(i, a) {
    this.encodeBuf = a.encodeBuf;
  }
  r.prototype.write = function(i) {
    for (var a = t.alloc(i.length), s = 0; s < i.length; s++)
      a[s] = this.encodeBuf[i.charCodeAt(s)];
    return a;
  }, r.prototype.end = function() {
  };
  function n(i, a) {
    this.decodeBuf = a.decodeBuf;
  }
  return n.prototype.write = function(i) {
    for (var a = this.decodeBuf, s = t.alloc(i.length * 2), o = 0, c = 0, f = 0; f < i.length; f++)
      o = i[f] * 2, c = f * 2, s[c] = a[o], s[c + 1] = a[o + 1];
    return s.toString("ucs2");
  }, n.prototype.end = function() {
  }, Qu;
}
var Vu, Qy;
function fI() {
  return Qy || (Qy = 1, Vu = {
    // Not supported by iconv, not sure why.
    10029: "maccenteuro",
    maccenteuro: {
      type: "_sbcs",
      chars: ""
    },
    808: "cp808",
    ibm808: "cp808",
    cp808: {
      type: "_sbcs",
      chars: ""
    },
    mik: {
      type: "_sbcs",
      chars: ""
    },
    // Aliases of generated encodings.
    ascii8bit: "ascii",
    usascii: "ascii",
    ansix34: "ascii",
    ansix341968: "ascii",
    ansix341986: "ascii",
    csascii: "ascii",
    cp367: "ascii",
    ibm367: "ascii",
    isoir6: "ascii",
    iso646us: "ascii",
    iso646irv: "ascii",
    us: "ascii",
    latin1: "iso88591",
    latin2: "iso88592",
    latin3: "iso88593",
    latin4: "iso88594",
    latin5: "iso88599",
    latin6: "iso885910",
    latin7: "iso885913",
    latin8: "iso885914",
    latin9: "iso885915",
    latin10: "iso885916",
    csisolatin1: "iso88591",
    csisolatin2: "iso88592",
    csisolatin3: "iso88593",
    csisolatin4: "iso88594",
    csisolatincyrillic: "iso88595",
    csisolatinarabic: "iso88596",
    csisolatingreek: "iso88597",
    csisolatinhebrew: "iso88598",
    csisolatin5: "iso88599",
    csisolatin6: "iso885910",
    l1: "iso88591",
    l2: "iso88592",
    l3: "iso88593",
    l4: "iso88594",
    l5: "iso88599",
    l6: "iso885910",
    l7: "iso885913",
    l8: "iso885914",
    l9: "iso885915",
    l10: "iso885916",
    isoir14: "iso646jp",
    isoir57: "iso646cn",
    isoir100: "iso88591",
    isoir101: "iso88592",
    isoir109: "iso88593",
    isoir110: "iso88594",
    isoir144: "iso88595",
    isoir127: "iso88596",
    isoir126: "iso88597",
    isoir138: "iso88598",
    isoir148: "iso88599",
    isoir157: "iso885910",
    isoir166: "tis620",
    isoir179: "iso885913",
    isoir199: "iso885914",
    isoir203: "iso885915",
    isoir226: "iso885916",
    cp819: "iso88591",
    ibm819: "iso88591",
    cyrillic: "iso88595",
    arabic: "iso88596",
    arabic8: "iso88596",
    ecma114: "iso88596",
    asmo708: "iso88596",
    greek: "iso88597",
    greek8: "iso88597",
    ecma118: "iso88597",
    elot928: "iso88597",
    hebrew: "iso88598",
    hebrew8: "iso88598",
    turkish: "iso88599",
    turkish8: "iso88599",
    thai: "iso885911",
    thai8: "iso885911",
    celtic: "iso885914",
    celtic8: "iso885914",
    isoceltic: "iso885914",
    tis6200: "tis620",
    tis62025291: "tis620",
    tis62025330: "tis620",
    1e4: "macroman",
    10006: "macgreek",
    10007: "maccyrillic",
    10079: "maciceland",
    10081: "macturkish",
    cspc8codepage437: "cp437",
    cspc775baltic: "cp775",
    cspc850multilingual: "cp850",
    cspcp852: "cp852",
    cspc862latinhebrew: "cp862",
    cpgr: "cp869",
    msee: "cp1250",
    mscyrl: "cp1251",
    msansi: "cp1252",
    msgreek: "cp1253",
    msturk: "cp1254",
    mshebr: "cp1255",
    msarab: "cp1256",
    winbaltrim: "cp1257",
    cp20866: "koi8r",
    20866: "koi8r",
    ibm878: "koi8r",
    cskoi8r: "koi8r",
    cp21866: "koi8u",
    21866: "koi8u",
    ibm1168: "koi8u",
    strk10482002: "rk1048",
    tcvn5712: "tcvn",
    tcvn57121: "tcvn",
    gb198880: "iso646cn",
    cn: "iso646cn",
    csiso14jisc6220ro: "iso646jp",
    jisc62201969ro: "iso646jp",
    jp: "iso646jp",
    cshproman8: "hproman8",
    r8: "hproman8",
    roman8: "hproman8",
    xroman8: "hproman8",
    ibm1051: "hproman8",
    mac: "macintosh",
    csmacintosh: "macintosh"
  }), Vu;
}
var Ku, Vy;
function hI() {
  return Vy || (Vy = 1, Ku = {
    437: "cp437",
    737: "cp737",
    775: "cp775",
    850: "cp850",
    852: "cp852",
    855: "cp855",
    856: "cp856",
    857: "cp857",
    858: "cp858",
    860: "cp860",
    861: "cp861",
    862: "cp862",
    863: "cp863",
    864: "cp864",
    865: "cp865",
    866: "cp866",
    869: "cp869",
    874: "windows874",
    922: "cp922",
    1046: "cp1046",
    1124: "cp1124",
    1125: "cp1125",
    1129: "cp1129",
    1133: "cp1133",
    1161: "cp1161",
    1162: "cp1162",
    1163: "cp1163",
    1250: "windows1250",
    1251: "windows1251",
    1252: "windows1252",
    1253: "windows1253",
    1254: "windows1254",
    1255: "windows1255",
    1256: "windows1256",
    1257: "windows1257",
    1258: "windows1258",
    28591: "iso88591",
    28592: "iso88592",
    28593: "iso88593",
    28594: "iso88594",
    28595: "iso88595",
    28596: "iso88596",
    28597: "iso88597",
    28598: "iso88598",
    28599: "iso88599",
    28600: "iso885910",
    28601: "iso885911",
    28603: "iso885913",
    28604: "iso885914",
    28605: "iso885915",
    28606: "iso885916",
    windows874: {
      type: "_sbcs",
      chars: ""
    },
    win874: "windows874",
    cp874: "windows874",
    windows1250: {
      type: "_sbcs",
      chars: ""
    },
    win1250: "windows1250",
    cp1250: "windows1250",
    windows1251: {
      type: "_sbcs",
      chars: ""
    },
    win1251: "windows1251",
    cp1251: "windows1251",
    windows1252: {
      type: "_sbcs",
      chars: ""
    },
    win1252: "windows1252",
    cp1252: "windows1252",
    windows1253: {
      type: "_sbcs",
      chars: ""
    },
    win1253: "windows1253",
    cp1253: "windows1253",
    windows1254: {
      type: "_sbcs",
      chars: ""
    },
    win1254: "windows1254",
    cp1254: "windows1254",
    windows1255: {
      type: "_sbcs",
      chars: ""
    },
    win1255: "windows1255",
    cp1255: "windows1255",
    windows1256: {
      type: "_sbcs",
      chars: ""
    },
    win1256: "windows1256",
    cp1256: "windows1256",
    windows1257: {
      type: "_sbcs",
      chars: ""
    },
    win1257: "windows1257",
    cp1257: "windows1257",
    windows1258: {
      type: "_sbcs",
      chars: ""
    },
    win1258: "windows1258",
    cp1258: "windows1258",
    iso88591: {
      type: "_sbcs",
      chars: ""
    },
    cp28591: "iso88591",
    iso88592: {
      type: "_sbcs",
      chars: ""
    },
    cp28592: "iso88592",
    iso88593: {
      type: "_sbcs",
      chars: ""
    },
    cp28593: "iso88593",
    iso88594: {
      type: "_sbcs",
      chars: ""
    },
    cp28594: "iso88594",
    iso88595: {
      type: "_sbcs",
      chars: ""
    },
    cp28595: "iso88595",
    iso88596: {
      type: "_sbcs",
      chars: ""
    },
    cp28596: "iso88596",
    iso88597: {
      type: "_sbcs",
      chars: ""
    },
    cp28597: "iso88597",
    iso88598: {
      type: "_sbcs",
      chars: ""
    },
    cp28598: "iso88598",
    iso88599: {
      type: "_sbcs",
      chars: ""
    },
    cp28599: "iso88599",
    iso885910: {
      type: "_sbcs",
      chars: ""
    },
    cp28600: "iso885910",
    iso885911: {
      type: "_sbcs",
      chars: ""
    },
    cp28601: "iso885911",
    iso885913: {
      type: "_sbcs",
      chars: ""
    },
    cp28603: "iso885913",
    iso885914: {
      type: "_sbcs",
      chars: ""
    },
    cp28604: "iso885914",
    iso885915: {
      type: "_sbcs",
      chars: ""
    },
    cp28605: "iso885915",
    iso885916: {
      type: "_sbcs",
      chars: ""
    },
    cp28606: "iso885916",
    cp437: {
      type: "_sbcs",
      chars: ""
    },
    ibm437: "cp437",
    csibm437: "cp437",
    cp737: {
      type: "_sbcs",
      chars: ""
    },
    ibm737: "cp737",
    csibm737: "cp737",
    cp775: {
      type: "_sbcs",
      chars: ""
    },
    ibm775: "cp775",
    csibm775: "cp775",
    cp850: {
      type: "_sbcs",
      chars: ""
    },
    ibm850: "cp850",
    csibm850: "cp850",
    cp852: {
      type: "_sbcs",
      chars: ""
    },
    ibm852: "cp852",
    csibm852: "cp852",
    cp855: {
      type: "_sbcs",
      chars: ""
    },
    ibm855: "cp855",
    csibm855: "cp855",
    cp856: {
      type: "_sbcs",
      chars: ""
    },
    ibm856: "cp856",
    csibm856: "cp856",
    cp857: {
      type: "_sbcs",
      chars: ""
    },
    ibm857: "cp857",
    csibm857: "cp857",
    cp858: {
      type: "_sbcs",
      chars: ""
    },
    ibm858: "cp858",
    csibm858: "cp858",
    cp860: {
      type: "_sbcs",
      chars: ""
    },
    ibm860: "cp860",
    csibm860: "cp860",
    cp861: {
      type: "_sbcs",
      chars: ""
    },
    ibm861: "cp861",
    csibm861: "cp861",
    cp862: {
      type: "_sbcs",
      chars: ""
    },
    ibm862: "cp862",
    csibm862: "cp862",
    cp863: {
      type: "_sbcs",
      chars: ""
    },
    ibm863: "cp863",
    csibm863: "cp863",
    cp864: {
      type: "_sbcs",
      chars: `\0\x07\b	
\v\f\r\x1B !"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}~`
    },
    ibm864: "cp864",
    csibm864: "cp864",
    cp865: {
      type: "_sbcs",
      chars: ""
    },
    ibm865: "cp865",
    csibm865: "cp865",
    cp866: {
      type: "_sbcs",
      chars: ""
    },
    ibm866: "cp866",
    csibm866: "cp866",
    cp869: {
      type: "_sbcs",
      chars: ""
    },
    ibm869: "cp869",
    csibm869: "cp869",
    cp922: {
      type: "_sbcs",
      chars: ""
    },
    ibm922: "cp922",
    csibm922: "cp922",
    cp1046: {
      type: "_sbcs",
      chars: ""
    },
    ibm1046: "cp1046",
    csibm1046: "cp1046",
    cp1124: {
      type: "_sbcs",
      chars: ""
    },
    ibm1124: "cp1124",
    csibm1124: "cp1124",
    cp1125: {
      type: "_sbcs",
      chars: ""
    },
    ibm1125: "cp1125",
    csibm1125: "cp1125",
    cp1129: {
      type: "_sbcs",
      chars: ""
    },
    ibm1129: "cp1129",
    csibm1129: "cp1129",
    cp1133: {
      type: "_sbcs",
      chars: ""
    },
    ibm1133: "cp1133",
    csibm1133: "cp1133",
    cp1161: {
      type: "_sbcs",
      chars: ""
    },
    ibm1161: "cp1161",
    csibm1161: "cp1161",
    cp1162: {
      type: "_sbcs",
      chars: ""
    },
    ibm1162: "cp1162",
    csibm1162: "cp1162",
    cp1163: {
      type: "_sbcs",
      chars: ""
    },
    ibm1163: "cp1163",
    csibm1163: "cp1163",
    maccroatian: {
      type: "_sbcs",
      chars: ""
    },
    maccyrillic: {
      type: "_sbcs",
      chars: ""
    },
    macgreek: {
      type: "_sbcs",
      chars: ""
    },
    maciceland: {
      type: "_sbcs",
      chars: ""
    },
    macroman: {
      type: "_sbcs",
      chars: ""
    },
    macromania: {
      type: "_sbcs",
      chars: ""
    },
    macthai: {
      type: "_sbcs",
      chars: "\uFEFF"
    },
    macturkish: {
      type: "_sbcs",
      chars: ""
    },
    macukraine: {
      type: "_sbcs",
      chars: ""
    },
    koi8r: {
      type: "_sbcs",
      chars: ""
    },
    koi8u: {
      type: "_sbcs",
      chars: ""
    },
    koi8ru: {
      type: "_sbcs",
      chars: ""
    },
    koi8t: {
      type: "_sbcs",
      chars: ""
    },
    armscii8: {
      type: "_sbcs",
      chars: ")(.,-"
    },
    rk1048: {
      type: "_sbcs",
      chars: ""
    },
    tcvn: {
      type: "_sbcs",
      chars: `\0\x07\b	
\v\f\r\x1B !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}~`
    },
    georgianacademy: {
      type: "_sbcs",
      chars: ""
    },
    georgianps: {
      type: "_sbcs",
      chars: ""
    },
    pt154: {
      type: "_sbcs",
      chars: ""
    },
    viscii: {
      type: "_sbcs",
      chars: `\0\x07\b	
\v\f\r\x1B !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}~`
    },
    iso646cn: {
      type: "_sbcs",
      chars: `\0\x07\b	
\v\f\r\x1B !"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}`
    },
    iso646jp: {
      type: "_sbcs",
      chars: `\0\x07\b	
\v\f\r\x1B !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_\`abcdefghijklmnopqrstuvwxyz{|}`
    },
    hproman8: {
      type: "_sbcs",
      chars: ""
    },
    macintosh: {
      type: "_sbcs",
      chars: ""
    },
    ascii: {
      type: "_sbcs",
      chars: ""
    },
    tis620: {
      type: "_sbcs",
      chars: ""
    }
  }), Ku;
}
var Ju = {}, Ky;
function dI() {
  if (Ky)
    return Ju;
  Ky = 1;
  var t = Ai().Buffer;
  Ju._dbcs = c;
  for (var e = -1, r = -2, n = -10, i = -1e3, a = new Array(256), s = -1, o = 0; o < 256; o++)
    a[o] = e;
  function c(p, m) {
    if (this.encodingName = p.encodingName, !p)
      throw new Error("DBCS codec is called without the data.");
    if (!p.table)
      throw new Error("Encoding '" + this.encodingName + "' has no data.");
    var h = p.table();
    this.decodeTables = [], this.decodeTables[0] = a.slice(0), this.decodeTableSeq = [];
    for (var g = 0; g < h.length; g++)
      this._addDecodeChunk(h[g]);
    this.defaultCharUnicode = m.defaultCharUnicode, this.encodeTable = [], this.encodeTableSeq = [];
    var v = {};
    if (p.encodeSkipVals)
      for (var g = 0; g < p.encodeSkipVals.length; g++) {
        var d = p.encodeSkipVals[g];
        if (typeof d == "number")
          v[d] = !0;
        else
          for (var y = d.from; y <= d.to; y++)
            v[y] = !0;
      }
    if (this._fillEncodeTable(0, 0, v), p.encodeAdd)
      for (var x in p.encodeAdd)
        Object.prototype.hasOwnProperty.call(p.encodeAdd, x) && this._setEncodeChar(x.charCodeAt(0), p.encodeAdd[x]);
    if (this.defCharSB = this.encodeTable[0][m.defaultCharSingleByte.charCodeAt(0)], this.defCharSB === e && (this.defCharSB = this.encodeTable[0]["?"]), this.defCharSB === e && (this.defCharSB = "?".charCodeAt(0)), typeof p.gb18030 == "function") {
      this.gb18030 = p.gb18030();
      for (var b = this.decodeTables.length, w = this.decodeTables[b] = a.slice(0), S = this.decodeTables.length, T = this.decodeTables[S] = a.slice(0), g = 129; g <= 254; g++)
        for (var E = i - this.decodeTables[0][g], C = this.decodeTables[E], y = 48; y <= 57; y++)
          C[y] = i - b;
      for (var g = 129; g <= 254; g++)
        w[g] = i - S;
      for (var g = 48; g <= 57; g++)
        T[g] = r;
    }
  }
  c.prototype.encoder = f, c.prototype.decoder = u, c.prototype._getDecodeTrieNode = function(p) {
    for (var m = []; p > 0; p >>= 8)
      m.push(p & 255);
    m.length == 0 && m.push(0);
    for (var h = this.decodeTables[0], g = m.length - 1; g > 0; g--) {
      var v = h[m[g]];
      if (v == e)
        h[m[g]] = i - this.decodeTables.length, this.decodeTables.push(h = a.slice(0));
      else if (v <= i)
        h = this.decodeTables[i - v];
      else
        throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + p.toString(16));
    }
    return h;
  }, c.prototype._addDecodeChunk = function(p) {
    var m = parseInt(p[0], 16), h = this._getDecodeTrieNode(m);
    m = m & 255;
    for (var g = 1; g < p.length; g++) {
      var v = p[g];
      if (typeof v == "string")
        for (var d = 0; d < v.length; ) {
          var y = v.charCodeAt(d++);
          if (55296 <= y && y < 56320) {
            var x = v.charCodeAt(d++);
            if (56320 <= x && x < 57344)
              h[m++] = 65536 + (y - 55296) * 1024 + (x - 56320);
            else
              throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + p[0]);
          } else if (4080 < y && y <= 4095) {
            for (var b = 4095 - y + 2, w = [], S = 0; S < b; S++)
              w.push(v.charCodeAt(d++));
            h[m++] = n - this.decodeTableSeq.length, this.decodeTableSeq.push(w);
          } else
            h[m++] = y;
        }
      else if (typeof v == "number")
        for (var T = h[m - 1] + 1, d = 0; d < v; d++)
          h[m++] = T++;
      else
        throw new Error("Incorrect type '" + typeof v + "' given in " + this.encodingName + " at chunk " + p[0]);
    }
    if (m > 255)
      throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + p[0] + ": too long" + m);
  }, c.prototype._getEncodeBucket = function(p) {
    var m = p >> 8;
    return this.encodeTable[m] === void 0 && (this.encodeTable[m] = a.slice(0)), this.encodeTable[m];
  }, c.prototype._setEncodeChar = function(p, m) {
    var h = this._getEncodeBucket(p), g = p & 255;
    h[g] <= n ? this.encodeTableSeq[n - h[g]][s] = m : h[g] == e && (h[g] = m);
  }, c.prototype._setEncodeSequence = function(p, m) {
    var h = p[0], g = this._getEncodeBucket(h), v = h & 255, d;
    g[v] <= n ? d = this.encodeTableSeq[n - g[v]] : (d = {}, g[v] !== e && (d[s] = g[v]), g[v] = n - this.encodeTableSeq.length, this.encodeTableSeq.push(d));
    for (var y = 1; y < p.length - 1; y++) {
      var x = d[h];
      typeof x == "object" ? d = x : (d = d[h] = {}, x !== void 0 && (d[s] = x));
    }
    h = p[p.length - 1], d[h] = m;
  }, c.prototype._fillEncodeTable = function(p, m, h) {
    for (var g = this.decodeTables[p], v = 0; v < 256; v++) {
      var d = g[v], y = m + v;
      h[y] || (d >= 0 ? this._setEncodeChar(d, y) : d <= i ? this._fillEncodeTable(i - d, y << 8, h) : d <= n && this._setEncodeSequence(this.decodeTableSeq[n - d], y));
    }
  };
  function f(p, m) {
    this.leadSurrogate = -1, this.seqObj = void 0, this.encodeTable = m.encodeTable, this.encodeTableSeq = m.encodeTableSeq, this.defaultCharSingleByte = m.defCharSB, this.gb18030 = m.gb18030;
  }
  f.prototype.write = function(p) {
    for (var m = t.alloc(p.length * (this.gb18030 ? 4 : 3)), h = this.leadSurrogate, g = this.seqObj, v = -1, d = 0, y = 0; ; ) {
      if (v === -1) {
        if (d == p.length)
          break;
        var x = p.charCodeAt(d++);
      } else {
        var x = v;
        v = -1;
      }
      if (55296 <= x && x < 57344)
        if (x < 56320)
          if (h === -1) {
            h = x;
            continue;
          } else
            h = x, x = e;
        else
          h !== -1 ? (x = 65536 + (h - 55296) * 1024 + (x - 56320), h = -1) : x = e;
      else
        h !== -1 && (v = x, x = e, h = -1);
      var b = e;
      if (g !== void 0 && x != e) {
        var w = g[x];
        if (typeof w == "object") {
          g = w;
          continue;
        } else
          typeof w == "number" ? b = w : w == null && (w = g[s], w !== void 0 && (b = w, v = x));
        g = void 0;
      } else if (x >= 0) {
        var S = this.encodeTable[x >> 8];
        if (S !== void 0 && (b = S[x & 255]), b <= n) {
          g = this.encodeTableSeq[n - b];
          continue;
        }
        if (b == e && this.gb18030) {
          var T = l(this.gb18030.uChars, x);
          if (T != -1) {
            var b = this.gb18030.gbChars[T] + (x - this.gb18030.uChars[T]);
            m[y++] = 129 + Math.floor(b / 12600), b = b % 12600, m[y++] = 48 + Math.floor(b / 1260), b = b % 1260, m[y++] = 129 + Math.floor(b / 10), b = b % 10, m[y++] = 48 + b;
            continue;
          }
        }
      }
      b === e && (b = this.defaultCharSingleByte), b < 256 ? m[y++] = b : b < 65536 ? (m[y++] = b >> 8, m[y++] = b & 255) : (m[y++] = b >> 16, m[y++] = b >> 8 & 255, m[y++] = b & 255);
    }
    return this.seqObj = g, this.leadSurrogate = h, m.slice(0, y);
  }, f.prototype.end = function() {
    if (!(this.leadSurrogate === -1 && this.seqObj === void 0)) {
      var p = t.alloc(10), m = 0;
      if (this.seqObj) {
        var h = this.seqObj[s];
        h !== void 0 && (h < 256 ? p[m++] = h : (p[m++] = h >> 8, p[m++] = h & 255)), this.seqObj = void 0;
      }
      return this.leadSurrogate !== -1 && (p[m++] = this.defaultCharSingleByte, this.leadSurrogate = -1), p.slice(0, m);
    }
  }, f.prototype.findIdx = l;
  function u(p, m) {
    this.nodeIdx = 0, this.prevBuf = t.alloc(0), this.decodeTables = m.decodeTables, this.decodeTableSeq = m.decodeTableSeq, this.defaultCharUnicode = m.defaultCharUnicode, this.gb18030 = m.gb18030;
  }
  u.prototype.write = function(p) {
    var m = t.alloc(p.length * 2), h = this.nodeIdx, g = this.prevBuf, v = this.prevBuf.length, d = -this.prevBuf.length, y;
    v > 0 && (g = t.concat([g, p.slice(0, 10)]));
    for (var x = 0, b = 0; x < p.length; x++) {
      var w = x >= 0 ? p[x] : g[x + v], y = this.decodeTables[h][w];
      if (!(y >= 0))
        if (y === e)
          x = d, y = this.defaultCharUnicode.charCodeAt(0);
        else if (y === r) {
          var S = d >= 0 ? p.slice(d, x + 1) : g.slice(d + v, x + 1 + v), T = (S[0] - 129) * 12600 + (S[1] - 48) * 1260 + (S[2] - 129) * 10 + (S[3] - 48), E = l(this.gb18030.gbChars, T);
          y = this.gb18030.uChars[E] + T - this.gb18030.gbChars[E];
        } else if (y <= i) {
          h = i - y;
          continue;
        } else if (y <= n) {
          for (var C = this.decodeTableSeq[n - y], A = 0; A < C.length - 1; A++)
            y = C[A], m[b++] = y & 255, m[b++] = y >> 8;
          y = C[C.length - 1];
        } else
          throw new Error("iconv-lite internal error: invalid decoding table value " + y + " at " + h + "/" + w);
      if (y > 65535) {
        y -= 65536;
        var R = 55296 + Math.floor(y / 1024);
        m[b++] = R & 255, m[b++] = R >> 8, y = 56320 + y % 1024;
      }
      m[b++] = y & 255, m[b++] = y >> 8, h = 0, d = x + 1;
    }
    return this.nodeIdx = h, this.prevBuf = d >= 0 ? p.slice(d) : g.slice(d + v), m.slice(0, b).toString("ucs2");
  }, u.prototype.end = function() {
    for (var p = ""; this.prevBuf.length > 0; ) {
      p += this.defaultCharUnicode;
      var m = this.prevBuf.slice(1);
      this.prevBuf = t.alloc(0), this.nodeIdx = 0, m.length > 0 && (p += this.write(m));
    }
    return this.nodeIdx = 0, p;
  };
  function l(p, m) {
    if (p[0] > m)
      return -1;
    for (var h = 0, g = p.length; h < g - 1; ) {
      var v = h + Math.floor((g - h + 1) / 2);
      p[v] <= m ? h = v : g = v;
    }
    return h;
  }
  return Ju;
}
const mI = [
  [
    "0",
    "\0",
    128
  ],
  [
    "a1",
    "",
    62
  ],
  [
    "8140",
    "",
    9,
    ""
  ],
  [
    "8180",
    ""
  ],
  [
    "81b8",
    ""
  ],
  [
    "81c8",
    ""
  ],
  [
    "81da",
    ""
  ],
  [
    "81f0",
    ""
  ],
  [
    "81fc",
    ""
  ],
  [
    "824f",
    "",
    9
  ],
  [
    "8260",
    "",
    25
  ],
  [
    "8281",
    "",
    25
  ],
  [
    "829f",
    "",
    82
  ],
  [
    "8340",
    "",
    62
  ],
  [
    "8380",
    "",
    22
  ],
  [
    "839f",
    "",
    16,
    "",
    6
  ],
  [
    "83bf",
    "",
    16,
    "",
    6
  ],
  [
    "8440",
    "",
    5,
    "",
    25
  ],
  [
    "8470",
    "",
    5,
    "",
    7
  ],
  [
    "8480",
    "",
    17
  ],
  [
    "849f",
    ""
  ],
  [
    "8740",
    "",
    19,
    "",
    9
  ],
  [
    "875f",
    ""
  ],
  [
    "877e",
    ""
  ],
  [
    "8780",
    "",
    4,
    ""
  ],
  [
    "889f",
    ""
  ],
  [
    "8940",
    ""
  ],
  [
    "8980",
    ""
  ],
  [
    "8a40",
    ""
  ],
  [
    "8a80",
    ""
  ],
  [
    "8b40",
    ""
  ],
  [
    "8b80",
    ""
  ],
  [
    "8c40",
    ""
  ],
  [
    "8c80",
    ""
  ],
  [
    "8d40",
    ""
  ],
  [
    "8d80",
    ""
  ],
  [
    "8e40",
    ""
  ],
  [
    "8e80",
    ""
  ],
  [
    "8f40",
    ""
  ],
  [
    "8f80",
    ""
  ],
  [
    "9040",
    ""
  ],
  [
    "9080",
    ""
  ],
  [
    "9140",
    ""
  ],
  [
    "9180",
    ""
  ],
  [
    "9240",
    ""
  ],
  [
    "9280",
    ""
  ],
  [
    "9340",
    ""
  ],
  [
    "9380",
    ""
  ],
  [
    "9440",
    ""
  ],
  [
    "9480",
    ""
  ],
  [
    "9540",
    ""
  ],
  [
    "9580",
    ""
  ],
  [
    "9640",
    ""
  ],
  [
    "9680",
    ""
  ],
  [
    "9740",
    ""
  ],
  [
    "9780",
    ""
  ],
  [
    "9840",
    ""
  ],
  [
    "989f",
    ""
  ],
  [
    "9940",
    ""
  ],
  [
    "9980",
    ""
  ],
  [
    "9a40",
    ""
  ],
  [
    "9a80",
    ""
  ],
  [
    "9b40",
    ""
  ],
  [
    "9b80",
    ""
  ],
  [
    "9c40",
    ""
  ],
  [
    "9c80",
    ""
  ],
  [
    "9d40",
    ""
  ],
  [
    "9d80",
    ""
  ],
  [
    "9e40",
    ""
  ],
  [
    "9e80",
    ""
  ],
  [
    "9f40",
    ""
  ],
  [
    "9f80",
    ""
  ],
  [
    "e040",
    ""
  ],
  [
    "e080",
    ""
  ],
  [
    "e140",
    ""
  ],
  [
    "e180",
    ""
  ],
  [
    "e240",
    ""
  ],
  [
    "e280",
    ""
  ],
  [
    "e340",
    ""
  ],
  [
    "e380",
    ""
  ],
  [
    "e440",
    ""
  ],
  [
    "e480",
    ""
  ],
  [
    "e540",
    ""
  ],
  [
    "e580",
    ""
  ],
  [
    "e640",
    ""
  ],
  [
    "e680",
    ""
  ],
  [
    "e740",
    ""
  ],
  [
    "e780",
    ""
  ],
  [
    "e840",
    ""
  ],
  [
    "e880",
    ""
  ],
  [
    "e940",
    ""
  ],
  [
    "e980",
    ""
  ],
  [
    "ea40",
    ""
  ],
  [
    "ea80",
    ""
  ],
  [
    "ed40",
    ""
  ],
  [
    "ed80",
    ""
  ],
  [
    "ee40",
    ""
  ],
  [
    "ee80",
    ""
  ],
  [
    "eeef",
    "",
    9,
    ""
  ],
  [
    "f040",
    "",
    62
  ],
  [
    "f080",
    "",
    124
  ],
  [
    "f140",
    "",
    62
  ],
  [
    "f180",
    "",
    124
  ],
  [
    "f240",
    "",
    62
  ],
  [
    "f280",
    "",
    124
  ],
  [
    "f340",
    "",
    62
  ],
  [
    "f380",
    "",
    124
  ],
  [
    "f440",
    "",
    62
  ],
  [
    "f480",
    "",
    124
  ],
  [
    "f540",
    "",
    62
  ],
  [
    "f580",
    "",
    124
  ],
  [
    "f640",
    "",
    62
  ],
  [
    "f680",
    "",
    124
  ],
  [
    "f740",
    "",
    62
  ],
  [
    "f780",
    "",
    124
  ],
  [
    "f840",
    "",
    62
  ],
  [
    "f880",
    "",
    124
  ],
  [
    "f940",
    ""
  ],
  [
    "fa40",
    "",
    9,
    "",
    9,
    ""
  ],
  [
    "fa80",
    ""
  ],
  [
    "fb40",
    ""
  ],
  [
    "fb80",
    ""
  ],
  [
    "fc40",
    ""
  ]
], gI = [
  [
    "0",
    "\0",
    127
  ],
  [
    "8ea1",
    "",
    62
  ],
  [
    "a1a1",
    "",
    9,
    ""
  ],
  [
    "a2a1",
    ""
  ],
  [
    "a2ba",
    ""
  ],
  [
    "a2ca",
    ""
  ],
  [
    "a2dc",
    ""
  ],
  [
    "a2f2",
    ""
  ],
  [
    "a2fe",
    ""
  ],
  [
    "a3b0",
    "",
    9
  ],
  [
    "a3c1",
    "",
    25
  ],
  [
    "a3e1",
    "",
    25
  ],
  [
    "a4a1",
    "",
    82
  ],
  [
    "a5a1",
    "",
    85
  ],
  [
    "a6a1",
    "",
    16,
    "",
    6
  ],
  [
    "a6c1",
    "",
    16,
    "",
    6
  ],
  [
    "a7a1",
    "",
    5,
    "",
    25
  ],
  [
    "a7d1",
    "",
    5,
    "",
    25
  ],
  [
    "a8a1",
    ""
  ],
  [
    "ada1",
    "",
    19,
    "",
    9
  ],
  [
    "adc0",
    ""
  ],
  [
    "addf",
    "",
    4,
    ""
  ],
  [
    "b0a1",
    ""
  ],
  [
    "b1a1",
    ""
  ],
  [
    "b2a1",
    ""
  ],
  [
    "b3a1",
    ""
  ],
  [
    "b4a1",
    ""
  ],
  [
    "b5a1",
    ""
  ],
  [
    "b6a1",
    ""
  ],
  [
    "b7a1",
    ""
  ],
  [
    "b8a1",
    ""
  ],
  [
    "b9a1",
    ""
  ],
  [
    "baa1",
    ""
  ],
  [
    "bba1",
    ""
  ],
  [
    "bca1",
    ""
  ],
  [
    "bda1",
    ""
  ],
  [
    "bea1",
    ""
  ],
  [
    "bfa1",
    ""
  ],
  [
    "c0a1",
    ""
  ],
  [
    "c1a1",
    ""
  ],
  [
    "c2a1",
    ""
  ],
  [
    "c3a1",
    ""
  ],
  [
    "c4a1",
    ""
  ],
  [
    "c5a1",
    ""
  ],
  [
    "c6a1",
    ""
  ],
  [
    "c7a1",
    ""
  ],
  [
    "c8a1",
    ""
  ],
  [
    "c9a1",
    ""
  ],
  [
    "caa1",
    ""
  ],
  [
    "cba1",
    ""
  ],
  [
    "cca1",
    ""
  ],
  [
    "cda1",
    ""
  ],
  [
    "cea1",
    ""
  ],
  [
    "cfa1",
    ""
  ],
  [
    "d0a1",
    ""
  ],
  [
    "d1a1",
    ""
  ],
  [
    "d2a1",
    ""
  ],
  [
    "d3a1",
    ""
  ],
  [
    "d4a1",
    ""
  ],
  [
    "d5a1",
    ""
  ],
  [
    "d6a1",
    ""
  ],
  [
    "d7a1",
    ""
  ],
  [
    "d8a1",
    ""
  ],
  [
    "d9a1",
    ""
  ],
  [
    "daa1",
    ""
  ],
  [
    "dba1",
    ""
  ],
  [
    "dca1",
    ""
  ],
  [
    "dda1",
    ""
  ],
  [
    "dea1",
    ""
  ],
  [
    "dfa1",
    ""
  ],
  [
    "e0a1",
    ""
  ],
  [
    "e1a1",
    ""
  ],
  [
    "e2a1",
    ""
  ],
  [
    "e3a1",
    ""
  ],
  [
    "e4a1",
    ""
  ],
  [
    "e5a1",
    ""
  ],
  [
    "e6a1",
    ""
  ],
  [
    "e7a1",
    ""
  ],
  [
    "e8a1",
    ""
  ],
  [
    "e9a1",
    ""
  ],
  [
    "eaa1",
    ""
  ],
  [
    "eba1",
    ""
  ],
  [
    "eca1",
    ""
  ],
  [
    "eda1",
    ""
  ],
  [
    "eea1",
    ""
  ],
  [
    "efa1",
    ""
  ],
  [
    "f0a1",
    ""
  ],
  [
    "f1a1",
    ""
  ],
  [
    "f2a1",
    ""
  ],
  [
    "f3a1",
    ""
  ],
  [
    "f4a1",
    ""
  ],
  [
    "f9a1",
    ""
  ],
  [
    "faa1",
    ""
  ],
  [
    "fba1",
    ""
  ],
  [
    "fca1",
    ""
  ],
  [
    "fcf1",
    "",
    9,
    ""
  ],
  [
    "8fa2af",
    ""
  ],
  [
    "8fa2c2",
    ""
  ],
  [
    "8fa2eb",
    ""
  ],
  [
    "8fa6e1",
    ""
  ],
  [
    "8fa6e7",
    ""
  ],
  [
    "8fa6e9",
    ""
  ],
  [
    "8fa6ec",
    ""
  ],
  [
    "8fa6f1",
    ""
  ],
  [
    "8fa7c2",
    "",
    10,
    ""
  ],
  [
    "8fa7f2",
    "",
    10,
    ""
  ],
  [
    "8fa9a1",
    ""
  ],
  [
    "8fa9a4",
    ""
  ],
  [
    "8fa9a6",
    ""
  ],
  [
    "8fa9a8",
    ""
  ],
  [
    "8fa9ab",
    ""
  ],
  [
    "8fa9af",
    ""
  ],
  [
    "8fa9c1",
    ""
  ],
  [
    "8faaa1",
    ""
  ],
  [
    "8faaba",
    ""
  ],
  [
    "8faba1",
    ""
  ],
  [
    "8fabbd",
    ""
  ],
  [
    "8fabc5",
    ""
  ],
  [
    "8fb0a1",
    ""
  ],
  [
    "8fb1a1",
    ""
  ],
  [
    "8fb2a1",
    "",
    4,
    ""
  ],
  [
    "8fb3a1",
    ""
  ],
  [
    "8fb4a1",
    ""
  ],
  [
    "8fb5a1",
    ""
  ],
  [
    "8fb6a1",
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "8fb7a1",
    "",
    4,
    ""
  ],
  [
    "8fb8a1",
    ""
  ],
  [
    "8fb9a1",
    ""
  ],
  [
    "8fbaa1",
    "",
    4,
    ""
  ],
  [
    "8fbba1",
    ""
  ],
  [
    "8fbca1",
    "",
    4,
    ""
  ],
  [
    "8fbda1",
    "",
    4,
    ""
  ],
  [
    "8fbea1",
    "",
    4,
    ""
  ],
  [
    "8fbfa1",
    ""
  ],
  [
    "8fc0a1",
    ""
  ],
  [
    "8fc1a1",
    ""
  ],
  [
    "8fc2a1",
    ""
  ],
  [
    "8fc3a1",
    "",
    4,
    ""
  ],
  [
    "8fc4a1",
    ""
  ],
  [
    "8fc5a1",
    ""
  ],
  [
    "8fc6a1",
    ""
  ],
  [
    "8fc7a1",
    ""
  ],
  [
    "8fc8a1",
    ""
  ],
  [
    "8fc9a1",
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "8fcaa1",
    ""
  ],
  [
    "8fcba1",
    ""
  ],
  [
    "8fcca1",
    "",
    9,
    ""
  ],
  [
    "8fcda1",
    "",
    5,
    ""
  ],
  [
    "8fcea1",
    "",
    6,
    ""
  ],
  [
    "8fcfa1",
    ""
  ],
  [
    "8fd0a1",
    ""
  ],
  [
    "8fd1a1",
    ""
  ],
  [
    "8fd2a1",
    "",
    5
  ],
  [
    "8fd3a1",
    ""
  ],
  [
    "8fd4a1",
    "",
    4,
    ""
  ],
  [
    "8fd5a1",
    ""
  ],
  [
    "8fd6a1",
    ""
  ],
  [
    "8fd7a1",
    ""
  ],
  [
    "8fd8a1",
    ""
  ],
  [
    "8fd9a1",
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "8fdaa1",
    "",
    4,
    ""
  ],
  [
    "8fdba1",
    "",
    6,
    ""
  ],
  [
    "8fdca1",
    "",
    4,
    ""
  ],
  [
    "8fdda1",
    "",
    4,
    ""
  ],
  [
    "8fdea1",
    "",
    4,
    ""
  ],
  [
    "8fdfa1",
    ""
  ],
  [
    "8fe0a1",
    ""
  ],
  [
    "8fe1a1",
    "",
    4,
    ""
  ],
  [
    "8fe2a1",
    ""
  ],
  [
    "8fe3a1",
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "8fe4a1",
    "",
    4,
    ""
  ],
  [
    "8fe5a1",
    "",
    4,
    ""
  ],
  [
    "8fe6a1",
    ""
  ],
  [
    "8fe7a1",
    ""
  ],
  [
    "8fe8a1",
    "",
    4,
    ""
  ],
  [
    "8fe9a1",
    "",
    4
  ],
  [
    "8feaa1",
    "",
    4,
    ""
  ],
  [
    "8feba1",
    "",
    4,
    ""
  ],
  [
    "8feca1",
    ""
  ],
  [
    "8feda1",
    "",
    4,
    "",
    4,
    ""
  ]
], Xu = [
  [
    "0",
    "\0",
    127,
    ""
  ],
  [
    "8140",
    "",
    5,
    "",
    9,
    "",
    6,
    ""
  ],
  [
    "8180",
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "8240",
    "",
    4,
    "",
    8,
    "",
    4,
    "",
    11
  ],
  [
    "8280",
    "",
    10,
    "",
    4,
    "",
    7,
    "",
    5,
    "",
    8,
    "",
    20,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "8340",
    "",
    17,
    "",
    5,
    "",
    10,
    "",
    4,
    "",
    9,
    ""
  ],
  [
    "8380",
    "",
    5,
    "",
    13,
    "",
    28,
    "",
    4,
    "",
    4,
    "",
    5
  ],
  [
    "8440",
    "",
    5,
    "",
    5,
    ""
  ],
  [
    "8480",
    "",
    9,
    "",
    4,
    "",
    6,
    "",
    6,
    "",
    9,
    "",
    5,
    "",
    10,
    "",
    7,
    ""
  ],
  [
    "8540",
    "",
    9,
    ""
  ],
  [
    "8580",
    "",
    4,
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    7,
    ""
  ],
  [
    "8640",
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "8680",
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    6,
    "",
    8,
    "",
    4,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "8740",
    "",
    7,
    "",
    11,
    "",
    4,
    "",
    4
  ],
  [
    "8780",
    "",
    7,
    "",
    6,
    "",
    14,
    "",
    10,
    "",
    6,
    "",
    12,
    "",
    8,
    "",
    5,
    "",
    6
  ],
  [
    "8840",
    "",
    9,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "8880",
    "",
    4,
    "",
    6,
    "",
    8,
    "",
    6,
    "",
    7,
    "",
    4,
    "",
    4,
    "",
    7
  ],
  [
    "8940",
    "",
    5,
    "",
    6,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    16,
    ""
  ],
  [
    "8980",
    "",
    4,
    "",
    4,
    "",
    7,
    "",
    17,
    "",
    10,
    "",
    13,
    "",
    5,
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "8a40",
    "",
    4,
    "",
    12,
    ""
  ],
  [
    "8a80",
    "",
    5,
    "",
    6,
    "",
    4,
    "",
    11,
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    9,
    "",
    5
  ],
  [
    "8b40",
    "",
    8,
    "",
    17,
    "",
    6,
    "",
    13,
    ""
  ],
  [
    "8b80",
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    22,
    "",
    11,
    "",
    25,
    "",
    7,
    "",
    6
  ],
  [
    "8c40",
    "",
    7,
    ""
  ],
  [
    "8c80",
    "",
    8,
    "",
    4,
    "",
    6,
    "",
    6,
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    4
  ],
  [
    "8d40",
    "",
    5,
    "",
    5,
    "",
    5,
    "",
    6,
    "",
    9,
    "",
    4
  ],
  [
    "8d80",
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    4,
    "",
    7,
    "",
    7,
    "",
    10,
    "",
    10,
    "",
    12,
    "",
    21,
    ""
  ],
  [
    "8e40",
    "",
    21,
    "",
    12,
    "",
    6,
    "",
    12,
    ""
  ],
  [
    "8e80",
    "",
    4,
    "",
    7,
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    6,
    "",
    4,
    "",
    14,
    "",
    4,
    "",
    4,
    "",
    6
  ],
  [
    "8f40",
    "",
    5,
    "",
    11,
    "",
    8,
    ""
  ],
  [
    "8f80",
    "",
    6,
    "",
    14,
    "",
    5,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "9040",
    "",
    4,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "9080",
    "",
    7,
    "",
    4,
    "",
    4,
    "",
    4,
    "",
    4,
    "",
    18,
    "",
    6
  ],
  [
    "9140",
    "",
    6,
    "",
    6,
    "",
    18,
    "",
    4,
    ""
  ],
  [
    "9180",
    "",
    6,
    "",
    8,
    "",
    9,
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    16,
    "",
    13,
    "",
    8,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "9240",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9280",
    "",
    5,
    "",
    7,
    "",
    6,
    ""
  ],
  [
    "9340",
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "9380",
    "",
    5,
    "",
    4,
    "",
    6,
    "",
    4,
    "",
    7,
    "",
    9,
    "",
    6,
    "",
    8,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "9440",
    "",
    24,
    "",
    7,
    "",
    7,
    "",
    4,
    "",
    8
  ],
  [
    "9480",
    "",
    4,
    "",
    4,
    "",
    14,
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "9540",
    "",
    4,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "9580",
    "",
    4,
    "",
    4,
    "",
    8,
    "",
    4,
    "",
    4,
    "",
    25,
    "",
    7,
    "",
    5,
    ""
  ],
  [
    "9640",
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "9680",
    "",
    7,
    "",
    9,
    "",
    7,
    "",
    4,
    "",
    6,
    "",
    6,
    "",
    5
  ],
  [
    "9740",
    "",
    7,
    "",
    8,
    "",
    7,
    "",
    9,
    ""
  ],
  [
    "9780",
    "",
    6,
    "",
    5,
    "",
    4,
    "",
    9,
    "",
    4,
    "",
    11,
    "",
    7,
    "",
    16,
    ""
  ],
  [
    "9840",
    "",
    4,
    "",
    5,
    "",
    9,
    ""
  ],
  [
    "9880",
    "",
    7,
    "",
    5,
    "",
    11,
    "",
    9,
    "",
    9,
    "",
    11,
    "",
    5,
    "",
    5,
    "",
    6,
    "",
    4,
    "",
    7,
    "",
    6,
    ""
  ],
  [
    "9940",
    "",
    4,
    "",
    10,
    "",
    6,
    "",
    8,
    "",
    4,
    "",
    7,
    "",
    5
  ],
  [
    "9980",
    "",
    114,
    "",
    6
  ],
  [
    "9a40",
    "",
    11,
    "",
    7,
    "",
    13,
    ""
  ],
  [
    "9a80",
    "",
    4,
    "",
    7,
    "",
    7,
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    7,
    "",
    6,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "9b40",
    "",
    4,
    ""
  ],
  [
    "9b80",
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "9c40",
    "",
    7,
    ""
  ],
  [
    "9c80",
    "",
    7,
    "",
    7,
    "",
    10,
    "",
    14,
    "",
    4,
    "",
    6,
    "",
    5
  ],
  [
    "9d40",
    "",
    7,
    "",
    4,
    "",
    9,
    "",
    6,
    ""
  ],
  [
    "9d80",
    "",
    9,
    "",
    5,
    "",
    6,
    "",
    12,
    "",
    4,
    "",
    10,
    "",
    5,
    "",
    5,
    "",
    6,
    "",
    10,
    ""
  ],
  [
    "9e40",
    "",
    7,
    "",
    32,
    "",
    7,
    "",
    6,
    "",
    6
  ],
  [
    "9e80",
    "",
    9,
    "",
    17,
    "",
    13,
    "",
    11,
    "",
    12,
    "",
    12,
    ""
  ],
  [
    "9f40",
    "",
    6,
    "",
    10,
    "",
    4,
    "",
    10,
    "",
    7,
    ""
  ],
  [
    "9f80",
    "",
    13,
    "",
    12,
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    8,
    "",
    9,
    "",
    4
  ],
  [
    "a040",
    "",
    9,
    "",
    5,
    "",
    9,
    "",
    11,
    "",
    19
  ],
  [
    "a080",
    "",
    9,
    "",
    6,
    "",
    4,
    "",
    11,
    "",
    11,
    "",
    6,
    ""
  ],
  [
    "a1a1",
    "",
    7,
    ""
  ],
  [
    "a2a1",
    "",
    9
  ],
  [
    "a2b1",
    "",
    19,
    "",
    19,
    "",
    9
  ],
  [
    "a2e5",
    "",
    9
  ],
  [
    "a2f1",
    "",
    11
  ],
  [
    "a3a1",
    "",
    88,
    ""
  ],
  [
    "a4a1",
    "",
    82
  ],
  [
    "a5a1",
    "",
    85
  ],
  [
    "a6a1",
    "",
    16,
    "",
    6
  ],
  [
    "a6c1",
    "",
    16,
    "",
    6
  ],
  [
    "a6e0",
    ""
  ],
  [
    "a6ee",
    ""
  ],
  [
    "a6f4",
    ""
  ],
  [
    "a7a1",
    "",
    5,
    "",
    25
  ],
  [
    "a7d1",
    "",
    5,
    "",
    25
  ],
  [
    "a840",
    "",
    35,
    "",
    6
  ],
  [
    "a880",
    "",
    7,
    ""
  ],
  [
    "a8a1",
    ""
  ],
  [
    "a8bd",
    ""
  ],
  [
    "a8c0",
    ""
  ],
  [
    "a8c5",
    "",
    36
  ],
  [
    "a940",
    "",
    8,
    ""
  ],
  [
    "a959",
    ""
  ],
  [
    "a95c",
    ""
  ],
  [
    "a960",
    "",
    9,
    "",
    8
  ],
  [
    "a980",
    "",
    4,
    ""
  ],
  [
    "a996",
    ""
  ],
  [
    "a9a4",
    "",
    75
  ],
  [
    "aa40",
    "",
    5,
    "",
    5,
    "",
    8
  ],
  [
    "aa80",
    "",
    7,
    "",
    10,
    ""
  ],
  [
    "ab40",
    "",
    11,
    "",
    4,
    "",
    5,
    "",
    4
  ],
  [
    "ab80",
    "",
    6,
    "",
    4
  ],
  [
    "ac40",
    "",
    10,
    "",
    8,
    "",
    5,
    "",
    4,
    "",
    11
  ],
  [
    "ac80",
    "",
    6,
    "",
    12,
    "",
    4,
    ""
  ],
  [
    "ad40",
    "",
    10,
    "",
    7,
    "",
    15,
    "",
    12
  ],
  [
    "ad80",
    "",
    9,
    "",
    8,
    "",
    6,
    ""
  ],
  [
    "ae40",
    "",
    6,
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "ae80",
    "",
    7,
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "af40",
    "",
    4,
    ""
  ],
  [
    "af80",
    ""
  ],
  [
    "b040",
    "",
    6,
    "",
    5,
    "",
    4,
    "",
    6,
    "",
    7,
    ""
  ],
  [
    "b080",
    "",
    7,
    "",
    8,
    "",
    9,
    ""
  ],
  [
    "b140",
    "",
    4,
    "",
    7,
    "",
    10,
    ""
  ],
  [
    "b180",
    "",
    4,
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "b240",
    "",
    11,
    "",
    5,
    "",
    11,
    "",
    4
  ],
  [
    "b280",
    "",
    12,
    "",
    8,
    "",
    4,
    ""
  ],
  [
    "b340",
    "",
    5,
    ""
  ],
  [
    "b380",
    "",
    11,
    "",
    7,
    "",
    6,
    ""
  ],
  [
    "b440",
    "",
    7,
    "",
    9
  ],
  [
    "b480",
    "",
    4,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "b540",
    "",
    5,
    "",
    9,
    "",
    4,
    "",
    14,
    "",
    4,
    "",
    8,
    ""
  ],
  [
    "b580",
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "b640",
    "",
    6,
    "",
    11,
    "",
    10,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "b680",
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "b740",
    "",
    14,
    "",
    5,
    "",
    9,
    "",
    4,
    "",
    16
  ],
  [
    "b780",
    "",
    6,
    ""
  ],
  [
    "b840",
    "",
    4,
    "",
    10,
    "",
    10,
    "",
    9,
    "",
    5,
    ""
  ],
  [
    "b880",
    "",
    4,
    ""
  ],
  [
    "b940",
    "",
    5,
    "",
    10,
    "",
    6,
    ""
  ],
  [
    "b980",
    "",
    7,
    ""
  ],
  [
    "ba40",
    "",
    4,
    "",
    4,
    "",
    7,
    "",
    5,
    ""
  ],
  [
    "ba80",
    "",
    4,
    "",
    5,
    "",
    12,
    "",
    5,
    ""
  ],
  [
    "bb40",
    "",
    9,
    "",
    36,
    "",
    5,
    "",
    9
  ],
  [
    "bb80",
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "bc40",
    "",
    6,
    "",
    6,
    "",
    5,
    "",
    7,
    "",
    13,
    "",
    5
  ],
  [
    "bc80",
    "",
    14,
    "",
    6,
    ""
  ],
  [
    "bd40",
    "",
    54,
    "",
    7
  ],
  [
    "bd80",
    "",
    32,
    ""
  ],
  [
    "be40",
    "",
    12,
    "",
    6,
    "",
    42
  ],
  [
    "be80",
    "",
    32,
    ""
  ],
  [
    "bf40",
    "",
    62
  ],
  [
    "bf80",
    "",
    4,
    "",
    4,
    "",
    21,
    ""
  ],
  [
    "c040",
    "",
    35,
    "",
    23,
    ""
  ],
  [
    "c080",
    "",
    6,
    "",
    9,
    ""
  ],
  [
    "c140",
    "",
    4,
    "",
    7,
    "",
    4,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "c180",
    "",
    4,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "c240",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "c280",
    "",
    13,
    "",
    5,
    "",
    11,
    ""
  ],
  [
    "c340",
    "",
    5,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "c380",
    "",
    12,
    "",
    4,
    ""
  ],
  [
    "c440",
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "c480",
    "",
    7,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "c540",
    "",
    14,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "c580",
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "c640",
    ""
  ],
  [
    "c680",
    "",
    4,
    "",
    9,
    ""
  ],
  [
    "c740",
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    6,
    "",
    6,
    ""
  ],
  [
    "c780",
    ""
  ],
  [
    "c840",
    "",
    4,
    "",
    5,
    "",
    5,
    "",
    7,
    "",
    5,
    "",
    7,
    ""
  ],
  [
    "c880",
    "",
    6,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "c940",
    "",
    4,
    "",
    7,
    "",
    12,
    ""
  ],
  [
    "c980",
    "",
    4,
    "",
    4,
    "",
    10,
    ""
  ],
  [
    "ca40",
    "",
    8,
    "",
    8,
    "",
    9,
    "",
    4,
    "",
    10
  ],
  [
    "ca80",
    "",
    4,
    "",
    8,
    ""
  ],
  [
    "cb40",
    "",
    6,
    "",
    10,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "cb80",
    "",
    5,
    "",
    6,
    "",
    14,
    ""
  ],
  [
    "cc40",
    "",
    4,
    "",
    10,
    "",
    15,
    "",
    13,
    ""
  ],
  [
    "cc80",
    "",
    11,
    "",
    4,
    "",
    7,
    ""
  ],
  [
    "cd40",
    "",
    6,
    "",
    6,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "cd80",
    ""
  ],
  [
    "ce40",
    "",
    6,
    "",
    5,
    "",
    7,
    ""
  ],
  [
    "ce80",
    "",
    4,
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "cf40",
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    9
  ],
  [
    "cf80",
    "",
    5,
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "d040",
    "",
    13,
    "",
    5,
    "",
    5,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "d080",
    "",
    4,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "d140",
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    5
  ],
  [
    "d180",
    "",
    4,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "d240",
    "",
    8,
    "",
    24,
    "",
    5,
    "",
    19,
    ""
  ],
  [
    "d280",
    "",
    26,
    ""
  ],
  [
    "d340",
    "",
    30,
    "",
    6
  ],
  [
    "d380",
    "",
    4,
    "",
    5,
    "",
    21,
    ""
  ],
  [
    "d440",
    "",
    31,
    "",
    8,
    "",
    21
  ],
  [
    "d480",
    "",
    25,
    "",
    6,
    ""
  ],
  [
    "d540",
    "",
    7,
    "",
    7,
    "",
    46
  ],
  [
    "d580",
    "",
    32,
    ""
  ],
  [
    "d640",
    "",
    34,
    "",
    27
  ],
  [
    "d680",
    "",
    30,
    ""
  ],
  [
    "d740",
    "",
    31,
    "",
    4,
    "",
    25
  ],
  [
    "d780",
    "",
    24,
    ""
  ],
  [
    "d840",
    "",
    8,
    "",
    7,
    "",
    5,
    "",
    6,
    "",
    6,
    "",
    6,
    ""
  ],
  [
    "d880",
    "",
    6,
    "",
    20,
    ""
  ],
  [
    "d940",
    "",
    62
  ],
  [
    "d980",
    "",
    32,
    ""
  ],
  [
    "da40",
    "",
    14,
    "",
    8,
    "",
    4,
    "",
    9,
    ""
  ],
  [
    "da80",
    "",
    12,
    ""
  ],
  [
    "db40",
    "",
    6,
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "db80",
    "",
    4,
    "",
    5,
    "",
    11,
    ""
  ],
  [
    "dc40",
    "",
    4,
    "",
    6,
    "",
    6,
    "",
    11,
    "",
    6,
    "",
    7
  ],
  [
    "dc80",
    "",
    10,
    "",
    21,
    ""
  ],
  [
    "dd40",
    "",
    62
  ],
  [
    "dd80",
    "",
    32,
    ""
  ],
  [
    "de40",
    "",
    32,
    ""
  ],
  [
    "de80",
    "",
    4,
    ""
  ],
  [
    "df40",
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "df80",
    "",
    4,
    ""
  ],
  [
    "e040",
    "",
    19,
    ""
  ],
  [
    "e080",
    "",
    10,
    "",
    6,
    "",
    8,
    ""
  ],
  [
    "e140",
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    5,
    ""
  ],
  [
    "e180",
    "",
    10,
    "",
    9,
    "",
    8,
    ""
  ],
  [
    "e240",
    "",
    62
  ],
  [
    "e280",
    "",
    32,
    "",
    5,
    ""
  ],
  [
    "e340",
    "",
    45,
    "",
    16
  ],
  [
    "e380",
    "",
    7,
    "",
    24,
    ""
  ],
  [
    "e440",
    "",
    5,
    "",
    24,
    "",
    31
  ],
  [
    "e480",
    "",
    32,
    ""
  ],
  [
    "e540",
    "",
    51,
    "",
    10
  ],
  [
    "e580",
    "",
    31,
    ""
  ],
  [
    "e640",
    "",
    34,
    "",
    27
  ],
  [
    "e680",
    "",
    29,
    ""
  ],
  [
    "e740",
    "",
    7,
    "",
    54
  ],
  [
    "e780",
    "",
    32,
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "e840",
    "",
    14,
    "",
    43,
    ""
  ],
  [
    "e880",
    "",
    20,
    ""
  ],
  [
    "e940",
    "",
    7,
    "",
    42
  ],
  [
    "e980",
    "",
    32,
    ""
  ],
  [
    "ea40",
    "",
    27,
    "",
    6,
    ""
  ],
  [
    "ea80",
    "",
    4,
    "",
    12,
    ""
  ],
  [
    "eb40",
    "",
    9,
    "",
    7,
    "",
    9,
    "",
    6,
    ""
  ],
  [
    "eb80",
    "",
    4,
    ""
  ],
  [
    "ec40",
    "",
    8,
    "",
    4,
    "",
    18,
    "",
    7
  ],
  [
    "ec80",
    "",
    4,
    "",
    7,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "ed40",
    "",
    6,
    "",
    46
  ],
  [
    "ed80",
    "",
    4,
    "",
    23,
    ""
  ],
  [
    "ee40",
    "",
    62
  ],
  [
    "ee80",
    "",
    32,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "ef40",
    "",
    5,
    "",
    37,
    "",
    4
  ],
  [
    "ef80",
    "",
    30,
    "",
    4,
    "",
    8,
    ""
  ],
  [
    "f040",
    "",
    4,
    "",
    28,
    "",
    26
  ],
  [
    "f080",
    "",
    9,
    "",
    12,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "f140",
    "",
    10,
    "",
    47
  ],
  [
    "f180",
    "",
    32,
    ""
  ],
  [
    "f240",
    "",
    62
  ],
  [
    "f280",
    "",
    32,
    ""
  ],
  [
    "f340",
    "",
    17,
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "f380",
    "",
    8,
    "",
    6,
    ""
  ],
  [
    "f440",
    "",
    5,
    "",
    10,
    "",
    10,
    "",
    7,
    "",
    5
  ],
  [
    "f480",
    "",
    32,
    ""
  ],
  [
    "f540",
    "",
    62
  ],
  [
    "f580",
    "",
    32,
    ""
  ],
  [
    "f640",
    "",
    62
  ],
  [
    "f680",
    "",
    32,
    "",
    5,
    "",
    5,
    "",
    4,
    "",
    7,
    ""
  ],
  [
    "f740",
    "",
    62
  ],
  [
    "f780",
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "f840",
    "",
    62
  ],
  [
    "f880",
    "",
    32
  ],
  [
    "f940",
    "",
    62
  ],
  [
    "f980",
    "",
    32
  ],
  [
    "fa40",
    "",
    62
  ],
  [
    "fa80",
    "",
    32
  ],
  [
    "fb40",
    "",
    27,
    "",
    9,
    ""
  ],
  [
    "fb80",
    "",
    5,
    "",
    8,
    "",
    5,
    ""
  ],
  [
    "fc40",
    "",
    8,
    "",
    4,
    "",
    8,
    "",
    6
  ],
  [
    "fc80",
    "",
    4,
    "",
    5,
    "",
    8,
    ""
  ],
  [
    "fd40",
    "",
    4,
    "",
    4,
    "",
    10,
    "",
    38
  ],
  [
    "fd80",
    "",
    5,
    "",
    11,
    "",
    4,
    ""
  ],
  [
    "fe40",
    ""
  ]
], Jy = [
  [
    "a140",
    "",
    62
  ],
  [
    "a180",
    "",
    32
  ],
  [
    "a240",
    "",
    62
  ],
  [
    "a280",
    "",
    32
  ],
  [
    "a2ab",
    "",
    5
  ],
  [
    "a2e3",
    ""
  ],
  [
    "a2ef",
    ""
  ],
  [
    "a2fd",
    ""
  ],
  [
    "a340",
    "",
    62
  ],
  [
    "a380",
    "",
    31,
    ""
  ],
  [
    "a440",
    "",
    62
  ],
  [
    "a480",
    "",
    32
  ],
  [
    "a4f4",
    "",
    10
  ],
  [
    "a540",
    "",
    62
  ],
  [
    "a580",
    "",
    32
  ],
  [
    "a5f7",
    "",
    7
  ],
  [
    "a640",
    "",
    62
  ],
  [
    "a680",
    "",
    32
  ],
  [
    "a6b9",
    "",
    7
  ],
  [
    "a6d9",
    "",
    6
  ],
  [
    "a6ec",
    ""
  ],
  [
    "a6f3",
    ""
  ],
  [
    "a6f6",
    "",
    8
  ],
  [
    "a740",
    "",
    62
  ],
  [
    "a780",
    "",
    32
  ],
  [
    "a7c2",
    "",
    14
  ],
  [
    "a7f2",
    "",
    12
  ],
  [
    "a896",
    "",
    10
  ],
  [
    "a8bc",
    ""
  ],
  [
    "a8bf",
    ""
  ],
  [
    "a8c1",
    ""
  ],
  [
    "a8ea",
    "",
    20
  ],
  [
    "a958",
    ""
  ],
  [
    "a95b",
    ""
  ],
  [
    "a95d",
    ""
  ],
  [
    "a989",
    "",
    11
  ],
  [
    "a997",
    "",
    12
  ],
  [
    "a9f0",
    "",
    14
  ],
  [
    "aaa1",
    "",
    93
  ],
  [
    "aba1",
    "",
    93
  ],
  [
    "aca1",
    "",
    93
  ],
  [
    "ada1",
    "",
    93
  ],
  [
    "aea1",
    "",
    93
  ],
  [
    "afa1",
    "",
    93
  ],
  [
    "d7fa",
    "",
    4
  ],
  [
    "f8a1",
    "",
    93
  ],
  [
    "f9a1",
    "",
    93
  ],
  [
    "faa1",
    "",
    93
  ],
  [
    "fba1",
    "",
    93
  ],
  [
    "fca1",
    "",
    93
  ],
  [
    "fda1",
    "",
    93
  ],
  [
    "fe50",
    ""
  ],
  [
    "fe80",
    "",
    6,
    "",
    93
  ]
], vI = [
  128,
  165,
  169,
  178,
  184,
  216,
  226,
  235,
  238,
  244,
  248,
  251,
  253,
  258,
  276,
  284,
  300,
  325,
  329,
  334,
  364,
  463,
  465,
  467,
  469,
  471,
  473,
  475,
  477,
  506,
  594,
  610,
  712,
  716,
  730,
  930,
  938,
  962,
  970,
  1026,
  1104,
  1106,
  8209,
  8215,
  8218,
  8222,
  8231,
  8241,
  8244,
  8246,
  8252,
  8365,
  8452,
  8454,
  8458,
  8471,
  8482,
  8556,
  8570,
  8596,
  8602,
  8713,
  8720,
  8722,
  8726,
  8731,
  8737,
  8740,
  8742,
  8748,
  8751,
  8760,
  8766,
  8777,
  8781,
  8787,
  8802,
  8808,
  8816,
  8854,
  8858,
  8870,
  8896,
  8979,
  9322,
  9372,
  9548,
  9588,
  9616,
  9622,
  9634,
  9652,
  9662,
  9672,
  9676,
  9680,
  9702,
  9735,
  9738,
  9793,
  9795,
  11906,
  11909,
  11913,
  11917,
  11928,
  11944,
  11947,
  11951,
  11956,
  11960,
  11964,
  11979,
  12284,
  12292,
  12312,
  12319,
  12330,
  12351,
  12436,
  12447,
  12535,
  12543,
  12586,
  12842,
  12850,
  12964,
  13200,
  13215,
  13218,
  13253,
  13263,
  13267,
  13270,
  13384,
  13428,
  13727,
  13839,
  13851,
  14617,
  14703,
  14801,
  14816,
  14964,
  15183,
  15471,
  15585,
  16471,
  16736,
  17208,
  17325,
  17330,
  17374,
  17623,
  17997,
  18018,
  18212,
  18218,
  18301,
  18318,
  18760,
  18811,
  18814,
  18820,
  18823,
  18844,
  18848,
  18872,
  19576,
  19620,
  19738,
  19887,
  40870,
  59244,
  59336,
  59367,
  59413,
  59417,
  59423,
  59431,
  59437,
  59443,
  59452,
  59460,
  59478,
  59493,
  63789,
  63866,
  63894,
  63976,
  63986,
  64016,
  64018,
  64021,
  64025,
  64034,
  64037,
  64042,
  65074,
  65093,
  65107,
  65112,
  65127,
  65132,
  65375,
  65510,
  65536
], yI = [
  0,
  36,
  38,
  45,
  50,
  81,
  89,
  95,
  96,
  100,
  103,
  104,
  105,
  109,
  126,
  133,
  148,
  172,
  175,
  179,
  208,
  306,
  307,
  308,
  309,
  310,
  311,
  312,
  313,
  341,
  428,
  443,
  544,
  545,
  558,
  741,
  742,
  749,
  750,
  805,
  819,
  820,
  7922,
  7924,
  7925,
  7927,
  7934,
  7943,
  7944,
  7945,
  7950,
  8062,
  8148,
  8149,
  8152,
  8164,
  8174,
  8236,
  8240,
  8262,
  8264,
  8374,
  8380,
  8381,
  8384,
  8388,
  8390,
  8392,
  8393,
  8394,
  8396,
  8401,
  8406,
  8416,
  8419,
  8424,
  8437,
  8439,
  8445,
  8482,
  8485,
  8496,
  8521,
  8603,
  8936,
  8946,
  9046,
  9050,
  9063,
  9066,
  9076,
  9092,
  9100,
  9108,
  9111,
  9113,
  9131,
  9162,
  9164,
  9218,
  9219,
  11329,
  11331,
  11334,
  11336,
  11346,
  11361,
  11363,
  11366,
  11370,
  11372,
  11375,
  11389,
  11682,
  11686,
  11687,
  11692,
  11694,
  11714,
  11716,
  11723,
  11725,
  11730,
  11736,
  11982,
  11989,
  12102,
  12336,
  12348,
  12350,
  12384,
  12393,
  12395,
  12397,
  12510,
  12553,
  12851,
  12962,
  12973,
  13738,
  13823,
  13919,
  13933,
  14080,
  14298,
  14585,
  14698,
  15583,
  15847,
  16318,
  16434,
  16438,
  16481,
  16729,
  17102,
  17122,
  17315,
  17320,
  17402,
  17418,
  17859,
  17909,
  17911,
  17915,
  17916,
  17936,
  17939,
  17961,
  18664,
  18703,
  18814,
  18962,
  19043,
  33469,
  33470,
  33471,
  33484,
  33485,
  33490,
  33497,
  33501,
  33505,
  33513,
  33520,
  33536,
  33550,
  37845,
  37921,
  37948,
  38029,
  38038,
  38064,
  38065,
  38066,
  38069,
  38075,
  38076,
  38078,
  39108,
  39109,
  39113,
  39114,
  39115,
  39116,
  39265,
  39394,
  189e3
], bI = {
  uChars: vI,
  gbChars: yI
}, wI = [
  [
    "0",
    "\0",
    127
  ],
  [
    "8141",
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "8161",
    "",
    9,
    "",
    5,
    ""
  ],
  [
    "8181",
    "",
    18,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    7,
    "",
    7,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "8241",
    "",
    7,
    "",
    5
  ],
  [
    "8261",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "8281",
    "",
    7,
    "",
    7,
    "",
    4,
    "",
    10,
    "",
    5,
    "",
    17,
    "",
    7,
    "",
    6,
    "",
    7,
    "",
    18
  ],
  [
    "8341",
    "",
    5,
    "",
    5,
    "",
    7
  ],
  [
    "8361",
    "",
    18,
    ""
  ],
  [
    "8381",
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    5,
    "",
    46,
    "",
    6,
    "",
    5,
    "",
    8
  ],
  [
    "8441",
    "",
    5,
    "",
    8
  ],
  [
    "8461",
    "",
    18
  ],
  [
    "8481",
    "",
    7,
    "",
    6,
    "",
    5,
    "",
    10,
    "",
    5,
    "",
    18,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    26,
    ""
  ],
  [
    "8541",
    "",
    5,
    "",
    4,
    "",
    6,
    "",
    4
  ],
  [
    "8561",
    "",
    5,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "8581",
    "",
    6,
    "",
    6,
    "",
    9,
    "",
    26,
    "",
    29,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "8641",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "8661",
    "",
    6,
    "",
    10
  ],
  [
    "8681",
    "",
    22,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    22,
    "",
    4,
    ""
  ],
  [
    "8741",
    "",
    9,
    "",
    15
  ],
  [
    "8761",
    "",
    18,
    ""
  ],
  [
    "8781",
    "",
    5,
    "",
    7,
    "",
    7,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    18,
    "",
    6,
    "",
    26,
    "",
    6,
    "",
    4
  ],
  [
    "8841",
    "",
    4,
    "",
    5,
    "",
    6,
    "",
    4
  ],
  [
    "8861",
    "",
    4,
    ""
  ],
  [
    "8881",
    "",
    15,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    54,
    ""
  ],
  [
    "8941",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "8961",
    "",
    10,
    "",
    5,
    ""
  ],
  [
    "8981",
    "",
    21,
    "",
    18,
    "",
    18,
    "",
    6,
    "",
    6,
    "",
    7,
    "",
    15
  ],
  [
    "8a41",
    "",
    10,
    "",
    6,
    ""
  ],
  [
    "8a61",
    "",
    4,
    "",
    18,
    ""
  ],
  [
    "8a81",
    "",
    4,
    "",
    19,
    "",
    5,
    "",
    7,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    4,
    "",
    5,
    "",
    26,
    ""
  ],
  [
    "8b41",
    "",
    5,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "8b61",
    "",
    6,
    "",
    8
  ],
  [
    "8b81",
    "",
    52,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    18,
    "",
    18
  ],
  [
    "8c41",
    "",
    15,
    "",
    4
  ],
  [
    "8c61",
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5
  ],
  [
    "8c81",
    "",
    12,
    "",
    26,
    "",
    50,
    "",
    5,
    "",
    16
  ],
  [
    "8d41",
    "",
    16,
    "",
    8
  ],
  [
    "8d61",
    "",
    17,
    ""
  ],
  [
    "8d81",
    "",
    4,
    "",
    33,
    "",
    6,
    "",
    7,
    "",
    6,
    "",
    9,
    "",
    6,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "8e41",
    "",
    6,
    "",
    5,
    "",
    8
  ],
  [
    "8e61",
    "",
    4,
    "",
    19
  ],
  [
    "8e81",
    "",
    13,
    "",
    6,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    11,
    "",
    7,
    "",
    6,
    "",
    5,
    "",
    7
  ],
  [
    "8f41",
    "",
    7,
    "",
    17
  ],
  [
    "8f61",
    "",
    7,
    "",
    6,
    "",
    4
  ],
  [
    "8f81",
    "",
    5,
    "",
    7,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    18,
    "",
    6,
    "",
    26,
    "",
    6,
    "",
    5
  ],
  [
    "9041",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9061",
    "",
    5,
    "",
    15
  ],
  [
    "9081",
    "",
    12,
    "",
    6,
    "",
    5,
    "",
    4,
    "",
    6,
    "",
    4,
    "",
    5,
    "",
    11,
    "",
    33,
    ""
  ],
  [
    "9141",
    "",
    6,
    "",
    5
  ],
  [
    "9161",
    "",
    9,
    "",
    5
  ],
  [
    "9181",
    "",
    20,
    "",
    4,
    "",
    5,
    "",
    14,
    "",
    33,
    "",
    7,
    "",
    5,
    "",
    6
  ],
  [
    "9241",
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "9261",
    "",
    7,
    "",
    7,
    "",
    4
  ],
  [
    "9281",
    "",
    21,
    "",
    18,
    "",
    6,
    "",
    7,
    "",
    6,
    "",
    35,
    ""
  ],
  [
    "9341",
    "",
    4,
    ""
  ],
  [
    "9361",
    "",
    6,
    "",
    8
  ],
  [
    "9381",
    "",
    37,
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    7,
    "",
    22,
    ""
  ],
  [
    "9441",
    "",
    5,
    "",
    5,
    "",
    8
  ],
  [
    "9461",
    "",
    5,
    "",
    6,
    "",
    12
  ],
  [
    "9481",
    "",
    5,
    "",
    6,
    "",
    6,
    "",
    9,
    "",
    22,
    "",
    4,
    "",
    6,
    "",
    10,
    "",
    6,
    "",
    24
  ],
  [
    "9541",
    "",
    11,
    "",
    5,
    ""
  ],
  [
    "9561",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9581",
    "",
    6,
    "",
    35,
    "",
    4,
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    13,
    "",
    14
  ],
  [
    "9641",
    "",
    23,
    ""
  ],
  [
    "9661",
    "",
    6,
    "",
    5,
    "",
    8
  ],
  [
    "9681",
    "",
    10,
    "",
    5,
    "",
    13,
    "",
    33,
    "",
    6,
    "",
    44
  ],
  [
    "9741",
    "",
    16,
    "",
    8
  ],
  [
    "9761",
    "",
    17,
    "",
    7
  ],
  [
    "9781",
    "",
    11,
    "",
    5,
    "",
    6,
    "",
    89,
    ""
  ],
  [
    "9841",
    "",
    16,
    "",
    5,
    ""
  ],
  [
    "9861",
    "",
    6,
    "",
    15
  ],
  [
    "9881",
    "",
    21,
    "",
    6,
    "",
    5,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9941",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9961",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9981",
    "",
    8,
    "",
    5,
    "",
    4,
    "",
    11,
    "",
    5,
    "",
    6,
    "",
    6,
    "",
    6,
    "",
    7,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9a41",
    "",
    16
  ],
  [
    "9a61",
    "",
    6,
    "",
    6,
    ""
  ],
  [
    "9a81",
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    5,
    "",
    33,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "9b41",
    "",
    6,
    "",
    8
  ],
  [
    "9b61",
    "",
    17,
    "",
    7
  ],
  [
    "9b81",
    "",
    25,
    "",
    4,
    "",
    5,
    "",
    50,
    "",
    22,
    ""
  ],
  [
    "9c41",
    "",
    4,
    "",
    5,
    "",
    5
  ],
  [
    "9c61",
    "",
    8,
    "",
    6,
    "",
    9
  ],
  [
    "9c81",
    "",
    8,
    "",
    6,
    "",
    6,
    "",
    9,
    "",
    26,
    "",
    6,
    "",
    5,
    "",
    18,
    "",
    6,
    "",
    12
  ],
  [
    "9d41",
    "",
    13,
    "",
    8
  ],
  [
    "9d61",
    "",
    25
  ],
  [
    "9d81",
    "",
    8,
    "",
    5,
    "",
    9,
    "",
    6,
    "",
    10,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9e41",
    "",
    7,
    "",
    9,
    ""
  ],
  [
    "9e61",
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "9e81",
    "",
    6,
    "",
    6,
    "",
    6,
    "",
    5,
    "",
    10,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "9f41",
    "",
    5,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "9f61",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9f81",
    "",
    4,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    4,
    "",
    6,
    "",
    7,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "a041",
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "a061",
    "",
    5,
    "",
    13
  ],
  [
    "a081",
    "",
    4,
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    26,
    "",
    4,
    "",
    5,
    "",
    7,
    ""
  ],
  [
    "a141",
    "",
    18,
    ""
  ],
  [
    "a161",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "a181",
    "",
    14,
    "",
    5,
    "",
    4,
    "",
    9,
    ""
  ],
  [
    "a241",
    "",
    5,
    "",
    18
  ],
  [
    "a261",
    "",
    6,
    "",
    18
  ],
  [
    "a281",
    "",
    7,
    "",
    6,
    "",
    7,
    ""
  ],
  [
    "a341",
    "",
    6,
    "",
    10,
    ""
  ],
  [
    "a361",
    "",
    6,
    "",
    16
  ],
  [
    "a381",
    "",
    16,
    "",
    4,
    "",
    58,
    "",
    32,
    ""
  ],
  [
    "a441",
    "",
    5,
    ""
  ],
  [
    "a461",
    "",
    5,
    "",
    12
  ],
  [
    "a481",
    "",
    28,
    "",
    93
  ],
  [
    "a541",
    "",
    4,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "a561",
    "",
    17,
    "",
    5,
    ""
  ],
  [
    "a581",
    "",
    16,
    "",
    14,
    "",
    9
  ],
  [
    "a5b0",
    "",
    9
  ],
  [
    "a5c1",
    "",
    16,
    "",
    6
  ],
  [
    "a5e1",
    "",
    16,
    "",
    6
  ],
  [
    "a641",
    "",
    19,
    ""
  ],
  [
    "a661",
    "",
    5,
    "",
    5,
    "",
    6
  ],
  [
    "a681",
    "",
    6,
    "",
    18,
    "",
    7
  ],
  [
    "a741",
    "",
    4,
    "",
    6,
    "",
    7
  ],
  [
    "a761",
    "",
    22,
    ""
  ],
  [
    "a781",
    "",
    6,
    "",
    5,
    "",
    7,
    "",
    9,
    "",
    9,
    "",
    4,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "a841",
    "",
    10,
    "",
    14
  ],
  [
    "a861",
    "",
    18,
    "",
    6
  ],
  [
    "a881",
    "",
    19,
    "",
    11,
    ""
  ],
  [
    "a8a6",
    ""
  ],
  [
    "a8a8",
    ""
  ],
  [
    "a8b1",
    "",
    27,
    "",
    25,
    "",
    14,
    ""
  ],
  [
    "a941",
    "",
    14,
    "",
    10
  ],
  [
    "a961",
    "",
    18
  ],
  [
    "a981",
    "",
    14,
    "",
    6,
    "",
    27,
    "",
    25,
    "",
    14,
    ""
  ],
  [
    "aa41",
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "aa61",
    "",
    4,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "aa81",
    "",
    29,
    "",
    82
  ],
  [
    "ab41",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "ab61",
    "",
    6,
    "",
    5,
    "",
    5
  ],
  [
    "ab81",
    "",
    8,
    "",
    6,
    "",
    12,
    "",
    85
  ],
  [
    "ac41",
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "ac61",
    "",
    11,
    "",
    4
  ],
  [
    "ac81",
    "",
    28,
    "",
    5,
    "",
    25
  ],
  [
    "acd1",
    "",
    5,
    "",
    25
  ],
  [
    "ad41",
    "",
    6,
    "",
    5,
    "",
    7
  ],
  [
    "ad61",
    "",
    6,
    "",
    10,
    ""
  ],
  [
    "ad81",
    "",
    5,
    "",
    18,
    ""
  ],
  [
    "ae41",
    "",
    5,
    "",
    16
  ],
  [
    "ae61",
    "",
    5,
    "",
    6,
    "",
    4
  ],
  [
    "ae81",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "af41",
    "",
    19
  ],
  [
    "af61",
    "",
    13,
    "",
    5,
    ""
  ],
  [
    "af81",
    "",
    5,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "b041",
    "",
    5,
    "",
    5,
    "",
    12
  ],
  [
    "b061",
    "",
    5,
    "",
    19
  ],
  [
    "b081",
    "",
    13,
    "",
    6,
    "",
    5,
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "b141",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "b161",
    "",
    6,
    "",
    5,
    "",
    11
  ],
  [
    "b181",
    "",
    14,
    "",
    6,
    ""
  ],
  [
    "b241",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "b261",
    "",
    18,
    "",
    5,
    ""
  ],
  [
    "b281",
    "",
    5,
    "",
    18,
    "",
    6,
    ""
  ],
  [
    "b341",
    "",
    19,
    ""
  ],
  [
    "b361",
    "",
    5,
    "",
    5,
    "",
    5
  ],
  [
    "b381",
    "",
    5,
    "",
    5,
    "",
    19,
    "",
    4,
    ""
  ],
  [
    "b441",
    "",
    5,
    "",
    6,
    "",
    5
  ],
  [
    "b461",
    "",
    6,
    "",
    10,
    ""
  ],
  [
    "b481",
    "",
    6,
    "",
    18,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "b541",
    "",
    14,
    "",
    5
  ],
  [
    "b561",
    "",
    5,
    "",
    5,
    "",
    4
  ],
  [
    "b581",
    "",
    6,
    "",
    5,
    "",
    11,
    ""
  ],
  [
    "b641",
    "",
    7,
    "",
    17
  ],
  [
    "b661",
    "",
    15,
    ""
  ],
  [
    "b681",
    "",
    5,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "b741",
    "",
    13,
    "",
    6,
    ""
  ],
  [
    "b761",
    "",
    20,
    ""
  ],
  [
    "b781",
    "",
    6,
    "",
    14,
    ""
  ],
  [
    "b841",
    "",
    7,
    "",
    17
  ],
  [
    "b861",
    "",
    8,
    "",
    13
  ],
  [
    "b881",
    "",
    5,
    "",
    24,
    "",
    4,
    ""
  ],
  [
    "b941",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "b961",
    "",
    14,
    "",
    6,
    ""
  ],
  [
    "b981",
    "",
    22,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "ba41",
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "ba61",
    "",
    5,
    "",
    4,
    "",
    5
  ],
  [
    "ba81",
    "",
    6,
    "",
    9,
    ""
  ],
  [
    "bb41",
    "",
    4,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "bb61",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "bb81",
    "",
    31,
    ""
  ],
  [
    "bc41",
    "",
    17,
    ""
  ],
  [
    "bc61",
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "bc81",
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "bd41",
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "bd61",
    "",
    5,
    "",
    13
  ],
  [
    "bd81",
    "",
    5,
    "",
    25,
    ""
  ],
  [
    "be41",
    "",
    7,
    "",
    14
  ],
  [
    "be61",
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "be81",
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    8,
    "",
    6,
    ""
  ],
  [
    "bf41",
    "",
    10,
    "",
    14
  ],
  [
    "bf61",
    "",
    18,
    ""
  ],
  [
    "bf81",
    "",
    5,
    "",
    7,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "c041",
    "",
    5,
    "",
    6,
    "",
    5
  ],
  [
    "c061",
    "",
    25
  ],
  [
    "c081",
    "",
    6,
    "",
    5,
    "",
    7,
    ""
  ],
  [
    "c141",
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "c161",
    "",
    19,
    ""
  ],
  [
    "c181",
    "",
    31,
    ""
  ],
  [
    "c241",
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "c261",
    "",
    4,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "c281",
    "",
    5,
    "",
    7,
    "",
    9,
    ""
  ],
  [
    "c341",
    "",
    4
  ],
  [
    "c361",
    "",
    4,
    "",
    5,
    "",
    11
  ],
  [
    "c381",
    "",
    5,
    "",
    7,
    "",
    5,
    ""
  ],
  [
    "c441",
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "c461",
    "",
    5,
    "",
    4
  ],
  [
    "c481",
    "",
    5,
    "",
    11,
    ""
  ],
  [
    "c541",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "c561",
    "",
    6,
    "",
    5,
    "",
    4
  ],
  [
    "c581",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "c641",
    "",
    6,
    "",
    5
  ],
  [
    "c6a1",
    ""
  ],
  [
    "c7a1",
    ""
  ],
  [
    "c8a1",
    ""
  ],
  [
    "caa1",
    ""
  ],
  [
    "cba1",
    ""
  ],
  [
    "cca1",
    ""
  ],
  [
    "cda1",
    ""
  ],
  [
    "cea1",
    ""
  ],
  [
    "cfa1",
    ""
  ],
  [
    "d0a1",
    ""
  ],
  [
    "d1a1",
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "d2a1",
    "",
    4,
    "",
    5,
    "",
    10,
    "",
    7,
    "",
    5,
    ""
  ],
  [
    "d3a1",
    ""
  ],
  [
    "d4a1",
    ""
  ],
  [
    "d5a1",
    ""
  ],
  [
    "d6a1",
    ""
  ],
  [
    "d7a1",
    ""
  ],
  [
    "d8a1",
    ""
  ],
  [
    "d9a1",
    ""
  ],
  [
    "daa1",
    ""
  ],
  [
    "dba1",
    ""
  ],
  [
    "dca1",
    ""
  ],
  [
    "dda1",
    ""
  ],
  [
    "dea1",
    ""
  ],
  [
    "dfa1",
    ""
  ],
  [
    "e0a1",
    ""
  ],
  [
    "e1a1",
    ""
  ],
  [
    "e2a1",
    ""
  ],
  [
    "e3a1",
    ""
  ],
  [
    "e4a1",
    ""
  ],
  [
    "e5a1",
    ""
  ],
  [
    "e6a1",
    ""
  ],
  [
    "e7a1",
    ""
  ],
  [
    "e8a1",
    ""
  ],
  [
    "e9a1",
    ""
  ],
  [
    "eaa1",
    ""
  ],
  [
    "eba1",
    ""
  ],
  [
    "eca1",
    ""
  ],
  [
    "eda1",
    ""
  ],
  [
    "eea1",
    ""
  ],
  [
    "efa1",
    ""
  ],
  [
    "f0a1",
    ""
  ],
  [
    "f1a1",
    ""
  ],
  [
    "f2a1",
    ""
  ],
  [
    "f3a1",
    ""
  ],
  [
    "f4a1",
    ""
  ],
  [
    "f5a1",
    ""
  ],
  [
    "f6a1",
    ""
  ],
  [
    "f7a1",
    ""
  ],
  [
    "f8a1",
    ""
  ],
  [
    "f9a1",
    ""
  ],
  [
    "faa1",
    ""
  ],
  [
    "fba1",
    ""
  ],
  [
    "fca1",
    ""
  ],
  [
    "fda1",
    ""
  ]
], Xy = [
  [
    "0",
    "\0",
    127
  ],
  [
    "a140",
    ""
  ],
  [
    "a1a1",
    "",
    4,
    ""
  ],
  [
    "a240",
    "",
    7,
    ""
  ],
  [
    "a2a1",
    "",
    9,
    "",
    9,
    "",
    8,
    "",
    25,
    "",
    21
  ],
  [
    "a340",
    "",
    16,
    "",
    6,
    "",
    16,
    "",
    6,
    "",
    10
  ],
  [
    "a3a1",
    "",
    25,
    ""
  ],
  [
    "a3e1",
    ""
  ],
  [
    "a440",
    ""
  ],
  [
    "a4a1",
    ""
  ],
  [
    "a540",
    ""
  ],
  [
    "a5a1",
    ""
  ],
  [
    "a640",
    ""
  ],
  [
    "a6a1",
    ""
  ],
  [
    "a740",
    ""
  ],
  [
    "a7a1",
    ""
  ],
  [
    "a840",
    ""
  ],
  [
    "a8a1",
    ""
  ],
  [
    "a940",
    ""
  ],
  [
    "a9a1",
    ""
  ],
  [
    "aa40",
    ""
  ],
  [
    "aaa1",
    ""
  ],
  [
    "ab40",
    ""
  ],
  [
    "aba1",
    ""
  ],
  [
    "ac40",
    ""
  ],
  [
    "aca1",
    ""
  ],
  [
    "ad40",
    ""
  ],
  [
    "ada1",
    ""
  ],
  [
    "ae40",
    ""
  ],
  [
    "aea1",
    ""
  ],
  [
    "af40",
    ""
  ],
  [
    "afa1",
    ""
  ],
  [
    "b040",
    ""
  ],
  [
    "b0a1",
    ""
  ],
  [
    "b140",
    ""
  ],
  [
    "b1a1",
    ""
  ],
  [
    "b240",
    ""
  ],
  [
    "b2a1",
    ""
  ],
  [
    "b340",
    ""
  ],
  [
    "b3a1",
    ""
  ],
  [
    "b440",
    ""
  ],
  [
    "b4a1",
    ""
  ],
  [
    "b540",
    ""
  ],
  [
    "b5a1",
    ""
  ],
  [
    "b640",
    ""
  ],
  [
    "b6a1",
    ""
  ],
  [
    "b740",
    ""
  ],
  [
    "b7a1",
    ""
  ],
  [
    "b840",
    ""
  ],
  [
    "b8a1",
    ""
  ],
  [
    "b940",
    ""
  ],
  [
    "b9a1",
    ""
  ],
  [
    "ba40",
    ""
  ],
  [
    "baa1",
    ""
  ],
  [
    "bb40",
    ""
  ],
  [
    "bba1",
    ""
  ],
  [
    "bc40",
    ""
  ],
  [
    "bca1",
    ""
  ],
  [
    "bd40",
    ""
  ],
  [
    "bda1",
    ""
  ],
  [
    "be40",
    ""
  ],
  [
    "bea1",
    ""
  ],
  [
    "bf40",
    ""
  ],
  [
    "bfa1",
    ""
  ],
  [
    "c040",
    ""
  ],
  [
    "c0a1",
    ""
  ],
  [
    "c140",
    ""
  ],
  [
    "c1a1",
    ""
  ],
  [
    "c240",
    ""
  ],
  [
    "c2a1",
    ""
  ],
  [
    "c340",
    ""
  ],
  [
    "c3a1",
    ""
  ],
  [
    "c440",
    ""
  ],
  [
    "c4a1",
    ""
  ],
  [
    "c540",
    ""
  ],
  [
    "c5a1",
    ""
  ],
  [
    "c640",
    ""
  ],
  [
    "c940",
    ""
  ],
  [
    "c9a1",
    ""
  ],
  [
    "ca40",
    ""
  ],
  [
    "caa1",
    ""
  ],
  [
    "cb40",
    ""
  ],
  [
    "cba1",
    ""
  ],
  [
    "cc40",
    ""
  ],
  [
    "cca1",
    ""
  ],
  [
    "cd40",
    ""
  ],
  [
    "cda1",
    ""
  ],
  [
    "ce40",
    ""
  ],
  [
    "cea1",
    ""
  ],
  [
    "cf40",
    ""
  ],
  [
    "cfa1",
    ""
  ],
  [
    "d040",
    ""
  ],
  [
    "d0a1",
    ""
  ],
  [
    "d140",
    ""
  ],
  [
    "d1a1",
    ""
  ],
  [
    "d240",
    ""
  ],
  [
    "d2a1",
    ""
  ],
  [
    "d340",
    ""
  ],
  [
    "d3a1",
    ""
  ],
  [
    "d440",
    ""
  ],
  [
    "d4a1",
    ""
  ],
  [
    "d540",
    ""
  ],
  [
    "d5a1",
    ""
  ],
  [
    "d640",
    ""
  ],
  [
    "d6a1",
    ""
  ],
  [
    "d740",
    ""
  ],
  [
    "d7a1",
    ""
  ],
  [
    "d840",
    ""
  ],
  [
    "d8a1",
    ""
  ],
  [
    "d940",
    ""
  ],
  [
    "d9a1",
    ""
  ],
  [
    "da40",
    ""
  ],
  [
    "daa1",
    ""
  ],
  [
    "db40",
    ""
  ],
  [
    "dba1",
    ""
  ],
  [
    "dc40",
    ""
  ],
  [
    "dca1",
    ""
  ],
  [
    "dd40",
    ""
  ],
  [
    "dda1",
    ""
  ],
  [
    "de40",
    ""
  ],
  [
    "dea1",
    ""
  ],
  [
    "df40",
    ""
  ],
  [
    "dfa1",
    ""
  ],
  [
    "e040",
    ""
  ],
  [
    "e0a1",
    ""
  ],
  [
    "e140",
    ""
  ],
  [
    "e1a1",
    ""
  ],
  [
    "e240",
    ""
  ],
  [
    "e2a1",
    ""
  ],
  [
    "e340",
    ""
  ],
  [
    "e3a1",
    ""
  ],
  [
    "e440",
    ""
  ],
  [
    "e4a1",
    ""
  ],
  [
    "e540",
    ""
  ],
  [
    "e5a1",
    ""
  ],
  [
    "e640",
    ""
  ],
  [
    "e6a1",
    ""
  ],
  [
    "e740",
    ""
  ],
  [
    "e7a1",
    ""
  ],
  [
    "e840",
    ""
  ],
  [
    "e8a1",
    ""
  ],
  [
    "e940",
    ""
  ],
  [
    "e9a1",
    ""
  ],
  [
    "ea40",
    ""
  ],
  [
    "eaa1",
    ""
  ],
  [
    "eb40",
    ""
  ],
  [
    "eba1",
    ""
  ],
  [
    "ec40",
    ""
  ],
  [
    "eca1",
    ""
  ],
  [
    "ed40",
    ""
  ],
  [
    "eda1",
    ""
  ],
  [
    "ee40",
    ""
  ],
  [
    "eea1",
    ""
  ],
  [
    "ef40",
    ""
  ],
  [
    "efa1",
    ""
  ],
  [
    "f040",
    ""
  ],
  [
    "f0a1",
    ""
  ],
  [
    "f140",
    ""
  ],
  [
    "f1a1",
    ""
  ],
  [
    "f240",
    ""
  ],
  [
    "f2a1",
    ""
  ],
  [
    "f340",
    ""
  ],
  [
    "f3a1",
    ""
  ],
  [
    "f440",
    ""
  ],
  [
    "f4a1",
    ""
  ],
  [
    "f540",
    ""
  ],
  [
    "f5a1",
    ""
  ],
  [
    "f640",
    ""
  ],
  [
    "f6a1",
    ""
  ],
  [
    "f740",
    ""
  ],
  [
    "f7a1",
    ""
  ],
  [
    "f840",
    ""
  ],
  [
    "f8a1",
    ""
  ],
  [
    "f940",
    ""
  ],
  [
    "f9a1",
    ""
  ]
], xI = [
  [
    "8740",
    ""
  ],
  [
    "8767",
    ""
  ],
  [
    "87a1",
    ""
  ],
  [
    "8840",
    "",
    4,
    ""
  ],
  [
    "88a1",
    ""
  ],
  [
    "8940",
    ""
  ],
  [
    "8943",
    ""
  ],
  [
    "8946",
    ""
  ],
  [
    "894c",
    ""
  ],
  [
    "89a1",
    ""
  ],
  [
    "89ab",
    ""
  ],
  [
    "89b0",
    ""
  ],
  [
    "89b5",
    ""
  ],
  [
    "89c1",
    ""
  ],
  [
    "89c5",
    ""
  ],
  [
    "8a40",
    ""
  ],
  [
    "8a43",
    ""
  ],
  [
    "8a64",
    ""
  ],
  [
    "8a76",
    ""
  ],
  [
    "8aa1",
    ""
  ],
  [
    "8aac",
    ""
  ],
  [
    "8ab2",
    ""
  ],
  [
    "8abb",
    ""
  ],
  [
    "8ac9",
    ""
  ],
  [
    "8ace",
    ""
  ],
  [
    "8adf",
    ""
  ],
  [
    "8af6",
    ""
  ],
  [
    "8b40",
    ""
  ],
  [
    "8b55",
    ""
  ],
  [
    "8ba1",
    ""
  ],
  [
    "8bde",
    ""
  ],
  [
    "8c40",
    ""
  ],
  [
    "8ca1",
    ""
  ],
  [
    "8ca7",
    ""
  ],
  [
    "8cc9",
    ""
  ],
  [
    "8cce",
    ""
  ],
  [
    "8ce6",
    ""
  ],
  [
    "8d40",
    ""
  ],
  [
    "8d42",
    ""
  ],
  [
    "8da1",
    ""
  ],
  [
    "8e40",
    ""
  ],
  [
    "8ea1",
    ""
  ],
  [
    "8f40",
    ""
  ],
  [
    "8fa1",
    ""
  ],
  [
    "9040",
    ""
  ],
  [
    "90a1",
    ""
  ],
  [
    "9140",
    ""
  ],
  [
    "91a1",
    ""
  ],
  [
    "9240",
    ""
  ],
  [
    "92a1",
    ""
  ],
  [
    "9340",
    ""
  ],
  [
    "93a1",
    ""
  ],
  [
    "9440",
    ""
  ],
  [
    "94a1",
    ""
  ],
  [
    "9540",
    ""
  ],
  [
    "95a1",
    ""
  ],
  [
    "9640",
    ""
  ],
  [
    "96a1",
    ""
  ],
  [
    "9740",
    ""
  ],
  [
    "97a1",
    ""
  ],
  [
    "9840",
    ""
  ],
  [
    "98a1",
    ""
  ],
  [
    "9940",
    ""
  ],
  [
    "99a1",
    ""
  ],
  [
    "9a40",
    ""
  ],
  [
    "9aa1",
    ""
  ],
  [
    "9b40",
    ""
  ],
  [
    "9b62",
    ""
  ],
  [
    "9ba1",
    ""
  ],
  [
    "9c40",
    ""
  ],
  [
    "9ca1",
    ""
  ],
  [
    "9d40",
    ""
  ],
  [
    "9da1",
    ""
  ],
  [
    "9e40",
    ""
  ],
  [
    "9ea1",
    ""
  ],
  [
    "9ead",
    ""
  ],
  [
    "9ec5",
    ""
  ],
  [
    "9ef5",
    ""
  ],
  [
    "9f40",
    ""
  ],
  [
    "9f4f",
    ""
  ],
  [
    "9fa1",
    ""
  ],
  [
    "9fae",
    ""
  ],
  [
    "9fb2",
    ""
  ],
  [
    "9fc1",
    ""
  ],
  [
    "9fc9",
    ""
  ],
  [
    "9fdb",
    ""
  ],
  [
    "9fe7",
    ""
  ],
  [
    "9feb",
    ""
  ],
  [
    "9ff0",
    ""
  ],
  [
    "a040",
    ""
  ],
  [
    "a055",
    ""
  ],
  [
    "a058",
    ""
  ],
  [
    "a05b",
    ""
  ],
  [
    "a063",
    ""
  ],
  [
    "a073",
    ""
  ],
  [
    "a0a1",
    ""
  ],
  [
    "a0a6",
    ""
  ],
  [
    "a0ae",
    ""
  ],
  [
    "a0b0",
    ""
  ],
  [
    "a0d4",
    ""
  ],
  [
    "a0e2",
    ""
  ],
  [
    "a3c0",
    "",
    31,
    ""
  ],
  [
    "c6a1",
    "",
    9,
    "",
    9,
    "",
    9,
    "",
    23
  ],
  [
    "c740",
    "",
    58,
    ""
  ],
  [
    "c7a1",
    "",
    81,
    "",
    5,
    "",
    4
  ],
  [
    "c840",
    "",
    26,
    "",
    25,
    ""
  ],
  [
    "c8a1",
    ""
  ],
  [
    "c8cd",
    ""
  ],
  [
    "c8f5",
    ""
  ],
  [
    "f9fe",
    ""
  ],
  [
    "fa40",
    ""
  ],
  [
    "faa1",
    ""
  ],
  [
    "fb40",
    ""
  ],
  [
    "fba1",
    ""
  ],
  [
    "fc40",
    ""
  ],
  [
    "fca1",
    ""
  ],
  [
    "fd40",
    ""
  ],
  [
    "fda1",
    ""
  ],
  [
    "fe40",
    ""
  ],
  [
    "fea1",
    ""
  ]
];
var Zu, Zy;
function _I() {
  return Zy || (Zy = 1, Zu = {
    // == Japanese/ShiftJIS ====================================================
    // All japanese encodings are based on JIS X set of standards:
    // JIS X 0201 - Single-byte encoding of ASCII +  + Kana chars at 0xA1-0xDF.
    // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
    //              Has several variations in 1978, 1983, 1990 and 1997.
    // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
    // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
    //              2 planes, first is superset of 0208, second - revised 0212.
    //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)
    // Byte encodings are:
    //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
    //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
    //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
    //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
    //               0x00-0x7F       - lower part of 0201
    //               0x8E, 0xA1-0xDF - upper part of 0201
    //               (0xA1-0xFE)x2   - 0208 plane (94x94).
    //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
    //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
    //               Used as-is in ISO2022 family.
    //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
    //                0201-1976 Roman, 0208-1978, 0208-1983.
    //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
    //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
    //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
    //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
    //
    // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
    //
    // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html
    shiftjis: {
      type: "_dbcs",
      table: function() {
        return mI;
      },
      encodeAdd: { "": 92, "": 126 },
      encodeSkipVals: [{ from: 60736, to: 63808 }]
    },
    csshiftjis: "shiftjis",
    mskanji: "shiftjis",
    sjis: "shiftjis",
    windows31j: "shiftjis",
    ms31j: "shiftjis",
    xsjis: "shiftjis",
    windows932: "shiftjis",
    ms932: "shiftjis",
    932: "shiftjis",
    cp932: "shiftjis",
    eucjp: {
      type: "_dbcs",
      table: function() {
        return gI;
      },
      encodeAdd: { "": 92, "": 126 }
    },
    // TODO: KDDI extension to Shift_JIS
    // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
    // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.
    // == Chinese/GBK ==========================================================
    // http://en.wikipedia.org/wiki/GBK
    // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder
    // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
    gb2312: "cp936",
    gb231280: "cp936",
    gb23121980: "cp936",
    csgb2312: "cp936",
    csiso58gb231280: "cp936",
    euccn: "cp936",
    // Microsoft's CP936 is a subset and approximation of GBK.
    windows936: "cp936",
    ms936: "cp936",
    936: "cp936",
    cp936: {
      type: "_dbcs",
      table: function() {
        return Xu;
      }
    },
    // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
    gbk: {
      type: "_dbcs",
      table: function() {
        return Xu.concat(Jy);
      }
    },
    xgbk: "gbk",
    isoir58: "gbk",
    // GB18030 is an algorithmic extension of GBK.
    // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
    // http://icu-project.org/docs/papers/gb18030.html
    // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
    // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
    gb18030: {
      type: "_dbcs",
      table: function() {
        return Xu.concat(Jy);
      },
      gb18030: function() {
        return bI;
      },
      encodeSkipVals: [128],
      encodeAdd: { "": 41699 }
    },
    chinese: "gb18030",
    // == Korean ===============================================================
    // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
    windows949: "cp949",
    ms949: "cp949",
    949: "cp949",
    cp949: {
      type: "_dbcs",
      table: function() {
        return wI;
      }
    },
    cseuckr: "cp949",
    csksc56011987: "cp949",
    euckr: "cp949",
    isoir149: "cp949",
    korean: "cp949",
    ksc56011987: "cp949",
    ksc56011989: "cp949",
    ksc5601: "cp949",
    // == Big5/Taiwan/Hong Kong ================================================
    // There are lots of tables for Big5 and cp950. Please see the following links for history:
    // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
    // Variations, in roughly number of defined chars:
    //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
    //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
    //  * Big5-2003 (Taiwan standard) almost superset of cp950.
    //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
    //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
    //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
    //    Plus, it has 4 combining sequences.
    //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
    //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
    //    Implementations are not consistent within browsers; sometimes labeled as just big5.
    //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
    //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
    //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
    //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
    //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
    // 
    // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
    // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.
    windows950: "cp950",
    ms950: "cp950",
    950: "cp950",
    cp950: {
      type: "_dbcs",
      table: function() {
        return Xy;
      }
    },
    // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
    big5: "big5hkscs",
    big5hkscs: {
      type: "_dbcs",
      table: function() {
        return Xy.concat(xI);
      },
      encodeSkipVals: [41676]
    },
    cnbig5: "big5hkscs",
    csbig5: "big5hkscs",
    xxbig5: "big5hkscs"
  }), Zu;
}
var Yy;
function EI() {
  return Yy || (Yy = 1, function(t) {
    for (var e = [
      cI(),
      uI(),
      lI(),
      pI(),
      fI(),
      hI(),
      dI(),
      _I()
    ], r = 0; r < e.length; r++) {
      var n = e[r];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
    }
  }(Hu)), Hu;
}
var eb;
function _c() {
  return eb || (eb = 1, function(t) {
    var e = Ai().Buffer, r = oI(), n = t.exports;
    n.encodings = null, n.defaultCharUnicode = "", n.defaultCharSingleByte = "?", n.encode = function(o, c, f) {
      o = "" + (o || "");
      var u = n.getEncoder(c, f), l = u.write(o), p = u.end();
      return p && p.length > 0 ? e.concat([l, p]) : l;
    }, n.decode = function(o, c, f) {
      typeof o == "string" && (n.skipDecodeWarning || (console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding"), n.skipDecodeWarning = !0), o = e.from("" + (o || ""), "binary"));
      var u = n.getDecoder(c, f), l = u.write(o), p = u.end();
      return p ? l + p : l;
    }, n.encodingExists = function(o) {
      try {
        return n.getCodec(o), !0;
      } catch {
        return !1;
      }
    }, n.toEncoding = n.encode, n.fromEncoding = n.decode, n._codecDataCache = {}, n.getCodec = function(o) {
      n.encodings || (n.encodings = EI());
      for (var c = n._canonicalizeEncoding(o), f = {}; ; ) {
        var u = n._codecDataCache[c];
        if (u)
          return u;
        var l = n.encodings[c];
        switch (typeof l) {
          case "string":
            c = l;
            break;
          case "object":
            for (var p in l)
              f[p] = l[p];
            f.encodingName || (f.encodingName = c), c = l.type;
            break;
          case "function":
            return f.encodingName || (f.encodingName = c), u = new l(f, n), n._codecDataCache[f.encodingName] = u, u;
          default:
            throw new Error("Encoding not recognized: '" + o + "' (searched as: '" + c + "')");
        }
      }
    }, n._canonicalizeEncoding = function(s) {
      return ("" + s).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
    }, n.getEncoder = function(o, c) {
      var f = n.getCodec(o), u = new f.encoder(c, f);
      return f.bomAware && c && c.addBOM && (u = new r.PrependBOM(u, c)), u;
    }, n.getDecoder = function(o, c) {
      var f = n.getCodec(o), u = new f.decoder(c, f);
      return f.bomAware && !(c && c.stripBOM === !1) && (u = new r.StripBOM(u, c)), u;
    };
    var i = typeof process < "u" && process.versions && process.versions.node;
    if (i) {
      var a = i.split(".").map(Number);
      (a[0] > 0 || a[1] >= 10) && se(n), se(n);
    }
  }(Bu)), Bu.exports;
}
/*!
 * unpipe
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var Yu, tb;
function Ya() {
  if (tb)
    return Yu;
  tb = 1, Yu = e;
  function t(r) {
    for (var n = r.listeners("data"), i = 0; i < n.length; i++)
      if (n[i].name === "ondata")
        return !0;
    return !1;
  }
  function e(r) {
    if (!r)
      throw new TypeError("argument stream is required");
    if (typeof r.unpipe == "function") {
      r.unpipe();
      return;
    }
    if (t(r))
      for (var n, i = r.listeners("close"), a = 0; a < i.length; a++)
        n = i[a], !(n.name !== "cleanup" && n.name !== "onclose") && n.call(r);
  }
  return Yu;
}
/*!
 * raw-body
 * Copyright(c) 2013-2014 Jonathan Ong
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var el, rb;
function SI() {
  if (rb)
    return el;
  rb = 1;
  var t = u(), e = vr(), r = yr(), n = _c(), i = Ya();
  el = o;
  var a = /^Encoding not recognized: /;
  function s(p) {
    if (!p)
      return null;
    try {
      return n.getDecoder(p);
    } catch (m) {
      throw a.test(m.message) ? r(415, "specified encoding unsupported", {
        encoding: p,
        type: "encoding.unsupported"
      }) : m;
    }
  }
  function o(p, m, h) {
    var g = h, v = m || {};
    if ((m === !0 || typeof m == "string") && (v = {
      encoding: m
    }), typeof m == "function" && (g = m, v = {}), g !== void 0 && typeof g != "function")
      throw new TypeError("argument callback must be a function");
    if (!g && !ve.Promise)
      throw new TypeError("argument callback is required");
    var d = v.encoding !== !0 ? v.encoding : "utf-8", y = e.parse(v.limit), x = v.length != null && !isNaN(v.length) ? parseInt(v.length, 10) : null;
    return g ? f(p, d, x, y, l(g)) : new Promise(function(w, S) {
      f(p, d, x, y, function(E, C) {
        if (E)
          return S(E);
        w(C);
      });
    });
  }
  function c(p) {
    i(p), typeof p.pause == "function" && p.pause();
  }
  function f(p, m, h, g, v) {
    var d = !1, y = !0;
    if (g !== null && h !== null && h > g)
      return T(r(413, "request entity too large", {
        expected: h,
        length: h,
        limit: g,
        type: "entity.too.large"
      }));
    var x = p._readableState;
    if (p._decoder || x && (x.encoding || x.decoder))
      return T(r(500, "stream encoding should not be set", {
        type: "stream.encoding.set"
      }));
    if (typeof p.readable < "u" && !p.readable)
      return T(r(500, "stream is not readable", {
        type: "stream.not.readable"
      }));
    var b = 0, w;
    try {
      w = s(m);
    } catch (D) {
      return T(D);
    }
    var S = w ? "" : [];
    p.on("aborted", E), p.on("close", R), p.on("data", C), p.on("end", A), p.on("error", A), y = !1;
    function T() {
      for (var D = new Array(arguments.length), F = 0; F < D.length; F++)
        D[F] = arguments[F];
      d = !0, y ? process.nextTick(K) : K();
      function K() {
        R(), D[0] && c(p), v.apply(null, D);
      }
    }
    function E() {
      d || T(r(400, "request aborted", {
        code: "ECONNABORTED",
        expected: h,
        length: h,
        received: b,
        type: "request.aborted"
      }));
    }
    function C(D) {
      d || (b += D.length, g !== null && b > g ? T(r(413, "request entity too large", {
        limit: g,
        received: b,
        type: "entity.too.large"
      })) : w ? S += w.write(D) : S.push(D));
    }
    function A(D) {
      if (!d) {
        if (D)
          return T(D);
        if (h !== null && b !== h)
          T(r(400, "request size did not match content length", {
            expected: h,
            length: h,
            received: b,
            type: "request.size.invalid"
          }));
        else {
          var F = w ? S + (w.end() || "") : Buffer.concat(S);
          T(null, F);
        }
      }
    }
    function R() {
      S = null, p.removeListener("aborted", E), p.removeListener("data", C), p.removeListener("end", A), p.removeListener("error", A), p.removeListener("close", R);
    }
  }
  function u() {
    try {
      return se;
    } catch {
      return {};
    }
  }
  function l(p) {
    var m;
    return t.AsyncResource && (m = new t.AsyncResource(p.name || "bound-anonymous-fn")), !m || !m.runInAsyncScope ? p : m.runInAsyncScope.bind(m, p, null);
  }
  return el;
}
var Eg = { exports: {} };
/*!
 * ee-first
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */
var CI = TI;
function TI(t, e) {
  if (!Array.isArray(t))
    throw new TypeError("arg must be an array of [ee, events...] arrays");
  for (var r = [], n = 0; n < t.length; n++) {
    var i = t[n];
    if (!Array.isArray(i) || i.length < 2)
      throw new TypeError("each array member must be [ee, events...]");
    for (var a = i[0], s = 1; s < i.length; s++) {
      var o = i[s], c = OI(o, f);
      a.on(o, c), r.push({
        ee: a,
        event: o,
        fn: c
      });
    }
  }
  function f() {
    u(), e.apply(null, arguments);
  }
  function u() {
    for (var p, m = 0; m < r.length; m++)
      p = r[m], p.ee.removeListener(p.event, p.fn);
  }
  function l(p) {
    e = p;
  }
  return l.cancel = u, l;
}
function OI(t, e) {
  return function(n) {
    for (var i = new Array(arguments.length), a = this, s = t === "error" ? n : null, o = 0; o < i.length; o++)
      i[o] = arguments[o];
    e(s, a, t, i);
  };
}
/*!
 * on-finished
 * Copyright(c) 2013 Jonathan Ong
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */
Eg.exports = $I;
Eg.exports.isFinished = x2;
var nb = LI(), ib = CI, AI = typeof setImmediate == "function" ? setImmediate : function(t) {
  process.nextTick(t.bind.apply(t, arguments));
};
function $I(t, e) {
  return x2(t) !== !1 ? (AI(e, null, t), t) : (kI(t, PI(e)), t);
}
function x2(t) {
  var e = t.socket;
  if (typeof t.finished == "boolean")
    return !!(t.finished || e && !e.writable);
  if (typeof t.complete == "boolean")
    return !!(t.upgrade || !e || !e.readable || t.complete && !t.readable);
}
function II(t, e) {
  var r, n, i = !1;
  function a(o) {
    r.cancel(), n.cancel(), i = !0, e(o);
  }
  r = n = ib([[t, "end", "finish"]], a);
  function s(o) {
    t.removeListener("socket", s), !i && r === n && (n = ib([[o, "error", "close"]], a));
  }
  if (t.socket) {
    s(t.socket);
    return;
  }
  t.on("socket", s), t.socket === void 0 && NI(t, s);
}
function kI(t, e) {
  var r = t.__onFinished;
  (!r || !r.queue) && (r = t.__onFinished = RI(t), II(t, r)), r.queue.push(e);
}
function RI(t) {
  function e(r) {
    if (t.__onFinished === e && (t.__onFinished = null), !!e.queue) {
      var n = e.queue;
      e.queue = null;
      for (var i = 0; i < n.length; i++)
        n[i](r, t);
    }
  }
  return e.queue = [], e;
}
function NI(t, e) {
  var r = t.assignSocket;
  typeof r == "function" && (t.assignSocket = function(i) {
    r.call(this, i), e(i);
  });
}
function LI() {
  try {
    return se;
  } catch {
    return {};
  }
}
function PI(t) {
  var e;
  return nb.AsyncResource && (e = new nb.AsyncResource(t.name || "bound-anonymous-fn")), !e || !e.runInAsyncScope ? t : e.runInAsyncScope.bind(e, t, null);
}
var es = Eg.exports;
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var tl, ab;
function Ec() {
  if (ab)
    return tl;
  ab = 1;
  var t = yr(), e = xg(), r = SI(), n = _c(), i = es, a = Ya(), s = se;
  tl = o;
  function o(u, l, p, m, h, g) {
    var v, d = g, y;
    u._body = !0;
    var x = d.encoding !== null ? d.encoding : null, b = d.verify;
    try {
      y = c(u, h, d.inflate), v = y.length, y.length = void 0;
    } catch (w) {
      return p(w);
    }
    if (d.length = v, d.encoding = b ? null : x, d.encoding === null && x !== null && !n.encodingExists(x))
      return p(t(415, 'unsupported charset "' + x.toUpperCase() + '"', {
        charset: x.toLowerCase(),
        type: "charset.unsupported"
      }));
    h("read body"), r(y, d, function(w, S) {
      if (w) {
        var T;
        w.type === "encoding.unsupported" ? T = t(415, 'unsupported charset "' + x.toUpperCase() + '"', {
          charset: x.toLowerCase(),
          type: "charset.unsupported"
        }) : T = t(400, w), y !== u && (a(u), e(y, !0)), f(u, function() {
          p(t(400, T));
        });
        return;
      }
      if (b)
        try {
          h("verify body"), b(u, l, S, x);
        } catch (C) {
          p(t(403, C, {
            body: S,
            type: C.type || "entity.verify.failed"
          }));
          return;
        }
      var E = S;
      try {
        h("parse body"), E = typeof S != "string" && x !== null ? n.decode(S, x) : S, u.body = m(E);
      } catch (C) {
        p(t(400, C, {
          body: E,
          type: C.type || "entity.parse.failed"
        }));
        return;
      }
      p();
    });
  }
  function c(u, l, p) {
    var m = (u.headers["content-encoding"] || "identity").toLowerCase(), h = u.headers["content-length"], g;
    if (l('content-encoding "%s"', m), p === !1 && m !== "identity")
      throw t(415, "content encoding unsupported", {
        encoding: m,
        type: "encoding.unsupported"
      });
    switch (m) {
      case "deflate":
        g = s.createInflate(), l("inflate body"), u.pipe(g);
        break;
      case "gzip":
        g = s.createGunzip(), l("gunzip body"), u.pipe(g);
        break;
      case "identity":
        g = u, g.length = h;
        break;
      default:
        throw t(415, 'unsupported content encoding "' + m + '"', {
          encoding: m,
          type: "encoding.unsupported"
        });
    }
    return g;
  }
  function f(u, l) {
    i.isFinished(u) ? l(null) : (i(u, l), u.resume());
  }
  return tl;
}
var gn = { exports: {} }, Ls = {};
/*!
 * media-typer
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */
var sb;
function DI() {
  if (sb)
    return Ls;
  sb = 1;
  var t = /; *([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *= *("(?:[ !\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u0020-\u007e])*"|[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) */g, e = /^[\u0020-\u007e\u0080-\u00ff]+$/, r = /^[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+$/, n = /\\([\u0000-\u007f])/g, i = /([\\"])/g, a = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/, s = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/, o = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
  Ls.format = c, Ls.parse = f;
  function c(m) {
    if (!m || typeof m != "object")
      throw new TypeError("argument obj is required");
    var h = m.parameters, g = m.subtype, v = m.suffix, d = m.type;
    if (!d || !s.test(d))
      throw new TypeError("invalid type");
    if (!g || !a.test(g))
      throw new TypeError("invalid subtype");
    var y = d + "/" + g;
    if (v) {
      if (!s.test(v))
        throw new TypeError("invalid suffix");
      y += "+" + v;
    }
    if (h && typeof h == "object")
      for (var x, b = Object.keys(h).sort(), w = 0; w < b.length; w++) {
        if (x = b[w], !r.test(x))
          throw new TypeError("invalid parameter name");
        y += "; " + x + "=" + l(h[x]);
      }
    return y;
  }
  function f(m) {
    if (!m)
      throw new TypeError("argument string is required");
    if (typeof m == "object" && (m = u(m)), typeof m != "string")
      throw new TypeError("argument string is required to be a string");
    var h = m.indexOf(";"), g = h !== -1 ? m.substr(0, h) : m, v, d, y = p(g), x = {}, b;
    for (t.lastIndex = h; d = t.exec(m); ) {
      if (d.index !== h)
        throw new TypeError("invalid parameter format");
      h += d[0].length, v = d[1].toLowerCase(), b = d[2], b[0] === '"' && (b = b.substr(1, b.length - 2).replace(n, "$1")), x[v] = b;
    }
    if (h !== -1 && h !== m.length)
      throw new TypeError("invalid parameter format");
    return y.parameters = x, y;
  }
  function u(m) {
    if (typeof m.getHeader == "function")
      return m.getHeader("content-type");
    if (typeof m.headers == "object")
      return m.headers && m.headers["content-type"];
  }
  function l(m) {
    var h = String(m);
    if (r.test(h))
      return h;
    if (h.length > 0 && !e.test(h))
      throw new TypeError("invalid parameter value");
    return '"' + h.replace(i, "\\$1") + '"';
  }
  function p(m) {
    var h = o.exec(m.toLowerCase());
    if (!h)
      throw new TypeError("invalid media type");
    var g = h[1], v = h[2], d, y = v.lastIndexOf("+");
    y !== -1 && (d = v.substr(y + 1), v = v.substr(0, y));
    var x = {
      type: g,
      subtype: v,
      suffix: d
    };
    return x;
  }
  return Ls;
}
var rl = {};
const MI = {
  "application/1d-interleaved-parityfec": {
    source: "iana"
  },
  "application/3gpdash-qoe-report+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/3gpp-ims+xml": {
    source: "iana",
    compressible: !0
  },
  "application/3gpphal+json": {
    source: "iana",
    compressible: !0
  },
  "application/3gpphalforms+json": {
    source: "iana",
    compressible: !0
  },
  "application/a2l": {
    source: "iana"
  },
  "application/ace+cbor": {
    source: "iana"
  },
  "application/activemessage": {
    source: "iana"
  },
  "application/activity+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-costmap+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-costmapfilter+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-directory+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-endpointcost+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-endpointcostparams+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-endpointprop+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-endpointpropparams+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-error+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-networkmap+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-networkmapfilter+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-updatestreamcontrol+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-updatestreamparams+json": {
    source: "iana",
    compressible: !0
  },
  "application/aml": {
    source: "iana"
  },
  "application/andrew-inset": {
    source: "iana",
    extensions: [
      "ez"
    ]
  },
  "application/applefile": {
    source: "iana"
  },
  "application/applixware": {
    source: "apache",
    extensions: [
      "aw"
    ]
  },
  "application/at+jwt": {
    source: "iana"
  },
  "application/atf": {
    source: "iana"
  },
  "application/atfx": {
    source: "iana"
  },
  "application/atom+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "atom"
    ]
  },
  "application/atomcat+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "atomcat"
    ]
  },
  "application/atomdeleted+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "atomdeleted"
    ]
  },
  "application/atomicmail": {
    source: "iana"
  },
  "application/atomsvc+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "atomsvc"
    ]
  },
  "application/atsc-dwd+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "dwd"
    ]
  },
  "application/atsc-dynamic-event-message": {
    source: "iana"
  },
  "application/atsc-held+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "held"
    ]
  },
  "application/atsc-rdt+json": {
    source: "iana",
    compressible: !0
  },
  "application/atsc-rsat+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rsat"
    ]
  },
  "application/atxml": {
    source: "iana"
  },
  "application/auth-policy+xml": {
    source: "iana",
    compressible: !0
  },
  "application/bacnet-xdd+zip": {
    source: "iana",
    compressible: !1
  },
  "application/batch-smtp": {
    source: "iana"
  },
  "application/bdoc": {
    compressible: !1,
    extensions: [
      "bdoc"
    ]
  },
  "application/beep+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/calendar+json": {
    source: "iana",
    compressible: !0
  },
  "application/calendar+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xcs"
    ]
  },
  "application/call-completion": {
    source: "iana"
  },
  "application/cals-1840": {
    source: "iana"
  },
  "application/captive+json": {
    source: "iana",
    compressible: !0
  },
  "application/cbor": {
    source: "iana"
  },
  "application/cbor-seq": {
    source: "iana"
  },
  "application/cccex": {
    source: "iana"
  },
  "application/ccmp+xml": {
    source: "iana",
    compressible: !0
  },
  "application/ccxml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "ccxml"
    ]
  },
  "application/cdfx+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "cdfx"
    ]
  },
  "application/cdmi-capability": {
    source: "iana",
    extensions: [
      "cdmia"
    ]
  },
  "application/cdmi-container": {
    source: "iana",
    extensions: [
      "cdmic"
    ]
  },
  "application/cdmi-domain": {
    source: "iana",
    extensions: [
      "cdmid"
    ]
  },
  "application/cdmi-object": {
    source: "iana",
    extensions: [
      "cdmio"
    ]
  },
  "application/cdmi-queue": {
    source: "iana",
    extensions: [
      "cdmiq"
    ]
  },
  "application/cdni": {
    source: "iana"
  },
  "application/cea": {
    source: "iana"
  },
  "application/cea-2018+xml": {
    source: "iana",
    compressible: !0
  },
  "application/cellml+xml": {
    source: "iana",
    compressible: !0
  },
  "application/cfw": {
    source: "iana"
  },
  "application/city+json": {
    source: "iana",
    compressible: !0
  },
  "application/clr": {
    source: "iana"
  },
  "application/clue+xml": {
    source: "iana",
    compressible: !0
  },
  "application/clue_info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/cms": {
    source: "iana"
  },
  "application/cnrp+xml": {
    source: "iana",
    compressible: !0
  },
  "application/coap-group+json": {
    source: "iana",
    compressible: !0
  },
  "application/coap-payload": {
    source: "iana"
  },
  "application/commonground": {
    source: "iana"
  },
  "application/conference-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/cose": {
    source: "iana"
  },
  "application/cose-key": {
    source: "iana"
  },
  "application/cose-key-set": {
    source: "iana"
  },
  "application/cpl+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "cpl"
    ]
  },
  "application/csrattrs": {
    source: "iana"
  },
  "application/csta+xml": {
    source: "iana",
    compressible: !0
  },
  "application/cstadata+xml": {
    source: "iana",
    compressible: !0
  },
  "application/csvm+json": {
    source: "iana",
    compressible: !0
  },
  "application/cu-seeme": {
    source: "apache",
    extensions: [
      "cu"
    ]
  },
  "application/cwt": {
    source: "iana"
  },
  "application/cybercash": {
    source: "iana"
  },
  "application/dart": {
    compressible: !0
  },
  "application/dash+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mpd"
    ]
  },
  "application/dash-patch+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mpp"
    ]
  },
  "application/dashdelta": {
    source: "iana"
  },
  "application/davmount+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "davmount"
    ]
  },
  "application/dca-rft": {
    source: "iana"
  },
  "application/dcd": {
    source: "iana"
  },
  "application/dec-dx": {
    source: "iana"
  },
  "application/dialog-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/dicom": {
    source: "iana"
  },
  "application/dicom+json": {
    source: "iana",
    compressible: !0
  },
  "application/dicom+xml": {
    source: "iana",
    compressible: !0
  },
  "application/dii": {
    source: "iana"
  },
  "application/dit": {
    source: "iana"
  },
  "application/dns": {
    source: "iana"
  },
  "application/dns+json": {
    source: "iana",
    compressible: !0
  },
  "application/dns-message": {
    source: "iana"
  },
  "application/docbook+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "dbk"
    ]
  },
  "application/dots+cbor": {
    source: "iana"
  },
  "application/dskpp+xml": {
    source: "iana",
    compressible: !0
  },
  "application/dssc+der": {
    source: "iana",
    extensions: [
      "dssc"
    ]
  },
  "application/dssc+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xdssc"
    ]
  },
  "application/dvcs": {
    source: "iana"
  },
  "application/ecmascript": {
    source: "iana",
    compressible: !0,
    extensions: [
      "es",
      "ecma"
    ]
  },
  "application/edi-consent": {
    source: "iana"
  },
  "application/edi-x12": {
    source: "iana",
    compressible: !1
  },
  "application/edifact": {
    source: "iana",
    compressible: !1
  },
  "application/efi": {
    source: "iana"
  },
  "application/elm+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/elm+xml": {
    source: "iana",
    compressible: !0
  },
  "application/emergencycalldata.cap+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/emergencycalldata.comment+xml": {
    source: "iana",
    compressible: !0
  },
  "application/emergencycalldata.control+xml": {
    source: "iana",
    compressible: !0
  },
  "application/emergencycalldata.deviceinfo+xml": {
    source: "iana",
    compressible: !0
  },
  "application/emergencycalldata.ecall.msd": {
    source: "iana"
  },
  "application/emergencycalldata.providerinfo+xml": {
    source: "iana",
    compressible: !0
  },
  "application/emergencycalldata.serviceinfo+xml": {
    source: "iana",
    compressible: !0
  },
  "application/emergencycalldata.subscriberinfo+xml": {
    source: "iana",
    compressible: !0
  },
  "application/emergencycalldata.veds+xml": {
    source: "iana",
    compressible: !0
  },
  "application/emma+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "emma"
    ]
  },
  "application/emotionml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "emotionml"
    ]
  },
  "application/encaprtp": {
    source: "iana"
  },
  "application/epp+xml": {
    source: "iana",
    compressible: !0
  },
  "application/epub+zip": {
    source: "iana",
    compressible: !1,
    extensions: [
      "epub"
    ]
  },
  "application/eshop": {
    source: "iana"
  },
  "application/exi": {
    source: "iana",
    extensions: [
      "exi"
    ]
  },
  "application/expect-ct-report+json": {
    source: "iana",
    compressible: !0
  },
  "application/express": {
    source: "iana",
    extensions: [
      "exp"
    ]
  },
  "application/fastinfoset": {
    source: "iana"
  },
  "application/fastsoap": {
    source: "iana"
  },
  "application/fdt+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "fdt"
    ]
  },
  "application/fhir+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/fhir+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/fido.trusted-apps+json": {
    compressible: !0
  },
  "application/fits": {
    source: "iana"
  },
  "application/flexfec": {
    source: "iana"
  },
  "application/font-sfnt": {
    source: "iana"
  },
  "application/font-tdpfr": {
    source: "iana",
    extensions: [
      "pfr"
    ]
  },
  "application/font-woff": {
    source: "iana",
    compressible: !1
  },
  "application/framework-attributes+xml": {
    source: "iana",
    compressible: !0
  },
  "application/geo+json": {
    source: "iana",
    compressible: !0,
    extensions: [
      "geojson"
    ]
  },
  "application/geo+json-seq": {
    source: "iana"
  },
  "application/geopackage+sqlite3": {
    source: "iana"
  },
  "application/geoxacml+xml": {
    source: "iana",
    compressible: !0
  },
  "application/gltf-buffer": {
    source: "iana"
  },
  "application/gml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "gml"
    ]
  },
  "application/gpx+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "gpx"
    ]
  },
  "application/gxf": {
    source: "apache",
    extensions: [
      "gxf"
    ]
  },
  "application/gzip": {
    source: "iana",
    compressible: !1,
    extensions: [
      "gz"
    ]
  },
  "application/h224": {
    source: "iana"
  },
  "application/held+xml": {
    source: "iana",
    compressible: !0
  },
  "application/hjson": {
    extensions: [
      "hjson"
    ]
  },
  "application/http": {
    source: "iana"
  },
  "application/hyperstudio": {
    source: "iana",
    extensions: [
      "stk"
    ]
  },
  "application/ibe-key-request+xml": {
    source: "iana",
    compressible: !0
  },
  "application/ibe-pkg-reply+xml": {
    source: "iana",
    compressible: !0
  },
  "application/ibe-pp-data": {
    source: "iana"
  },
  "application/iges": {
    source: "iana"
  },
  "application/im-iscomposing+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/index": {
    source: "iana"
  },
  "application/index.cmd": {
    source: "iana"
  },
  "application/index.obj": {
    source: "iana"
  },
  "application/index.response": {
    source: "iana"
  },
  "application/index.vnd": {
    source: "iana"
  },
  "application/inkml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "ink",
      "inkml"
    ]
  },
  "application/iotp": {
    source: "iana"
  },
  "application/ipfix": {
    source: "iana",
    extensions: [
      "ipfix"
    ]
  },
  "application/ipp": {
    source: "iana"
  },
  "application/isup": {
    source: "iana"
  },
  "application/its+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "its"
    ]
  },
  "application/java-archive": {
    source: "apache",
    compressible: !1,
    extensions: [
      "jar",
      "war",
      "ear"
    ]
  },
  "application/java-serialized-object": {
    source: "apache",
    compressible: !1,
    extensions: [
      "ser"
    ]
  },
  "application/java-vm": {
    source: "apache",
    compressible: !1,
    extensions: [
      "class"
    ]
  },
  "application/javascript": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: [
      "js",
      "mjs"
    ]
  },
  "application/jf2feed+json": {
    source: "iana",
    compressible: !0
  },
  "application/jose": {
    source: "iana"
  },
  "application/jose+json": {
    source: "iana",
    compressible: !0
  },
  "application/jrd+json": {
    source: "iana",
    compressible: !0
  },
  "application/jscalendar+json": {
    source: "iana",
    compressible: !0
  },
  "application/json": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: [
      "json",
      "map"
    ]
  },
  "application/json-patch+json": {
    source: "iana",
    compressible: !0
  },
  "application/json-seq": {
    source: "iana"
  },
  "application/json5": {
    extensions: [
      "json5"
    ]
  },
  "application/jsonml+json": {
    source: "apache",
    compressible: !0,
    extensions: [
      "jsonml"
    ]
  },
  "application/jwk+json": {
    source: "iana",
    compressible: !0
  },
  "application/jwk-set+json": {
    source: "iana",
    compressible: !0
  },
  "application/jwt": {
    source: "iana"
  },
  "application/kpml-request+xml": {
    source: "iana",
    compressible: !0
  },
  "application/kpml-response+xml": {
    source: "iana",
    compressible: !0
  },
  "application/ld+json": {
    source: "iana",
    compressible: !0,
    extensions: [
      "jsonld"
    ]
  },
  "application/lgr+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "lgr"
    ]
  },
  "application/link-format": {
    source: "iana"
  },
  "application/load-control+xml": {
    source: "iana",
    compressible: !0
  },
  "application/lost+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "lostxml"
    ]
  },
  "application/lostsync+xml": {
    source: "iana",
    compressible: !0
  },
  "application/lpf+zip": {
    source: "iana",
    compressible: !1
  },
  "application/lxf": {
    source: "iana"
  },
  "application/mac-binhex40": {
    source: "iana",
    extensions: [
      "hqx"
    ]
  },
  "application/mac-compactpro": {
    source: "apache",
    extensions: [
      "cpt"
    ]
  },
  "application/macwriteii": {
    source: "iana"
  },
  "application/mads+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mads"
    ]
  },
  "application/manifest+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: [
      "webmanifest"
    ]
  },
  "application/marc": {
    source: "iana",
    extensions: [
      "mrc"
    ]
  },
  "application/marcxml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mrcx"
    ]
  },
  "application/mathematica": {
    source: "iana",
    extensions: [
      "ma",
      "nb",
      "mb"
    ]
  },
  "application/mathml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mathml"
    ]
  },
  "application/mathml-content+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mathml-presentation+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-associated-procedure-description+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-deregister+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-envelope+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-msk+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-msk-response+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-protection-description+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-reception-report+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-register+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-register-response+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-schedule+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-user-service-description+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbox": {
    source: "iana",
    extensions: [
      "mbox"
    ]
  },
  "application/media-policy-dataset+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mpf"
    ]
  },
  "application/media_control+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mediaservercontrol+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mscml"
    ]
  },
  "application/merge-patch+json": {
    source: "iana",
    compressible: !0
  },
  "application/metalink+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "metalink"
    ]
  },
  "application/metalink4+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "meta4"
    ]
  },
  "application/mets+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mets"
    ]
  },
  "application/mf4": {
    source: "iana"
  },
  "application/mikey": {
    source: "iana"
  },
  "application/mipc": {
    source: "iana"
  },
  "application/missing-blocks+cbor-seq": {
    source: "iana"
  },
  "application/mmt-aei+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "maei"
    ]
  },
  "application/mmt-usd+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "musd"
    ]
  },
  "application/mods+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mods"
    ]
  },
  "application/moss-keys": {
    source: "iana"
  },
  "application/moss-signature": {
    source: "iana"
  },
  "application/mosskey-data": {
    source: "iana"
  },
  "application/mosskey-request": {
    source: "iana"
  },
  "application/mp21": {
    source: "iana",
    extensions: [
      "m21",
      "mp21"
    ]
  },
  "application/mp4": {
    source: "iana",
    extensions: [
      "mp4s",
      "m4p"
    ]
  },
  "application/mpeg4-generic": {
    source: "iana"
  },
  "application/mpeg4-iod": {
    source: "iana"
  },
  "application/mpeg4-iod-xmt": {
    source: "iana"
  },
  "application/mrb-consumer+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mrb-publish+xml": {
    source: "iana",
    compressible: !0
  },
  "application/msc-ivr+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/msc-mixer+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/msword": {
    source: "iana",
    compressible: !1,
    extensions: [
      "doc",
      "dot"
    ]
  },
  "application/mud+json": {
    source: "iana",
    compressible: !0
  },
  "application/multipart-core": {
    source: "iana"
  },
  "application/mxf": {
    source: "iana",
    extensions: [
      "mxf"
    ]
  },
  "application/n-quads": {
    source: "iana",
    extensions: [
      "nq"
    ]
  },
  "application/n-triples": {
    source: "iana",
    extensions: [
      "nt"
    ]
  },
  "application/nasdata": {
    source: "iana"
  },
  "application/news-checkgroups": {
    source: "iana",
    charset: "US-ASCII"
  },
  "application/news-groupinfo": {
    source: "iana",
    charset: "US-ASCII"
  },
  "application/news-transmission": {
    source: "iana"
  },
  "application/nlsml+xml": {
    source: "iana",
    compressible: !0
  },
  "application/node": {
    source: "iana",
    extensions: [
      "cjs"
    ]
  },
  "application/nss": {
    source: "iana"
  },
  "application/oauth-authz-req+jwt": {
    source: "iana"
  },
  "application/oblivious-dns-message": {
    source: "iana"
  },
  "application/ocsp-request": {
    source: "iana"
  },
  "application/ocsp-response": {
    source: "iana"
  },
  "application/octet-stream": {
    source: "iana",
    compressible: !1,
    extensions: [
      "bin",
      "dms",
      "lrf",
      "mar",
      "so",
      "dist",
      "distz",
      "pkg",
      "bpk",
      "dump",
      "elc",
      "deploy",
      "exe",
      "dll",
      "deb",
      "dmg",
      "iso",
      "img",
      "msi",
      "msp",
      "msm",
      "buffer"
    ]
  },
  "application/oda": {
    source: "iana",
    extensions: [
      "oda"
    ]
  },
  "application/odm+xml": {
    source: "iana",
    compressible: !0
  },
  "application/odx": {
    source: "iana"
  },
  "application/oebps-package+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "opf"
    ]
  },
  "application/ogg": {
    source: "iana",
    compressible: !1,
    extensions: [
      "ogx"
    ]
  },
  "application/omdoc+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "omdoc"
    ]
  },
  "application/onenote": {
    source: "apache",
    extensions: [
      "onetoc",
      "onetoc2",
      "onetmp",
      "onepkg"
    ]
  },
  "application/opc-nodeset+xml": {
    source: "iana",
    compressible: !0
  },
  "application/oscore": {
    source: "iana"
  },
  "application/oxps": {
    source: "iana",
    extensions: [
      "oxps"
    ]
  },
  "application/p21": {
    source: "iana"
  },
  "application/p21+zip": {
    source: "iana",
    compressible: !1
  },
  "application/p2p-overlay+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "relo"
    ]
  },
  "application/parityfec": {
    source: "iana"
  },
  "application/passport": {
    source: "iana"
  },
  "application/patch-ops-error+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xer"
    ]
  },
  "application/pdf": {
    source: "iana",
    compressible: !1,
    extensions: [
      "pdf"
    ]
  },
  "application/pdx": {
    source: "iana"
  },
  "application/pem-certificate-chain": {
    source: "iana"
  },
  "application/pgp-encrypted": {
    source: "iana",
    compressible: !1,
    extensions: [
      "pgp"
    ]
  },
  "application/pgp-keys": {
    source: "iana",
    extensions: [
      "asc"
    ]
  },
  "application/pgp-signature": {
    source: "iana",
    extensions: [
      "asc",
      "sig"
    ]
  },
  "application/pics-rules": {
    source: "apache",
    extensions: [
      "prf"
    ]
  },
  "application/pidf+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/pidf-diff+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/pkcs10": {
    source: "iana",
    extensions: [
      "p10"
    ]
  },
  "application/pkcs12": {
    source: "iana"
  },
  "application/pkcs7-mime": {
    source: "iana",
    extensions: [
      "p7m",
      "p7c"
    ]
  },
  "application/pkcs7-signature": {
    source: "iana",
    extensions: [
      "p7s"
    ]
  },
  "application/pkcs8": {
    source: "iana",
    extensions: [
      "p8"
    ]
  },
  "application/pkcs8-encrypted": {
    source: "iana"
  },
  "application/pkix-attr-cert": {
    source: "iana",
    extensions: [
      "ac"
    ]
  },
  "application/pkix-cert": {
    source: "iana",
    extensions: [
      "cer"
    ]
  },
  "application/pkix-crl": {
    source: "iana",
    extensions: [
      "crl"
    ]
  },
  "application/pkix-pkipath": {
    source: "iana",
    extensions: [
      "pkipath"
    ]
  },
  "application/pkixcmp": {
    source: "iana",
    extensions: [
      "pki"
    ]
  },
  "application/pls+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "pls"
    ]
  },
  "application/poc-settings+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/postscript": {
    source: "iana",
    compressible: !0,
    extensions: [
      "ai",
      "eps",
      "ps"
    ]
  },
  "application/ppsp-tracker+json": {
    source: "iana",
    compressible: !0
  },
  "application/problem+json": {
    source: "iana",
    compressible: !0
  },
  "application/problem+xml": {
    source: "iana",
    compressible: !0
  },
  "application/provenance+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "provx"
    ]
  },
  "application/prs.alvestrand.titrax-sheet": {
    source: "iana"
  },
  "application/prs.cww": {
    source: "iana",
    extensions: [
      "cww"
    ]
  },
  "application/prs.cyn": {
    source: "iana",
    charset: "7-BIT"
  },
  "application/prs.hpub+zip": {
    source: "iana",
    compressible: !1
  },
  "application/prs.nprend": {
    source: "iana"
  },
  "application/prs.plucker": {
    source: "iana"
  },
  "application/prs.rdf-xml-crypt": {
    source: "iana"
  },
  "application/prs.xsf+xml": {
    source: "iana",
    compressible: !0
  },
  "application/pskc+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "pskcxml"
    ]
  },
  "application/pvd+json": {
    source: "iana",
    compressible: !0
  },
  "application/qsig": {
    source: "iana"
  },
  "application/raml+yaml": {
    compressible: !0,
    extensions: [
      "raml"
    ]
  },
  "application/raptorfec": {
    source: "iana"
  },
  "application/rdap+json": {
    source: "iana",
    compressible: !0
  },
  "application/rdf+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rdf",
      "owl"
    ]
  },
  "application/reginfo+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rif"
    ]
  },
  "application/relax-ng-compact-syntax": {
    source: "iana",
    extensions: [
      "rnc"
    ]
  },
  "application/remote-printing": {
    source: "iana"
  },
  "application/reputon+json": {
    source: "iana",
    compressible: !0
  },
  "application/resource-lists+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rl"
    ]
  },
  "application/resource-lists-diff+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rld"
    ]
  },
  "application/rfc+xml": {
    source: "iana",
    compressible: !0
  },
  "application/riscos": {
    source: "iana"
  },
  "application/rlmi+xml": {
    source: "iana",
    compressible: !0
  },
  "application/rls-services+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rs"
    ]
  },
  "application/route-apd+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rapd"
    ]
  },
  "application/route-s-tsid+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "sls"
    ]
  },
  "application/route-usd+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rusd"
    ]
  },
  "application/rpki-ghostbusters": {
    source: "iana",
    extensions: [
      "gbr"
    ]
  },
  "application/rpki-manifest": {
    source: "iana",
    extensions: [
      "mft"
    ]
  },
  "application/rpki-publication": {
    source: "iana"
  },
  "application/rpki-roa": {
    source: "iana",
    extensions: [
      "roa"
    ]
  },
  "application/rpki-updown": {
    source: "iana"
  },
  "application/rsd+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "rsd"
    ]
  },
  "application/rss+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "rss"
    ]
  },
  "application/rtf": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rtf"
    ]
  },
  "application/rtploopback": {
    source: "iana"
  },
  "application/rtx": {
    source: "iana"
  },
  "application/samlassertion+xml": {
    source: "iana",
    compressible: !0
  },
  "application/samlmetadata+xml": {
    source: "iana",
    compressible: !0
  },
  "application/sarif+json": {
    source: "iana",
    compressible: !0
  },
  "application/sarif-external-properties+json": {
    source: "iana",
    compressible: !0
  },
  "application/sbe": {
    source: "iana"
  },
  "application/sbml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "sbml"
    ]
  },
  "application/scaip+xml": {
    source: "iana",
    compressible: !0
  },
  "application/scim+json": {
    source: "iana",
    compressible: !0
  },
  "application/scvp-cv-request": {
    source: "iana",
    extensions: [
      "scq"
    ]
  },
  "application/scvp-cv-response": {
    source: "iana",
    extensions: [
      "scs"
    ]
  },
  "application/scvp-vp-request": {
    source: "iana",
    extensions: [
      "spq"
    ]
  },
  "application/scvp-vp-response": {
    source: "iana",
    extensions: [
      "spp"
    ]
  },
  "application/sdp": {
    source: "iana",
    extensions: [
      "sdp"
    ]
  },
  "application/secevent+jwt": {
    source: "iana"
  },
  "application/senml+cbor": {
    source: "iana"
  },
  "application/senml+json": {
    source: "iana",
    compressible: !0
  },
  "application/senml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "senmlx"
    ]
  },
  "application/senml-etch+cbor": {
    source: "iana"
  },
  "application/senml-etch+json": {
    source: "iana",
    compressible: !0
  },
  "application/senml-exi": {
    source: "iana"
  },
  "application/sensml+cbor": {
    source: "iana"
  },
  "application/sensml+json": {
    source: "iana",
    compressible: !0
  },
  "application/sensml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "sensmlx"
    ]
  },
  "application/sensml-exi": {
    source: "iana"
  },
  "application/sep+xml": {
    source: "iana",
    compressible: !0
  },
  "application/sep-exi": {
    source: "iana"
  },
  "application/session-info": {
    source: "iana"
  },
  "application/set-payment": {
    source: "iana"
  },
  "application/set-payment-initiation": {
    source: "iana",
    extensions: [
      "setpay"
    ]
  },
  "application/set-registration": {
    source: "iana"
  },
  "application/set-registration-initiation": {
    source: "iana",
    extensions: [
      "setreg"
    ]
  },
  "application/sgml": {
    source: "iana"
  },
  "application/sgml-open-catalog": {
    source: "iana"
  },
  "application/shf+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "shf"
    ]
  },
  "application/sieve": {
    source: "iana",
    extensions: [
      "siv",
      "sieve"
    ]
  },
  "application/simple-filter+xml": {
    source: "iana",
    compressible: !0
  },
  "application/simple-message-summary": {
    source: "iana"
  },
  "application/simplesymbolcontainer": {
    source: "iana"
  },
  "application/sipc": {
    source: "iana"
  },
  "application/slate": {
    source: "iana"
  },
  "application/smil": {
    source: "iana"
  },
  "application/smil+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "smi",
      "smil"
    ]
  },
  "application/smpte336m": {
    source: "iana"
  },
  "application/soap+fastinfoset": {
    source: "iana"
  },
  "application/soap+xml": {
    source: "iana",
    compressible: !0
  },
  "application/sparql-query": {
    source: "iana",
    extensions: [
      "rq"
    ]
  },
  "application/sparql-results+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "srx"
    ]
  },
  "application/spdx+json": {
    source: "iana",
    compressible: !0
  },
  "application/spirits-event+xml": {
    source: "iana",
    compressible: !0
  },
  "application/sql": {
    source: "iana"
  },
  "application/srgs": {
    source: "iana",
    extensions: [
      "gram"
    ]
  },
  "application/srgs+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "grxml"
    ]
  },
  "application/sru+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "sru"
    ]
  },
  "application/ssdl+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "ssdl"
    ]
  },
  "application/ssml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "ssml"
    ]
  },
  "application/stix+json": {
    source: "iana",
    compressible: !0
  },
  "application/swid+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "swidtag"
    ]
  },
  "application/tamp-apex-update": {
    source: "iana"
  },
  "application/tamp-apex-update-confirm": {
    source: "iana"
  },
  "application/tamp-community-update": {
    source: "iana"
  },
  "application/tamp-community-update-confirm": {
    source: "iana"
  },
  "application/tamp-error": {
    source: "iana"
  },
  "application/tamp-sequence-adjust": {
    source: "iana"
  },
  "application/tamp-sequence-adjust-confirm": {
    source: "iana"
  },
  "application/tamp-status-query": {
    source: "iana"
  },
  "application/tamp-status-response": {
    source: "iana"
  },
  "application/tamp-update": {
    source: "iana"
  },
  "application/tamp-update-confirm": {
    source: "iana"
  },
  "application/tar": {
    compressible: !0
  },
  "application/taxii+json": {
    source: "iana",
    compressible: !0
  },
  "application/td+json": {
    source: "iana",
    compressible: !0
  },
  "application/tei+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "tei",
      "teicorpus"
    ]
  },
  "application/tetra_isi": {
    source: "iana"
  },
  "application/thraud+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "tfi"
    ]
  },
  "application/timestamp-query": {
    source: "iana"
  },
  "application/timestamp-reply": {
    source: "iana"
  },
  "application/timestamped-data": {
    source: "iana",
    extensions: [
      "tsd"
    ]
  },
  "application/tlsrpt+gzip": {
    source: "iana"
  },
  "application/tlsrpt+json": {
    source: "iana",
    compressible: !0
  },
  "application/tnauthlist": {
    source: "iana"
  },
  "application/token-introspection+jwt": {
    source: "iana"
  },
  "application/toml": {
    compressible: !0,
    extensions: [
      "toml"
    ]
  },
  "application/trickle-ice-sdpfrag": {
    source: "iana"
  },
  "application/trig": {
    source: "iana",
    extensions: [
      "trig"
    ]
  },
  "application/ttml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "ttml"
    ]
  },
  "application/tve-trigger": {
    source: "iana"
  },
  "application/tzif": {
    source: "iana"
  },
  "application/tzif-leap": {
    source: "iana"
  },
  "application/ubjson": {
    compressible: !1,
    extensions: [
      "ubj"
    ]
  },
  "application/ulpfec": {
    source: "iana"
  },
  "application/urc-grpsheet+xml": {
    source: "iana",
    compressible: !0
  },
  "application/urc-ressheet+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rsheet"
    ]
  },
  "application/urc-targetdesc+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "td"
    ]
  },
  "application/urc-uisocketdesc+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vcard+json": {
    source: "iana",
    compressible: !0
  },
  "application/vcard+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vemmi": {
    source: "iana"
  },
  "application/vividence.scriptfile": {
    source: "apache"
  },
  "application/vnd.1000minds.decision-model+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "1km"
    ]
  },
  "application/vnd.3gpp-prose+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp-prose-pc3ch+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp-v2x-local-service-information": {
    source: "iana"
  },
  "application/vnd.3gpp.5gnas": {
    source: "iana"
  },
  "application/vnd.3gpp.access-transfer-events+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.bsf+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.gmop+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.gtpc": {
    source: "iana"
  },
  "application/vnd.3gpp.interworking-data": {
    source: "iana"
  },
  "application/vnd.3gpp.lpp": {
    source: "iana"
  },
  "application/vnd.3gpp.mc-signalling-ear": {
    source: "iana"
  },
  "application/vnd.3gpp.mcdata-affiliation-command+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcdata-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcdata-payload": {
    source: "iana"
  },
  "application/vnd.3gpp.mcdata-service-config+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcdata-signalling": {
    source: "iana"
  },
  "application/vnd.3gpp.mcdata-ue-config+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcdata-user-profile+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcptt-affiliation-command+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcptt-floor-request+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcptt-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcptt-location-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcptt-service-config+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcptt-signed+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcptt-ue-config+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcptt-ue-init-config+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcptt-user-profile+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcvideo-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcvideo-location-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcvideo-service-config+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcvideo-transmission-request+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcvideo-ue-config+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcvideo-user-profile+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mid-call+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.ngap": {
    source: "iana"
  },
  "application/vnd.3gpp.pfcp": {
    source: "iana"
  },
  "application/vnd.3gpp.pic-bw-large": {
    source: "iana",
    extensions: [
      "plb"
    ]
  },
  "application/vnd.3gpp.pic-bw-small": {
    source: "iana",
    extensions: [
      "psb"
    ]
  },
  "application/vnd.3gpp.pic-bw-var": {
    source: "iana",
    extensions: [
      "pvb"
    ]
  },
  "application/vnd.3gpp.s1ap": {
    source: "iana"
  },
  "application/vnd.3gpp.sms": {
    source: "iana"
  },
  "application/vnd.3gpp.sms+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.srvcc-ext+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.srvcc-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.state-and-event-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.ussd+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp2.bcmcsinfo+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp2.sms": {
    source: "iana"
  },
  "application/vnd.3gpp2.tcap": {
    source: "iana",
    extensions: [
      "tcap"
    ]
  },
  "application/vnd.3lightssoftware.imagescal": {
    source: "iana"
  },
  "application/vnd.3m.post-it-notes": {
    source: "iana",
    extensions: [
      "pwn"
    ]
  },
  "application/vnd.accpac.simply.aso": {
    source: "iana",
    extensions: [
      "aso"
    ]
  },
  "application/vnd.accpac.simply.imp": {
    source: "iana",
    extensions: [
      "imp"
    ]
  },
  "application/vnd.acucobol": {
    source: "iana",
    extensions: [
      "acu"
    ]
  },
  "application/vnd.acucorp": {
    source: "iana",
    extensions: [
      "atc",
      "acutc"
    ]
  },
  "application/vnd.adobe.air-application-installer-package+zip": {
    source: "apache",
    compressible: !1,
    extensions: [
      "air"
    ]
  },
  "application/vnd.adobe.flash.movie": {
    source: "iana"
  },
  "application/vnd.adobe.formscentral.fcdt": {
    source: "iana",
    extensions: [
      "fcdt"
    ]
  },
  "application/vnd.adobe.fxp": {
    source: "iana",
    extensions: [
      "fxp",
      "fxpl"
    ]
  },
  "application/vnd.adobe.partial-upload": {
    source: "iana"
  },
  "application/vnd.adobe.xdp+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xdp"
    ]
  },
  "application/vnd.adobe.xfdf": {
    source: "iana",
    extensions: [
      "xfdf"
    ]
  },
  "application/vnd.aether.imp": {
    source: "iana"
  },
  "application/vnd.afpc.afplinedata": {
    source: "iana"
  },
  "application/vnd.afpc.afplinedata-pagedef": {
    source: "iana"
  },
  "application/vnd.afpc.cmoca-cmresource": {
    source: "iana"
  },
  "application/vnd.afpc.foca-charset": {
    source: "iana"
  },
  "application/vnd.afpc.foca-codedfont": {
    source: "iana"
  },
  "application/vnd.afpc.foca-codepage": {
    source: "iana"
  },
  "application/vnd.afpc.modca": {
    source: "iana"
  },
  "application/vnd.afpc.modca-cmtable": {
    source: "iana"
  },
  "application/vnd.afpc.modca-formdef": {
    source: "iana"
  },
  "application/vnd.afpc.modca-mediummap": {
    source: "iana"
  },
  "application/vnd.afpc.modca-objectcontainer": {
    source: "iana"
  },
  "application/vnd.afpc.modca-overlay": {
    source: "iana"
  },
  "application/vnd.afpc.modca-pagesegment": {
    source: "iana"
  },
  "application/vnd.age": {
    source: "iana",
    extensions: [
      "age"
    ]
  },
  "application/vnd.ah-barcode": {
    source: "iana"
  },
  "application/vnd.ahead.space": {
    source: "iana",
    extensions: [
      "ahead"
    ]
  },
  "application/vnd.airzip.filesecure.azf": {
    source: "iana",
    extensions: [
      "azf"
    ]
  },
  "application/vnd.airzip.filesecure.azs": {
    source: "iana",
    extensions: [
      "azs"
    ]
  },
  "application/vnd.amadeus+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.amazon.ebook": {
    source: "apache",
    extensions: [
      "azw"
    ]
  },
  "application/vnd.amazon.mobi8-ebook": {
    source: "iana"
  },
  "application/vnd.americandynamics.acc": {
    source: "iana",
    extensions: [
      "acc"
    ]
  },
  "application/vnd.amiga.ami": {
    source: "iana",
    extensions: [
      "ami"
    ]
  },
  "application/vnd.amundsen.maze+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.android.ota": {
    source: "iana"
  },
  "application/vnd.android.package-archive": {
    source: "apache",
    compressible: !1,
    extensions: [
      "apk"
    ]
  },
  "application/vnd.anki": {
    source: "iana"
  },
  "application/vnd.anser-web-certificate-issue-initiation": {
    source: "iana",
    extensions: [
      "cii"
    ]
  },
  "application/vnd.anser-web-funds-transfer-initiation": {
    source: "apache",
    extensions: [
      "fti"
    ]
  },
  "application/vnd.antix.game-component": {
    source: "iana",
    extensions: [
      "atx"
    ]
  },
  "application/vnd.apache.arrow.file": {
    source: "iana"
  },
  "application/vnd.apache.arrow.stream": {
    source: "iana"
  },
  "application/vnd.apache.thrift.binary": {
    source: "iana"
  },
  "application/vnd.apache.thrift.compact": {
    source: "iana"
  },
  "application/vnd.apache.thrift.json": {
    source: "iana"
  },
  "application/vnd.api+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.aplextor.warrp+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.apothekende.reservation+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.apple.installer+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mpkg"
    ]
  },
  "application/vnd.apple.keynote": {
    source: "iana",
    extensions: [
      "key"
    ]
  },
  "application/vnd.apple.mpegurl": {
    source: "iana",
    extensions: [
      "m3u8"
    ]
  },
  "application/vnd.apple.numbers": {
    source: "iana",
    extensions: [
      "numbers"
    ]
  },
  "application/vnd.apple.pages": {
    source: "iana",
    extensions: [
      "pages"
    ]
  },
  "application/vnd.apple.pkpass": {
    compressible: !1,
    extensions: [
      "pkpass"
    ]
  },
  "application/vnd.arastra.swi": {
    source: "iana"
  },
  "application/vnd.aristanetworks.swi": {
    source: "iana",
    extensions: [
      "swi"
    ]
  },
  "application/vnd.artisan+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.artsquare": {
    source: "iana"
  },
  "application/vnd.astraea-software.iota": {
    source: "iana",
    extensions: [
      "iota"
    ]
  },
  "application/vnd.audiograph": {
    source: "iana",
    extensions: [
      "aep"
    ]
  },
  "application/vnd.autopackage": {
    source: "iana"
  },
  "application/vnd.avalon+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.avistar+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.balsamiq.bmml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "bmml"
    ]
  },
  "application/vnd.balsamiq.bmpr": {
    source: "iana"
  },
  "application/vnd.banana-accounting": {
    source: "iana"
  },
  "application/vnd.bbf.usp.error": {
    source: "iana"
  },
  "application/vnd.bbf.usp.msg": {
    source: "iana"
  },
  "application/vnd.bbf.usp.msg+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.bekitzur-stech+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.bint.med-content": {
    source: "iana"
  },
  "application/vnd.biopax.rdf+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.blink-idb-value-wrapper": {
    source: "iana"
  },
  "application/vnd.blueice.multipass": {
    source: "iana",
    extensions: [
      "mpm"
    ]
  },
  "application/vnd.bluetooth.ep.oob": {
    source: "iana"
  },
  "application/vnd.bluetooth.le.oob": {
    source: "iana"
  },
  "application/vnd.bmi": {
    source: "iana",
    extensions: [
      "bmi"
    ]
  },
  "application/vnd.bpf": {
    source: "iana"
  },
  "application/vnd.bpf3": {
    source: "iana"
  },
  "application/vnd.businessobjects": {
    source: "iana",
    extensions: [
      "rep"
    ]
  },
  "application/vnd.byu.uapi+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.cab-jscript": {
    source: "iana"
  },
  "application/vnd.canon-cpdl": {
    source: "iana"
  },
  "application/vnd.canon-lips": {
    source: "iana"
  },
  "application/vnd.capasystems-pg+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.cendio.thinlinc.clientconf": {
    source: "iana"
  },
  "application/vnd.century-systems.tcp_stream": {
    source: "iana"
  },
  "application/vnd.chemdraw+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "cdxml"
    ]
  },
  "application/vnd.chess-pgn": {
    source: "iana"
  },
  "application/vnd.chipnuts.karaoke-mmd": {
    source: "iana",
    extensions: [
      "mmd"
    ]
  },
  "application/vnd.ciedi": {
    source: "iana"
  },
  "application/vnd.cinderella": {
    source: "iana",
    extensions: [
      "cdy"
    ]
  },
  "application/vnd.cirpack.isdn-ext": {
    source: "iana"
  },
  "application/vnd.citationstyles.style+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "csl"
    ]
  },
  "application/vnd.claymore": {
    source: "iana",
    extensions: [
      "cla"
    ]
  },
  "application/vnd.cloanto.rp9": {
    source: "iana",
    extensions: [
      "rp9"
    ]
  },
  "application/vnd.clonk.c4group": {
    source: "iana",
    extensions: [
      "c4g",
      "c4d",
      "c4f",
      "c4p",
      "c4u"
    ]
  },
  "application/vnd.cluetrust.cartomobile-config": {
    source: "iana",
    extensions: [
      "c11amc"
    ]
  },
  "application/vnd.cluetrust.cartomobile-config-pkg": {
    source: "iana",
    extensions: [
      "c11amz"
    ]
  },
  "application/vnd.coffeescript": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.document": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.document-template": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.presentation": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.presentation-template": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.spreadsheet": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.spreadsheet-template": {
    source: "iana"
  },
  "application/vnd.collection+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.collection.doc+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.collection.next+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.comicbook+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.comicbook-rar": {
    source: "iana"
  },
  "application/vnd.commerce-battelle": {
    source: "iana"
  },
  "application/vnd.commonspace": {
    source: "iana",
    extensions: [
      "csp"
    ]
  },
  "application/vnd.contact.cmsg": {
    source: "iana",
    extensions: [
      "cdbcmsg"
    ]
  },
  "application/vnd.coreos.ignition+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.cosmocaller": {
    source: "iana",
    extensions: [
      "cmc"
    ]
  },
  "application/vnd.crick.clicker": {
    source: "iana",
    extensions: [
      "clkx"
    ]
  },
  "application/vnd.crick.clicker.keyboard": {
    source: "iana",
    extensions: [
      "clkk"
    ]
  },
  "application/vnd.crick.clicker.palette": {
    source: "iana",
    extensions: [
      "clkp"
    ]
  },
  "application/vnd.crick.clicker.template": {
    source: "iana",
    extensions: [
      "clkt"
    ]
  },
  "application/vnd.crick.clicker.wordbank": {
    source: "iana",
    extensions: [
      "clkw"
    ]
  },
  "application/vnd.criticaltools.wbs+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "wbs"
    ]
  },
  "application/vnd.cryptii.pipe+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.crypto-shade-file": {
    source: "iana"
  },
  "application/vnd.cryptomator.encrypted": {
    source: "iana"
  },
  "application/vnd.cryptomator.vault": {
    source: "iana"
  },
  "application/vnd.ctc-posml": {
    source: "iana",
    extensions: [
      "pml"
    ]
  },
  "application/vnd.ctct.ws+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.cups-pdf": {
    source: "iana"
  },
  "application/vnd.cups-postscript": {
    source: "iana"
  },
  "application/vnd.cups-ppd": {
    source: "iana",
    extensions: [
      "ppd"
    ]
  },
  "application/vnd.cups-raster": {
    source: "iana"
  },
  "application/vnd.cups-raw": {
    source: "iana"
  },
  "application/vnd.curl": {
    source: "iana"
  },
  "application/vnd.curl.car": {
    source: "apache",
    extensions: [
      "car"
    ]
  },
  "application/vnd.curl.pcurl": {
    source: "apache",
    extensions: [
      "pcurl"
    ]
  },
  "application/vnd.cyan.dean.root+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.cybank": {
    source: "iana"
  },
  "application/vnd.cyclonedx+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.cyclonedx+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.d2l.coursepackage1p0+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.d3m-dataset": {
    source: "iana"
  },
  "application/vnd.d3m-problem": {
    source: "iana"
  },
  "application/vnd.dart": {
    source: "iana",
    compressible: !0,
    extensions: [
      "dart"
    ]
  },
  "application/vnd.data-vision.rdz": {
    source: "iana",
    extensions: [
      "rdz"
    ]
  },
  "application/vnd.datapackage+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dataresource+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dbf": {
    source: "iana",
    extensions: [
      "dbf"
    ]
  },
  "application/vnd.debian.binary-package": {
    source: "iana"
  },
  "application/vnd.dece.data": {
    source: "iana",
    extensions: [
      "uvf",
      "uvvf",
      "uvd",
      "uvvd"
    ]
  },
  "application/vnd.dece.ttml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "uvt",
      "uvvt"
    ]
  },
  "application/vnd.dece.unspecified": {
    source: "iana",
    extensions: [
      "uvx",
      "uvvx"
    ]
  },
  "application/vnd.dece.zip": {
    source: "iana",
    extensions: [
      "uvz",
      "uvvz"
    ]
  },
  "application/vnd.denovo.fcselayout-link": {
    source: "iana",
    extensions: [
      "fe_launch"
    ]
  },
  "application/vnd.desmume.movie": {
    source: "iana"
  },
  "application/vnd.dir-bi.plate-dl-nosuffix": {
    source: "iana"
  },
  "application/vnd.dm.delegation+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dna": {
    source: "iana",
    extensions: [
      "dna"
    ]
  },
  "application/vnd.document+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dolby.mlp": {
    source: "apache",
    extensions: [
      "mlp"
    ]
  },
  "application/vnd.dolby.mobile.1": {
    source: "iana"
  },
  "application/vnd.dolby.mobile.2": {
    source: "iana"
  },
  "application/vnd.doremir.scorecloud-binary-document": {
    source: "iana"
  },
  "application/vnd.dpgraph": {
    source: "iana",
    extensions: [
      "dpg"
    ]
  },
  "application/vnd.dreamfactory": {
    source: "iana",
    extensions: [
      "dfac"
    ]
  },
  "application/vnd.drive+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ds-keypoint": {
    source: "apache",
    extensions: [
      "kpxx"
    ]
  },
  "application/vnd.dtg.local": {
    source: "iana"
  },
  "application/vnd.dtg.local.flash": {
    source: "iana"
  },
  "application/vnd.dtg.local.html": {
    source: "iana"
  },
  "application/vnd.dvb.ait": {
    source: "iana",
    extensions: [
      "ait"
    ]
  },
  "application/vnd.dvb.dvbisl+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dvb.dvbj": {
    source: "iana"
  },
  "application/vnd.dvb.esgcontainer": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcdftnotifaccess": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcesgaccess": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcesgaccess2": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcesgpdd": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcroaming": {
    source: "iana"
  },
  "application/vnd.dvb.iptv.alfec-base": {
    source: "iana"
  },
  "application/vnd.dvb.iptv.alfec-enhancement": {
    source: "iana"
  },
  "application/vnd.dvb.notif-aggregate-root+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dvb.notif-container+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dvb.notif-generic+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dvb.notif-ia-msglist+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dvb.notif-ia-registration-request+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dvb.notif-ia-registration-response+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dvb.notif-init+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dvb.pfr": {
    source: "iana"
  },
  "application/vnd.dvb.service": {
    source: "iana",
    extensions: [
      "svc"
    ]
  },
  "application/vnd.dxr": {
    source: "iana"
  },
  "application/vnd.dynageo": {
    source: "iana",
    extensions: [
      "geo"
    ]
  },
  "application/vnd.dzr": {
    source: "iana"
  },
  "application/vnd.easykaraoke.cdgdownload": {
    source: "iana"
  },
  "application/vnd.ecdis-update": {
    source: "iana"
  },
  "application/vnd.ecip.rlp": {
    source: "iana"
  },
  "application/vnd.eclipse.ditto+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ecowin.chart": {
    source: "iana",
    extensions: [
      "mag"
    ]
  },
  "application/vnd.ecowin.filerequest": {
    source: "iana"
  },
  "application/vnd.ecowin.fileupdate": {
    source: "iana"
  },
  "application/vnd.ecowin.series": {
    source: "iana"
  },
  "application/vnd.ecowin.seriesrequest": {
    source: "iana"
  },
  "application/vnd.ecowin.seriesupdate": {
    source: "iana"
  },
  "application/vnd.efi.img": {
    source: "iana"
  },
  "application/vnd.efi.iso": {
    source: "iana"
  },
  "application/vnd.emclient.accessrequest+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.enliven": {
    source: "iana",
    extensions: [
      "nml"
    ]
  },
  "application/vnd.enphase.envoy": {
    source: "iana"
  },
  "application/vnd.eprints.data+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.epson.esf": {
    source: "iana",
    extensions: [
      "esf"
    ]
  },
  "application/vnd.epson.msf": {
    source: "iana",
    extensions: [
      "msf"
    ]
  },
  "application/vnd.epson.quickanime": {
    source: "iana",
    extensions: [
      "qam"
    ]
  },
  "application/vnd.epson.salt": {
    source: "iana",
    extensions: [
      "slt"
    ]
  },
  "application/vnd.epson.ssf": {
    source: "iana",
    extensions: [
      "ssf"
    ]
  },
  "application/vnd.ericsson.quickcall": {
    source: "iana"
  },
  "application/vnd.espass-espass+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.eszigno3+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "es3",
      "et3"
    ]
  },
  "application/vnd.etsi.aoc+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.asic-e+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.etsi.asic-s+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.etsi.cug+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.iptvcommand+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.iptvdiscovery+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.iptvprofile+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.iptvsad-bc+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.iptvsad-cod+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.iptvsad-npvr+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.iptvservice+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.iptvsync+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.iptvueprofile+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.mcid+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.mheg5": {
    source: "iana"
  },
  "application/vnd.etsi.overload-control-policy-dataset+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.pstn+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.sci+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.simservs+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.timestamp-token": {
    source: "iana"
  },
  "application/vnd.etsi.tsl+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.tsl.der": {
    source: "iana"
  },
  "application/vnd.eu.kasparian.car+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.eudora.data": {
    source: "iana"
  },
  "application/vnd.evolv.ecig.profile": {
    source: "iana"
  },
  "application/vnd.evolv.ecig.settings": {
    source: "iana"
  },
  "application/vnd.evolv.ecig.theme": {
    source: "iana"
  },
  "application/vnd.exstream-empower+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.exstream-package": {
    source: "iana"
  },
  "application/vnd.ezpix-album": {
    source: "iana",
    extensions: [
      "ez2"
    ]
  },
  "application/vnd.ezpix-package": {
    source: "iana",
    extensions: [
      "ez3"
    ]
  },
  "application/vnd.f-secure.mobile": {
    source: "iana"
  },
  "application/vnd.familysearch.gedcom+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.fastcopy-disk-image": {
    source: "iana"
  },
  "application/vnd.fdf": {
    source: "iana",
    extensions: [
      "fdf"
    ]
  },
  "application/vnd.fdsn.mseed": {
    source: "iana",
    extensions: [
      "mseed"
    ]
  },
  "application/vnd.fdsn.seed": {
    source: "iana",
    extensions: [
      "seed",
      "dataless"
    ]
  },
  "application/vnd.ffsns": {
    source: "iana"
  },
  "application/vnd.ficlab.flb+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.filmit.zfc": {
    source: "iana"
  },
  "application/vnd.fints": {
    source: "iana"
  },
  "application/vnd.firemonkeys.cloudcell": {
    source: "iana"
  },
  "application/vnd.flographit": {
    source: "iana",
    extensions: [
      "gph"
    ]
  },
  "application/vnd.fluxtime.clip": {
    source: "iana",
    extensions: [
      "ftc"
    ]
  },
  "application/vnd.font-fontforge-sfd": {
    source: "iana"
  },
  "application/vnd.framemaker": {
    source: "iana",
    extensions: [
      "fm",
      "frame",
      "maker",
      "book"
    ]
  },
  "application/vnd.frogans.fnc": {
    source: "iana",
    extensions: [
      "fnc"
    ]
  },
  "application/vnd.frogans.ltf": {
    source: "iana",
    extensions: [
      "ltf"
    ]
  },
  "application/vnd.fsc.weblaunch": {
    source: "iana",
    extensions: [
      "fsc"
    ]
  },
  "application/vnd.fujifilm.fb.docuworks": {
    source: "iana"
  },
  "application/vnd.fujifilm.fb.docuworks.binder": {
    source: "iana"
  },
  "application/vnd.fujifilm.fb.docuworks.container": {
    source: "iana"
  },
  "application/vnd.fujifilm.fb.jfi+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.fujitsu.oasys": {
    source: "iana",
    extensions: [
      "oas"
    ]
  },
  "application/vnd.fujitsu.oasys2": {
    source: "iana",
    extensions: [
      "oa2"
    ]
  },
  "application/vnd.fujitsu.oasys3": {
    source: "iana",
    extensions: [
      "oa3"
    ]
  },
  "application/vnd.fujitsu.oasysgp": {
    source: "iana",
    extensions: [
      "fg5"
    ]
  },
  "application/vnd.fujitsu.oasysprs": {
    source: "iana",
    extensions: [
      "bh2"
    ]
  },
  "application/vnd.fujixerox.art-ex": {
    source: "iana"
  },
  "application/vnd.fujixerox.art4": {
    source: "iana"
  },
  "application/vnd.fujixerox.ddd": {
    source: "iana",
    extensions: [
      "ddd"
    ]
  },
  "application/vnd.fujixerox.docuworks": {
    source: "iana",
    extensions: [
      "xdw"
    ]
  },
  "application/vnd.fujixerox.docuworks.binder": {
    source: "iana",
    extensions: [
      "xbd"
    ]
  },
  "application/vnd.fujixerox.docuworks.container": {
    source: "iana"
  },
  "application/vnd.fujixerox.hbpl": {
    source: "iana"
  },
  "application/vnd.fut-misnet": {
    source: "iana"
  },
  "application/vnd.futoin+cbor": {
    source: "iana"
  },
  "application/vnd.futoin+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.fuzzysheet": {
    source: "iana",
    extensions: [
      "fzs"
    ]
  },
  "application/vnd.genomatix.tuxedo": {
    source: "iana",
    extensions: [
      "txd"
    ]
  },
  "application/vnd.gentics.grd+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.geo+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.geocube+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.geogebra.file": {
    source: "iana",
    extensions: [
      "ggb"
    ]
  },
  "application/vnd.geogebra.slides": {
    source: "iana"
  },
  "application/vnd.geogebra.tool": {
    source: "iana",
    extensions: [
      "ggt"
    ]
  },
  "application/vnd.geometry-explorer": {
    source: "iana",
    extensions: [
      "gex",
      "gre"
    ]
  },
  "application/vnd.geonext": {
    source: "iana",
    extensions: [
      "gxt"
    ]
  },
  "application/vnd.geoplan": {
    source: "iana",
    extensions: [
      "g2w"
    ]
  },
  "application/vnd.geospace": {
    source: "iana",
    extensions: [
      "g3w"
    ]
  },
  "application/vnd.gerber": {
    source: "iana"
  },
  "application/vnd.globalplatform.card-content-mgt": {
    source: "iana"
  },
  "application/vnd.globalplatform.card-content-mgt-response": {
    source: "iana"
  },
  "application/vnd.gmx": {
    source: "iana",
    extensions: [
      "gmx"
    ]
  },
  "application/vnd.google-apps.document": {
    compressible: !1,
    extensions: [
      "gdoc"
    ]
  },
  "application/vnd.google-apps.presentation": {
    compressible: !1,
    extensions: [
      "gslides"
    ]
  },
  "application/vnd.google-apps.spreadsheet": {
    compressible: !1,
    extensions: [
      "gsheet"
    ]
  },
  "application/vnd.google-earth.kml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "kml"
    ]
  },
  "application/vnd.google-earth.kmz": {
    source: "iana",
    compressible: !1,
    extensions: [
      "kmz"
    ]
  },
  "application/vnd.gov.sk.e-form+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.gov.sk.e-form+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.gov.sk.xmldatacontainer+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.grafeq": {
    source: "iana",
    extensions: [
      "gqf",
      "gqs"
    ]
  },
  "application/vnd.gridmp": {
    source: "iana"
  },
  "application/vnd.groove-account": {
    source: "iana",
    extensions: [
      "gac"
    ]
  },
  "application/vnd.groove-help": {
    source: "iana",
    extensions: [
      "ghf"
    ]
  },
  "application/vnd.groove-identity-message": {
    source: "iana",
    extensions: [
      "gim"
    ]
  },
  "application/vnd.groove-injector": {
    source: "iana",
    extensions: [
      "grv"
    ]
  },
  "application/vnd.groove-tool-message": {
    source: "iana",
    extensions: [
      "gtm"
    ]
  },
  "application/vnd.groove-tool-template": {
    source: "iana",
    extensions: [
      "tpl"
    ]
  },
  "application/vnd.groove-vcard": {
    source: "iana",
    extensions: [
      "vcg"
    ]
  },
  "application/vnd.hal+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.hal+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "hal"
    ]
  },
  "application/vnd.handheld-entertainment+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "zmm"
    ]
  },
  "application/vnd.hbci": {
    source: "iana",
    extensions: [
      "hbci"
    ]
  },
  "application/vnd.hc+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.hcl-bireports": {
    source: "iana"
  },
  "application/vnd.hdt": {
    source: "iana"
  },
  "application/vnd.heroku+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.hhe.lesson-player": {
    source: "iana",
    extensions: [
      "les"
    ]
  },
  "application/vnd.hl7cda+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/vnd.hl7v2+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/vnd.hp-hpgl": {
    source: "iana",
    extensions: [
      "hpgl"
    ]
  },
  "application/vnd.hp-hpid": {
    source: "iana",
    extensions: [
      "hpid"
    ]
  },
  "application/vnd.hp-hps": {
    source: "iana",
    extensions: [
      "hps"
    ]
  },
  "application/vnd.hp-jlyt": {
    source: "iana",
    extensions: [
      "jlt"
    ]
  },
  "application/vnd.hp-pcl": {
    source: "iana",
    extensions: [
      "pcl"
    ]
  },
  "application/vnd.hp-pclxl": {
    source: "iana",
    extensions: [
      "pclxl"
    ]
  },
  "application/vnd.httphone": {
    source: "iana"
  },
  "application/vnd.hydrostatix.sof-data": {
    source: "iana",
    extensions: [
      "sfd-hdstx"
    ]
  },
  "application/vnd.hyper+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.hyper-item+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.hyperdrive+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.hzn-3d-crossword": {
    source: "iana"
  },
  "application/vnd.ibm.afplinedata": {
    source: "iana"
  },
  "application/vnd.ibm.electronic-media": {
    source: "iana"
  },
  "application/vnd.ibm.minipay": {
    source: "iana",
    extensions: [
      "mpy"
    ]
  },
  "application/vnd.ibm.modcap": {
    source: "iana",
    extensions: [
      "afp",
      "listafp",
      "list3820"
    ]
  },
  "application/vnd.ibm.rights-management": {
    source: "iana",
    extensions: [
      "irm"
    ]
  },
  "application/vnd.ibm.secure-container": {
    source: "iana",
    extensions: [
      "sc"
    ]
  },
  "application/vnd.iccprofile": {
    source: "iana",
    extensions: [
      "icc",
      "icm"
    ]
  },
  "application/vnd.ieee.1905": {
    source: "iana"
  },
  "application/vnd.igloader": {
    source: "iana",
    extensions: [
      "igl"
    ]
  },
  "application/vnd.imagemeter.folder+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.imagemeter.image+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.immervision-ivp": {
    source: "iana",
    extensions: [
      "ivp"
    ]
  },
  "application/vnd.immervision-ivu": {
    source: "iana",
    extensions: [
      "ivu"
    ]
  },
  "application/vnd.ims.imsccv1p1": {
    source: "iana"
  },
  "application/vnd.ims.imsccv1p2": {
    source: "iana"
  },
  "application/vnd.ims.imsccv1p3": {
    source: "iana"
  },
  "application/vnd.ims.lis.v2.result+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ims.lti.v2.toolproxy+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ims.lti.v2.toolproxy.id+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ims.lti.v2.toolsettings+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ims.lti.v2.toolsettings.simple+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.informedcontrol.rms+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.informix-visionary": {
    source: "iana"
  },
  "application/vnd.infotech.project": {
    source: "iana"
  },
  "application/vnd.infotech.project+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.innopath.wamp.notification": {
    source: "iana"
  },
  "application/vnd.insors.igm": {
    source: "iana",
    extensions: [
      "igm"
    ]
  },
  "application/vnd.intercon.formnet": {
    source: "iana",
    extensions: [
      "xpw",
      "xpx"
    ]
  },
  "application/vnd.intergeo": {
    source: "iana",
    extensions: [
      "i2g"
    ]
  },
  "application/vnd.intertrust.digibox": {
    source: "iana"
  },
  "application/vnd.intertrust.nncp": {
    source: "iana"
  },
  "application/vnd.intu.qbo": {
    source: "iana",
    extensions: [
      "qbo"
    ]
  },
  "application/vnd.intu.qfx": {
    source: "iana",
    extensions: [
      "qfx"
    ]
  },
  "application/vnd.iptc.g2.catalogitem+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.iptc.g2.conceptitem+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.iptc.g2.knowledgeitem+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.iptc.g2.newsitem+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.iptc.g2.newsmessage+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.iptc.g2.packageitem+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.iptc.g2.planningitem+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ipunplugged.rcprofile": {
    source: "iana",
    extensions: [
      "rcprofile"
    ]
  },
  "application/vnd.irepository.package+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "irp"
    ]
  },
  "application/vnd.is-xpr": {
    source: "iana",
    extensions: [
      "xpr"
    ]
  },
  "application/vnd.isac.fcs": {
    source: "iana",
    extensions: [
      "fcs"
    ]
  },
  "application/vnd.iso11783-10+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.jam": {
    source: "iana",
    extensions: [
      "jam"
    ]
  },
  "application/vnd.japannet-directory-service": {
    source: "iana"
  },
  "application/vnd.japannet-jpnstore-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-payment-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-registration": {
    source: "iana"
  },
  "application/vnd.japannet-registration-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-setstore-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-verification": {
    source: "iana"
  },
  "application/vnd.japannet-verification-wakeup": {
    source: "iana"
  },
  "application/vnd.jcp.javame.midlet-rms": {
    source: "iana",
    extensions: [
      "rms"
    ]
  },
  "application/vnd.jisp": {
    source: "iana",
    extensions: [
      "jisp"
    ]
  },
  "application/vnd.joost.joda-archive": {
    source: "iana",
    extensions: [
      "joda"
    ]
  },
  "application/vnd.jsk.isdn-ngn": {
    source: "iana"
  },
  "application/vnd.kahootz": {
    source: "iana",
    extensions: [
      "ktz",
      "ktr"
    ]
  },
  "application/vnd.kde.karbon": {
    source: "iana",
    extensions: [
      "karbon"
    ]
  },
  "application/vnd.kde.kchart": {
    source: "iana",
    extensions: [
      "chrt"
    ]
  },
  "application/vnd.kde.kformula": {
    source: "iana",
    extensions: [
      "kfo"
    ]
  },
  "application/vnd.kde.kivio": {
    source: "iana",
    extensions: [
      "flw"
    ]
  },
  "application/vnd.kde.kontour": {
    source: "iana",
    extensions: [
      "kon"
    ]
  },
  "application/vnd.kde.kpresenter": {
    source: "iana",
    extensions: [
      "kpr",
      "kpt"
    ]
  },
  "application/vnd.kde.kspread": {
    source: "iana",
    extensions: [
      "ksp"
    ]
  },
  "application/vnd.kde.kword": {
    source: "iana",
    extensions: [
      "kwd",
      "kwt"
    ]
  },
  "application/vnd.kenameaapp": {
    source: "iana",
    extensions: [
      "htke"
    ]
  },
  "application/vnd.kidspiration": {
    source: "iana",
    extensions: [
      "kia"
    ]
  },
  "application/vnd.kinar": {
    source: "iana",
    extensions: [
      "kne",
      "knp"
    ]
  },
  "application/vnd.koan": {
    source: "iana",
    extensions: [
      "skp",
      "skd",
      "skt",
      "skm"
    ]
  },
  "application/vnd.kodak-descriptor": {
    source: "iana",
    extensions: [
      "sse"
    ]
  },
  "application/vnd.las": {
    source: "iana"
  },
  "application/vnd.las.las+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.las.las+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "lasxml"
    ]
  },
  "application/vnd.laszip": {
    source: "iana"
  },
  "application/vnd.leap+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.liberty-request+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.llamagraphics.life-balance.desktop": {
    source: "iana",
    extensions: [
      "lbd"
    ]
  },
  "application/vnd.llamagraphics.life-balance.exchange+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "lbe"
    ]
  },
  "application/vnd.logipipe.circuit+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.loom": {
    source: "iana"
  },
  "application/vnd.lotus-1-2-3": {
    source: "iana",
    extensions: [
      "123"
    ]
  },
  "application/vnd.lotus-approach": {
    source: "iana",
    extensions: [
      "apr"
    ]
  },
  "application/vnd.lotus-freelance": {
    source: "iana",
    extensions: [
      "pre"
    ]
  },
  "application/vnd.lotus-notes": {
    source: "iana",
    extensions: [
      "nsf"
    ]
  },
  "application/vnd.lotus-organizer": {
    source: "iana",
    extensions: [
      "org"
    ]
  },
  "application/vnd.lotus-screencam": {
    source: "iana",
    extensions: [
      "scm"
    ]
  },
  "application/vnd.lotus-wordpro": {
    source: "iana",
    extensions: [
      "lwp"
    ]
  },
  "application/vnd.macports.portpkg": {
    source: "iana",
    extensions: [
      "portpkg"
    ]
  },
  "application/vnd.mapbox-vector-tile": {
    source: "iana",
    extensions: [
      "mvt"
    ]
  },
  "application/vnd.marlin.drm.actiontoken+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.marlin.drm.conftoken+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.marlin.drm.license+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.marlin.drm.mdcf": {
    source: "iana"
  },
  "application/vnd.mason+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.maxar.archive.3tz+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.maxmind.maxmind-db": {
    source: "iana"
  },
  "application/vnd.mcd": {
    source: "iana",
    extensions: [
      "mcd"
    ]
  },
  "application/vnd.medcalcdata": {
    source: "iana",
    extensions: [
      "mc1"
    ]
  },
  "application/vnd.mediastation.cdkey": {
    source: "iana",
    extensions: [
      "cdkey"
    ]
  },
  "application/vnd.meridian-slingshot": {
    source: "iana"
  },
  "application/vnd.mfer": {
    source: "iana",
    extensions: [
      "mwf"
    ]
  },
  "application/vnd.mfmp": {
    source: "iana",
    extensions: [
      "mfm"
    ]
  },
  "application/vnd.micro+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.micrografx.flo": {
    source: "iana",
    extensions: [
      "flo"
    ]
  },
  "application/vnd.micrografx.igx": {
    source: "iana",
    extensions: [
      "igx"
    ]
  },
  "application/vnd.microsoft.portable-executable": {
    source: "iana"
  },
  "application/vnd.microsoft.windows.thumbnail-cache": {
    source: "iana"
  },
  "application/vnd.miele+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.mif": {
    source: "iana",
    extensions: [
      "mif"
    ]
  },
  "application/vnd.minisoft-hp3000-save": {
    source: "iana"
  },
  "application/vnd.mitsubishi.misty-guard.trustweb": {
    source: "iana"
  },
  "application/vnd.mobius.daf": {
    source: "iana",
    extensions: [
      "daf"
    ]
  },
  "application/vnd.mobius.dis": {
    source: "iana",
    extensions: [
      "dis"
    ]
  },
  "application/vnd.mobius.mbk": {
    source: "iana",
    extensions: [
      "mbk"
    ]
  },
  "application/vnd.mobius.mqy": {
    source: "iana",
    extensions: [
      "mqy"
    ]
  },
  "application/vnd.mobius.msl": {
    source: "iana",
    extensions: [
      "msl"
    ]
  },
  "application/vnd.mobius.plc": {
    source: "iana",
    extensions: [
      "plc"
    ]
  },
  "application/vnd.mobius.txf": {
    source: "iana",
    extensions: [
      "txf"
    ]
  },
  "application/vnd.mophun.application": {
    source: "iana",
    extensions: [
      "mpn"
    ]
  },
  "application/vnd.mophun.certificate": {
    source: "iana",
    extensions: [
      "mpc"
    ]
  },
  "application/vnd.motorola.flexsuite": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.adsi": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.fis": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.gotap": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.kmr": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.ttc": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.wem": {
    source: "iana"
  },
  "application/vnd.motorola.iprm": {
    source: "iana"
  },
  "application/vnd.mozilla.xul+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xul"
    ]
  },
  "application/vnd.ms-3mfdocument": {
    source: "iana"
  },
  "application/vnd.ms-artgalry": {
    source: "iana",
    extensions: [
      "cil"
    ]
  },
  "application/vnd.ms-asf": {
    source: "iana"
  },
  "application/vnd.ms-cab-compressed": {
    source: "iana",
    extensions: [
      "cab"
    ]
  },
  "application/vnd.ms-color.iccprofile": {
    source: "apache"
  },
  "application/vnd.ms-excel": {
    source: "iana",
    compressible: !1,
    extensions: [
      "xls",
      "xlm",
      "xla",
      "xlc",
      "xlt",
      "xlw"
    ]
  },
  "application/vnd.ms-excel.addin.macroenabled.12": {
    source: "iana",
    extensions: [
      "xlam"
    ]
  },
  "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
    source: "iana",
    extensions: [
      "xlsb"
    ]
  },
  "application/vnd.ms-excel.sheet.macroenabled.12": {
    source: "iana",
    extensions: [
      "xlsm"
    ]
  },
  "application/vnd.ms-excel.template.macroenabled.12": {
    source: "iana",
    extensions: [
      "xltm"
    ]
  },
  "application/vnd.ms-fontobject": {
    source: "iana",
    compressible: !0,
    extensions: [
      "eot"
    ]
  },
  "application/vnd.ms-htmlhelp": {
    source: "iana",
    extensions: [
      "chm"
    ]
  },
  "application/vnd.ms-ims": {
    source: "iana",
    extensions: [
      "ims"
    ]
  },
  "application/vnd.ms-lrm": {
    source: "iana",
    extensions: [
      "lrm"
    ]
  },
  "application/vnd.ms-office.activex+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ms-officetheme": {
    source: "iana",
    extensions: [
      "thmx"
    ]
  },
  "application/vnd.ms-opentype": {
    source: "apache",
    compressible: !0
  },
  "application/vnd.ms-outlook": {
    compressible: !1,
    extensions: [
      "msg"
    ]
  },
  "application/vnd.ms-package.obfuscated-opentype": {
    source: "apache"
  },
  "application/vnd.ms-pki.seccat": {
    source: "apache",
    extensions: [
      "cat"
    ]
  },
  "application/vnd.ms-pki.stl": {
    source: "apache",
    extensions: [
      "stl"
    ]
  },
  "application/vnd.ms-playready.initiator+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ms-powerpoint": {
    source: "iana",
    compressible: !1,
    extensions: [
      "ppt",
      "pps",
      "pot"
    ]
  },
  "application/vnd.ms-powerpoint.addin.macroenabled.12": {
    source: "iana",
    extensions: [
      "ppam"
    ]
  },
  "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
    source: "iana",
    extensions: [
      "pptm"
    ]
  },
  "application/vnd.ms-powerpoint.slide.macroenabled.12": {
    source: "iana",
    extensions: [
      "sldm"
    ]
  },
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
    source: "iana",
    extensions: [
      "ppsm"
    ]
  },
  "application/vnd.ms-powerpoint.template.macroenabled.12": {
    source: "iana",
    extensions: [
      "potm"
    ]
  },
  "application/vnd.ms-printdevicecapabilities+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ms-printing.printticket+xml": {
    source: "apache",
    compressible: !0
  },
  "application/vnd.ms-printschematicket+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ms-project": {
    source: "iana",
    extensions: [
      "mpp",
      "mpt"
    ]
  },
  "application/vnd.ms-tnef": {
    source: "iana"
  },
  "application/vnd.ms-windows.devicepairing": {
    source: "iana"
  },
  "application/vnd.ms-windows.nwprinting.oob": {
    source: "iana"
  },
  "application/vnd.ms-windows.printerpairing": {
    source: "iana"
  },
  "application/vnd.ms-windows.wsd.oob": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.lic-chlg-req": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.lic-resp": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.meter-chlg-req": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.meter-resp": {
    source: "iana"
  },
  "application/vnd.ms-word.document.macroenabled.12": {
    source: "iana",
    extensions: [
      "docm"
    ]
  },
  "application/vnd.ms-word.template.macroenabled.12": {
    source: "iana",
    extensions: [
      "dotm"
    ]
  },
  "application/vnd.ms-works": {
    source: "iana",
    extensions: [
      "wps",
      "wks",
      "wcm",
      "wdb"
    ]
  },
  "application/vnd.ms-wpl": {
    source: "iana",
    extensions: [
      "wpl"
    ]
  },
  "application/vnd.ms-xpsdocument": {
    source: "iana",
    compressible: !1,
    extensions: [
      "xps"
    ]
  },
  "application/vnd.msa-disk-image": {
    source: "iana"
  },
  "application/vnd.mseq": {
    source: "iana",
    extensions: [
      "mseq"
    ]
  },
  "application/vnd.msign": {
    source: "iana"
  },
  "application/vnd.multiad.creator": {
    source: "iana"
  },
  "application/vnd.multiad.creator.cif": {
    source: "iana"
  },
  "application/vnd.music-niff": {
    source: "iana"
  },
  "application/vnd.musician": {
    source: "iana",
    extensions: [
      "mus"
    ]
  },
  "application/vnd.muvee.style": {
    source: "iana",
    extensions: [
      "msty"
    ]
  },
  "application/vnd.mynfc": {
    source: "iana",
    extensions: [
      "taglet"
    ]
  },
  "application/vnd.nacamar.ybrid+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ncd.control": {
    source: "iana"
  },
  "application/vnd.ncd.reference": {
    source: "iana"
  },
  "application/vnd.nearst.inv+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.nebumind.line": {
    source: "iana"
  },
  "application/vnd.nervana": {
    source: "iana"
  },
  "application/vnd.netfpx": {
    source: "iana"
  },
  "application/vnd.neurolanguage.nlu": {
    source: "iana",
    extensions: [
      "nlu"
    ]
  },
  "application/vnd.nimn": {
    source: "iana"
  },
  "application/vnd.nintendo.nitro.rom": {
    source: "iana"
  },
  "application/vnd.nintendo.snes.rom": {
    source: "iana"
  },
  "application/vnd.nitf": {
    source: "iana",
    extensions: [
      "ntf",
      "nitf"
    ]
  },
  "application/vnd.noblenet-directory": {
    source: "iana",
    extensions: [
      "nnd"
    ]
  },
  "application/vnd.noblenet-sealer": {
    source: "iana",
    extensions: [
      "nns"
    ]
  },
  "application/vnd.noblenet-web": {
    source: "iana",
    extensions: [
      "nnw"
    ]
  },
  "application/vnd.nokia.catalogs": {
    source: "iana"
  },
  "application/vnd.nokia.conml+wbxml": {
    source: "iana"
  },
  "application/vnd.nokia.conml+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.nokia.iptv.config+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.nokia.isds-radio-presets": {
    source: "iana"
  },
  "application/vnd.nokia.landmark+wbxml": {
    source: "iana"
  },
  "application/vnd.nokia.landmark+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.nokia.landmarkcollection+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.nokia.n-gage.ac+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "ac"
    ]
  },
  "application/vnd.nokia.n-gage.data": {
    source: "iana",
    extensions: [
      "ngdat"
    ]
  },
  "application/vnd.nokia.n-gage.symbian.install": {
    source: "iana",
    extensions: [
      "n-gage"
    ]
  },
  "application/vnd.nokia.ncd": {
    source: "iana"
  },
  "application/vnd.nokia.pcd+wbxml": {
    source: "iana"
  },
  "application/vnd.nokia.pcd+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.nokia.radio-preset": {
    source: "iana",
    extensions: [
      "rpst"
    ]
  },
  "application/vnd.nokia.radio-presets": {
    source: "iana",
    extensions: [
      "rpss"
    ]
  },
  "application/vnd.novadigm.edm": {
    source: "iana",
    extensions: [
      "edm"
    ]
  },
  "application/vnd.novadigm.edx": {
    source: "iana",
    extensions: [
      "edx"
    ]
  },
  "application/vnd.novadigm.ext": {
    source: "iana",
    extensions: [
      "ext"
    ]
  },
  "application/vnd.ntt-local.content-share": {
    source: "iana"
  },
  "application/vnd.ntt-local.file-transfer": {
    source: "iana"
  },
  "application/vnd.ntt-local.ogw_remote-access": {
    source: "iana"
  },
  "application/vnd.ntt-local.sip-ta_remote": {
    source: "iana"
  },
  "application/vnd.ntt-local.sip-ta_tcp_stream": {
    source: "iana"
  },
  "application/vnd.oasis.opendocument.chart": {
    source: "iana",
    extensions: [
      "odc"
    ]
  },
  "application/vnd.oasis.opendocument.chart-template": {
    source: "iana",
    extensions: [
      "otc"
    ]
  },
  "application/vnd.oasis.opendocument.database": {
    source: "iana",
    extensions: [
      "odb"
    ]
  },
  "application/vnd.oasis.opendocument.formula": {
    source: "iana",
    extensions: [
      "odf"
    ]
  },
  "application/vnd.oasis.opendocument.formula-template": {
    source: "iana",
    extensions: [
      "odft"
    ]
  },
  "application/vnd.oasis.opendocument.graphics": {
    source: "iana",
    compressible: !1,
    extensions: [
      "odg"
    ]
  },
  "application/vnd.oasis.opendocument.graphics-template": {
    source: "iana",
    extensions: [
      "otg"
    ]
  },
  "application/vnd.oasis.opendocument.image": {
    source: "iana",
    extensions: [
      "odi"
    ]
  },
  "application/vnd.oasis.opendocument.image-template": {
    source: "iana",
    extensions: [
      "oti"
    ]
  },
  "application/vnd.oasis.opendocument.presentation": {
    source: "iana",
    compressible: !1,
    extensions: [
      "odp"
    ]
  },
  "application/vnd.oasis.opendocument.presentation-template": {
    source: "iana",
    extensions: [
      "otp"
    ]
  },
  "application/vnd.oasis.opendocument.spreadsheet": {
    source: "iana",
    compressible: !1,
    extensions: [
      "ods"
    ]
  },
  "application/vnd.oasis.opendocument.spreadsheet-template": {
    source: "iana",
    extensions: [
      "ots"
    ]
  },
  "application/vnd.oasis.opendocument.text": {
    source: "iana",
    compressible: !1,
    extensions: [
      "odt"
    ]
  },
  "application/vnd.oasis.opendocument.text-master": {
    source: "iana",
    extensions: [
      "odm"
    ]
  },
  "application/vnd.oasis.opendocument.text-template": {
    source: "iana",
    extensions: [
      "ott"
    ]
  },
  "application/vnd.oasis.opendocument.text-web": {
    source: "iana",
    extensions: [
      "oth"
    ]
  },
  "application/vnd.obn": {
    source: "iana"
  },
  "application/vnd.ocf+cbor": {
    source: "iana"
  },
  "application/vnd.oci.image.manifest.v1+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oftn.l10n+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oipf.contentaccessdownload+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oipf.contentaccessstreaming+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oipf.cspg-hexbinary": {
    source: "iana"
  },
  "application/vnd.oipf.dae.svg+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oipf.dae.xhtml+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oipf.mippvcontrolmessage+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oipf.pae.gem": {
    source: "iana"
  },
  "application/vnd.oipf.spdiscovery+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oipf.spdlist+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oipf.ueprofile+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oipf.userprofile+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.olpc-sugar": {
    source: "iana",
    extensions: [
      "xo"
    ]
  },
  "application/vnd.oma-scws-config": {
    source: "iana"
  },
  "application/vnd.oma-scws-http-request": {
    source: "iana"
  },
  "application/vnd.oma-scws-http-response": {
    source: "iana"
  },
  "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.bcast.drm-trigger+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.bcast.imd+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.bcast.ltkm": {
    source: "iana"
  },
  "application/vnd.oma.bcast.notification+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.bcast.provisioningtrigger": {
    source: "iana"
  },
  "application/vnd.oma.bcast.sgboot": {
    source: "iana"
  },
  "application/vnd.oma.bcast.sgdd+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.bcast.sgdu": {
    source: "iana"
  },
  "application/vnd.oma.bcast.simple-symbol-container": {
    source: "iana"
  },
  "application/vnd.oma.bcast.smartcard-trigger+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.bcast.sprov+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.bcast.stkm": {
    source: "iana"
  },
  "application/vnd.oma.cab-address-book+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.cab-feature-handler+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.cab-pcc+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.cab-subs-invite+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.cab-user-prefs+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.dcd": {
    source: "iana"
  },
  "application/vnd.oma.dcdc": {
    source: "iana"
  },
  "application/vnd.oma.dd2+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "dd2"
    ]
  },
  "application/vnd.oma.drm.risd+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.group-usage-list+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.lwm2m+cbor": {
    source: "iana"
  },
  "application/vnd.oma.lwm2m+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.lwm2m+tlv": {
    source: "iana"
  },
  "application/vnd.oma.pal+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.poc.detailed-progress-report+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.poc.final-report+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.poc.groups+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.poc.invocation-descriptor+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.poc.optimized-progress-report+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.push": {
    source: "iana"
  },
  "application/vnd.oma.scidm.messages+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.xcap-directory+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.omads-email+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/vnd.omads-file+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/vnd.omads-folder+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/vnd.omaloc-supl-init": {
    source: "iana"
  },
  "application/vnd.onepager": {
    source: "iana"
  },
  "application/vnd.onepagertamp": {
    source: "iana"
  },
  "application/vnd.onepagertamx": {
    source: "iana"
  },
  "application/vnd.onepagertat": {
    source: "iana"
  },
  "application/vnd.onepagertatp": {
    source: "iana"
  },
  "application/vnd.onepagertatx": {
    source: "iana"
  },
  "application/vnd.openblox.game+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "obgx"
    ]
  },
  "application/vnd.openblox.game-binary": {
    source: "iana"
  },
  "application/vnd.openeye.oeb": {
    source: "iana"
  },
  "application/vnd.openofficeorg.extension": {
    source: "apache",
    extensions: [
      "oxt"
    ]
  },
  "application/vnd.openstreetmap.data+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "osm"
    ]
  },
  "application/vnd.opentimestamps.ots": {
    source: "iana"
  },
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.drawing+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
    source: "iana",
    compressible: !1,
    extensions: [
      "pptx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slide": {
    source: "iana",
    extensions: [
      "sldx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
    source: "iana",
    extensions: [
      "ppsx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template": {
    source: "iana",
    extensions: [
      "potx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
    source: "iana",
    compressible: !1,
    extensions: [
      "xlsx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
    source: "iana",
    extensions: [
      "xltx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.theme+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.vmldrawing": {
    source: "iana"
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
    source: "iana",
    compressible: !1,
    extensions: [
      "docx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
    source: "iana",
    extensions: [
      "dotx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-package.core-properties+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-package.relationships+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oracle.resource+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.orange.indata": {
    source: "iana"
  },
  "application/vnd.osa.netdeploy": {
    source: "iana"
  },
  "application/vnd.osgeo.mapguide.package": {
    source: "iana",
    extensions: [
      "mgp"
    ]
  },
  "application/vnd.osgi.bundle": {
    source: "iana"
  },
  "application/vnd.osgi.dp": {
    source: "iana",
    extensions: [
      "dp"
    ]
  },
  "application/vnd.osgi.subsystem": {
    source: "iana",
    extensions: [
      "esa"
    ]
  },
  "application/vnd.otps.ct-kip+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oxli.countgraph": {
    source: "iana"
  },
  "application/vnd.pagerduty+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.palm": {
    source: "iana",
    extensions: [
      "pdb",
      "pqa",
      "oprc"
    ]
  },
  "application/vnd.panoply": {
    source: "iana"
  },
  "application/vnd.paos.xml": {
    source: "iana"
  },
  "application/vnd.patentdive": {
    source: "iana"
  },
  "application/vnd.patientecommsdoc": {
    source: "iana"
  },
  "application/vnd.pawaafile": {
    source: "iana",
    extensions: [
      "paw"
    ]
  },
  "application/vnd.pcos": {
    source: "iana"
  },
  "application/vnd.pg.format": {
    source: "iana",
    extensions: [
      "str"
    ]
  },
  "application/vnd.pg.osasli": {
    source: "iana",
    extensions: [
      "ei6"
    ]
  },
  "application/vnd.piaccess.application-licence": {
    source: "iana"
  },
  "application/vnd.picsel": {
    source: "iana",
    extensions: [
      "efif"
    ]
  },
  "application/vnd.pmi.widget": {
    source: "iana",
    extensions: [
      "wg"
    ]
  },
  "application/vnd.poc.group-advertisement+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.pocketlearn": {
    source: "iana",
    extensions: [
      "plf"
    ]
  },
  "application/vnd.powerbuilder6": {
    source: "iana",
    extensions: [
      "pbd"
    ]
  },
  "application/vnd.powerbuilder6-s": {
    source: "iana"
  },
  "application/vnd.powerbuilder7": {
    source: "iana"
  },
  "application/vnd.powerbuilder7-s": {
    source: "iana"
  },
  "application/vnd.powerbuilder75": {
    source: "iana"
  },
  "application/vnd.powerbuilder75-s": {
    source: "iana"
  },
  "application/vnd.preminet": {
    source: "iana"
  },
  "application/vnd.previewsystems.box": {
    source: "iana",
    extensions: [
      "box"
    ]
  },
  "application/vnd.proteus.magazine": {
    source: "iana",
    extensions: [
      "mgz"
    ]
  },
  "application/vnd.psfs": {
    source: "iana"
  },
  "application/vnd.publishare-delta-tree": {
    source: "iana",
    extensions: [
      "qps"
    ]
  },
  "application/vnd.pvi.ptid1": {
    source: "iana",
    extensions: [
      "ptid"
    ]
  },
  "application/vnd.pwg-multiplexed": {
    source: "iana"
  },
  "application/vnd.pwg-xhtml-print+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.qualcomm.brew-app-res": {
    source: "iana"
  },
  "application/vnd.quarantainenet": {
    source: "iana"
  },
  "application/vnd.quark.quarkxpress": {
    source: "iana",
    extensions: [
      "qxd",
      "qxt",
      "qwd",
      "qwt",
      "qxl",
      "qxb"
    ]
  },
  "application/vnd.quobject-quoxdocument": {
    source: "iana"
  },
  "application/vnd.radisys.moml+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-audit+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-audit-conf+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-audit-conn+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-audit-dialog+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-audit-stream+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-conf+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-dialog+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-dialog-base+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-dialog-fax-detect+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-dialog-group+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-dialog-speech+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-dialog-transform+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.rainstor.data": {
    source: "iana"
  },
  "application/vnd.rapid": {
    source: "iana"
  },
  "application/vnd.rar": {
    source: "iana",
    extensions: [
      "rar"
    ]
  },
  "application/vnd.realvnc.bed": {
    source: "iana",
    extensions: [
      "bed"
    ]
  },
  "application/vnd.recordare.musicxml": {
    source: "iana",
    extensions: [
      "mxl"
    ]
  },
  "application/vnd.recordare.musicxml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "musicxml"
    ]
  },
  "application/vnd.renlearn.rlprint": {
    source: "iana"
  },
  "application/vnd.resilient.logic": {
    source: "iana"
  },
  "application/vnd.restful+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.rig.cryptonote": {
    source: "iana",
    extensions: [
      "cryptonote"
    ]
  },
  "application/vnd.rim.cod": {
    source: "apache",
    extensions: [
      "cod"
    ]
  },
  "application/vnd.rn-realmedia": {
    source: "apache",
    extensions: [
      "rm"
    ]
  },
  "application/vnd.rn-realmedia-vbr": {
    source: "apache",
    extensions: [
      "rmvb"
    ]
  },
  "application/vnd.route66.link66+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "link66"
    ]
  },
  "application/vnd.rs-274x": {
    source: "iana"
  },
  "application/vnd.ruckus.download": {
    source: "iana"
  },
  "application/vnd.s3sms": {
    source: "iana"
  },
  "application/vnd.sailingtracker.track": {
    source: "iana",
    extensions: [
      "st"
    ]
  },
  "application/vnd.sar": {
    source: "iana"
  },
  "application/vnd.sbm.cid": {
    source: "iana"
  },
  "application/vnd.sbm.mid2": {
    source: "iana"
  },
  "application/vnd.scribus": {
    source: "iana"
  },
  "application/vnd.sealed.3df": {
    source: "iana"
  },
  "application/vnd.sealed.csf": {
    source: "iana"
  },
  "application/vnd.sealed.doc": {
    source: "iana"
  },
  "application/vnd.sealed.eml": {
    source: "iana"
  },
  "application/vnd.sealed.mht": {
    source: "iana"
  },
  "application/vnd.sealed.net": {
    source: "iana"
  },
  "application/vnd.sealed.ppt": {
    source: "iana"
  },
  "application/vnd.sealed.tiff": {
    source: "iana"
  },
  "application/vnd.sealed.xls": {
    source: "iana"
  },
  "application/vnd.sealedmedia.softseal.html": {
    source: "iana"
  },
  "application/vnd.sealedmedia.softseal.pdf": {
    source: "iana"
  },
  "application/vnd.seemail": {
    source: "iana",
    extensions: [
      "see"
    ]
  },
  "application/vnd.seis+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.sema": {
    source: "iana",
    extensions: [
      "sema"
    ]
  },
  "application/vnd.semd": {
    source: "iana",
    extensions: [
      "semd"
    ]
  },
  "application/vnd.semf": {
    source: "iana",
    extensions: [
      "semf"
    ]
  },
  "application/vnd.shade-save-file": {
    source: "iana"
  },
  "application/vnd.shana.informed.formdata": {
    source: "iana",
    extensions: [
      "ifm"
    ]
  },
  "application/vnd.shana.informed.formtemplate": {
    source: "iana",
    extensions: [
      "itp"
    ]
  },
  "application/vnd.shana.informed.interchange": {
    source: "iana",
    extensions: [
      "iif"
    ]
  },
  "application/vnd.shana.informed.package": {
    source: "iana",
    extensions: [
      "ipk"
    ]
  },
  "application/vnd.shootproof+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.shopkick+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.shp": {
    source: "iana"
  },
  "application/vnd.shx": {
    source: "iana"
  },
  "application/vnd.sigrok.session": {
    source: "iana"
  },
  "application/vnd.simtech-mindmapper": {
    source: "iana",
    extensions: [
      "twd",
      "twds"
    ]
  },
  "application/vnd.siren+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.smaf": {
    source: "iana",
    extensions: [
      "mmf"
    ]
  },
  "application/vnd.smart.notebook": {
    source: "iana"
  },
  "application/vnd.smart.teacher": {
    source: "iana",
    extensions: [
      "teacher"
    ]
  },
  "application/vnd.snesdev-page-table": {
    source: "iana"
  },
  "application/vnd.software602.filler.form+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "fo"
    ]
  },
  "application/vnd.software602.filler.form-xml-zip": {
    source: "iana"
  },
  "application/vnd.solent.sdkm+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "sdkm",
      "sdkd"
    ]
  },
  "application/vnd.spotfire.dxp": {
    source: "iana",
    extensions: [
      "dxp"
    ]
  },
  "application/vnd.spotfire.sfs": {
    source: "iana",
    extensions: [
      "sfs"
    ]
  },
  "application/vnd.sqlite3": {
    source: "iana"
  },
  "application/vnd.sss-cod": {
    source: "iana"
  },
  "application/vnd.sss-dtf": {
    source: "iana"
  },
  "application/vnd.sss-ntf": {
    source: "iana"
  },
  "application/vnd.stardivision.calc": {
    source: "apache",
    extensions: [
      "sdc"
    ]
  },
  "application/vnd.stardivision.draw": {
    source: "apache",
    extensions: [
      "sda"
    ]
  },
  "application/vnd.stardivision.impress": {
    source: "apache",
    extensions: [
      "sdd"
    ]
  },
  "application/vnd.stardivision.math": {
    source: "apache",
    extensions: [
      "smf"
    ]
  },
  "application/vnd.stardivision.writer": {
    source: "apache",
    extensions: [
      "sdw",
      "vor"
    ]
  },
  "application/vnd.stardivision.writer-global": {
    source: "apache",
    extensions: [
      "sgl"
    ]
  },
  "application/vnd.stepmania.package": {
    source: "iana",
    extensions: [
      "smzip"
    ]
  },
  "application/vnd.stepmania.stepchart": {
    source: "iana",
    extensions: [
      "sm"
    ]
  },
  "application/vnd.street-stream": {
    source: "iana"
  },
  "application/vnd.sun.wadl+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "wadl"
    ]
  },
  "application/vnd.sun.xml.calc": {
    source: "apache",
    extensions: [
      "sxc"
    ]
  },
  "application/vnd.sun.xml.calc.template": {
    source: "apache",
    extensions: [
      "stc"
    ]
  },
  "application/vnd.sun.xml.draw": {
    source: "apache",
    extensions: [
      "sxd"
    ]
  },
  "application/vnd.sun.xml.draw.template": {
    source: "apache",
    extensions: [
      "std"
    ]
  },
  "application/vnd.sun.xml.impress": {
    source: "apache",
    extensions: [
      "sxi"
    ]
  },
  "application/vnd.sun.xml.impress.template": {
    source: "apache",
    extensions: [
      "sti"
    ]
  },
  "application/vnd.sun.xml.math": {
    source: "apache",
    extensions: [
      "sxm"
    ]
  },
  "application/vnd.sun.xml.writer": {
    source: "apache",
    extensions: [
      "sxw"
    ]
  },
  "application/vnd.sun.xml.writer.global": {
    source: "apache",
    extensions: [
      "sxg"
    ]
  },
  "application/vnd.sun.xml.writer.template": {
    source: "apache",
    extensions: [
      "stw"
    ]
  },
  "application/vnd.sus-calendar": {
    source: "iana",
    extensions: [
      "sus",
      "susp"
    ]
  },
  "application/vnd.svd": {
    source: "iana",
    extensions: [
      "svd"
    ]
  },
  "application/vnd.swiftview-ics": {
    source: "iana"
  },
  "application/vnd.sycle+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.syft+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.symbian.install": {
    source: "apache",
    extensions: [
      "sis",
      "sisx"
    ]
  },
  "application/vnd.syncml+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: [
      "xsm"
    ]
  },
  "application/vnd.syncml.dm+wbxml": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "bdm"
    ]
  },
  "application/vnd.syncml.dm+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: [
      "xdm"
    ]
  },
  "application/vnd.syncml.dm.notification": {
    source: "iana"
  },
  "application/vnd.syncml.dmddf+wbxml": {
    source: "iana"
  },
  "application/vnd.syncml.dmddf+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: [
      "ddf"
    ]
  },
  "application/vnd.syncml.dmtnds+wbxml": {
    source: "iana"
  },
  "application/vnd.syncml.dmtnds+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/vnd.syncml.ds.notification": {
    source: "iana"
  },
  "application/vnd.tableschema+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.tao.intent-module-archive": {
    source: "iana",
    extensions: [
      "tao"
    ]
  },
  "application/vnd.tcpdump.pcap": {
    source: "iana",
    extensions: [
      "pcap",
      "cap",
      "dmp"
    ]
  },
  "application/vnd.think-cell.ppttc+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.tmd.mediaflex.api+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.tml": {
    source: "iana"
  },
  "application/vnd.tmobile-livetv": {
    source: "iana",
    extensions: [
      "tmo"
    ]
  },
  "application/vnd.tri.onesource": {
    source: "iana"
  },
  "application/vnd.trid.tpt": {
    source: "iana",
    extensions: [
      "tpt"
    ]
  },
  "application/vnd.triscape.mxs": {
    source: "iana",
    extensions: [
      "mxs"
    ]
  },
  "application/vnd.trueapp": {
    source: "iana",
    extensions: [
      "tra"
    ]
  },
  "application/vnd.truedoc": {
    source: "iana"
  },
  "application/vnd.ubisoft.webplayer": {
    source: "iana"
  },
  "application/vnd.ufdl": {
    source: "iana",
    extensions: [
      "ufd",
      "ufdl"
    ]
  },
  "application/vnd.uiq.theme": {
    source: "iana",
    extensions: [
      "utz"
    ]
  },
  "application/vnd.umajin": {
    source: "iana",
    extensions: [
      "umj"
    ]
  },
  "application/vnd.unity": {
    source: "iana",
    extensions: [
      "unityweb"
    ]
  },
  "application/vnd.uoml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "uoml"
    ]
  },
  "application/vnd.uplanet.alert": {
    source: "iana"
  },
  "application/vnd.uplanet.alert-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.bearer-choice": {
    source: "iana"
  },
  "application/vnd.uplanet.bearer-choice-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.cacheop": {
    source: "iana"
  },
  "application/vnd.uplanet.cacheop-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.channel": {
    source: "iana"
  },
  "application/vnd.uplanet.channel-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.list": {
    source: "iana"
  },
  "application/vnd.uplanet.list-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.listcmd": {
    source: "iana"
  },
  "application/vnd.uplanet.listcmd-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.signal": {
    source: "iana"
  },
  "application/vnd.uri-map": {
    source: "iana"
  },
  "application/vnd.valve.source.material": {
    source: "iana"
  },
  "application/vnd.vcx": {
    source: "iana",
    extensions: [
      "vcx"
    ]
  },
  "application/vnd.vd-study": {
    source: "iana"
  },
  "application/vnd.vectorworks": {
    source: "iana"
  },
  "application/vnd.vel+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.verimatrix.vcas": {
    source: "iana"
  },
  "application/vnd.veritone.aion+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.veryant.thin": {
    source: "iana"
  },
  "application/vnd.ves.encrypted": {
    source: "iana"
  },
  "application/vnd.vidsoft.vidconference": {
    source: "iana"
  },
  "application/vnd.visio": {
    source: "iana",
    extensions: [
      "vsd",
      "vst",
      "vss",
      "vsw"
    ]
  },
  "application/vnd.visionary": {
    source: "iana",
    extensions: [
      "vis"
    ]
  },
  "application/vnd.vividence.scriptfile": {
    source: "iana"
  },
  "application/vnd.vsf": {
    source: "iana",
    extensions: [
      "vsf"
    ]
  },
  "application/vnd.wap.sic": {
    source: "iana"
  },
  "application/vnd.wap.slc": {
    source: "iana"
  },
  "application/vnd.wap.wbxml": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "wbxml"
    ]
  },
  "application/vnd.wap.wmlc": {
    source: "iana",
    extensions: [
      "wmlc"
    ]
  },
  "application/vnd.wap.wmlscriptc": {
    source: "iana",
    extensions: [
      "wmlsc"
    ]
  },
  "application/vnd.webturbo": {
    source: "iana",
    extensions: [
      "wtb"
    ]
  },
  "application/vnd.wfa.dpp": {
    source: "iana"
  },
  "application/vnd.wfa.p2p": {
    source: "iana"
  },
  "application/vnd.wfa.wsc": {
    source: "iana"
  },
  "application/vnd.windows.devicepairing": {
    source: "iana"
  },
  "application/vnd.wmc": {
    source: "iana"
  },
  "application/vnd.wmf.bootstrap": {
    source: "iana"
  },
  "application/vnd.wolfram.mathematica": {
    source: "iana"
  },
  "application/vnd.wolfram.mathematica.package": {
    source: "iana"
  },
  "application/vnd.wolfram.player": {
    source: "iana",
    extensions: [
      "nbp"
    ]
  },
  "application/vnd.wordperfect": {
    source: "iana",
    extensions: [
      "wpd"
    ]
  },
  "application/vnd.wqd": {
    source: "iana",
    extensions: [
      "wqd"
    ]
  },
  "application/vnd.wrq-hp3000-labelled": {
    source: "iana"
  },
  "application/vnd.wt.stf": {
    source: "iana",
    extensions: [
      "stf"
    ]
  },
  "application/vnd.wv.csp+wbxml": {
    source: "iana"
  },
  "application/vnd.wv.csp+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.wv.ssp+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.xacml+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.xara": {
    source: "iana",
    extensions: [
      "xar"
    ]
  },
  "application/vnd.xfdl": {
    source: "iana",
    extensions: [
      "xfdl"
    ]
  },
  "application/vnd.xfdl.webform": {
    source: "iana"
  },
  "application/vnd.xmi+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.xmpie.cpkg": {
    source: "iana"
  },
  "application/vnd.xmpie.dpkg": {
    source: "iana"
  },
  "application/vnd.xmpie.plan": {
    source: "iana"
  },
  "application/vnd.xmpie.ppkg": {
    source: "iana"
  },
  "application/vnd.xmpie.xlim": {
    source: "iana"
  },
  "application/vnd.yamaha.hv-dic": {
    source: "iana",
    extensions: [
      "hvd"
    ]
  },
  "application/vnd.yamaha.hv-script": {
    source: "iana",
    extensions: [
      "hvs"
    ]
  },
  "application/vnd.yamaha.hv-voice": {
    source: "iana",
    extensions: [
      "hvp"
    ]
  },
  "application/vnd.yamaha.openscoreformat": {
    source: "iana",
    extensions: [
      "osf"
    ]
  },
  "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "osfpvg"
    ]
  },
  "application/vnd.yamaha.remote-setup": {
    source: "iana"
  },
  "application/vnd.yamaha.smaf-audio": {
    source: "iana",
    extensions: [
      "saf"
    ]
  },
  "application/vnd.yamaha.smaf-phrase": {
    source: "iana",
    extensions: [
      "spf"
    ]
  },
  "application/vnd.yamaha.through-ngn": {
    source: "iana"
  },
  "application/vnd.yamaha.tunnel-udpencap": {
    source: "iana"
  },
  "application/vnd.yaoweme": {
    source: "iana"
  },
  "application/vnd.yellowriver-custom-menu": {
    source: "iana",
    extensions: [
      "cmp"
    ]
  },
  "application/vnd.youtube.yt": {
    source: "iana"
  },
  "application/vnd.zul": {
    source: "iana",
    extensions: [
      "zir",
      "zirz"
    ]
  },
  "application/vnd.zzazz.deck+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "zaz"
    ]
  },
  "application/voicexml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "vxml"
    ]
  },
  "application/voucher-cms+json": {
    source: "iana",
    compressible: !0
  },
  "application/vq-rtcpxr": {
    source: "iana"
  },
  "application/wasm": {
    source: "iana",
    compressible: !0,
    extensions: [
      "wasm"
    ]
  },
  "application/watcherinfo+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "wif"
    ]
  },
  "application/webpush-options+json": {
    source: "iana",
    compressible: !0
  },
  "application/whoispp-query": {
    source: "iana"
  },
  "application/whoispp-response": {
    source: "iana"
  },
  "application/widget": {
    source: "iana",
    extensions: [
      "wgt"
    ]
  },
  "application/winhlp": {
    source: "apache",
    extensions: [
      "hlp"
    ]
  },
  "application/wita": {
    source: "iana"
  },
  "application/wordperfect5.1": {
    source: "iana"
  },
  "application/wsdl+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "wsdl"
    ]
  },
  "application/wspolicy+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "wspolicy"
    ]
  },
  "application/x-7z-compressed": {
    source: "apache",
    compressible: !1,
    extensions: [
      "7z"
    ]
  },
  "application/x-abiword": {
    source: "apache",
    extensions: [
      "abw"
    ]
  },
  "application/x-ace-compressed": {
    source: "apache",
    extensions: [
      "ace"
    ]
  },
  "application/x-amf": {
    source: "apache"
  },
  "application/x-apple-diskimage": {
    source: "apache",
    extensions: [
      "dmg"
    ]
  },
  "application/x-arj": {
    compressible: !1,
    extensions: [
      "arj"
    ]
  },
  "application/x-authorware-bin": {
    source: "apache",
    extensions: [
      "aab",
      "x32",
      "u32",
      "vox"
    ]
  },
  "application/x-authorware-map": {
    source: "apache",
    extensions: [
      "aam"
    ]
  },
  "application/x-authorware-seg": {
    source: "apache",
    extensions: [
      "aas"
    ]
  },
  "application/x-bcpio": {
    source: "apache",
    extensions: [
      "bcpio"
    ]
  },
  "application/x-bdoc": {
    compressible: !1,
    extensions: [
      "bdoc"
    ]
  },
  "application/x-bittorrent": {
    source: "apache",
    extensions: [
      "torrent"
    ]
  },
  "application/x-blorb": {
    source: "apache",
    extensions: [
      "blb",
      "blorb"
    ]
  },
  "application/x-bzip": {
    source: "apache",
    compressible: !1,
    extensions: [
      "bz"
    ]
  },
  "application/x-bzip2": {
    source: "apache",
    compressible: !1,
    extensions: [
      "bz2",
      "boz"
    ]
  },
  "application/x-cbr": {
    source: "apache",
    extensions: [
      "cbr",
      "cba",
      "cbt",
      "cbz",
      "cb7"
    ]
  },
  "application/x-cdlink": {
    source: "apache",
    extensions: [
      "vcd"
    ]
  },
  "application/x-cfs-compressed": {
    source: "apache",
    extensions: [
      "cfs"
    ]
  },
  "application/x-chat": {
    source: "apache",
    extensions: [
      "chat"
    ]
  },
  "application/x-chess-pgn": {
    source: "apache",
    extensions: [
      "pgn"
    ]
  },
  "application/x-chrome-extension": {
    extensions: [
      "crx"
    ]
  },
  "application/x-cocoa": {
    source: "nginx",
    extensions: [
      "cco"
    ]
  },
  "application/x-compress": {
    source: "apache"
  },
  "application/x-conference": {
    source: "apache",
    extensions: [
      "nsc"
    ]
  },
  "application/x-cpio": {
    source: "apache",
    extensions: [
      "cpio"
    ]
  },
  "application/x-csh": {
    source: "apache",
    extensions: [
      "csh"
    ]
  },
  "application/x-deb": {
    compressible: !1
  },
  "application/x-debian-package": {
    source: "apache",
    extensions: [
      "deb",
      "udeb"
    ]
  },
  "application/x-dgc-compressed": {
    source: "apache",
    extensions: [
      "dgc"
    ]
  },
  "application/x-director": {
    source: "apache",
    extensions: [
      "dir",
      "dcr",
      "dxr",
      "cst",
      "cct",
      "cxt",
      "w3d",
      "fgd",
      "swa"
    ]
  },
  "application/x-doom": {
    source: "apache",
    extensions: [
      "wad"
    ]
  },
  "application/x-dtbncx+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "ncx"
    ]
  },
  "application/x-dtbook+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "dtb"
    ]
  },
  "application/x-dtbresource+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "res"
    ]
  },
  "application/x-dvi": {
    source: "apache",
    compressible: !1,
    extensions: [
      "dvi"
    ]
  },
  "application/x-envoy": {
    source: "apache",
    extensions: [
      "evy"
    ]
  },
  "application/x-eva": {
    source: "apache",
    extensions: [
      "eva"
    ]
  },
  "application/x-font-bdf": {
    source: "apache",
    extensions: [
      "bdf"
    ]
  },
  "application/x-font-dos": {
    source: "apache"
  },
  "application/x-font-framemaker": {
    source: "apache"
  },
  "application/x-font-ghostscript": {
    source: "apache",
    extensions: [
      "gsf"
    ]
  },
  "application/x-font-libgrx": {
    source: "apache"
  },
  "application/x-font-linux-psf": {
    source: "apache",
    extensions: [
      "psf"
    ]
  },
  "application/x-font-pcf": {
    source: "apache",
    extensions: [
      "pcf"
    ]
  },
  "application/x-font-snf": {
    source: "apache",
    extensions: [
      "snf"
    ]
  },
  "application/x-font-speedo": {
    source: "apache"
  },
  "application/x-font-sunos-news": {
    source: "apache"
  },
  "application/x-font-type1": {
    source: "apache",
    extensions: [
      "pfa",
      "pfb",
      "pfm",
      "afm"
    ]
  },
  "application/x-font-vfont": {
    source: "apache"
  },
  "application/x-freearc": {
    source: "apache",
    extensions: [
      "arc"
    ]
  },
  "application/x-futuresplash": {
    source: "apache",
    extensions: [
      "spl"
    ]
  },
  "application/x-gca-compressed": {
    source: "apache",
    extensions: [
      "gca"
    ]
  },
  "application/x-glulx": {
    source: "apache",
    extensions: [
      "ulx"
    ]
  },
  "application/x-gnumeric": {
    source: "apache",
    extensions: [
      "gnumeric"
    ]
  },
  "application/x-gramps-xml": {
    source: "apache",
    extensions: [
      "gramps"
    ]
  },
  "application/x-gtar": {
    source: "apache",
    extensions: [
      "gtar"
    ]
  },
  "application/x-gzip": {
    source: "apache"
  },
  "application/x-hdf": {
    source: "apache",
    extensions: [
      "hdf"
    ]
  },
  "application/x-httpd-php": {
    compressible: !0,
    extensions: [
      "php"
    ]
  },
  "application/x-install-instructions": {
    source: "apache",
    extensions: [
      "install"
    ]
  },
  "application/x-iso9660-image": {
    source: "apache",
    extensions: [
      "iso"
    ]
  },
  "application/x-iwork-keynote-sffkey": {
    extensions: [
      "key"
    ]
  },
  "application/x-iwork-numbers-sffnumbers": {
    extensions: [
      "numbers"
    ]
  },
  "application/x-iwork-pages-sffpages": {
    extensions: [
      "pages"
    ]
  },
  "application/x-java-archive-diff": {
    source: "nginx",
    extensions: [
      "jardiff"
    ]
  },
  "application/x-java-jnlp-file": {
    source: "apache",
    compressible: !1,
    extensions: [
      "jnlp"
    ]
  },
  "application/x-javascript": {
    compressible: !0
  },
  "application/x-keepass2": {
    extensions: [
      "kdbx"
    ]
  },
  "application/x-latex": {
    source: "apache",
    compressible: !1,
    extensions: [
      "latex"
    ]
  },
  "application/x-lua-bytecode": {
    extensions: [
      "luac"
    ]
  },
  "application/x-lzh-compressed": {
    source: "apache",
    extensions: [
      "lzh",
      "lha"
    ]
  },
  "application/x-makeself": {
    source: "nginx",
    extensions: [
      "run"
    ]
  },
  "application/x-mie": {
    source: "apache",
    extensions: [
      "mie"
    ]
  },
  "application/x-mobipocket-ebook": {
    source: "apache",
    extensions: [
      "prc",
      "mobi"
    ]
  },
  "application/x-mpegurl": {
    compressible: !1
  },
  "application/x-ms-application": {
    source: "apache",
    extensions: [
      "application"
    ]
  },
  "application/x-ms-shortcut": {
    source: "apache",
    extensions: [
      "lnk"
    ]
  },
  "application/x-ms-wmd": {
    source: "apache",
    extensions: [
      "wmd"
    ]
  },
  "application/x-ms-wmz": {
    source: "apache",
    extensions: [
      "wmz"
    ]
  },
  "application/x-ms-xbap": {
    source: "apache",
    extensions: [
      "xbap"
    ]
  },
  "application/x-msaccess": {
    source: "apache",
    extensions: [
      "mdb"
    ]
  },
  "application/x-msbinder": {
    source: "apache",
    extensions: [
      "obd"
    ]
  },
  "application/x-mscardfile": {
    source: "apache",
    extensions: [
      "crd"
    ]
  },
  "application/x-msclip": {
    source: "apache",
    extensions: [
      "clp"
    ]
  },
  "application/x-msdos-program": {
    extensions: [
      "exe"
    ]
  },
  "application/x-msdownload": {
    source: "apache",
    extensions: [
      "exe",
      "dll",
      "com",
      "bat",
      "msi"
    ]
  },
  "application/x-msmediaview": {
    source: "apache",
    extensions: [
      "mvb",
      "m13",
      "m14"
    ]
  },
  "application/x-msmetafile": {
    source: "apache",
    extensions: [
      "wmf",
      "wmz",
      "emf",
      "emz"
    ]
  },
  "application/x-msmoney": {
    source: "apache",
    extensions: [
      "mny"
    ]
  },
  "application/x-mspublisher": {
    source: "apache",
    extensions: [
      "pub"
    ]
  },
  "application/x-msschedule": {
    source: "apache",
    extensions: [
      "scd"
    ]
  },
  "application/x-msterminal": {
    source: "apache",
    extensions: [
      "trm"
    ]
  },
  "application/x-mswrite": {
    source: "apache",
    extensions: [
      "wri"
    ]
  },
  "application/x-netcdf": {
    source: "apache",
    extensions: [
      "nc",
      "cdf"
    ]
  },
  "application/x-ns-proxy-autoconfig": {
    compressible: !0,
    extensions: [
      "pac"
    ]
  },
  "application/x-nzb": {
    source: "apache",
    extensions: [
      "nzb"
    ]
  },
  "application/x-perl": {
    source: "nginx",
    extensions: [
      "pl",
      "pm"
    ]
  },
  "application/x-pilot": {
    source: "nginx",
    extensions: [
      "prc",
      "pdb"
    ]
  },
  "application/x-pkcs12": {
    source: "apache",
    compressible: !1,
    extensions: [
      "p12",
      "pfx"
    ]
  },
  "application/x-pkcs7-certificates": {
    source: "apache",
    extensions: [
      "p7b",
      "spc"
    ]
  },
  "application/x-pkcs7-certreqresp": {
    source: "apache",
    extensions: [
      "p7r"
    ]
  },
  "application/x-pki-message": {
    source: "iana"
  },
  "application/x-rar-compressed": {
    source: "apache",
    compressible: !1,
    extensions: [
      "rar"
    ]
  },
  "application/x-redhat-package-manager": {
    source: "nginx",
    extensions: [
      "rpm"
    ]
  },
  "application/x-research-info-systems": {
    source: "apache",
    extensions: [
      "ris"
    ]
  },
  "application/x-sea": {
    source: "nginx",
    extensions: [
      "sea"
    ]
  },
  "application/x-sh": {
    source: "apache",
    compressible: !0,
    extensions: [
      "sh"
    ]
  },
  "application/x-shar": {
    source: "apache",
    extensions: [
      "shar"
    ]
  },
  "application/x-shockwave-flash": {
    source: "apache",
    compressible: !1,
    extensions: [
      "swf"
    ]
  },
  "application/x-silverlight-app": {
    source: "apache",
    extensions: [
      "xap"
    ]
  },
  "application/x-sql": {
    source: "apache",
    extensions: [
      "sql"
    ]
  },
  "application/x-stuffit": {
    source: "apache",
    compressible: !1,
    extensions: [
      "sit"
    ]
  },
  "application/x-stuffitx": {
    source: "apache",
    extensions: [
      "sitx"
    ]
  },
  "application/x-subrip": {
    source: "apache",
    extensions: [
      "srt"
    ]
  },
  "application/x-sv4cpio": {
    source: "apache",
    extensions: [
      "sv4cpio"
    ]
  },
  "application/x-sv4crc": {
    source: "apache",
    extensions: [
      "sv4crc"
    ]
  },
  "application/x-t3vm-image": {
    source: "apache",
    extensions: [
      "t3"
    ]
  },
  "application/x-tads": {
    source: "apache",
    extensions: [
      "gam"
    ]
  },
  "application/x-tar": {
    source: "apache",
    compressible: !0,
    extensions: [
      "tar"
    ]
  },
  "application/x-tcl": {
    source: "apache",
    extensions: [
      "tcl",
      "tk"
    ]
  },
  "application/x-tex": {
    source: "apache",
    extensions: [
      "tex"
    ]
  },
  "application/x-tex-tfm": {
    source: "apache",
    extensions: [
      "tfm"
    ]
  },
  "application/x-texinfo": {
    source: "apache",
    extensions: [
      "texinfo",
      "texi"
    ]
  },
  "application/x-tgif": {
    source: "apache",
    extensions: [
      "obj"
    ]
  },
  "application/x-ustar": {
    source: "apache",
    extensions: [
      "ustar"
    ]
  },
  "application/x-virtualbox-hdd": {
    compressible: !0,
    extensions: [
      "hdd"
    ]
  },
  "application/x-virtualbox-ova": {
    compressible: !0,
    extensions: [
      "ova"
    ]
  },
  "application/x-virtualbox-ovf": {
    compressible: !0,
    extensions: [
      "ovf"
    ]
  },
  "application/x-virtualbox-vbox": {
    compressible: !0,
    extensions: [
      "vbox"
    ]
  },
  "application/x-virtualbox-vbox-extpack": {
    compressible: !1,
    extensions: [
      "vbox-extpack"
    ]
  },
  "application/x-virtualbox-vdi": {
    compressible: !0,
    extensions: [
      "vdi"
    ]
  },
  "application/x-virtualbox-vhd": {
    compressible: !0,
    extensions: [
      "vhd"
    ]
  },
  "application/x-virtualbox-vmdk": {
    compressible: !0,
    extensions: [
      "vmdk"
    ]
  },
  "application/x-wais-source": {
    source: "apache",
    extensions: [
      "src"
    ]
  },
  "application/x-web-app-manifest+json": {
    compressible: !0,
    extensions: [
      "webapp"
    ]
  },
  "application/x-www-form-urlencoded": {
    source: "iana",
    compressible: !0
  },
  "application/x-x509-ca-cert": {
    source: "iana",
    extensions: [
      "der",
      "crt",
      "pem"
    ]
  },
  "application/x-x509-ca-ra-cert": {
    source: "iana"
  },
  "application/x-x509-next-ca-cert": {
    source: "iana"
  },
  "application/x-xfig": {
    source: "apache",
    extensions: [
      "fig"
    ]
  },
  "application/x-xliff+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "xlf"
    ]
  },
  "application/x-xpinstall": {
    source: "apache",
    compressible: !1,
    extensions: [
      "xpi"
    ]
  },
  "application/x-xz": {
    source: "apache",
    extensions: [
      "xz"
    ]
  },
  "application/x-zmachine": {
    source: "apache",
    extensions: [
      "z1",
      "z2",
      "z3",
      "z4",
      "z5",
      "z6",
      "z7",
      "z8"
    ]
  },
  "application/x400-bp": {
    source: "iana"
  },
  "application/xacml+xml": {
    source: "iana",
    compressible: !0
  },
  "application/xaml+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "xaml"
    ]
  },
  "application/xcap-att+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xav"
    ]
  },
  "application/xcap-caps+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xca"
    ]
  },
  "application/xcap-diff+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xdf"
    ]
  },
  "application/xcap-el+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xel"
    ]
  },
  "application/xcap-error+xml": {
    source: "iana",
    compressible: !0
  },
  "application/xcap-ns+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xns"
    ]
  },
  "application/xcon-conference-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/xcon-conference-info-diff+xml": {
    source: "iana",
    compressible: !0
  },
  "application/xenc+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xenc"
    ]
  },
  "application/xhtml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xhtml",
      "xht"
    ]
  },
  "application/xhtml-voice+xml": {
    source: "apache",
    compressible: !0
  },
  "application/xliff+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xlf"
    ]
  },
  "application/xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xml",
      "xsl",
      "xsd",
      "rng"
    ]
  },
  "application/xml-dtd": {
    source: "iana",
    compressible: !0,
    extensions: [
      "dtd"
    ]
  },
  "application/xml-external-parsed-entity": {
    source: "iana"
  },
  "application/xml-patch+xml": {
    source: "iana",
    compressible: !0
  },
  "application/xmpp+xml": {
    source: "iana",
    compressible: !0
  },
  "application/xop+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xop"
    ]
  },
  "application/xproc+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "xpl"
    ]
  },
  "application/xslt+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xsl",
      "xslt"
    ]
  },
  "application/xspf+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "xspf"
    ]
  },
  "application/xv+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mxml",
      "xhvml",
      "xvml",
      "xvm"
    ]
  },
  "application/yang": {
    source: "iana",
    extensions: [
      "yang"
    ]
  },
  "application/yang-data+json": {
    source: "iana",
    compressible: !0
  },
  "application/yang-data+xml": {
    source: "iana",
    compressible: !0
  },
  "application/yang-patch+json": {
    source: "iana",
    compressible: !0
  },
  "application/yang-patch+xml": {
    source: "iana",
    compressible: !0
  },
  "application/yin+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "yin"
    ]
  },
  "application/zip": {
    source: "iana",
    compressible: !1,
    extensions: [
      "zip"
    ]
  },
  "application/zlib": {
    source: "iana"
  },
  "application/zstd": {
    source: "iana"
  },
  "audio/1d-interleaved-parityfec": {
    source: "iana"
  },
  "audio/32kadpcm": {
    source: "iana"
  },
  "audio/3gpp": {
    source: "iana",
    compressible: !1,
    extensions: [
      "3gpp"
    ]
  },
  "audio/3gpp2": {
    source: "iana"
  },
  "audio/aac": {
    source: "iana"
  },
  "audio/ac3": {
    source: "iana"
  },
  "audio/adpcm": {
    source: "apache",
    extensions: [
      "adp"
    ]
  },
  "audio/amr": {
    source: "iana",
    extensions: [
      "amr"
    ]
  },
  "audio/amr-wb": {
    source: "iana"
  },
  "audio/amr-wb+": {
    source: "iana"
  },
  "audio/aptx": {
    source: "iana"
  },
  "audio/asc": {
    source: "iana"
  },
  "audio/atrac-advanced-lossless": {
    source: "iana"
  },
  "audio/atrac-x": {
    source: "iana"
  },
  "audio/atrac3": {
    source: "iana"
  },
  "audio/basic": {
    source: "iana",
    compressible: !1,
    extensions: [
      "au",
      "snd"
    ]
  },
  "audio/bv16": {
    source: "iana"
  },
  "audio/bv32": {
    source: "iana"
  },
  "audio/clearmode": {
    source: "iana"
  },
  "audio/cn": {
    source: "iana"
  },
  "audio/dat12": {
    source: "iana"
  },
  "audio/dls": {
    source: "iana"
  },
  "audio/dsr-es201108": {
    source: "iana"
  },
  "audio/dsr-es202050": {
    source: "iana"
  },
  "audio/dsr-es202211": {
    source: "iana"
  },
  "audio/dsr-es202212": {
    source: "iana"
  },
  "audio/dv": {
    source: "iana"
  },
  "audio/dvi4": {
    source: "iana"
  },
  "audio/eac3": {
    source: "iana"
  },
  "audio/encaprtp": {
    source: "iana"
  },
  "audio/evrc": {
    source: "iana"
  },
  "audio/evrc-qcp": {
    source: "iana"
  },
  "audio/evrc0": {
    source: "iana"
  },
  "audio/evrc1": {
    source: "iana"
  },
  "audio/evrcb": {
    source: "iana"
  },
  "audio/evrcb0": {
    source: "iana"
  },
  "audio/evrcb1": {
    source: "iana"
  },
  "audio/evrcnw": {
    source: "iana"
  },
  "audio/evrcnw0": {
    source: "iana"
  },
  "audio/evrcnw1": {
    source: "iana"
  },
  "audio/evrcwb": {
    source: "iana"
  },
  "audio/evrcwb0": {
    source: "iana"
  },
  "audio/evrcwb1": {
    source: "iana"
  },
  "audio/evs": {
    source: "iana"
  },
  "audio/flexfec": {
    source: "iana"
  },
  "audio/fwdred": {
    source: "iana"
  },
  "audio/g711-0": {
    source: "iana"
  },
  "audio/g719": {
    source: "iana"
  },
  "audio/g722": {
    source: "iana"
  },
  "audio/g7221": {
    source: "iana"
  },
  "audio/g723": {
    source: "iana"
  },
  "audio/g726-16": {
    source: "iana"
  },
  "audio/g726-24": {
    source: "iana"
  },
  "audio/g726-32": {
    source: "iana"
  },
  "audio/g726-40": {
    source: "iana"
  },
  "audio/g728": {
    source: "iana"
  },
  "audio/g729": {
    source: "iana"
  },
  "audio/g7291": {
    source: "iana"
  },
  "audio/g729d": {
    source: "iana"
  },
  "audio/g729e": {
    source: "iana"
  },
  "audio/gsm": {
    source: "iana"
  },
  "audio/gsm-efr": {
    source: "iana"
  },
  "audio/gsm-hr-08": {
    source: "iana"
  },
  "audio/ilbc": {
    source: "iana"
  },
  "audio/ip-mr_v2.5": {
    source: "iana"
  },
  "audio/isac": {
    source: "apache"
  },
  "audio/l16": {
    source: "iana"
  },
  "audio/l20": {
    source: "iana"
  },
  "audio/l24": {
    source: "iana",
    compressible: !1
  },
  "audio/l8": {
    source: "iana"
  },
  "audio/lpc": {
    source: "iana"
  },
  "audio/melp": {
    source: "iana"
  },
  "audio/melp1200": {
    source: "iana"
  },
  "audio/melp2400": {
    source: "iana"
  },
  "audio/melp600": {
    source: "iana"
  },
  "audio/mhas": {
    source: "iana"
  },
  "audio/midi": {
    source: "apache",
    extensions: [
      "mid",
      "midi",
      "kar",
      "rmi"
    ]
  },
  "audio/mobile-xmf": {
    source: "iana",
    extensions: [
      "mxmf"
    ]
  },
  "audio/mp3": {
    compressible: !1,
    extensions: [
      "mp3"
    ]
  },
  "audio/mp4": {
    source: "iana",
    compressible: !1,
    extensions: [
      "m4a",
      "mp4a"
    ]
  },
  "audio/mp4a-latm": {
    source: "iana"
  },
  "audio/mpa": {
    source: "iana"
  },
  "audio/mpa-robust": {
    source: "iana"
  },
  "audio/mpeg": {
    source: "iana",
    compressible: !1,
    extensions: [
      "mpga",
      "mp2",
      "mp2a",
      "mp3",
      "m2a",
      "m3a"
    ]
  },
  "audio/mpeg4-generic": {
    source: "iana"
  },
  "audio/musepack": {
    source: "apache"
  },
  "audio/ogg": {
    source: "iana",
    compressible: !1,
    extensions: [
      "oga",
      "ogg",
      "spx",
      "opus"
    ]
  },
  "audio/opus": {
    source: "iana"
  },
  "audio/parityfec": {
    source: "iana"
  },
  "audio/pcma": {
    source: "iana"
  },
  "audio/pcma-wb": {
    source: "iana"
  },
  "audio/pcmu": {
    source: "iana"
  },
  "audio/pcmu-wb": {
    source: "iana"
  },
  "audio/prs.sid": {
    source: "iana"
  },
  "audio/qcelp": {
    source: "iana"
  },
  "audio/raptorfec": {
    source: "iana"
  },
  "audio/red": {
    source: "iana"
  },
  "audio/rtp-enc-aescm128": {
    source: "iana"
  },
  "audio/rtp-midi": {
    source: "iana"
  },
  "audio/rtploopback": {
    source: "iana"
  },
  "audio/rtx": {
    source: "iana"
  },
  "audio/s3m": {
    source: "apache",
    extensions: [
      "s3m"
    ]
  },
  "audio/scip": {
    source: "iana"
  },
  "audio/silk": {
    source: "apache",
    extensions: [
      "sil"
    ]
  },
  "audio/smv": {
    source: "iana"
  },
  "audio/smv-qcp": {
    source: "iana"
  },
  "audio/smv0": {
    source: "iana"
  },
  "audio/sofa": {
    source: "iana"
  },
  "audio/sp-midi": {
    source: "iana"
  },
  "audio/speex": {
    source: "iana"
  },
  "audio/t140c": {
    source: "iana"
  },
  "audio/t38": {
    source: "iana"
  },
  "audio/telephone-event": {
    source: "iana"
  },
  "audio/tetra_acelp": {
    source: "iana"
  },
  "audio/tetra_acelp_bb": {
    source: "iana"
  },
  "audio/tone": {
    source: "iana"
  },
  "audio/tsvcis": {
    source: "iana"
  },
  "audio/uemclip": {
    source: "iana"
  },
  "audio/ulpfec": {
    source: "iana"
  },
  "audio/usac": {
    source: "iana"
  },
  "audio/vdvi": {
    source: "iana"
  },
  "audio/vmr-wb": {
    source: "iana"
  },
  "audio/vnd.3gpp.iufp": {
    source: "iana"
  },
  "audio/vnd.4sb": {
    source: "iana"
  },
  "audio/vnd.audiokoz": {
    source: "iana"
  },
  "audio/vnd.celp": {
    source: "iana"
  },
  "audio/vnd.cisco.nse": {
    source: "iana"
  },
  "audio/vnd.cmles.radio-events": {
    source: "iana"
  },
  "audio/vnd.cns.anp1": {
    source: "iana"
  },
  "audio/vnd.cns.inf1": {
    source: "iana"
  },
  "audio/vnd.dece.audio": {
    source: "iana",
    extensions: [
      "uva",
      "uvva"
    ]
  },
  "audio/vnd.digital-winds": {
    source: "iana",
    extensions: [
      "eol"
    ]
  },
  "audio/vnd.dlna.adts": {
    source: "iana"
  },
  "audio/vnd.dolby.heaac.1": {
    source: "iana"
  },
  "audio/vnd.dolby.heaac.2": {
    source: "iana"
  },
  "audio/vnd.dolby.mlp": {
    source: "iana"
  },
  "audio/vnd.dolby.mps": {
    source: "iana"
  },
  "audio/vnd.dolby.pl2": {
    source: "iana"
  },
  "audio/vnd.dolby.pl2x": {
    source: "iana"
  },
  "audio/vnd.dolby.pl2z": {
    source: "iana"
  },
  "audio/vnd.dolby.pulse.1": {
    source: "iana"
  },
  "audio/vnd.dra": {
    source: "iana",
    extensions: [
      "dra"
    ]
  },
  "audio/vnd.dts": {
    source: "iana",
    extensions: [
      "dts"
    ]
  },
  "audio/vnd.dts.hd": {
    source: "iana",
    extensions: [
      "dtshd"
    ]
  },
  "audio/vnd.dts.uhd": {
    source: "iana"
  },
  "audio/vnd.dvb.file": {
    source: "iana"
  },
  "audio/vnd.everad.plj": {
    source: "iana"
  },
  "audio/vnd.hns.audio": {
    source: "iana"
  },
  "audio/vnd.lucent.voice": {
    source: "iana",
    extensions: [
      "lvp"
    ]
  },
  "audio/vnd.ms-playready.media.pya": {
    source: "iana",
    extensions: [
      "pya"
    ]
  },
  "audio/vnd.nokia.mobile-xmf": {
    source: "iana"
  },
  "audio/vnd.nortel.vbk": {
    source: "iana"
  },
  "audio/vnd.nuera.ecelp4800": {
    source: "iana",
    extensions: [
      "ecelp4800"
    ]
  },
  "audio/vnd.nuera.ecelp7470": {
    source: "iana",
    extensions: [
      "ecelp7470"
    ]
  },
  "audio/vnd.nuera.ecelp9600": {
    source: "iana",
    extensions: [
      "ecelp9600"
    ]
  },
  "audio/vnd.octel.sbc": {
    source: "iana"
  },
  "audio/vnd.presonus.multitrack": {
    source: "iana"
  },
  "audio/vnd.qcelp": {
    source: "iana"
  },
  "audio/vnd.rhetorex.32kadpcm": {
    source: "iana"
  },
  "audio/vnd.rip": {
    source: "iana",
    extensions: [
      "rip"
    ]
  },
  "audio/vnd.rn-realaudio": {
    compressible: !1
  },
  "audio/vnd.sealedmedia.softseal.mpeg": {
    source: "iana"
  },
  "audio/vnd.vmx.cvsd": {
    source: "iana"
  },
  "audio/vnd.wave": {
    compressible: !1
  },
  "audio/vorbis": {
    source: "iana",
    compressible: !1
  },
  "audio/vorbis-config": {
    source: "iana"
  },
  "audio/wav": {
    compressible: !1,
    extensions: [
      "wav"
    ]
  },
  "audio/wave": {
    compressible: !1,
    extensions: [
      "wav"
    ]
  },
  "audio/webm": {
    source: "apache",
    compressible: !1,
    extensions: [
      "weba"
    ]
  },
  "audio/x-aac": {
    source: "apache",
    compressible: !1,
    extensions: [
      "aac"
    ]
  },
  "audio/x-aiff": {
    source: "apache",
    extensions: [
      "aif",
      "aiff",
      "aifc"
    ]
  },
  "audio/x-caf": {
    source: "apache",
    compressible: !1,
    extensions: [
      "caf"
    ]
  },
  "audio/x-flac": {
    source: "apache",
    extensions: [
      "flac"
    ]
  },
  "audio/x-m4a": {
    source: "nginx",
    extensions: [
      "m4a"
    ]
  },
  "audio/x-matroska": {
    source: "apache",
    extensions: [
      "mka"
    ]
  },
  "audio/x-mpegurl": {
    source: "apache",
    extensions: [
      "m3u"
    ]
  },
  "audio/x-ms-wax": {
    source: "apache",
    extensions: [
      "wax"
    ]
  },
  "audio/x-ms-wma": {
    source: "apache",
    extensions: [
      "wma"
    ]
  },
  "audio/x-pn-realaudio": {
    source: "apache",
    extensions: [
      "ram",
      "ra"
    ]
  },
  "audio/x-pn-realaudio-plugin": {
    source: "apache",
    extensions: [
      "rmp"
    ]
  },
  "audio/x-realaudio": {
    source: "nginx",
    extensions: [
      "ra"
    ]
  },
  "audio/x-tta": {
    source: "apache"
  },
  "audio/x-wav": {
    source: "apache",
    extensions: [
      "wav"
    ]
  },
  "audio/xm": {
    source: "apache",
    extensions: [
      "xm"
    ]
  },
  "chemical/x-cdx": {
    source: "apache",
    extensions: [
      "cdx"
    ]
  },
  "chemical/x-cif": {
    source: "apache",
    extensions: [
      "cif"
    ]
  },
  "chemical/x-cmdf": {
    source: "apache",
    extensions: [
      "cmdf"
    ]
  },
  "chemical/x-cml": {
    source: "apache",
    extensions: [
      "cml"
    ]
  },
  "chemical/x-csml": {
    source: "apache",
    extensions: [
      "csml"
    ]
  },
  "chemical/x-pdb": {
    source: "apache"
  },
  "chemical/x-xyz": {
    source: "apache",
    extensions: [
      "xyz"
    ]
  },
  "font/collection": {
    source: "iana",
    extensions: [
      "ttc"
    ]
  },
  "font/otf": {
    source: "iana",
    compressible: !0,
    extensions: [
      "otf"
    ]
  },
  "font/sfnt": {
    source: "iana"
  },
  "font/ttf": {
    source: "iana",
    compressible: !0,
    extensions: [
      "ttf"
    ]
  },
  "font/woff": {
    source: "iana",
    extensions: [
      "woff"
    ]
  },
  "font/woff2": {
    source: "iana",
    extensions: [
      "woff2"
    ]
  },
  "image/aces": {
    source: "iana",
    extensions: [
      "exr"
    ]
  },
  "image/apng": {
    compressible: !1,
    extensions: [
      "apng"
    ]
  },
  "image/avci": {
    source: "iana",
    extensions: [
      "avci"
    ]
  },
  "image/avcs": {
    source: "iana",
    extensions: [
      "avcs"
    ]
  },
  "image/avif": {
    source: "iana",
    compressible: !1,
    extensions: [
      "avif"
    ]
  },
  "image/bmp": {
    source: "iana",
    compressible: !0,
    extensions: [
      "bmp"
    ]
  },
  "image/cgm": {
    source: "iana",
    extensions: [
      "cgm"
    ]
  },
  "image/dicom-rle": {
    source: "iana",
    extensions: [
      "drle"
    ]
  },
  "image/emf": {
    source: "iana",
    extensions: [
      "emf"
    ]
  },
  "image/fits": {
    source: "iana",
    extensions: [
      "fits"
    ]
  },
  "image/g3fax": {
    source: "iana",
    extensions: [
      "g3"
    ]
  },
  "image/gif": {
    source: "iana",
    compressible: !1,
    extensions: [
      "gif"
    ]
  },
  "image/heic": {
    source: "iana",
    extensions: [
      "heic"
    ]
  },
  "image/heic-sequence": {
    source: "iana",
    extensions: [
      "heics"
    ]
  },
  "image/heif": {
    source: "iana",
    extensions: [
      "heif"
    ]
  },
  "image/heif-sequence": {
    source: "iana",
    extensions: [
      "heifs"
    ]
  },
  "image/hej2k": {
    source: "iana",
    extensions: [
      "hej2"
    ]
  },
  "image/hsj2": {
    source: "iana",
    extensions: [
      "hsj2"
    ]
  },
  "image/ief": {
    source: "iana",
    extensions: [
      "ief"
    ]
  },
  "image/jls": {
    source: "iana",
    extensions: [
      "jls"
    ]
  },
  "image/jp2": {
    source: "iana",
    compressible: !1,
    extensions: [
      "jp2",
      "jpg2"
    ]
  },
  "image/jpeg": {
    source: "iana",
    compressible: !1,
    extensions: [
      "jpeg",
      "jpg",
      "jpe"
    ]
  },
  "image/jph": {
    source: "iana",
    extensions: [
      "jph"
    ]
  },
  "image/jphc": {
    source: "iana",
    extensions: [
      "jhc"
    ]
  },
  "image/jpm": {
    source: "iana",
    compressible: !1,
    extensions: [
      "jpm"
    ]
  },
  "image/jpx": {
    source: "iana",
    compressible: !1,
    extensions: [
      "jpx",
      "jpf"
    ]
  },
  "image/jxr": {
    source: "iana",
    extensions: [
      "jxr"
    ]
  },
  "image/jxra": {
    source: "iana",
    extensions: [
      "jxra"
    ]
  },
  "image/jxrs": {
    source: "iana",
    extensions: [
      "jxrs"
    ]
  },
  "image/jxs": {
    source: "iana",
    extensions: [
      "jxs"
    ]
  },
  "image/jxsc": {
    source: "iana",
    extensions: [
      "jxsc"
    ]
  },
  "image/jxsi": {
    source: "iana",
    extensions: [
      "jxsi"
    ]
  },
  "image/jxss": {
    source: "iana",
    extensions: [
      "jxss"
    ]
  },
  "image/ktx": {
    source: "iana",
    extensions: [
      "ktx"
    ]
  },
  "image/ktx2": {
    source: "iana",
    extensions: [
      "ktx2"
    ]
  },
  "image/naplps": {
    source: "iana"
  },
  "image/pjpeg": {
    compressible: !1
  },
  "image/png": {
    source: "iana",
    compressible: !1,
    extensions: [
      "png"
    ]
  },
  "image/prs.btif": {
    source: "iana",
    extensions: [
      "btif"
    ]
  },
  "image/prs.pti": {
    source: "iana",
    extensions: [
      "pti"
    ]
  },
  "image/pwg-raster": {
    source: "iana"
  },
  "image/sgi": {
    source: "apache",
    extensions: [
      "sgi"
    ]
  },
  "image/svg+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "svg",
      "svgz"
    ]
  },
  "image/t38": {
    source: "iana",
    extensions: [
      "t38"
    ]
  },
  "image/tiff": {
    source: "iana",
    compressible: !1,
    extensions: [
      "tif",
      "tiff"
    ]
  },
  "image/tiff-fx": {
    source: "iana",
    extensions: [
      "tfx"
    ]
  },
  "image/vnd.adobe.photoshop": {
    source: "iana",
    compressible: !0,
    extensions: [
      "psd"
    ]
  },
  "image/vnd.airzip.accelerator.azv": {
    source: "iana",
    extensions: [
      "azv"
    ]
  },
  "image/vnd.cns.inf2": {
    source: "iana"
  },
  "image/vnd.dece.graphic": {
    source: "iana",
    extensions: [
      "uvi",
      "uvvi",
      "uvg",
      "uvvg"
    ]
  },
  "image/vnd.djvu": {
    source: "iana",
    extensions: [
      "djvu",
      "djv"
    ]
  },
  "image/vnd.dvb.subtitle": {
    source: "iana",
    extensions: [
      "sub"
    ]
  },
  "image/vnd.dwg": {
    source: "iana",
    extensions: [
      "dwg"
    ]
  },
  "image/vnd.dxf": {
    source: "iana",
    extensions: [
      "dxf"
    ]
  },
  "image/vnd.fastbidsheet": {
    source: "iana",
    extensions: [
      "fbs"
    ]
  },
  "image/vnd.fpx": {
    source: "iana",
    extensions: [
      "fpx"
    ]
  },
  "image/vnd.fst": {
    source: "iana",
    extensions: [
      "fst"
    ]
  },
  "image/vnd.fujixerox.edmics-mmr": {
    source: "iana",
    extensions: [
      "mmr"
    ]
  },
  "image/vnd.fujixerox.edmics-rlc": {
    source: "iana",
    extensions: [
      "rlc"
    ]
  },
  "image/vnd.globalgraphics.pgb": {
    source: "iana"
  },
  "image/vnd.microsoft.icon": {
    source: "iana",
    compressible: !0,
    extensions: [
      "ico"
    ]
  },
  "image/vnd.mix": {
    source: "iana"
  },
  "image/vnd.mozilla.apng": {
    source: "iana"
  },
  "image/vnd.ms-dds": {
    compressible: !0,
    extensions: [
      "dds"
    ]
  },
  "image/vnd.ms-modi": {
    source: "iana",
    extensions: [
      "mdi"
    ]
  },
  "image/vnd.ms-photo": {
    source: "apache",
    extensions: [
      "wdp"
    ]
  },
  "image/vnd.net-fpx": {
    source: "iana",
    extensions: [
      "npx"
    ]
  },
  "image/vnd.pco.b16": {
    source: "iana",
    extensions: [
      "b16"
    ]
  },
  "image/vnd.radiance": {
    source: "iana"
  },
  "image/vnd.sealed.png": {
    source: "iana"
  },
  "image/vnd.sealedmedia.softseal.gif": {
    source: "iana"
  },
  "image/vnd.sealedmedia.softseal.jpg": {
    source: "iana"
  },
  "image/vnd.svf": {
    source: "iana"
  },
  "image/vnd.tencent.tap": {
    source: "iana",
    extensions: [
      "tap"
    ]
  },
  "image/vnd.valve.source.texture": {
    source: "iana",
    extensions: [
      "vtf"
    ]
  },
  "image/vnd.wap.wbmp": {
    source: "iana",
    extensions: [
      "wbmp"
    ]
  },
  "image/vnd.xiff": {
    source: "iana",
    extensions: [
      "xif"
    ]
  },
  "image/vnd.zbrush.pcx": {
    source: "iana",
    extensions: [
      "pcx"
    ]
  },
  "image/webp": {
    source: "apache",
    extensions: [
      "webp"
    ]
  },
  "image/wmf": {
    source: "iana",
    extensions: [
      "wmf"
    ]
  },
  "image/x-3ds": {
    source: "apache",
    extensions: [
      "3ds"
    ]
  },
  "image/x-cmu-raster": {
    source: "apache",
    extensions: [
      "ras"
    ]
  },
  "image/x-cmx": {
    source: "apache",
    extensions: [
      "cmx"
    ]
  },
  "image/x-freehand": {
    source: "apache",
    extensions: [
      "fh",
      "fhc",
      "fh4",
      "fh5",
      "fh7"
    ]
  },
  "image/x-icon": {
    source: "apache",
    compressible: !0,
    extensions: [
      "ico"
    ]
  },
  "image/x-jng": {
    source: "nginx",
    extensions: [
      "jng"
    ]
  },
  "image/x-mrsid-image": {
    source: "apache",
    extensions: [
      "sid"
    ]
  },
  "image/x-ms-bmp": {
    source: "nginx",
    compressible: !0,
    extensions: [
      "bmp"
    ]
  },
  "image/x-pcx": {
    source: "apache",
    extensions: [
      "pcx"
    ]
  },
  "image/x-pict": {
    source: "apache",
    extensions: [
      "pic",
      "pct"
    ]
  },
  "image/x-portable-anymap": {
    source: "apache",
    extensions: [
      "pnm"
    ]
  },
  "image/x-portable-bitmap": {
    source: "apache",
    extensions: [
      "pbm"
    ]
  },
  "image/x-portable-graymap": {
    source: "apache",
    extensions: [
      "pgm"
    ]
  },
  "image/x-portable-pixmap": {
    source: "apache",
    extensions: [
      "ppm"
    ]
  },
  "image/x-rgb": {
    source: "apache",
    extensions: [
      "rgb"
    ]
  },
  "image/x-tga": {
    source: "apache",
    extensions: [
      "tga"
    ]
  },
  "image/x-xbitmap": {
    source: "apache",
    extensions: [
      "xbm"
    ]
  },
  "image/x-xcf": {
    compressible: !1
  },
  "image/x-xpixmap": {
    source: "apache",
    extensions: [
      "xpm"
    ]
  },
  "image/x-xwindowdump": {
    source: "apache",
    extensions: [
      "xwd"
    ]
  },
  "message/cpim": {
    source: "iana"
  },
  "message/delivery-status": {
    source: "iana"
  },
  "message/disposition-notification": {
    source: "iana",
    extensions: [
      "disposition-notification"
    ]
  },
  "message/external-body": {
    source: "iana"
  },
  "message/feedback-report": {
    source: "iana"
  },
  "message/global": {
    source: "iana",
    extensions: [
      "u8msg"
    ]
  },
  "message/global-delivery-status": {
    source: "iana",
    extensions: [
      "u8dsn"
    ]
  },
  "message/global-disposition-notification": {
    source: "iana",
    extensions: [
      "u8mdn"
    ]
  },
  "message/global-headers": {
    source: "iana",
    extensions: [
      "u8hdr"
    ]
  },
  "message/http": {
    source: "iana",
    compressible: !1
  },
  "message/imdn+xml": {
    source: "iana",
    compressible: !0
  },
  "message/news": {
    source: "iana"
  },
  "message/partial": {
    source: "iana",
    compressible: !1
  },
  "message/rfc822": {
    source: "iana",
    compressible: !0,
    extensions: [
      "eml",
      "mime"
    ]
  },
  "message/s-http": {
    source: "iana"
  },
  "message/sip": {
    source: "iana"
  },
  "message/sipfrag": {
    source: "iana"
  },
  "message/tracking-status": {
    source: "iana"
  },
  "message/vnd.si.simp": {
    source: "iana"
  },
  "message/vnd.wfa.wsc": {
    source: "iana",
    extensions: [
      "wsc"
    ]
  },
  "model/3mf": {
    source: "iana",
    extensions: [
      "3mf"
    ]
  },
  "model/e57": {
    source: "iana"
  },
  "model/gltf+json": {
    source: "iana",
    compressible: !0,
    extensions: [
      "gltf"
    ]
  },
  "model/gltf-binary": {
    source: "iana",
    compressible: !0,
    extensions: [
      "glb"
    ]
  },
  "model/iges": {
    source: "iana",
    compressible: !1,
    extensions: [
      "igs",
      "iges"
    ]
  },
  "model/mesh": {
    source: "iana",
    compressible: !1,
    extensions: [
      "msh",
      "mesh",
      "silo"
    ]
  },
  "model/mtl": {
    source: "iana",
    extensions: [
      "mtl"
    ]
  },
  "model/obj": {
    source: "iana",
    extensions: [
      "obj"
    ]
  },
  "model/step": {
    source: "iana"
  },
  "model/step+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "stpx"
    ]
  },
  "model/step+zip": {
    source: "iana",
    compressible: !1,
    extensions: [
      "stpz"
    ]
  },
  "model/step-xml+zip": {
    source: "iana",
    compressible: !1,
    extensions: [
      "stpxz"
    ]
  },
  "model/stl": {
    source: "iana",
    extensions: [
      "stl"
    ]
  },
  "model/vnd.collada+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "dae"
    ]
  },
  "model/vnd.dwf": {
    source: "iana",
    extensions: [
      "dwf"
    ]
  },
  "model/vnd.flatland.3dml": {
    source: "iana"
  },
  "model/vnd.gdl": {
    source: "iana",
    extensions: [
      "gdl"
    ]
  },
  "model/vnd.gs-gdl": {
    source: "apache"
  },
  "model/vnd.gs.gdl": {
    source: "iana"
  },
  "model/vnd.gtw": {
    source: "iana",
    extensions: [
      "gtw"
    ]
  },
  "model/vnd.moml+xml": {
    source: "iana",
    compressible: !0
  },
  "model/vnd.mts": {
    source: "iana",
    extensions: [
      "mts"
    ]
  },
  "model/vnd.opengex": {
    source: "iana",
    extensions: [
      "ogex"
    ]
  },
  "model/vnd.parasolid.transmit.binary": {
    source: "iana",
    extensions: [
      "x_b"
    ]
  },
  "model/vnd.parasolid.transmit.text": {
    source: "iana",
    extensions: [
      "x_t"
    ]
  },
  "model/vnd.pytha.pyox": {
    source: "iana"
  },
  "model/vnd.rosette.annotated-data-model": {
    source: "iana"
  },
  "model/vnd.sap.vds": {
    source: "iana",
    extensions: [
      "vds"
    ]
  },
  "model/vnd.usdz+zip": {
    source: "iana",
    compressible: !1,
    extensions: [
      "usdz"
    ]
  },
  "model/vnd.valve.source.compiled-map": {
    source: "iana",
    extensions: [
      "bsp"
    ]
  },
  "model/vnd.vtu": {
    source: "iana",
    extensions: [
      "vtu"
    ]
  },
  "model/vrml": {
    source: "iana",
    compressible: !1,
    extensions: [
      "wrl",
      "vrml"
    ]
  },
  "model/x3d+binary": {
    source: "apache",
    compressible: !1,
    extensions: [
      "x3db",
      "x3dbz"
    ]
  },
  "model/x3d+fastinfoset": {
    source: "iana",
    extensions: [
      "x3db"
    ]
  },
  "model/x3d+vrml": {
    source: "apache",
    compressible: !1,
    extensions: [
      "x3dv",
      "x3dvz"
    ]
  },
  "model/x3d+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "x3d",
      "x3dz"
    ]
  },
  "model/x3d-vrml": {
    source: "iana",
    extensions: [
      "x3dv"
    ]
  },
  "multipart/alternative": {
    source: "iana",
    compressible: !1
  },
  "multipart/appledouble": {
    source: "iana"
  },
  "multipart/byteranges": {
    source: "iana"
  },
  "multipart/digest": {
    source: "iana"
  },
  "multipart/encrypted": {
    source: "iana",
    compressible: !1
  },
  "multipart/form-data": {
    source: "iana",
    compressible: !1
  },
  "multipart/header-set": {
    source: "iana"
  },
  "multipart/mixed": {
    source: "iana"
  },
  "multipart/multilingual": {
    source: "iana"
  },
  "multipart/parallel": {
    source: "iana"
  },
  "multipart/related": {
    source: "iana",
    compressible: !1
  },
  "multipart/report": {
    source: "iana"
  },
  "multipart/signed": {
    source: "iana",
    compressible: !1
  },
  "multipart/vnd.bint.med-plus": {
    source: "iana"
  },
  "multipart/voice-message": {
    source: "iana"
  },
  "multipart/x-mixed-replace": {
    source: "iana"
  },
  "text/1d-interleaved-parityfec": {
    source: "iana"
  },
  "text/cache-manifest": {
    source: "iana",
    compressible: !0,
    extensions: [
      "appcache",
      "manifest"
    ]
  },
  "text/calendar": {
    source: "iana",
    extensions: [
      "ics",
      "ifb"
    ]
  },
  "text/calender": {
    compressible: !0
  },
  "text/cmd": {
    compressible: !0
  },
  "text/coffeescript": {
    extensions: [
      "coffee",
      "litcoffee"
    ]
  },
  "text/cql": {
    source: "iana"
  },
  "text/cql-expression": {
    source: "iana"
  },
  "text/cql-identifier": {
    source: "iana"
  },
  "text/css": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: [
      "css"
    ]
  },
  "text/csv": {
    source: "iana",
    compressible: !0,
    extensions: [
      "csv"
    ]
  },
  "text/csv-schema": {
    source: "iana"
  },
  "text/directory": {
    source: "iana"
  },
  "text/dns": {
    source: "iana"
  },
  "text/ecmascript": {
    source: "iana"
  },
  "text/encaprtp": {
    source: "iana"
  },
  "text/enriched": {
    source: "iana"
  },
  "text/fhirpath": {
    source: "iana"
  },
  "text/flexfec": {
    source: "iana"
  },
  "text/fwdred": {
    source: "iana"
  },
  "text/gff3": {
    source: "iana"
  },
  "text/grammar-ref-list": {
    source: "iana"
  },
  "text/html": {
    source: "iana",
    compressible: !0,
    extensions: [
      "html",
      "htm",
      "shtml"
    ]
  },
  "text/jade": {
    extensions: [
      "jade"
    ]
  },
  "text/javascript": {
    source: "iana",
    compressible: !0
  },
  "text/jcr-cnd": {
    source: "iana"
  },
  "text/jsx": {
    compressible: !0,
    extensions: [
      "jsx"
    ]
  },
  "text/less": {
    compressible: !0,
    extensions: [
      "less"
    ]
  },
  "text/markdown": {
    source: "iana",
    compressible: !0,
    extensions: [
      "markdown",
      "md"
    ]
  },
  "text/mathml": {
    source: "nginx",
    extensions: [
      "mml"
    ]
  },
  "text/mdx": {
    compressible: !0,
    extensions: [
      "mdx"
    ]
  },
  "text/mizar": {
    source: "iana"
  },
  "text/n3": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: [
      "n3"
    ]
  },
  "text/parameters": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/parityfec": {
    source: "iana"
  },
  "text/plain": {
    source: "iana",
    compressible: !0,
    extensions: [
      "txt",
      "text",
      "conf",
      "def",
      "list",
      "log",
      "in",
      "ini"
    ]
  },
  "text/provenance-notation": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/prs.fallenstein.rst": {
    source: "iana"
  },
  "text/prs.lines.tag": {
    source: "iana",
    extensions: [
      "dsc"
    ]
  },
  "text/prs.prop.logic": {
    source: "iana"
  },
  "text/raptorfec": {
    source: "iana"
  },
  "text/red": {
    source: "iana"
  },
  "text/rfc822-headers": {
    source: "iana"
  },
  "text/richtext": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rtx"
    ]
  },
  "text/rtf": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rtf"
    ]
  },
  "text/rtp-enc-aescm128": {
    source: "iana"
  },
  "text/rtploopback": {
    source: "iana"
  },
  "text/rtx": {
    source: "iana"
  },
  "text/sgml": {
    source: "iana",
    extensions: [
      "sgml",
      "sgm"
    ]
  },
  "text/shaclc": {
    source: "iana"
  },
  "text/shex": {
    source: "iana",
    extensions: [
      "shex"
    ]
  },
  "text/slim": {
    extensions: [
      "slim",
      "slm"
    ]
  },
  "text/spdx": {
    source: "iana",
    extensions: [
      "spdx"
    ]
  },
  "text/strings": {
    source: "iana"
  },
  "text/stylus": {
    extensions: [
      "stylus",
      "styl"
    ]
  },
  "text/t140": {
    source: "iana"
  },
  "text/tab-separated-values": {
    source: "iana",
    compressible: !0,
    extensions: [
      "tsv"
    ]
  },
  "text/troff": {
    source: "iana",
    extensions: [
      "t",
      "tr",
      "roff",
      "man",
      "me",
      "ms"
    ]
  },
  "text/turtle": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "ttl"
    ]
  },
  "text/ulpfec": {
    source: "iana"
  },
  "text/uri-list": {
    source: "iana",
    compressible: !0,
    extensions: [
      "uri",
      "uris",
      "urls"
    ]
  },
  "text/vcard": {
    source: "iana",
    compressible: !0,
    extensions: [
      "vcard"
    ]
  },
  "text/vnd.a": {
    source: "iana"
  },
  "text/vnd.abc": {
    source: "iana"
  },
  "text/vnd.ascii-art": {
    source: "iana"
  },
  "text/vnd.curl": {
    source: "iana",
    extensions: [
      "curl"
    ]
  },
  "text/vnd.curl.dcurl": {
    source: "apache",
    extensions: [
      "dcurl"
    ]
  },
  "text/vnd.curl.mcurl": {
    source: "apache",
    extensions: [
      "mcurl"
    ]
  },
  "text/vnd.curl.scurl": {
    source: "apache",
    extensions: [
      "scurl"
    ]
  },
  "text/vnd.debian.copyright": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/vnd.dmclientscript": {
    source: "iana"
  },
  "text/vnd.dvb.subtitle": {
    source: "iana",
    extensions: [
      "sub"
    ]
  },
  "text/vnd.esmertec.theme-descriptor": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/vnd.familysearch.gedcom": {
    source: "iana",
    extensions: [
      "ged"
    ]
  },
  "text/vnd.ficlab.flt": {
    source: "iana"
  },
  "text/vnd.fly": {
    source: "iana",
    extensions: [
      "fly"
    ]
  },
  "text/vnd.fmi.flexstor": {
    source: "iana",
    extensions: [
      "flx"
    ]
  },
  "text/vnd.gml": {
    source: "iana"
  },
  "text/vnd.graphviz": {
    source: "iana",
    extensions: [
      "gv"
    ]
  },
  "text/vnd.hans": {
    source: "iana"
  },
  "text/vnd.hgl": {
    source: "iana"
  },
  "text/vnd.in3d.3dml": {
    source: "iana",
    extensions: [
      "3dml"
    ]
  },
  "text/vnd.in3d.spot": {
    source: "iana",
    extensions: [
      "spot"
    ]
  },
  "text/vnd.iptc.newsml": {
    source: "iana"
  },
  "text/vnd.iptc.nitf": {
    source: "iana"
  },
  "text/vnd.latex-z": {
    source: "iana"
  },
  "text/vnd.motorola.reflex": {
    source: "iana"
  },
  "text/vnd.ms-mediapackage": {
    source: "iana"
  },
  "text/vnd.net2phone.commcenter.command": {
    source: "iana"
  },
  "text/vnd.radisys.msml-basic-layout": {
    source: "iana"
  },
  "text/vnd.senx.warpscript": {
    source: "iana"
  },
  "text/vnd.si.uricatalogue": {
    source: "iana"
  },
  "text/vnd.sosi": {
    source: "iana"
  },
  "text/vnd.sun.j2me.app-descriptor": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "jad"
    ]
  },
  "text/vnd.trolltech.linguist": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/vnd.wap.si": {
    source: "iana"
  },
  "text/vnd.wap.sl": {
    source: "iana"
  },
  "text/vnd.wap.wml": {
    source: "iana",
    extensions: [
      "wml"
    ]
  },
  "text/vnd.wap.wmlscript": {
    source: "iana",
    extensions: [
      "wmls"
    ]
  },
  "text/vtt": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: [
      "vtt"
    ]
  },
  "text/x-asm": {
    source: "apache",
    extensions: [
      "s",
      "asm"
    ]
  },
  "text/x-c": {
    source: "apache",
    extensions: [
      "c",
      "cc",
      "cxx",
      "cpp",
      "h",
      "hh",
      "dic"
    ]
  },
  "text/x-component": {
    source: "nginx",
    extensions: [
      "htc"
    ]
  },
  "text/x-fortran": {
    source: "apache",
    extensions: [
      "f",
      "for",
      "f77",
      "f90"
    ]
  },
  "text/x-gwt-rpc": {
    compressible: !0
  },
  "text/x-handlebars-template": {
    extensions: [
      "hbs"
    ]
  },
  "text/x-java-source": {
    source: "apache",
    extensions: [
      "java"
    ]
  },
  "text/x-jquery-tmpl": {
    compressible: !0
  },
  "text/x-lua": {
    extensions: [
      "lua"
    ]
  },
  "text/x-markdown": {
    compressible: !0,
    extensions: [
      "mkd"
    ]
  },
  "text/x-nfo": {
    source: "apache",
    extensions: [
      "nfo"
    ]
  },
  "text/x-opml": {
    source: "apache",
    extensions: [
      "opml"
    ]
  },
  "text/x-org": {
    compressible: !0,
    extensions: [
      "org"
    ]
  },
  "text/x-pascal": {
    source: "apache",
    extensions: [
      "p",
      "pas"
    ]
  },
  "text/x-processing": {
    compressible: !0,
    extensions: [
      "pde"
    ]
  },
  "text/x-sass": {
    extensions: [
      "sass"
    ]
  },
  "text/x-scss": {
    extensions: [
      "scss"
    ]
  },
  "text/x-setext": {
    source: "apache",
    extensions: [
      "etx"
    ]
  },
  "text/x-sfv": {
    source: "apache",
    extensions: [
      "sfv"
    ]
  },
  "text/x-suse-ymp": {
    compressible: !0,
    extensions: [
      "ymp"
    ]
  },
  "text/x-uuencode": {
    source: "apache",
    extensions: [
      "uu"
    ]
  },
  "text/x-vcalendar": {
    source: "apache",
    extensions: [
      "vcs"
    ]
  },
  "text/x-vcard": {
    source: "apache",
    extensions: [
      "vcf"
    ]
  },
  "text/xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xml"
    ]
  },
  "text/xml-external-parsed-entity": {
    source: "iana"
  },
  "text/yaml": {
    compressible: !0,
    extensions: [
      "yaml",
      "yml"
    ]
  },
  "video/1d-interleaved-parityfec": {
    source: "iana"
  },
  "video/3gpp": {
    source: "iana",
    extensions: [
      "3gp",
      "3gpp"
    ]
  },
  "video/3gpp-tt": {
    source: "iana"
  },
  "video/3gpp2": {
    source: "iana",
    extensions: [
      "3g2"
    ]
  },
  "video/av1": {
    source: "iana"
  },
  "video/bmpeg": {
    source: "iana"
  },
  "video/bt656": {
    source: "iana"
  },
  "video/celb": {
    source: "iana"
  },
  "video/dv": {
    source: "iana"
  },
  "video/encaprtp": {
    source: "iana"
  },
  "video/ffv1": {
    source: "iana"
  },
  "video/flexfec": {
    source: "iana"
  },
  "video/h261": {
    source: "iana",
    extensions: [
      "h261"
    ]
  },
  "video/h263": {
    source: "iana",
    extensions: [
      "h263"
    ]
  },
  "video/h263-1998": {
    source: "iana"
  },
  "video/h263-2000": {
    source: "iana"
  },
  "video/h264": {
    source: "iana",
    extensions: [
      "h264"
    ]
  },
  "video/h264-rcdo": {
    source: "iana"
  },
  "video/h264-svc": {
    source: "iana"
  },
  "video/h265": {
    source: "iana"
  },
  "video/iso.segment": {
    source: "iana",
    extensions: [
      "m4s"
    ]
  },
  "video/jpeg": {
    source: "iana",
    extensions: [
      "jpgv"
    ]
  },
  "video/jpeg2000": {
    source: "iana"
  },
  "video/jpm": {
    source: "apache",
    extensions: [
      "jpm",
      "jpgm"
    ]
  },
  "video/jxsv": {
    source: "iana"
  },
  "video/mj2": {
    source: "iana",
    extensions: [
      "mj2",
      "mjp2"
    ]
  },
  "video/mp1s": {
    source: "iana"
  },
  "video/mp2p": {
    source: "iana"
  },
  "video/mp2t": {
    source: "iana",
    extensions: [
      "ts"
    ]
  },
  "video/mp4": {
    source: "iana",
    compressible: !1,
    extensions: [
      "mp4",
      "mp4v",
      "mpg4"
    ]
  },
  "video/mp4v-es": {
    source: "iana"
  },
  "video/mpeg": {
    source: "iana",
    compressible: !1,
    extensions: [
      "mpeg",
      "mpg",
      "mpe",
      "m1v",
      "m2v"
    ]
  },
  "video/mpeg4-generic": {
    source: "iana"
  },
  "video/mpv": {
    source: "iana"
  },
  "video/nv": {
    source: "iana"
  },
  "video/ogg": {
    source: "iana",
    compressible: !1,
    extensions: [
      "ogv"
    ]
  },
  "video/parityfec": {
    source: "iana"
  },
  "video/pointer": {
    source: "iana"
  },
  "video/quicktime": {
    source: "iana",
    compressible: !1,
    extensions: [
      "qt",
      "mov"
    ]
  },
  "video/raptorfec": {
    source: "iana"
  },
  "video/raw": {
    source: "iana"
  },
  "video/rtp-enc-aescm128": {
    source: "iana"
  },
  "video/rtploopback": {
    source: "iana"
  },
  "video/rtx": {
    source: "iana"
  },
  "video/scip": {
    source: "iana"
  },
  "video/smpte291": {
    source: "iana"
  },
  "video/smpte292m": {
    source: "iana"
  },
  "video/ulpfec": {
    source: "iana"
  },
  "video/vc1": {
    source: "iana"
  },
  "video/vc2": {
    source: "iana"
  },
  "video/vnd.cctv": {
    source: "iana"
  },
  "video/vnd.dece.hd": {
    source: "iana",
    extensions: [
      "uvh",
      "uvvh"
    ]
  },
  "video/vnd.dece.mobile": {
    source: "iana",
    extensions: [
      "uvm",
      "uvvm"
    ]
  },
  "video/vnd.dece.mp4": {
    source: "iana"
  },
  "video/vnd.dece.pd": {
    source: "iana",
    extensions: [
      "uvp",
      "uvvp"
    ]
  },
  "video/vnd.dece.sd": {
    source: "iana",
    extensions: [
      "uvs",
      "uvvs"
    ]
  },
  "video/vnd.dece.video": {
    source: "iana",
    extensions: [
      "uvv",
      "uvvv"
    ]
  },
  "video/vnd.directv.mpeg": {
    source: "iana"
  },
  "video/vnd.directv.mpeg-tts": {
    source: "iana"
  },
  "video/vnd.dlna.mpeg-tts": {
    source: "iana"
  },
  "video/vnd.dvb.file": {
    source: "iana",
    extensions: [
      "dvb"
    ]
  },
  "video/vnd.fvt": {
    source: "iana",
    extensions: [
      "fvt"
    ]
  },
  "video/vnd.hns.video": {
    source: "iana"
  },
  "video/vnd.iptvforum.1dparityfec-1010": {
    source: "iana"
  },
  "video/vnd.iptvforum.1dparityfec-2005": {
    source: "iana"
  },
  "video/vnd.iptvforum.2dparityfec-1010": {
    source: "iana"
  },
  "video/vnd.iptvforum.2dparityfec-2005": {
    source: "iana"
  },
  "video/vnd.iptvforum.ttsavc": {
    source: "iana"
  },
  "video/vnd.iptvforum.ttsmpeg2": {
    source: "iana"
  },
  "video/vnd.motorola.video": {
    source: "iana"
  },
  "video/vnd.motorola.videop": {
    source: "iana"
  },
  "video/vnd.mpegurl": {
    source: "iana",
    extensions: [
      "mxu",
      "m4u"
    ]
  },
  "video/vnd.ms-playready.media.pyv": {
    source: "iana",
    extensions: [
      "pyv"
    ]
  },
  "video/vnd.nokia.interleaved-multimedia": {
    source: "iana"
  },
  "video/vnd.nokia.mp4vr": {
    source: "iana"
  },
  "video/vnd.nokia.videovoip": {
    source: "iana"
  },
  "video/vnd.objectvideo": {
    source: "iana"
  },
  "video/vnd.radgamettools.bink": {
    source: "iana"
  },
  "video/vnd.radgamettools.smacker": {
    source: "iana"
  },
  "video/vnd.sealed.mpeg1": {
    source: "iana"
  },
  "video/vnd.sealed.mpeg4": {
    source: "iana"
  },
  "video/vnd.sealed.swf": {
    source: "iana"
  },
  "video/vnd.sealedmedia.softseal.mov": {
    source: "iana"
  },
  "video/vnd.uvvu.mp4": {
    source: "iana",
    extensions: [
      "uvu",
      "uvvu"
    ]
  },
  "video/vnd.vivo": {
    source: "iana",
    extensions: [
      "viv"
    ]
  },
  "video/vnd.youtube.yt": {
    source: "iana"
  },
  "video/vp8": {
    source: "iana"
  },
  "video/vp9": {
    source: "iana"
  },
  "video/webm": {
    source: "apache",
    compressible: !1,
    extensions: [
      "webm"
    ]
  },
  "video/x-f4v": {
    source: "apache",
    extensions: [
      "f4v"
    ]
  },
  "video/x-fli": {
    source: "apache",
    extensions: [
      "fli"
    ]
  },
  "video/x-flv": {
    source: "apache",
    compressible: !1,
    extensions: [
      "flv"
    ]
  },
  "video/x-m4v": {
    source: "apache",
    extensions: [
      "m4v"
    ]
  },
  "video/x-matroska": {
    source: "apache",
    compressible: !1,
    extensions: [
      "mkv",
      "mk3d",
      "mks"
    ]
  },
  "video/x-mng": {
    source: "apache",
    extensions: [
      "mng"
    ]
  },
  "video/x-ms-asf": {
    source: "apache",
    extensions: [
      "asf",
      "asx"
    ]
  },
  "video/x-ms-vob": {
    source: "apache",
    extensions: [
      "vob"
    ]
  },
  "video/x-ms-wm": {
    source: "apache",
    extensions: [
      "wm"
    ]
  },
  "video/x-ms-wmv": {
    source: "apache",
    compressible: !1,
    extensions: [
      "wmv"
    ]
  },
  "video/x-ms-wmx": {
    source: "apache",
    extensions: [
      "wmx"
    ]
  },
  "video/x-ms-wvx": {
    source: "apache",
    extensions: [
      "wvx"
    ]
  },
  "video/x-msvideo": {
    source: "apache",
    extensions: [
      "avi"
    ]
  },
  "video/x-sgi-movie": {
    source: "apache",
    extensions: [
      "movie"
    ]
  },
  "video/x-smv": {
    source: "apache",
    extensions: [
      "smv"
    ]
  },
  "x-conference/x-cooltalk": {
    source: "apache",
    extensions: [
      "ice"
    ]
  },
  "x-shader/x-fragment": {
    compressible: !0
  },
  "x-shader/x-vertex": {
    compressible: !0
  }
};
/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var nl, ob;
function qI() {
  return ob || (ob = 1, nl = MI), nl;
}
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var cb;
function _2() {
  return cb || (cb = 1, function(t) {
    var e = qI(), r = se.extname, n = /^\s*([^;\s]*)(?:;|\s|$)/, i = /^text\//i;
    t.charset = a, t.charsets = { lookup: a }, t.contentType = s, t.extension = o, t.extensions = /* @__PURE__ */ Object.create(null), t.lookup = c, t.types = /* @__PURE__ */ Object.create(null), f(t.extensions, t.types);
    function a(u) {
      if (!u || typeof u != "string")
        return !1;
      var l = n.exec(u), p = l && e[l[1].toLowerCase()];
      return p && p.charset ? p.charset : l && i.test(l[1]) ? "UTF-8" : !1;
    }
    function s(u) {
      if (!u || typeof u != "string")
        return !1;
      var l = u.indexOf("/") === -1 ? t.lookup(u) : u;
      if (!l)
        return !1;
      if (l.indexOf("charset") === -1) {
        var p = t.charset(l);
        p && (l += "; charset=" + p.toLowerCase());
      }
      return l;
    }
    function o(u) {
      if (!u || typeof u != "string")
        return !1;
      var l = n.exec(u), p = l && t.extensions[l[1].toLowerCase()];
      return !p || !p.length ? !1 : p[0];
    }
    function c(u) {
      if (!u || typeof u != "string")
        return !1;
      var l = r("x." + u).toLowerCase().substr(1);
      return l && t.types[l] || !1;
    }
    function f(u, l) {
      var p = ["nginx", "apache", void 0, "iana"];
      Object.keys(e).forEach(function(h) {
        var g = e[h], v = g.extensions;
        if (!(!v || !v.length)) {
          u[h] = v;
          for (var d = 0; d < v.length; d++) {
            var y = v[d];
            if (l[y]) {
              var x = p.indexOf(e[l[y]].source), b = p.indexOf(g.source);
              if (l[y] !== "application/octet-stream" && (x > b || x === b && l[y].substr(0, 12) === "application/"))
                continue;
            }
            l[y] = h;
          }
        }
      });
    }
  }(rl)), rl;
}
/*!
 * type-is
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var ub;
function qr() {
  if (ub)
    return gn.exports;
  ub = 1;
  var t = DI(), e = _2();
  gn.exports = i, gn.exports.is = r, gn.exports.hasBody = n, gn.exports.normalize = a, gn.exports.match = s;
  function r(f, u) {
    var l, p = u, m = c(f);
    if (!m)
      return !1;
    if (p && !Array.isArray(p))
      for (p = new Array(arguments.length - 1), l = 0; l < p.length; l++)
        p[l] = arguments[l + 1];
    if (!p || !p.length)
      return m;
    var h;
    for (l = 0; l < p.length; l++)
      if (s(a(h = p[l]), m))
        return h[0] === "+" || h.indexOf("*") !== -1 ? m : h;
    return !1;
  }
  function n(f) {
    return f.headers["transfer-encoding"] !== void 0 || !isNaN(f.headers["content-length"]);
  }
  function i(f, u) {
    var l = u;
    if (!n(f))
      return null;
    if (arguments.length > 2) {
      l = new Array(arguments.length - 1);
      for (var p = 0; p < l.length; p++)
        l[p] = arguments[p + 1];
    }
    var m = f.headers["content-type"];
    return r(m, l);
  }
  function a(f) {
    if (typeof f != "string")
      return !1;
    switch (f) {
      case "urlencoded":
        return "application/x-www-form-urlencoded";
      case "multipart":
        return "multipart/*";
    }
    return f[0] === "+" ? "*/*" + f : f.indexOf("/") === -1 ? e.lookup(f) : f;
  }
  function s(f, u) {
    if (f === !1)
      return !1;
    var l = u.split("/"), p = f.split("/");
    return l.length !== 2 || p.length !== 2 || p[0] !== "*" && p[0] !== l[0] ? !1 : p[1].substr(0, 2) === "*+" ? p[1].length <= l[1].length + 1 && p[1].substr(1) === l[1].substr(1 - p[1].length) : !(p[1] !== "*" && p[1] !== l[1]);
  }
  function o(f) {
    var u = t.parse(f);
    return u.parameters = void 0, t.format(u);
  }
  function c(f) {
    if (!f)
      return null;
    try {
      return o(f);
    } catch {
      return null;
    }
  }
  return gn.exports;
}
/*!
 * body-parser
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var il, lb;
function jI() {
  if (lb)
    return il;
  lb = 1;
  var t = vr(), e = An(), r = yr(), n = Mr("body-parser:json"), i = Ec(), a = qr();
  il = o;
  var s = /^[\x20\x09\x0a\x0d]*([^\x20\x09\x0a\x0d])/;
  function o(m) {
    var h = m || {}, g = typeof h.limit != "number" ? t.parse(h.limit || "100kb") : h.limit, v = h.inflate !== !1, d = h.reviver, y = h.strict !== !1, x = h.type || "application/json", b = h.verify || !1;
    if (b !== !1 && typeof b != "function")
      throw new TypeError("option verify must be function");
    var w = typeof x != "function" ? p(x) : x;
    function S(T) {
      if (T.length === 0)
        return {};
      if (y) {
        var E = f(T);
        if (E !== "{" && E !== "[")
          throw n("strict violation"), c(T, E);
      }
      try {
        return n("parse json"), JSON.parse(T, d);
      } catch (C) {
        throw l(C, {
          message: C.message,
          stack: C.stack
        });
      }
    }
    return function(E, C, A) {
      if (E._body) {
        n("body already parsed"), A();
        return;
      }
      if (E.body = E.body || {}, !a.hasBody(E)) {
        n("skip empty body"), A();
        return;
      }
      if (n("content-type %j", E.headers["content-type"]), !w(E)) {
        n("skip parsing"), A();
        return;
      }
      var R = u(E) || "utf-8";
      if (R.slice(0, 4) !== "utf-") {
        n("invalid charset"), A(r(415, 'unsupported charset "' + R.toUpperCase() + '"', {
          charset: R,
          type: "charset.unsupported"
        }));
        return;
      }
      i(E, C, A, S, n, {
        encoding: R,
        inflate: v,
        limit: g,
        verify: b
      });
    };
  }
  function c(m, h) {
    var g = m.indexOf(h), v = g !== -1 ? m.substring(0, g) + "#" : "";
    try {
      throw JSON.parse(v), new SyntaxError("strict violation");
    } catch (d) {
      return l(d, {
        message: d.message.replace("#", h),
        stack: d.stack
      });
    }
  }
  function f(m) {
    var h = s.exec(m);
    return h ? h[1] : void 0;
  }
  function u(m) {
    try {
      return (e.parse(m).parameters.charset || "").toLowerCase();
    } catch {
      return;
    }
  }
  function l(m, h) {
    for (var g = Object.getOwnPropertyNames(m), v = 0; v < g.length; v++) {
      var d = g[v];
      d !== "stack" && d !== "message" && delete m[d];
    }
    return m.stack = h.stack.replace(m.message, h.message), m.message = h.message, m;
  }
  function p(m) {
    return function(g) {
      return !!a(g, m);
    };
  }
  return il;
}
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var al, pb;
function FI() {
  if (pb)
    return al;
  pb = 1;
  var t = vr(), e = Mr("body-parser:raw"), r = Ec(), n = qr();
  al = i;
  function i(s) {
    var o = s || {}, c = o.inflate !== !1, f = typeof o.limit != "number" ? t.parse(o.limit || "100kb") : o.limit, u = o.type || "application/octet-stream", l = o.verify || !1;
    if (l !== !1 && typeof l != "function")
      throw new TypeError("option verify must be function");
    var p = typeof u != "function" ? a(u) : u;
    function m(h) {
      return h;
    }
    return function(g, v, d) {
      if (g._body) {
        e("body already parsed"), d();
        return;
      }
      if (g.body = g.body || {}, !n.hasBody(g)) {
        e("skip empty body"), d();
        return;
      }
      if (e("content-type %j", g.headers["content-type"]), !p(g)) {
        e("skip parsing"), d();
        return;
      }
      r(g, v, d, m, e, {
        encoding: null,
        inflate: c,
        limit: f,
        verify: l
      });
    };
  }
  function a(s) {
    return function(c) {
      return !!n(c, s);
    };
  }
  return al;
}
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var sl, fb;
function BI() {
  if (fb)
    return sl;
  fb = 1;
  var t = vr(), e = An(), r = Mr("body-parser:text"), n = Ec(), i = qr();
  sl = a;
  function a(c) {
    var f = c || {}, u = f.defaultCharset || "utf-8", l = f.inflate !== !1, p = typeof f.limit != "number" ? t.parse(f.limit || "100kb") : f.limit, m = f.type || "text/plain", h = f.verify || !1;
    if (h !== !1 && typeof h != "function")
      throw new TypeError("option verify must be function");
    var g = typeof m != "function" ? o(m) : m;
    function v(d) {
      return d;
    }
    return function(y, x, b) {
      if (y._body) {
        r("body already parsed"), b();
        return;
      }
      if (y.body = y.body || {}, !i.hasBody(y)) {
        r("skip empty body"), b();
        return;
      }
      if (r("content-type %j", y.headers["content-type"]), !g(y)) {
        r("skip parsing"), b();
        return;
      }
      var w = s(y) || u;
      n(y, x, b, v, r, {
        encoding: w,
        inflate: l,
        limit: p,
        verify: h
      });
    };
  }
  function s(c) {
    try {
      return (e.parse(c).parameters.charset || "").toLowerCase();
    } catch {
      return;
    }
  }
  function o(c) {
    return function(u) {
      return !!i(u, c);
    };
  }
  return sl;
}
var ol, hb;
function UI() {
  return hb || (hb = 1, ol = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
      return !1;
    if (typeof Symbol.iterator == "symbol")
      return !0;
    var e = {}, r = Symbol("test"), n = Object(r);
    if (typeof r == "string" || Object.prototype.toString.call(r) !== "[object Symbol]" || Object.prototype.toString.call(n) !== "[object Symbol]")
      return !1;
    var i = 42;
    e[r] = i;
    for (r in e)
      return !1;
    if (typeof Object.keys == "function" && Object.keys(e).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(e).length !== 0)
      return !1;
    var a = Object.getOwnPropertySymbols(e);
    if (a.length !== 1 || a[0] !== r || !Object.prototype.propertyIsEnumerable.call(e, r))
      return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var s = Object.getOwnPropertyDescriptor(e, r);
      if (s.value !== i || s.enumerable !== !0)
        return !1;
    }
    return !0;
  }), ol;
}
var cl, db;
function zI() {
  if (db)
    return cl;
  db = 1;
  var t = typeof Symbol < "u" && Symbol, e = UI();
  return cl = function() {
    return typeof t != "function" || typeof Symbol != "function" || typeof t("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : e();
  }, cl;
}
var ul, mb;
function HI() {
  if (mb)
    return ul;
  mb = 1;
  var t = {
    foo: {}
  }, e = Object;
  return ul = function() {
    return { __proto__: t }.foo === t.foo && !({ __proto__: null } instanceof e);
  }, ul;
}
var ll, gb;
function WI() {
  if (gb)
    return ll;
  gb = 1;
  var t = "Function.prototype.bind called on incompatible ", e = Array.prototype.slice, r = Object.prototype.toString, n = "[object Function]";
  return ll = function(a) {
    var s = this;
    if (typeof s != "function" || r.call(s) !== n)
      throw new TypeError(t + s);
    for (var o = e.call(arguments, 1), c, f = function() {
      if (this instanceof c) {
        var h = s.apply(
          this,
          o.concat(e.call(arguments))
        );
        return Object(h) === h ? h : this;
      } else
        return s.apply(
          a,
          o.concat(e.call(arguments))
        );
    }, u = Math.max(0, s.length - o.length), l = [], p = 0; p < u; p++)
      l.push("$" + p);
    if (c = Function("binder", "return function (" + l.join(",") + "){ return binder.apply(this,arguments); }")(f), s.prototype) {
      var m = function() {
      };
      m.prototype = s.prototype, c.prototype = new m(), m.prototype = null;
    }
    return c;
  }, ll;
}
var pl, vb;
function Sg() {
  if (vb)
    return pl;
  vb = 1;
  var t = WI();
  return pl = Function.prototype.bind || t, pl;
}
var fl, yb;
function GI() {
  if (yb)
    return fl;
  yb = 1;
  var t = Sg();
  return fl = t.call(Function.call, Object.prototype.hasOwnProperty), fl;
}
var hl, bb;
function Cg() {
  if (bb)
    return hl;
  bb = 1;
  var t, e = SyntaxError, r = Function, n = TypeError, i = function(D) {
    try {
      return r('"use strict"; return (' + D + ").constructor;")();
    } catch {
    }
  }, a = Object.getOwnPropertyDescriptor;
  if (a)
    try {
      a({}, "");
    } catch {
      a = null;
    }
  var s = function() {
    throw new n();
  }, o = a ? function() {
    try {
      return arguments.callee, s;
    } catch {
      try {
        return a(arguments, "callee").get;
      } catch {
        return s;
      }
    }
  }() : s, c = zI()(), f = HI()(), u = Object.getPrototypeOf || (f ? function(D) {
    return D.__proto__;
  } : null), l = {}, p = typeof Uint8Array > "u" || !u ? t : u(Uint8Array), m = {
    "%AggregateError%": typeof AggregateError > "u" ? t : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer > "u" ? t : ArrayBuffer,
    "%ArrayIteratorPrototype%": c && u ? u([][Symbol.iterator]()) : t,
    "%AsyncFromSyncIteratorPrototype%": t,
    "%AsyncFunction%": l,
    "%AsyncGenerator%": l,
    "%AsyncGeneratorFunction%": l,
    "%AsyncIteratorPrototype%": l,
    "%Atomics%": typeof Atomics > "u" ? t : Atomics,
    "%BigInt%": typeof BigInt > "u" ? t : BigInt,
    "%BigInt64Array%": typeof BigInt64Array > "u" ? t : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array > "u" ? t : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView > "u" ? t : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": Error,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": EvalError,
    "%Float32Array%": typeof Float32Array > "u" ? t : Float32Array,
    "%Float64Array%": typeof Float64Array > "u" ? t : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? t : FinalizationRegistry,
    "%Function%": r,
    "%GeneratorFunction%": l,
    "%Int8Array%": typeof Int8Array > "u" ? t : Int8Array,
    "%Int16Array%": typeof Int16Array > "u" ? t : Int16Array,
    "%Int32Array%": typeof Int32Array > "u" ? t : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": c && u ? u(u([][Symbol.iterator]())) : t,
    "%JSON%": typeof JSON == "object" ? JSON : t,
    "%Map%": typeof Map > "u" ? t : Map,
    "%MapIteratorPrototype%": typeof Map > "u" || !c || !u ? t : u((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": Object,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise > "u" ? t : Promise,
    "%Proxy%": typeof Proxy > "u" ? t : Proxy,
    "%RangeError%": RangeError,
    "%ReferenceError%": ReferenceError,
    "%Reflect%": typeof Reflect > "u" ? t : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set > "u" ? t : Set,
    "%SetIteratorPrototype%": typeof Set > "u" || !c || !u ? t : u((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? t : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": c && u ? u(""[Symbol.iterator]()) : t,
    "%Symbol%": c ? Symbol : t,
    "%SyntaxError%": e,
    "%ThrowTypeError%": o,
    "%TypedArray%": p,
    "%TypeError%": n,
    "%Uint8Array%": typeof Uint8Array > "u" ? t : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? t : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array > "u" ? t : Uint16Array,
    "%Uint32Array%": typeof Uint32Array > "u" ? t : Uint32Array,
    "%URIError%": URIError,
    "%WeakMap%": typeof WeakMap > "u" ? t : WeakMap,
    "%WeakRef%": typeof WeakRef > "u" ? t : WeakRef,
    "%WeakSet%": typeof WeakSet > "u" ? t : WeakSet
  };
  if (u)
    try {
      null.error;
    } catch (D) {
      var h = u(u(D));
      m["%Error.prototype%"] = h;
    }
  var g = function D(F) {
    var K;
    if (F === "%AsyncFunction%")
      K = i("async function () {}");
    else if (F === "%GeneratorFunction%")
      K = i("function* () {}");
    else if (F === "%AsyncGeneratorFunction%")
      K = i("async function* () {}");
    else if (F === "%AsyncGenerator%") {
      var V = D("%AsyncGeneratorFunction%");
      V && (K = V.prototype);
    } else if (F === "%AsyncIteratorPrototype%") {
      var ne = D("%AsyncGenerator%");
      ne && u && (K = u(ne.prototype));
    }
    return m[F] = K, K;
  }, v = {
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  }, d = Sg(), y = GI(), x = d.call(Function.call, Array.prototype.concat), b = d.call(Function.apply, Array.prototype.splice), w = d.call(Function.call, String.prototype.replace), S = d.call(Function.call, String.prototype.slice), T = d.call(Function.call, RegExp.prototype.exec), E = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, C = /\\(\\)?/g, A = function(F) {
    var K = S(F, 0, 1), V = S(F, -1);
    if (K === "%" && V !== "%")
      throw new e("invalid intrinsic syntax, expected closing `%`");
    if (V === "%" && K !== "%")
      throw new e("invalid intrinsic syntax, expected opening `%`");
    var ne = [];
    return w(F, E, function($, L, P, H) {
      ne[ne.length] = P ? w(H, C, "$1") : L || $;
    }), ne;
  }, R = function(F, K) {
    var V = F, ne;
    if (y(v, V) && (ne = v[V], V = "%" + ne[0] + "%"), y(m, V)) {
      var $ = m[V];
      if ($ === l && ($ = g(V)), typeof $ > "u" && !K)
        throw new n("intrinsic " + F + " exists, but is not available. Please file an issue!");
      return {
        alias: ne,
        name: V,
        value: $
      };
    }
    throw new e("intrinsic " + F + " does not exist!");
  };
  return hl = function(F, K) {
    if (typeof F != "string" || F.length === 0)
      throw new n("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof K != "boolean")
      throw new n('"allowMissing" argument must be a boolean');
    if (T(/^%?[^%]*%?$/, F) === null)
      throw new e("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var V = A(F), ne = V.length > 0 ? V[0] : "", $ = R("%" + ne + "%", K), L = $.name, P = $.value, H = !1, Q = $.alias;
    Q && (ne = Q[0], b(V, x([0, 1], Q)));
    for (var Y = 1, ce = !0; Y < V.length; Y += 1) {
      var ue = V[Y], me = S(ue, 0, 1), J = S(ue, -1);
      if ((me === '"' || me === "'" || me === "`" || J === '"' || J === "'" || J === "`") && me !== J)
        throw new e("property names with quotes must have matching quotes");
      if ((ue === "constructor" || !ce) && (H = !0), ne += "." + ue, L = "%" + ne + "%", y(m, L))
        P = m[L];
      else if (P != null) {
        if (!(ue in P)) {
          if (!K)
            throw new n("base intrinsic for " + F + " exists, but the property is not available.");
          return;
        }
        if (a && Y + 1 >= V.length) {
          var O = a(P, ue);
          ce = !!O, ce && "get" in O && !("originalValue" in O.get) ? P = O.get : P = P[ue];
        } else
          ce = y(P, ue), P = P[ue];
        ce && !H && (m[L] = P);
      }
    }
    return P;
  }, hl;
}
var dl = { exports: {} }, wb;
function QI() {
  return wb || (wb = 1, function(t) {
    var e = Sg(), r = Cg(), n = r("%Function.prototype.apply%"), i = r("%Function.prototype.call%"), a = r("%Reflect.apply%", !0) || e.call(i, n), s = r("%Object.getOwnPropertyDescriptor%", !0), o = r("%Object.defineProperty%", !0), c = r("%Math.max%");
    if (o)
      try {
        o({}, "a", { value: 1 });
      } catch {
        o = null;
      }
    t.exports = function(l) {
      var p = a(e, i, arguments);
      if (s && o) {
        var m = s(p, "length");
        m.configurable && o(
          p,
          "length",
          { value: 1 + c(0, l.length - (arguments.length - 1)) }
        );
      }
      return p;
    };
    var f = function() {
      return a(e, n, arguments);
    };
    o ? o(t.exports, "apply", { value: f }) : t.exports.apply = f;
  }(dl)), dl.exports;
}
var ml, xb;
function VI() {
  if (xb)
    return ml;
  xb = 1;
  var t = Cg(), e = QI(), r = e(t("String.prototype.indexOf"));
  return ml = function(i, a) {
    var s = t(i, !!a);
    return typeof s == "function" && r(i, ".prototype.") > -1 ? e(s) : s;
  }, ml;
}
var gl, _b;
function KI() {
  if (_b)
    return gl;
  _b = 1;
  var t = typeof Map == "function" && Map.prototype, e = Object.getOwnPropertyDescriptor && t ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null, r = t && e && typeof e.get == "function" ? e.get : null, n = t && Map.prototype.forEach, i = typeof Set == "function" && Set.prototype, a = Object.getOwnPropertyDescriptor && i ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null, s = i && a && typeof a.get == "function" ? a.get : null, o = i && Set.prototype.forEach, c = typeof WeakMap == "function" && WeakMap.prototype, f = c ? WeakMap.prototype.has : null, u = typeof WeakSet == "function" && WeakSet.prototype, l = u ? WeakSet.prototype.has : null, p = typeof WeakRef == "function" && WeakRef.prototype, m = p ? WeakRef.prototype.deref : null, h = Boolean.prototype.valueOf, g = Object.prototype.toString, v = Function.prototype.toString, d = String.prototype.match, y = String.prototype.slice, x = String.prototype.replace, b = String.prototype.toUpperCase, w = String.prototype.toLowerCase, S = RegExp.prototype.test, T = Array.prototype.concat, E = Array.prototype.join, C = Array.prototype.slice, A = Math.floor, R = typeof BigInt == "function" ? BigInt.prototype.valueOf : null, D = Object.getOwnPropertySymbols, F = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null, K = typeof Symbol == "function" && typeof Symbol.iterator == "object", V = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === K || "symbol") ? Symbol.toStringTag : null, ne = Object.prototype.propertyIsEnumerable, $ = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(ie) {
    return ie.__proto__;
  } : null);
  function L(ie, ae) {
    if (ie === 1 / 0 || ie === -1 / 0 || ie !== ie || ie && ie > -1e3 && ie < 1e3 || S.call(/e/, ae))
      return ae;
    var Ne = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof ie == "number") {
      var Pe = ie < 0 ? -A(-ie) : A(ie);
      if (Pe !== ie) {
        var Qe = String(Pe), Oe = y.call(ae, Qe.length + 1);
        return x.call(Qe, Ne, "$&_") + "." + x.call(x.call(Oe, /([0-9]{3})/g, "$&_"), /_$/, "");
      }
    }
    return x.call(ae, Ne, "$&_");
  }
  var P = se, H = P.custom, Q = q(H) ? H : null;
  gl = function ie(ae, Ne, Pe, Qe) {
    var Oe = Ne || {};
    if (B(Oe, "quoteStyle") && Oe.quoteStyle !== "single" && Oe.quoteStyle !== "double")
      throw new TypeError('option "quoteStyle" must be "single" or "double"');
    if (B(Oe, "maxStringLength") && (typeof Oe.maxStringLength == "number" ? Oe.maxStringLength < 0 && Oe.maxStringLength !== 1 / 0 : Oe.maxStringLength !== null))
      throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    var qt = B(Oe, "customInspect") ? Oe.customInspect : !0;
    if (typeof qt != "boolean" && qt !== "symbol")
      throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
    if (B(Oe, "indent") && Oe.indent !== null && Oe.indent !== "	" && !(parseInt(Oe.indent, 10) === Oe.indent && Oe.indent > 0))
      throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    if (B(Oe, "numericSeparator") && typeof Oe.numericSeparator != "boolean")
      throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    var Nt = Oe.numericSeparator;
    if (typeof ae > "u")
      return "undefined";
    if (ae === null)
      return "null";
    if (typeof ae == "boolean")
      return ae ? "true" : "false";
    if (typeof ae == "string")
      return ye(ae, Oe);
    if (typeof ae == "number") {
      if (ae === 0)
        return 1 / 0 / ae > 0 ? "0" : "-0";
      var ut = String(ae);
      return Nt ? L(ae, ut) : ut;
    }
    if (typeof ae == "bigint") {
      var Lt = String(ae) + "n";
      return Nt ? L(ae, Lt) : Lt;
    }
    var Cr = typeof Oe.depth > "u" ? 5 : Oe.depth;
    if (typeof Pe > "u" && (Pe = 0), Pe >= Cr && Cr > 0 && typeof ae == "object")
      return ue(ae) ? "[Array]" : "[Object]";
    var lr = Se(Oe, Pe);
    if (typeof Qe > "u")
      Qe = [];
    else if (k(Qe, ae) >= 0)
      return "[Circular]";
    function te(Zn, As, $8) {
      if (As && (Qe = C.call(Qe), Qe.push(As)), $8) {
        var Iy = {
          depth: Oe.depth
        };
        return B(Oe, "quoteStyle") && (Iy.quoteStyle = Oe.quoteStyle), ie(Zn, Iy, Pe + 1, Qe);
      }
      return ie(Zn, Oe, Pe + 1, Qe);
    }
    if (typeof ae == "function" && !J(ae)) {
      var fe = j(ae), ge = ur(ae, te);
      return "[Function" + (fe ? ": " + fe : " (anonymous)") + "]" + (ge.length > 0 ? " { " + E.call(ge, ", ") + " }" : "");
    }
    if (q(ae)) {
      var X = K ? x.call(String(ae), /^(Symbol\(.*\))_[^)]*$/, "$1") : F.call(ae);
      return typeof ae == "object" && !K ? $e(X) : X;
    }
    if (be(ae)) {
      for (var oe = "<" + w.call(String(ae.nodeName)), de = ae.attributes || [], _e = 0; _e < de.length; _e++)
        oe += " " + de[_e].name + "=" + Y(ce(de[_e].value), "double", Oe);
      return oe += ">", ae.childNodes && ae.childNodes.length && (oe += "..."), oe += "</" + w.call(String(ae.nodeName)) + ">", oe;
    }
    if (ue(ae)) {
      if (ae.length === 0)
        return "[]";
      var Le = ur(ae, te);
      return lr && !W(Le) ? "[" + cr(Le, lr) + "]" : "[ " + E.call(Le, ", ") + " ]";
    }
    if (O(ae)) {
      var Xe = ur(ae, te);
      return !("cause" in Error.prototype) && "cause" in ae && !ne.call(ae, "cause") ? "{ [" + String(ae) + "] " + E.call(T.call("[cause]: " + te(ae.cause), Xe), ", ") + " }" : Xe.length === 0 ? "[" + String(ae) + "]" : "{ [" + String(ae) + "] " + E.call(Xe, ", ") + " }";
    }
    if (typeof ae == "object" && qt) {
      if (Q && typeof ae[Q] == "function" && P)
        return P(ae, { depth: Cr - Pe });
      if (qt !== "symbol" && typeof ae.inspect == "function")
        return ae.inspect();
    }
    if (N(ae)) {
      var It = [];
      return n && n.call(ae, function(Zn, As) {
        It.push(te(As, ae, !0) + " => " + te(Zn, ae));
      }), le("Map", r.call(ae), It, lr);
    }
    if (pe(ae)) {
      var tt = [];
      return o && o.call(ae, function(Zn) {
        tt.push(te(Zn, ae));
      }), le("Set", s.call(ae), tt, lr);
    }
    if (U(ae))
      return Ce("WeakMap");
    if (he(ae))
      return Ce("WeakSet");
    if (ee(ae))
      return Ce("WeakRef");
    if (z(ae))
      return $e(te(Number(ae)));
    if (M(ae))
      return $e(te(R.call(ae)));
    if (G(ae))
      return $e(h.call(ae));
    if (I(ae))
      return $e(te(String(ae)));
    if (!me(ae) && !J(ae)) {
      var dt = ur(ae, te), zr = $ ? $(ae) === Object.prototype : ae instanceof Object || ae.constructor === Object, Qt = ae instanceof Object ? "" : "null prototype", Tr = !zr && V && Object(ae) === ae && V in ae ? y.call(re(ae), 8, -1) : Qt ? "Object" : "", Os = zr || typeof ae.constructor != "function" ? "" : ae.constructor.name ? ae.constructor.name + " " : "", Mu = Os + (Tr || Qt ? "[" + E.call(T.call([], Tr || [], Qt || []), ": ") + "] " : "");
      return dt.length === 0 ? Mu + "{}" : lr ? Mu + "{" + cr(dt, lr) + "}" : Mu + "{ " + E.call(dt, ", ") + " }";
    }
    return String(ae);
  };
  function Y(ie, ae, Ne) {
    var Pe = (Ne.quoteStyle || ae) === "double" ? '"' : "'";
    return Pe + ie + Pe;
  }
  function ce(ie) {
    return x.call(String(ie), /"/g, "&quot;");
  }
  function ue(ie) {
    return re(ie) === "[object Array]" && (!V || !(typeof ie == "object" && V in ie));
  }
  function me(ie) {
    return re(ie) === "[object Date]" && (!V || !(typeof ie == "object" && V in ie));
  }
  function J(ie) {
    return re(ie) === "[object RegExp]" && (!V || !(typeof ie == "object" && V in ie));
  }
  function O(ie) {
    return re(ie) === "[object Error]" && (!V || !(typeof ie == "object" && V in ie));
  }
  function I(ie) {
    return re(ie) === "[object String]" && (!V || !(typeof ie == "object" && V in ie));
  }
  function z(ie) {
    return re(ie) === "[object Number]" && (!V || !(typeof ie == "object" && V in ie));
  }
  function G(ie) {
    return re(ie) === "[object Boolean]" && (!V || !(typeof ie == "object" && V in ie));
  }
  function q(ie) {
    if (K)
      return ie && typeof ie == "object" && ie instanceof Symbol;
    if (typeof ie == "symbol")
      return !0;
    if (!ie || typeof ie != "object" || !F)
      return !1;
    try {
      return F.call(ie), !0;
    } catch {
    }
    return !1;
  }
  function M(ie) {
    if (!ie || typeof ie != "object" || !R)
      return !1;
    try {
      return R.call(ie), !0;
    } catch {
    }
    return !1;
  }
  var Z = Object.prototype.hasOwnProperty || function(ie) {
    return ie in this;
  };
  function B(ie, ae) {
    return Z.call(ie, ae);
  }
  function re(ie) {
    return g.call(ie);
  }
  function j(ie) {
    if (ie.name)
      return ie.name;
    var ae = d.call(v.call(ie), /^function\s*([\w$]+)/);
    return ae ? ae[1] : null;
  }
  function k(ie, ae) {
    if (ie.indexOf)
      return ie.indexOf(ae);
    for (var Ne = 0, Pe = ie.length; Ne < Pe; Ne++)
      if (ie[Ne] === ae)
        return Ne;
    return -1;
  }
  function N(ie) {
    if (!r || !ie || typeof ie != "object")
      return !1;
    try {
      r.call(ie);
      try {
        s.call(ie);
      } catch {
        return !0;
      }
      return ie instanceof Map;
    } catch {
    }
    return !1;
  }
  function U(ie) {
    if (!f || !ie || typeof ie != "object")
      return !1;
    try {
      f.call(ie, f);
      try {
        l.call(ie, l);
      } catch {
        return !0;
      }
      return ie instanceof WeakMap;
    } catch {
    }
    return !1;
  }
  function ee(ie) {
    if (!m || !ie || typeof ie != "object")
      return !1;
    try {
      return m.call(ie), !0;
    } catch {
    }
    return !1;
  }
  function pe(ie) {
    if (!s || !ie || typeof ie != "object")
      return !1;
    try {
      s.call(ie);
      try {
        r.call(ie);
      } catch {
        return !0;
      }
      return ie instanceof Set;
    } catch {
    }
    return !1;
  }
  function he(ie) {
    if (!l || !ie || typeof ie != "object")
      return !1;
    try {
      l.call(ie, l);
      try {
        f.call(ie, f);
      } catch {
        return !0;
      }
      return ie instanceof WeakSet;
    } catch {
    }
    return !1;
  }
  function be(ie) {
    return !ie || typeof ie != "object" ? !1 : typeof HTMLElement < "u" && ie instanceof HTMLElement ? !0 : typeof ie.nodeName == "string" && typeof ie.getAttribute == "function";
  }
  function ye(ie, ae) {
    if (ie.length > ae.maxStringLength) {
      var Ne = ie.length - ae.maxStringLength, Pe = "... " + Ne + " more character" + (Ne > 1 ? "s" : "");
      return ye(y.call(ie, 0, ae.maxStringLength), ae) + Pe;
    }
    var Qe = x.call(x.call(ie, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, Ee);
    return Y(Qe, "single", ae);
  }
  function Ee(ie) {
    var ae = ie.charCodeAt(0), Ne = {
      8: "b",
      9: "t",
      10: "n",
      12: "f",
      13: "r"
    }[ae];
    return Ne ? "\\" + Ne : "\\x" + (ae < 16 ? "0" : "") + b.call(ae.toString(16));
  }
  function $e(ie) {
    return "Object(" + ie + ")";
  }
  function Ce(ie) {
    return ie + " { ? }";
  }
  function le(ie, ae, Ne, Pe) {
    var Qe = Pe ? cr(Ne, Pe) : E.call(Ne, ", ");
    return ie + " (" + ae + ") {" + Qe + "}";
  }
  function W(ie) {
    for (var ae = 0; ae < ie.length; ae++)
      if (k(ie[ae], `
`) >= 0)
        return !1;
    return !0;
  }
  function Se(ie, ae) {
    var Ne;
    if (ie.indent === "	")
      Ne = "	";
    else if (typeof ie.indent == "number" && ie.indent > 0)
      Ne = E.call(Array(ie.indent + 1), " ");
    else
      return null;
    return {
      base: Ne,
      prev: E.call(Array(ae + 1), Ne)
    };
  }
  function cr(ie, ae) {
    if (ie.length === 0)
      return "";
    var Ne = `
` + ae.prev + ae.base;
    return Ne + E.call(ie, "," + Ne) + `
` + ae.prev;
  }
  function ur(ie, ae) {
    var Ne = ue(ie), Pe = [];
    if (Ne) {
      Pe.length = ie.length;
      for (var Qe = 0; Qe < ie.length; Qe++)
        Pe[Qe] = B(ie, Qe) ? ae(ie[Qe], ie) : "";
    }
    var Oe = typeof D == "function" ? D(ie) : [], qt;
    if (K) {
      qt = {};
      for (var Nt = 0; Nt < Oe.length; Nt++)
        qt["$" + Oe[Nt]] = Oe[Nt];
    }
    for (var ut in ie)
      B(ie, ut) && (Ne && String(Number(ut)) === ut && ut < ie.length || K && qt["$" + ut] instanceof Symbol || (S.call(/[^\w$]/, ut) ? Pe.push(ae(ut, ie) + ": " + ae(ie[ut], ie)) : Pe.push(ut + ": " + ae(ie[ut], ie))));
    if (typeof D == "function")
      for (var Lt = 0; Lt < Oe.length; Lt++)
        ne.call(ie, Oe[Lt]) && Pe.push("[" + ae(Oe[Lt]) + "]: " + ae(ie[Oe[Lt]], ie));
    return Pe;
  }
  return gl;
}
var vl, Eb;
function JI() {
  if (Eb)
    return vl;
  Eb = 1;
  var t = Cg(), e = VI(), r = KI(), n = t("%TypeError%"), i = t("%WeakMap%", !0), a = t("%Map%", !0), s = e("WeakMap.prototype.get", !0), o = e("WeakMap.prototype.set", !0), c = e("WeakMap.prototype.has", !0), f = e("Map.prototype.get", !0), u = e("Map.prototype.set", !0), l = e("Map.prototype.has", !0), p = function(v, d) {
    for (var y = v, x; (x = y.next) !== null; y = x)
      if (x.key === d)
        return y.next = x.next, x.next = v.next, v.next = x, x;
  }, m = function(v, d) {
    var y = p(v, d);
    return y && y.value;
  }, h = function(v, d, y) {
    var x = p(v, d);
    x ? x.value = y : v.next = {
      // eslint-disable-line no-param-reassign
      key: d,
      next: v.next,
      value: y
    };
  }, g = function(v, d) {
    return !!p(v, d);
  };
  return vl = function() {
    var d, y, x, b = {
      assert: function(w) {
        if (!b.has(w))
          throw new n("Side channel does not contain " + r(w));
      },
      get: function(w) {
        if (i && w && (typeof w == "object" || typeof w == "function")) {
          if (d)
            return s(d, w);
        } else if (a) {
          if (y)
            return f(y, w);
        } else if (x)
          return m(x, w);
      },
      has: function(w) {
        if (i && w && (typeof w == "object" || typeof w == "function")) {
          if (d)
            return c(d, w);
        } else if (a) {
          if (y)
            return l(y, w);
        } else if (x)
          return g(x, w);
        return !1;
      },
      set: function(w, S) {
        i && w && (typeof w == "object" || typeof w == "function") ? (d || (d = new i()), o(d, w, S)) : a ? (y || (y = new a()), u(y, w, S)) : (x || (x = { key: {}, next: null }), h(x, w, S));
      }
    };
    return b;
  }, vl;
}
var yl, Sb;
function Tg() {
  if (Sb)
    return yl;
  Sb = 1;
  var t = String.prototype.replace, e = /%20/g, r = {
    RFC1738: "RFC1738",
    RFC3986: "RFC3986"
  };
  return yl = {
    default: r.RFC3986,
    formatters: {
      RFC1738: function(n) {
        return t.call(n, e, "+");
      },
      RFC3986: function(n) {
        return String(n);
      }
    },
    RFC1738: r.RFC1738,
    RFC3986: r.RFC3986
  }, yl;
}
var bl, Cb;
function E2() {
  if (Cb)
    return bl;
  Cb = 1;
  var t = Tg(), e = Object.prototype.hasOwnProperty, r = Array.isArray, n = function() {
    for (var g = [], v = 0; v < 256; ++v)
      g.push("%" + ((v < 16 ? "0" : "") + v.toString(16)).toUpperCase());
    return g;
  }(), i = function(v) {
    for (; v.length > 1; ) {
      var d = v.pop(), y = d.obj[d.prop];
      if (r(y)) {
        for (var x = [], b = 0; b < y.length; ++b)
          typeof y[b] < "u" && x.push(y[b]);
        d.obj[d.prop] = x;
      }
    }
  }, a = function(v, d) {
    for (var y = d && d.plainObjects ? /* @__PURE__ */ Object.create(null) : {}, x = 0; x < v.length; ++x)
      typeof v[x] < "u" && (y[x] = v[x]);
    return y;
  }, s = function g(v, d, y) {
    if (!d)
      return v;
    if (typeof d != "object") {
      if (r(v))
        v.push(d);
      else if (v && typeof v == "object")
        (y && (y.plainObjects || y.allowPrototypes) || !e.call(Object.prototype, d)) && (v[d] = !0);
      else
        return [v, d];
      return v;
    }
    if (!v || typeof v != "object")
      return [v].concat(d);
    var x = v;
    return r(v) && !r(d) && (x = a(v, y)), r(v) && r(d) ? (d.forEach(function(b, w) {
      if (e.call(v, w)) {
        var S = v[w];
        S && typeof S == "object" && b && typeof b == "object" ? v[w] = g(S, b, y) : v.push(b);
      } else
        v[w] = b;
    }), v) : Object.keys(d).reduce(function(b, w) {
      var S = d[w];
      return e.call(b, w) ? b[w] = g(b[w], S, y) : b[w] = S, b;
    }, x);
  }, o = function(v, d) {
    return Object.keys(d).reduce(function(y, x) {
      return y[x] = d[x], y;
    }, v);
  }, c = function(g, v, d) {
    var y = g.replace(/\+/g, " ");
    if (d === "iso-8859-1")
      return y.replace(/%[0-9a-f]{2}/gi, unescape);
    try {
      return decodeURIComponent(y);
    } catch {
      return y;
    }
  }, f = function(v, d, y, x, b) {
    if (v.length === 0)
      return v;
    var w = v;
    if (typeof v == "symbol" ? w = Symbol.prototype.toString.call(v) : typeof v != "string" && (w = String(v)), y === "iso-8859-1")
      return escape(w).replace(/%u[0-9a-f]{4}/gi, function(C) {
        return "%26%23" + parseInt(C.slice(2), 16) + "%3B";
      });
    for (var S = "", T = 0; T < w.length; ++T) {
      var E = w.charCodeAt(T);
      if (E === 45 || E === 46 || E === 95 || E === 126 || E >= 48 && E <= 57 || E >= 65 && E <= 90 || E >= 97 && E <= 122 || b === t.RFC1738 && (E === 40 || E === 41)) {
        S += w.charAt(T);
        continue;
      }
      if (E < 128) {
        S = S + n[E];
        continue;
      }
      if (E < 2048) {
        S = S + (n[192 | E >> 6] + n[128 | E & 63]);
        continue;
      }
      if (E < 55296 || E >= 57344) {
        S = S + (n[224 | E >> 12] + n[128 | E >> 6 & 63] + n[128 | E & 63]);
        continue;
      }
      T += 1, E = 65536 + ((E & 1023) << 10 | w.charCodeAt(T) & 1023), S += n[240 | E >> 18] + n[128 | E >> 12 & 63] + n[128 | E >> 6 & 63] + n[128 | E & 63];
    }
    return S;
  }, u = function(v) {
    for (var d = [{ obj: { o: v }, prop: "o" }], y = [], x = 0; x < d.length; ++x)
      for (var b = d[x], w = b.obj[b.prop], S = Object.keys(w), T = 0; T < S.length; ++T) {
        var E = S[T], C = w[E];
        typeof C == "object" && C !== null && y.indexOf(C) === -1 && (d.push({ obj: w, prop: E }), y.push(C));
      }
    return i(d), v;
  }, l = function(v) {
    return Object.prototype.toString.call(v) === "[object RegExp]";
  }, p = function(v) {
    return !v || typeof v != "object" ? !1 : !!(v.constructor && v.constructor.isBuffer && v.constructor.isBuffer(v));
  }, m = function(v, d) {
    return [].concat(v, d);
  }, h = function(v, d) {
    if (r(v)) {
      for (var y = [], x = 0; x < v.length; x += 1)
        y.push(d(v[x]));
      return y;
    }
    return d(v);
  };
  return bl = {
    arrayToObject: a,
    assign: o,
    combine: m,
    compact: u,
    decode: c,
    encode: f,
    isBuffer: p,
    isRegExp: l,
    maybeMap: h,
    merge: s
  }, bl;
}
var wl, Tb;
function XI() {
  if (Tb)
    return wl;
  Tb = 1;
  var t = JI(), e = E2(), r = Tg(), n = Object.prototype.hasOwnProperty, i = {
    brackets: function(d) {
      return d + "[]";
    },
    comma: "comma",
    indices: function(d, y) {
      return d + "[" + y + "]";
    },
    repeat: function(d) {
      return d;
    }
  }, a = Array.isArray, s = String.prototype.split, o = Array.prototype.push, c = function(v, d) {
    o.apply(v, a(d) ? d : [d]);
  }, f = Date.prototype.toISOString, u = r.default, l = {
    addQueryPrefix: !1,
    allowDots: !1,
    charset: "utf-8",
    charsetSentinel: !1,
    delimiter: "&",
    encode: !0,
    encoder: e.encode,
    encodeValuesOnly: !1,
    format: u,
    formatter: r.formatters[u],
    // deprecated
    indices: !1,
    serializeDate: function(d) {
      return f.call(d);
    },
    skipNulls: !1,
    strictNullHandling: !1
  }, p = function(d) {
    return typeof d == "string" || typeof d == "number" || typeof d == "boolean" || typeof d == "symbol" || typeof d == "bigint";
  }, m = {}, h = function v(d, y, x, b, w, S, T, E, C, A, R, D, F, K, V, ne) {
    for (var $ = d, L = ne, P = 0, H = !1; (L = L.get(m)) !== void 0 && !H; ) {
      var Q = L.get(d);
      if (P += 1, typeof Q < "u") {
        if (Q === P)
          throw new RangeError("Cyclic object value");
        H = !0;
      }
      typeof L.get(m) > "u" && (P = 0);
    }
    if (typeof E == "function" ? $ = E(y, $) : $ instanceof Date ? $ = R($) : x === "comma" && a($) && ($ = e.maybeMap($, function(re) {
      return re instanceof Date ? R(re) : re;
    })), $ === null) {
      if (w)
        return T && !K ? T(y, l.encoder, V, "key", D) : y;
      $ = "";
    }
    if (p($) || e.isBuffer($)) {
      if (T) {
        var Y = K ? y : T(y, l.encoder, V, "key", D);
        if (x === "comma" && K) {
          for (var ce = s.call(String($), ","), ue = "", me = 0; me < ce.length; ++me)
            ue += (me === 0 ? "" : ",") + F(T(ce[me], l.encoder, V, "value", D));
          return [F(Y) + (b && a($) && ce.length === 1 ? "[]" : "") + "=" + ue];
        }
        return [F(Y) + "=" + F(T($, l.encoder, V, "value", D))];
      }
      return [F(y) + "=" + F(String($))];
    }
    var J = [];
    if (typeof $ > "u")
      return J;
    var O;
    if (x === "comma" && a($))
      O = [{ value: $.length > 0 ? $.join(",") || null : void 0 }];
    else if (a(E))
      O = E;
    else {
      var I = Object.keys($);
      O = C ? I.sort(C) : I;
    }
    for (var z = b && a($) && $.length === 1 ? y + "[]" : y, G = 0; G < O.length; ++G) {
      var q = O[G], M = typeof q == "object" && typeof q.value < "u" ? q.value : $[q];
      if (!(S && M === null)) {
        var Z = a($) ? typeof x == "function" ? x(z, q) : z : z + (A ? "." + q : "[" + q + "]");
        ne.set(d, P);
        var B = t();
        B.set(m, ne), c(J, v(
          M,
          Z,
          x,
          b,
          w,
          S,
          T,
          E,
          C,
          A,
          R,
          D,
          F,
          K,
          V,
          B
        ));
      }
    }
    return J;
  }, g = function(d) {
    if (!d)
      return l;
    if (d.encoder !== null && typeof d.encoder < "u" && typeof d.encoder != "function")
      throw new TypeError("Encoder has to be a function.");
    var y = d.charset || l.charset;
    if (typeof d.charset < "u" && d.charset !== "utf-8" && d.charset !== "iso-8859-1")
      throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    var x = r.default;
    if (typeof d.format < "u") {
      if (!n.call(r.formatters, d.format))
        throw new TypeError("Unknown format option provided.");
      x = d.format;
    }
    var b = r.formatters[x], w = l.filter;
    return (typeof d.filter == "function" || a(d.filter)) && (w = d.filter), {
      addQueryPrefix: typeof d.addQueryPrefix == "boolean" ? d.addQueryPrefix : l.addQueryPrefix,
      allowDots: typeof d.allowDots > "u" ? l.allowDots : !!d.allowDots,
      charset: y,
      charsetSentinel: typeof d.charsetSentinel == "boolean" ? d.charsetSentinel : l.charsetSentinel,
      delimiter: typeof d.delimiter > "u" ? l.delimiter : d.delimiter,
      encode: typeof d.encode == "boolean" ? d.encode : l.encode,
      encoder: typeof d.encoder == "function" ? d.encoder : l.encoder,
      encodeValuesOnly: typeof d.encodeValuesOnly == "boolean" ? d.encodeValuesOnly : l.encodeValuesOnly,
      filter: w,
      format: x,
      formatter: b,
      serializeDate: typeof d.serializeDate == "function" ? d.serializeDate : l.serializeDate,
      skipNulls: typeof d.skipNulls == "boolean" ? d.skipNulls : l.skipNulls,
      sort: typeof d.sort == "function" ? d.sort : null,
      strictNullHandling: typeof d.strictNullHandling == "boolean" ? d.strictNullHandling : l.strictNullHandling
    };
  };
  return wl = function(v, d) {
    var y = v, x = g(d), b, w;
    typeof x.filter == "function" ? (w = x.filter, y = w("", y)) : a(x.filter) && (w = x.filter, b = w);
    var S = [];
    if (typeof y != "object" || y === null)
      return "";
    var T;
    d && d.arrayFormat in i ? T = d.arrayFormat : d && "indices" in d ? T = d.indices ? "indices" : "repeat" : T = "indices";
    var E = i[T];
    if (d && "commaRoundTrip" in d && typeof d.commaRoundTrip != "boolean")
      throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
    var C = E === "comma" && d && d.commaRoundTrip;
    b || (b = Object.keys(y)), x.sort && b.sort(x.sort);
    for (var A = t(), R = 0; R < b.length; ++R) {
      var D = b[R];
      x.skipNulls && y[D] === null || c(S, h(
        y[D],
        D,
        E,
        C,
        x.strictNullHandling,
        x.skipNulls,
        x.encode ? x.encoder : null,
        x.filter,
        x.sort,
        x.allowDots,
        x.serializeDate,
        x.format,
        x.formatter,
        x.encodeValuesOnly,
        x.charset,
        A
      ));
    }
    var F = S.join(x.delimiter), K = x.addQueryPrefix === !0 ? "?" : "";
    return x.charsetSentinel && (x.charset === "iso-8859-1" ? K += "utf8=%26%2310003%3B&" : K += "utf8=%E2%9C%93&"), F.length > 0 ? K + F : "";
  }, wl;
}
var xl, Ob;
function ZI() {
  if (Ob)
    return xl;
  Ob = 1;
  var t = E2(), e = Object.prototype.hasOwnProperty, r = Array.isArray, n = {
    allowDots: !1,
    allowPrototypes: !1,
    allowSparse: !1,
    arrayLimit: 20,
    charset: "utf-8",
    charsetSentinel: !1,
    comma: !1,
    decoder: t.decode,
    delimiter: "&",
    depth: 5,
    ignoreQueryPrefix: !1,
    interpretNumericEntities: !1,
    parameterLimit: 1e3,
    parseArrays: !0,
    plainObjects: !1,
    strictNullHandling: !1
  }, i = function(p) {
    return p.replace(/&#(\d+);/g, function(m, h) {
      return String.fromCharCode(parseInt(h, 10));
    });
  }, a = function(p, m) {
    return p && typeof p == "string" && m.comma && p.indexOf(",") > -1 ? p.split(",") : p;
  }, s = "utf8=%26%2310003%3B", o = "utf8=%E2%9C%93", c = function(m, h) {
    var g = {}, v = h.ignoreQueryPrefix ? m.replace(/^\?/, "") : m, d = h.parameterLimit === 1 / 0 ? void 0 : h.parameterLimit, y = v.split(h.delimiter, d), x = -1, b, w = h.charset;
    if (h.charsetSentinel)
      for (b = 0; b < y.length; ++b)
        y[b].indexOf("utf8=") === 0 && (y[b] === o ? w = "utf-8" : y[b] === s && (w = "iso-8859-1"), x = b, b = y.length);
    for (b = 0; b < y.length; ++b)
      if (b !== x) {
        var S = y[b], T = S.indexOf("]="), E = T === -1 ? S.indexOf("=") : T + 1, C, A;
        E === -1 ? (C = h.decoder(S, n.decoder, w, "key"), A = h.strictNullHandling ? null : "") : (C = h.decoder(S.slice(0, E), n.decoder, w, "key"), A = t.maybeMap(
          a(S.slice(E + 1), h),
          function(R) {
            return h.decoder(R, n.decoder, w, "value");
          }
        )), A && h.interpretNumericEntities && w === "iso-8859-1" && (A = i(A)), S.indexOf("[]=") > -1 && (A = r(A) ? [A] : A), e.call(g, C) ? g[C] = t.combine(g[C], A) : g[C] = A;
      }
    return g;
  }, f = function(p, m, h, g) {
    for (var v = g ? m : a(m, h), d = p.length - 1; d >= 0; --d) {
      var y, x = p[d];
      if (x === "[]" && h.parseArrays)
        y = [].concat(v);
      else {
        y = h.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
        var b = x.charAt(0) === "[" && x.charAt(x.length - 1) === "]" ? x.slice(1, -1) : x, w = parseInt(b, 10);
        !h.parseArrays && b === "" ? y = { 0: v } : !isNaN(w) && x !== b && String(w) === b && w >= 0 && h.parseArrays && w <= h.arrayLimit ? (y = [], y[w] = v) : b !== "__proto__" && (y[b] = v);
      }
      v = y;
    }
    return v;
  }, u = function(m, h, g, v) {
    if (m) {
      var d = g.allowDots ? m.replace(/\.([^.[]+)/g, "[$1]") : m, y = /(\[[^[\]]*])/, x = /(\[[^[\]]*])/g, b = g.depth > 0 && y.exec(d), w = b ? d.slice(0, b.index) : d, S = [];
      if (w) {
        if (!g.plainObjects && e.call(Object.prototype, w) && !g.allowPrototypes)
          return;
        S.push(w);
      }
      for (var T = 0; g.depth > 0 && (b = x.exec(d)) !== null && T < g.depth; ) {
        if (T += 1, !g.plainObjects && e.call(Object.prototype, b[1].slice(1, -1)) && !g.allowPrototypes)
          return;
        S.push(b[1]);
      }
      return b && S.push("[" + d.slice(b.index) + "]"), f(S, h, g, v);
    }
  }, l = function(m) {
    if (!m)
      return n;
    if (m.decoder !== null && m.decoder !== void 0 && typeof m.decoder != "function")
      throw new TypeError("Decoder has to be a function.");
    if (typeof m.charset < "u" && m.charset !== "utf-8" && m.charset !== "iso-8859-1")
      throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    var h = typeof m.charset > "u" ? n.charset : m.charset;
    return {
      allowDots: typeof m.allowDots > "u" ? n.allowDots : !!m.allowDots,
      allowPrototypes: typeof m.allowPrototypes == "boolean" ? m.allowPrototypes : n.allowPrototypes,
      allowSparse: typeof m.allowSparse == "boolean" ? m.allowSparse : n.allowSparse,
      arrayLimit: typeof m.arrayLimit == "number" ? m.arrayLimit : n.arrayLimit,
      charset: h,
      charsetSentinel: typeof m.charsetSentinel == "boolean" ? m.charsetSentinel : n.charsetSentinel,
      comma: typeof m.comma == "boolean" ? m.comma : n.comma,
      decoder: typeof m.decoder == "function" ? m.decoder : n.decoder,
      delimiter: typeof m.delimiter == "string" || t.isRegExp(m.delimiter) ? m.delimiter : n.delimiter,
      // eslint-disable-next-line no-implicit-coercion, no-extra-parens
      depth: typeof m.depth == "number" || m.depth === !1 ? +m.depth : n.depth,
      ignoreQueryPrefix: m.ignoreQueryPrefix === !0,
      interpretNumericEntities: typeof m.interpretNumericEntities == "boolean" ? m.interpretNumericEntities : n.interpretNumericEntities,
      parameterLimit: typeof m.parameterLimit == "number" ? m.parameterLimit : n.parameterLimit,
      parseArrays: m.parseArrays !== !1,
      plainObjects: typeof m.plainObjects == "boolean" ? m.plainObjects : n.plainObjects,
      strictNullHandling: typeof m.strictNullHandling == "boolean" ? m.strictNullHandling : n.strictNullHandling
    };
  };
  return xl = function(p, m) {
    var h = l(m);
    if (p === "" || p === null || typeof p > "u")
      return h.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
    for (var g = typeof p == "string" ? c(p, h) : p, v = h.plainObjects ? /* @__PURE__ */ Object.create(null) : {}, d = Object.keys(g), y = 0; y < d.length; ++y) {
      var x = d[y], b = u(x, g[x], h, typeof p == "string");
      v = t.merge(v, b, h);
    }
    return h.allowSparse === !0 ? v : t.compact(v);
  }, xl;
}
var _l, Ab;
function Sc() {
  if (Ab)
    return _l;
  Ab = 1;
  var t = XI(), e = ZI(), r = Tg();
  return _l = {
    formats: r,
    parse: e,
    stringify: t
  }, _l;
}
/*!
 * body-parser
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var El, $b;
function YI() {
  if ($b)
    return El;
  $b = 1;
  var t = vr(), e = An(), r = yr(), n = Mr("body-parser:urlencoded");
  tr("body-parser");
  var i = Ec(), a = qr();
  El = o;
  var s = /* @__PURE__ */ Object.create(null);
  function o(h) {
    var g = h || {};
    g.extended;
    var v = g.extended !== !1, d = g.inflate !== !1, y = typeof g.limit != "number" ? t.parse(g.limit || "100kb") : g.limit, x = g.type || "application/x-www-form-urlencoded", b = g.verify || !1;
    if (b !== !1 && typeof b != "function")
      throw new TypeError("option verify must be function");
    var w = v ? c(g) : p(g), S = typeof x != "function" ? m(x) : x;
    function T(E) {
      return E.length ? w(E) : {};
    }
    return function(C, A, R) {
      if (C._body) {
        n("body already parsed"), R();
        return;
      }
      if (C.body = C.body || {}, !a.hasBody(C)) {
        n("skip empty body"), R();
        return;
      }
      if (n("content-type %j", C.headers["content-type"]), !S(C)) {
        n("skip parsing"), R();
        return;
      }
      var D = f(C) || "utf-8";
      if (D !== "utf-8") {
        n("invalid charset"), R(r(415, 'unsupported charset "' + D.toUpperCase() + '"', {
          charset: D,
          type: "charset.unsupported"
        }));
        return;
      }
      i(C, A, R, T, n, {
        debug: n,
        encoding: D,
        inflate: d,
        limit: y,
        verify: b
      });
    };
  }
  function c(h) {
    var g = h.parameterLimit !== void 0 ? h.parameterLimit : 1e3, v = l("qs");
    if (isNaN(g) || g < 1)
      throw new TypeError("option parameterLimit must be a positive number");
    return isFinite(g) && (g = g | 0), function(y) {
      var x = u(y, g);
      if (x === void 0)
        throw n("too many parameters"), r(413, "too many parameters", {
          type: "parameters.too.many"
        });
      var b = Math.max(100, x);
      return n("parse extended urlencoding"), v(y, {
        allowPrototypes: !0,
        arrayLimit: b,
        depth: 1 / 0,
        parameterLimit: g
      });
    };
  }
  function f(h) {
    try {
      return (e.parse(h).parameters.charset || "").toLowerCase();
    } catch {
      return;
    }
  }
  function u(h, g) {
    for (var v = 0, d = 0; (d = h.indexOf("&", d)) !== -1; )
      if (v++, d++, v === g)
        return;
    return v;
  }
  function l(h) {
    var g = s[h];
    if (g !== void 0)
      return g.parse;
    switch (h) {
      case "qs":
        g = Sc();
        break;
      case "querystring":
        g = se;
        break;
    }
    return s[h] = g, g.parse;
  }
  function p(h) {
    var g = h.parameterLimit !== void 0 ? h.parameterLimit : 1e3, v = l("querystring");
    if (isNaN(g) || g < 1)
      throw new TypeError("option parameterLimit must be a positive number");
    return isFinite(g) && (g = g | 0), function(y) {
      var x = u(y, g);
      if (x === void 0)
        throw n("too many parameters"), r(413, "too many parameters", {
          type: "parameters.too.many"
        });
      return n("parse urlencoding"), v(y, void 0, void 0, { maxKeys: g });
    };
  }
  function m(h) {
    return function(v) {
      return !!a(v, h);
    };
  }
  return El;
}
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
(function(t, e) {
  var r = tr("body-parser"), n = /* @__PURE__ */ Object.create(null);
  e = t.exports = r.function(
    i,
    "bodyParser: use individual json/urlencoded middlewares"
  ), Object.defineProperty(e, "json", {
    configurable: !0,
    enumerable: !0,
    get: a("json")
  }), Object.defineProperty(e, "raw", {
    configurable: !0,
    enumerable: !0,
    get: a("raw")
  }), Object.defineProperty(e, "text", {
    configurable: !0,
    enumerable: !0,
    get: a("text")
  }), Object.defineProperty(e, "urlencoded", {
    configurable: !0,
    enumerable: !0,
    get: a("urlencoded")
  });
  function i(o) {
    var c = Object.create(o || null, {
      type: {
        configurable: !0,
        enumerable: !0,
        value: void 0,
        writable: !0
      }
    }), f = e.urlencoded(c), u = e.json(c);
    return function(p, m, h) {
      u(p, m, function(g) {
        if (g)
          return h(g);
        f(p, m, h);
      });
    };
  }
  function a(o) {
    return function() {
      return s(o);
    };
  }
  function s(o) {
    var c = n[o];
    if (c !== void 0)
      return c;
    switch (o) {
      case "json":
        c = jI();
        break;
      case "raw":
        c = FI();
        break;
      case "text":
        c = BI();
        break;
      case "urlencoded":
        c = YI();
        break;
    }
    return n[o] = c;
  }
})(pm, pm.exports);
var ek = pm.exports;
/*!
 * merge-descriptors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var tk = nk, rk = Object.prototype.hasOwnProperty;
function nk(t, e, r) {
  if (!t)
    throw new TypeError("argument dest is required");
  if (!e)
    throw new TypeError("argument src is required");
  return r === void 0 && (r = !0), Object.getOwnPropertyNames(e).forEach(function(i) {
    if (!(!r && rk.call(t, i))) {
      var a = Object.getOwnPropertyDescriptor(e, i);
      Object.defineProperty(t, i, a);
    }
  }), t;
}
var S2 = { exports: {} }, mm = { exports: {} }, gm = { exports: {} }, Ca = 1e3, Ta = Ca * 60, Oa = Ta * 60, Aa = Oa * 24, ik = Aa * 365.25, ak = function(t, e) {
  e = e || {};
  var r = typeof t;
  if (r === "string" && t.length > 0)
    return sk(t);
  if (r === "number" && isNaN(t) === !1)
    return e.long ? ck(t) : ok(t);
  throw new Error(
    "val is not a non-empty string or a valid number. val=" + JSON.stringify(t)
  );
};
function sk(t) {
  if (t = String(t), !(t.length > 100)) {
    var e = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
      t
    );
    if (e) {
      var r = parseFloat(e[1]), n = (e[2] || "ms").toLowerCase();
      switch (n) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return r * ik;
        case "days":
        case "day":
        case "d":
          return r * Aa;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return r * Oa;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return r * Ta;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return r * Ca;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return r;
        default:
          return;
      }
    }
  }
}
function ok(t) {
  return t >= Aa ? Math.round(t / Aa) + "d" : t >= Oa ? Math.round(t / Oa) + "h" : t >= Ta ? Math.round(t / Ta) + "m" : t >= Ca ? Math.round(t / Ca) + "s" : t + "ms";
}
function ck(t) {
  return Ps(t, Aa, "day") || Ps(t, Oa, "hour") || Ps(t, Ta, "minute") || Ps(t, Ca, "second") || t + " ms";
}
function Ps(t, e, r) {
  if (!(t < e))
    return t < e * 1.5 ? Math.floor(t / e) + " " + r : Math.ceil(t / e) + " " + r + "s";
}
(function(t, e) {
  e = t.exports = i.debug = i.default = i, e.coerce = c, e.disable = s, e.enable = a, e.enabled = o, e.humanize = ak, e.names = [], e.skips = [], e.formatters = {};
  var r;
  function n(f) {
    var u = 0, l;
    for (l in f)
      u = (u << 5) - u + f.charCodeAt(l), u |= 0;
    return e.colors[Math.abs(u) % e.colors.length];
  }
  function i(f) {
    function u() {
      if (u.enabled) {
        var l = u, p = +/* @__PURE__ */ new Date(), m = p - (r || p);
        l.diff = m, l.prev = r, l.curr = p, r = p;
        for (var h = new Array(arguments.length), g = 0; g < h.length; g++)
          h[g] = arguments[g];
        h[0] = e.coerce(h[0]), typeof h[0] != "string" && h.unshift("%O");
        var v = 0;
        h[0] = h[0].replace(/%([a-zA-Z%])/g, function(y, x) {
          if (y === "%%")
            return y;
          v++;
          var b = e.formatters[x];
          if (typeof b == "function") {
            var w = h[v];
            y = b.call(l, w), h.splice(v, 1), v--;
          }
          return y;
        }), e.formatArgs.call(l, h);
        var d = u.log || e.log || console.log.bind(console);
        d.apply(l, h);
      }
    }
    return u.namespace = f, u.enabled = e.enabled(f), u.useColors = e.useColors(), u.color = n(f), typeof e.init == "function" && e.init(u), u;
  }
  function a(f) {
    e.save(f), e.names = [], e.skips = [];
    for (var u = (typeof f == "string" ? f : "").split(/[\s,]+/), l = u.length, p = 0; p < l; p++)
      u[p] && (f = u[p].replace(/\*/g, ".*?"), f[0] === "-" ? e.skips.push(new RegExp("^" + f.substr(1) + "$")) : e.names.push(new RegExp("^" + f + "$")));
  }
  function s() {
    e.enable("");
  }
  function o(f) {
    var u, l;
    for (u = 0, l = e.skips.length; u < l; u++)
      if (e.skips[u].test(f))
        return !1;
    for (u = 0, l = e.names.length; u < l; u++)
      if (e.names[u].test(f))
        return !0;
    return !1;
  }
  function c(f) {
    return f instanceof Error ? f.stack || f.message : f;
  }
})(gm, gm.exports);
var uk = gm.exports;
(function(t, e) {
  e = t.exports = uk, e.log = i, e.formatArgs = n, e.save = a, e.load = s, e.useColors = r, e.storage = typeof chrome < "u" && typeof chrome.storage < "u" ? chrome.storage.local : o(), e.colors = [
    "lightseagreen",
    "forestgreen",
    "goldenrod",
    "dodgerblue",
    "darkorchid",
    "crimson"
  ];
  function r() {
    return typeof window < "u" && window.process && window.process.type === "renderer" ? !0 : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  e.formatters.j = function(c) {
    try {
      return JSON.stringify(c);
    } catch (f) {
      return "[UnexpectedJSONParseError]: " + f.message;
    }
  };
  function n(c) {
    var f = this.useColors;
    if (c[0] = (f ? "%c" : "") + this.namespace + (f ? " %c" : " ") + c[0] + (f ? "%c " : " ") + "+" + e.humanize(this.diff), !!f) {
      var u = "color: " + this.color;
      c.splice(1, 0, u, "color: inherit");
      var l = 0, p = 0;
      c[0].replace(/%[a-zA-Z%]/g, function(m) {
        m !== "%%" && (l++, m === "%c" && (p = l));
      }), c.splice(p, 0, u);
    }
  }
  function i() {
    return typeof console == "object" && console.log && Function.prototype.apply.call(console.log, console, arguments);
  }
  function a(c) {
    try {
      c == null ? e.storage.removeItem("debug") : e.storage.debug = c;
    } catch {
    }
  }
  function s() {
    var c;
    try {
      c = e.storage.debug;
    } catch {
    }
    return !c && typeof process < "u" && "env" in process && (c = process.env.DEBUG), c;
  }
  e.enable(s());
  function o() {
    try {
      return window.localStorage;
    } catch {
    }
  }
})(mm, mm.exports);
var lk = mm.exports;
/*!
 * encodeurl
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var Cc = dk, pk = /(?:[^\x21\x25\x26-\x3B\x3D\x3F-\x5B\x5D\x5F\x61-\x7A\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g, fk = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g, hk = "$1$2";
function dk(t) {
  return String(t).replace(fk, hk).replace(pk, encodeURI);
}
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */
var mk = /["'&<>]/, Tc = gk;
function gk(t) {
  var e = "" + t, r = mk.exec(e);
  if (!r)
    return e;
  var n, i = "", a = 0, s = 0;
  for (a = r.index; a < e.length; a++) {
    switch (e.charCodeAt(a)) {
      case 34:
        n = "&quot;";
        break;
      case 38:
        n = "&amp;";
        break;
      case 39:
        n = "&#39;";
        break;
      case 60:
        n = "&lt;";
        break;
      case 62:
        n = "&gt;";
        break;
      default:
        continue;
    }
    s !== a && (i += e.substring(s, a)), s = a + 1, i += n;
  }
  return s !== a ? i + e.substring(s, a) : i;
}
var Og = { exports: {} };
/*!
 * parseurl
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
var C2 = se, Ib = C2.parse, Lo = C2.Url;
Og.exports = T2;
Og.exports.original = vk;
function T2(t) {
  var e = t.url;
  if (e !== void 0) {
    var r = t._parsedUrl;
    return A2(e, r) ? r : (r = O2(e), r._raw = e, t._parsedUrl = r);
  }
}
function vk(t) {
  var e = t.originalUrl;
  if (typeof e != "string")
    return T2(t);
  var r = t._parsedOriginalUrl;
  return A2(e, r) ? r : (r = O2(e), r._raw = e, t._parsedOriginalUrl = r);
}
function O2(t) {
  if (typeof t != "string" || t.charCodeAt(0) !== 47)
    return Ib(t);
  for (var e = t, r = null, n = null, i = 1; i < t.length; i++)
    switch (t.charCodeAt(i)) {
      case 63:
        n === null && (e = t.substring(0, i), r = t.substring(i + 1), n = t.substring(i));
        break;
      case 9:
      case 10:
      case 12:
      case 13:
      case 32:
      case 35:
      case 160:
      case 65279:
        return Ib(t);
    }
  var a = Lo !== void 0 ? new Lo() : {};
  return a.path = t, a.href = t, a.pathname = e, n !== null && (a.query = r, a.search = n), a;
}
function A2(t, e) {
  return typeof e == "object" && e !== null && (Lo === void 0 || e instanceof Lo) && e._raw === t;
}
var ts = Og.exports;
/*!
 * finalhandler
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var Sl = lk("finalhandler"), yk = Cc, bk = Tc, $2 = es, wk = ts, I2 = yc, xk = Ya(), _k = /\x20{2}/g, Ek = /\n/g, Sk = typeof setImmediate == "function" ? setImmediate : function(t) {
  process.nextTick(t.bind.apply(t, arguments));
}, Ck = $2.isFinished;
function Tk(t) {
  var e = bk(t).replace(Ek, "<br>").replace(_k, " &nbsp;");
  return `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Error</title>
</head>
<body>
<pre>` + e + `</pre>
</body>
</html>
`;
}
var Ok = Ak;
function Ak(t, e, r) {
  var n = r || {}, i = n.env || process.env.NODE_ENV || "development", a = n.onerror;
  return function(s) {
    var o, c, f;
    if (!s && kb(e)) {
      Sl("cannot 404 after headers sent");
      return;
    }
    if (s ? (f = kk(s), f === void 0 ? f = Nk(e) : o = $k(s), c = Ik(s, f, i)) : (f = 404, c = "Cannot " + t.method + " " + yk(Rk(t))), Sl("default %s", f), s && a && Sk(a, s, t, e), kb(e)) {
      Sl("cannot %d after headers sent", f), t.socket.destroy();
      return;
    }
    Lk(t, e, f, o, c);
  };
}
function $k(t) {
  if (!(!t.headers || typeof t.headers != "object")) {
    for (var e = /* @__PURE__ */ Object.create(null), r = Object.keys(t.headers), n = 0; n < r.length; n++) {
      var i = r[n];
      e[i] = t.headers[i];
    }
    return e;
  }
}
function Ik(t, e, r) {
  var n;
  return r !== "production" && (n = t.stack, !n && typeof t.toString == "function" && (n = t.toString())), n || I2.message[e];
}
function kk(t) {
  if (typeof t.status == "number" && t.status >= 400 && t.status < 600)
    return t.status;
  if (typeof t.statusCode == "number" && t.statusCode >= 400 && t.statusCode < 600)
    return t.statusCode;
}
function Rk(t) {
  try {
    return wk.original(t).pathname;
  } catch {
    return "resource";
  }
}
function Nk(t) {
  var e = t.statusCode;
  return (typeof e != "number" || e < 400 || e > 599) && (e = 500), e;
}
function kb(t) {
  return typeof t.headersSent != "boolean" ? !!t._header : t.headersSent;
}
function Lk(t, e, r, n, i) {
  function a() {
    var s = Tk(i);
    if (e.statusCode = r, e.statusMessage = I2.message[r], e.removeHeader("Content-Encoding"), e.removeHeader("Content-Language"), e.removeHeader("Content-Range"), Pk(e, n), e.setHeader("Content-Security-Policy", "default-src 'none'"), e.setHeader("X-Content-Type-Options", "nosniff"), e.setHeader("Content-Type", "text/html; charset=utf-8"), e.setHeader("Content-Length", Buffer.byteLength(s, "utf8")), t.method === "HEAD") {
      e.end();
      return;
    }
    e.end(s, "utf8");
  }
  if (Ck(t)) {
    a();
    return;
  }
  xk(t), $2(t, a), t.resume();
}
function Pk(t, e) {
  if (e)
    for (var r = Object.keys(e), n = 0; n < r.length; n++) {
      var i = r[n];
      t.setHeader(i, e[i]);
    }
}
var k2 = { exports: {} }, Oc = Dk;
function R2(t, e, r) {
  for (var n = 0; n < t.length; n++) {
    var i = t[n];
    r > 0 && Array.isArray(i) ? R2(i, e, r - 1) : e.push(i);
  }
  return e;
}
function N2(t, e) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    Array.isArray(n) ? N2(n, e) : e.push(n);
  }
  return e;
}
function Dk(t, e) {
  return e == null ? N2(t, []) : R2(t, [], e);
}
var Mk = L2, Rb = /\((?!\?)/g;
function L2(t, e, r) {
  r = r || {}, e = e || [];
  var n = r.strict, i = r.end !== !1, a = r.sensitive ? "" : "i", s = 0, o = e.length, c = 0, f = 0, u;
  if (t instanceof RegExp) {
    for (; u = Rb.exec(t.source); )
      e.push({
        name: f++,
        optional: !1,
        offset: u.index
      });
    return t;
  }
  if (Array.isArray(t))
    return t = t.map(function(m) {
      return L2(m, e, r).source;
    }), new RegExp("(?:" + t.join("|") + ")", a);
  for (t = ("^" + t + (n ? "" : t[t.length - 1] === "/" ? "?" : "/?")).replace(/\/\(/g, "/(?:").replace(/([\/\.])/g, "\\$1").replace(/(\\\/)?(\\\.)?:(\w+)(\(.*?\))?(\*)?(\?)?/g, function(m, h, g, v, d, y, x, b) {
    h = h || "", g = g || "", d = d || "([^\\/" + g + "]+?)", x = x || "", e.push({
      name: v,
      optional: !!x,
      offset: b + s
    });
    var w = "" + (x ? "" : h) + "(?:" + g + (x ? h : "") + d + (y ? "((?:[\\/" + g + "].+?)?)" : "") + ")" + x;
    return s += w.length - m.length, w;
  }).replace(/\*/g, function(m, h) {
    for (var g = e.length; g-- > o && e[g].offset > h; )
      e[g].offset += 3;
    return "(.*)";
  }); u = Rb.exec(t); ) {
    for (var l = 0, p = u.index; t.charAt(--p) === "\\"; )
      l++;
    l % 2 !== 1 && ((o + c === e.length || e[o + c].offset > u.index) && e.splice(o + c, 0, {
      name: f++,
      // Unnamed matching groups must be consistently linear.
      optional: !1,
      offset: u.index
    }), c++);
  }
  return t += i ? "$" : t[t.length - 1] === "/" ? "" : "(?=\\/|$)", new RegExp(t, a);
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var qk = Mk, jk = Mr("express:router:layer"), Fk = Object.prototype.hasOwnProperty, P2 = hi;
function hi(t, e, r) {
  if (!(this instanceof hi))
    return new hi(t, e, r);
  jk("new %o", t);
  var n = e || {};
  this.handle = r, this.name = r.name || "<anonymous>", this.params = void 0, this.path = void 0, this.regexp = qk(t, this.keys = [], n), this.regexp.fast_star = t === "*", this.regexp.fast_slash = t === "/" && n.end === !1;
}
hi.prototype.handle_error = function(e, r, n, i) {
  var a = this.handle;
  if (a.length !== 4)
    return i(e);
  try {
    a(e, r, n, i);
  } catch (s) {
    i(s);
  }
};
hi.prototype.handle_request = function(e, r, n) {
  var i = this.handle;
  if (i.length > 3)
    return n();
  try {
    i(e, r, n);
  } catch (a) {
    n(a);
  }
};
hi.prototype.match = function(e) {
  var r;
  if (e != null) {
    if (this.regexp.fast_slash)
      return this.params = {}, this.path = "", !0;
    if (this.regexp.fast_star)
      return this.params = { 0: Nb(e) }, this.path = e, !0;
    r = this.regexp.exec(e);
  }
  if (!r)
    return this.params = void 0, this.path = void 0, !1;
  this.params = {}, this.path = r[0];
  for (var n = this.keys, i = this.params, a = 1; a < r.length; a++) {
    var s = n[a - 1], o = s.name, c = Nb(r[a]);
    (c !== void 0 || !Fk.call(i, o)) && (i[o] = c);
  }
  return !0;
};
function Nb(t) {
  if (typeof t != "string" || t.length === 0)
    return t;
  try {
    return decodeURIComponent(t);
  } catch (e) {
    throw e instanceof URIError && (e.message = "Failed to decode param '" + t + "'", e.status = e.statusCode = 400), e;
  }
}
/*!
 * methods
 * Copyright(c) 2013-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var Lb = se, Ag = Bk() || Uk();
function Bk() {
  return Lb.METHODS && Lb.METHODS.map(function(e) {
    return e.toLowerCase();
  });
}
function Uk() {
  return [
    "get",
    "post",
    "put",
    "head",
    "delete",
    "options",
    "trace",
    "copy",
    "lock",
    "mkcol",
    "move",
    "purge",
    "propfind",
    "proppatch",
    "unlock",
    "report",
    "mkactivity",
    "checkout",
    "merge",
    "m-search",
    "notify",
    "subscribe",
    "unsubscribe",
    "patch",
    "search",
    "connect"
  ];
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var D2 = Mr("express:router:route"), M2 = Oc, q2 = P2, zk = Ag, j2 = Array.prototype.slice, F2 = Object.prototype.toString, B2 = $i;
function $i(t) {
  this.path = t, this.stack = [], D2("new %o", t), this.methods = {};
}
$i.prototype._handles_method = function(e) {
  if (this.methods._all)
    return !0;
  var r = e.toLowerCase();
  return r === "head" && !this.methods.head && (r = "get"), !!this.methods[r];
};
$i.prototype._options = function() {
  var e = Object.keys(this.methods);
  this.methods.get && !this.methods.head && e.push("head");
  for (var r = 0; r < e.length; r++)
    e[r] = e[r].toUpperCase();
  return e;
};
$i.prototype.dispatch = function(e, r, n) {
  var i = 0, a = this.stack, s = 0;
  if (a.length === 0)
    return n();
  var o = e.method.toLowerCase();
  o === "head" && !this.methods.head && (o = "get"), e.route = this, c();
  function c(f) {
    if (f && f === "route")
      return n();
    if (f && f === "router")
      return n(f);
    if (++s > 100)
      return setImmediate(c, f);
    var u = a[i++];
    if (!u)
      return n(f);
    u.method && u.method !== o ? c(f) : f ? u.handle_error(f, e, r, c) : u.handle_request(e, r, c), s = 0;
  }
};
$i.prototype.all = function() {
  for (var e = M2(j2.call(arguments)), r = 0; r < e.length; r++) {
    var n = e[r];
    if (typeof n != "function") {
      var i = F2.call(n), a = "Route.all() requires a callback function but got a " + i;
      throw new TypeError(a);
    }
    var s = q2("/", {}, n);
    s.method = void 0, this.methods._all = !0, this.stack.push(s);
  }
  return this;
};
zk.forEach(function(t) {
  $i.prototype[t] = function() {
    for (var e = M2(j2.call(arguments)), r = 0; r < e.length; r++) {
      var n = e[r];
      if (typeof n != "function") {
        var i = F2.call(n), a = "Route." + t + "() requires a callback function but got a " + i;
        throw new Error(a);
      }
      D2("%s %o", t, this.path);
      var s = q2("/", {}, n);
      s.method = t, this.methods[t] = !0, this.stack.push(s);
    }
    return this;
  };
});
var U2 = { exports: {} };
(function(t, e) {
  t.exports = function(r, n) {
    if (r && n)
      for (var i in n)
        r[i] = n[i];
    return r;
  };
})(U2);
var Ac = U2.exports;
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var Hk = B2, z2 = P2, Wk = Ag, Cl = Ac, yo = Mr("express:router"), Gk = tr("express"), Qk = Oc, Vk = ts, Kk = vc, Jk = /^\[object (\S+)\]$/, H2 = Array.prototype.slice, Xk = Object.prototype.toString, $n = k2.exports = function(t) {
  var e = t || {};
  function r(n, i, a) {
    r.handle(n, i, a);
  }
  return Kk(r, $n), r.params = {}, r._params = [], r.caseSensitive = e.caseSensitive, r.mergeParams = e.mergeParams, r.strict = e.strict, r.stack = [], r;
};
$n.param = function(e, r) {
  if (typeof e == "function") {
    this._params.push(e);
    return;
  }
  var n = this._params, i = n.length, a;
  e[0] === ":" && (Gk("router.param(" + JSON.stringify(e) + ", fn): Use router.param(" + JSON.stringify(e.slice(1)) + ", fn) instead"), e = e.slice(1));
  for (var s = 0; s < i; ++s)
    (a = n[s](e, r)) && (r = a);
  if (typeof r != "function")
    throw new Error("invalid param() call for " + e + ", got " + r);
  return (this.params[e] = this.params[e] || []).push(r), this;
};
$n.handle = function(e, r, n) {
  var i = this;
  yo("dispatching %s %s", e.method, e.url);
  var a = 0, s = e3(e.url) || "", o = "", c = !1, f = 0, u = {}, l = [], p = i.stack, m = e.params, h = e.baseUrl || "", g = i3(n, e, "baseUrl", "next", "params");
  e.next = v, e.method === "OPTIONS" && (g = s3(g, function(y, x) {
    if (x || l.length === 0)
      return y(x);
    a3(r, l, y);
  })), e.baseUrl = h, e.originalUrl = e.originalUrl || e.url, v();
  function v(y) {
    var x = y === "route" ? null : y;
    if (c && (e.url = e.url.slice(1), c = !1), o.length !== 0 && (e.baseUrl = h, e.url = s + o + e.url.slice(s.length), o = ""), x === "router") {
      setImmediate(g, null);
      return;
    }
    if (a >= p.length) {
      setImmediate(g, x);
      return;
    }
    if (++f > 100)
      return setImmediate(v, y);
    var b = Yk(e);
    if (b == null)
      return g(x);
    for (var w, S, T; S !== !0 && a < p.length; )
      if (w = p[a++], S = r3(w, b), T = w.route, typeof S != "boolean" && (x = x || S), S === !0 && T) {
        if (x) {
          S = !1;
          continue;
        }
        var E = e.method, C = T._handles_method(E);
        !C && E === "OPTIONS" && Zk(l, T._options()), !C && E !== "HEAD" && (S = !1);
      }
    if (S !== !0)
      return g(x);
    T && (e.route = T), e.params = i.mergeParams ? n3(w.params, m) : w.params;
    var A = w.path;
    i.process_params(w, u, e, r, function(R) {
      R ? v(x || R) : T ? w.handle_request(e, r, v) : d(w, x, A, b), f = 0;
    });
  }
  function d(y, x, b, w) {
    if (b.length !== 0) {
      if (b !== w.slice(0, b.length)) {
        v(x);
        return;
      }
      var S = w[b.length];
      if (S && S !== "/" && S !== ".")
        return v(x);
      yo("trim prefix (%s) from url %s", b, e.url), o = b, e.url = s + e.url.slice(s.length + o.length), !s && e.url[0] !== "/" && (e.url = "/" + e.url, c = !0), e.baseUrl = h + (o[o.length - 1] === "/" ? o.substring(0, o.length - 1) : o);
    }
    yo("%s %s : %s", y.name, b, e.originalUrl), x ? y.handle_error(x, e, r, v) : y.handle_request(e, r, v);
  }
};
$n.process_params = function(e, r, n, i, a) {
  var s = this.params, o = e.keys;
  if (!o || o.length === 0)
    return a();
  var c = 0, f, u = 0, l, p, m, h;
  function g(d) {
    if (d)
      return a(d);
    if (c >= o.length)
      return a();
    if (u = 0, l = o[c++], f = l.name, p = n.params[f], m = s[f], h = r[f], p === void 0 || !m)
      return g();
    if (h && (h.match === p || h.error && h.error !== "route"))
      return n.params[f] = h.value, g(h.error);
    r[f] = h = {
      error: null,
      match: p,
      value: p
    }, v();
  }
  function v(d) {
    var y = m[u++];
    if (h.value = n.params[l.name], d) {
      h.error = d, g(d);
      return;
    }
    if (!y)
      return g();
    try {
      y(n, i, v, p, l.name);
    } catch (x) {
      v(x);
    }
  }
  g();
};
$n.use = function(e) {
  var r = 0, n = "/";
  if (typeof e != "function") {
    for (var i = e; Array.isArray(i) && i.length !== 0; )
      i = i[0];
    typeof i != "function" && (r = 1, n = e);
  }
  var a = Qk(H2.call(arguments, r));
  if (a.length === 0)
    throw new TypeError("Router.use() requires a middleware function");
  for (var s = 0; s < a.length; s++) {
    var e = a[s];
    if (typeof e != "function")
      throw new TypeError("Router.use() requires a middleware function but got a " + t3(e));
    yo("use %o %s", n, e.name || "<anonymous>");
    var o = new z2(n, {
      sensitive: this.caseSensitive,
      strict: !1,
      end: !1
    }, e);
    o.route = void 0, this.stack.push(o);
  }
  return this;
};
$n.route = function(e) {
  var r = new Hk(e), n = new z2(e, {
    sensitive: this.caseSensitive,
    strict: this.strict,
    end: !0
  }, r.dispatch.bind(r));
  return n.route = r, this.stack.push(n), r;
};
Wk.concat("all").forEach(function(t) {
  $n[t] = function(e) {
    var r = this.route(e);
    return r[t].apply(r, H2.call(arguments, 1)), this;
  };
});
function Zk(t, e) {
  for (var r = 0; r < e.length; r++) {
    var n = e[r];
    t.indexOf(n) === -1 && t.push(n);
  }
}
function Yk(t) {
  try {
    return Vk(t).pathname;
  } catch {
    return;
  }
}
function e3(t) {
  if (!(typeof t != "string" || t.length === 0 || t[0] === "/")) {
    var e = t.indexOf("?"), r = e !== -1 ? e : t.length, n = t.slice(0, r).indexOf("://");
    return n !== -1 ? t.substring(0, t.indexOf("/", 3 + n)) : void 0;
  }
}
function t3(t) {
  var e = typeof t;
  return e !== "object" ? e : Xk.call(t).replace(Jk, "$1");
}
function r3(t, e) {
  try {
    return t.match(e);
  } catch (r) {
    return r;
  }
}
function n3(t, e) {
  if (typeof e != "object" || !e)
    return t;
  var r = Cl({}, e);
  if (!(0 in t) || !(0 in e))
    return Cl(r, t);
  for (var n = 0, i = 0; n in t; )
    n++;
  for (; i in e; )
    i++;
  for (n--; n >= 0; n--)
    t[n + i] = t[n], n < i && delete t[n];
  return Cl(r, t);
}
function i3(t, e) {
  for (var r = new Array(arguments.length - 2), n = new Array(arguments.length - 2), i = 0; i < r.length; i++)
    r[i] = arguments[i + 2], n[i] = e[r[i]];
  return function() {
    for (var a = 0; a < r.length; a++)
      e[r[a]] = n[a];
    return t.apply(this, arguments);
  };
}
function a3(t, e, r) {
  try {
    var n = e.join(",");
    t.set("Allow", n), t.send(n);
  } catch (i) {
    r(i);
  }
}
function s3(t, e) {
  return function() {
    var n = new Array(arguments.length + 1);
    n[0] = t;
    for (var i = 0, a = arguments.length; i < a; i++)
      n[i + 1] = arguments[i];
    e.apply(this, n);
  };
}
var W2 = k2.exports, G2 = {};
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var Pb = vc;
G2.init = function(t) {
  return function(r, n, i) {
    t.enabled("x-powered-by") && n.setHeader("X-Powered-By", "Express"), r.res = n, n.req = r, r.next = i, Pb(r, t.request), Pb(n, t.response), n.locals = n.locals || /* @__PURE__ */ Object.create(null), i();
  };
};
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var o3 = Ac, c3 = ts, u3 = Sc(), Q2 = function(e) {
  var r = o3({}, e), n = u3.parse;
  return typeof e == "function" && (n = e, r = void 0), r !== void 0 && r.allowPrototypes === void 0 && (r.allowPrototypes = !0), function(a, s, o) {
    if (!a.query) {
      var c = c3(a).query;
      a.query = n(c, r);
    }
    o();
  };
};
function l3(t) {
  throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var $c = Mr("express:view"), rs = se, p3 = se, f3 = rs.dirname, V2 = rs.basename, h3 = rs.extname, Db = rs.join, d3 = rs.resolve, m3 = Ic;
function Ic(t, e) {
  var r = e || {};
  if (this.defaultEngine = r.defaultEngine, this.ext = h3(t), this.name = t, this.root = r.root, !this.ext && !this.defaultEngine)
    throw new Error("No default engine was specified and no extension was provided.");
  var n = t;
  if (this.ext || (this.ext = this.defaultEngine[0] !== "." ? "." + this.defaultEngine : this.defaultEngine, n += this.ext), !r.engines[this.ext]) {
    var i = this.ext.slice(1);
    $c('require "%s"', i);
    var a = l3(i).__express;
    if (typeof a != "function")
      throw new Error('Module "' + i + '" does not provide a view engine.');
    r.engines[this.ext] = a;
  }
  this.engine = r.engines[this.ext], this.path = this.lookup(n);
}
Ic.prototype.lookup = function(e) {
  var r, n = [].concat(this.root);
  $c('lookup "%s"', e);
  for (var i = 0; i < n.length && !r; i++) {
    var a = n[i], s = d3(a, e), o = f3(s), c = V2(s);
    r = this.resolve(o, c);
  }
  return r;
};
Ic.prototype.render = function(e, r) {
  $c('render "%s"', this.path), this.engine(this.path, e, r);
};
Ic.prototype.resolve = function(e, r) {
  var n = this.ext, i = Db(e, r), a = Mb(i);
  if (a && a.isFile() || (i = Db(e, V2(r, n), "index" + n), a = Mb(i), a && a.isFile()))
    return i;
};
function Mb(t) {
  $c('stat "%s"', t);
  try {
    return p3.statSync(t);
  } catch {
    return;
  }
}
var tn = {}, $g = { exports: {} };
/*!
 * content-disposition
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
$g.exports = T3;
$g.exports.parse = I3;
var qb = se.basename, g3 = xc.Buffer, v3 = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g, y3 = /%[0-9A-Fa-f]{2}/, b3 = /%([0-9A-Fa-f]{2})/g, K2 = /[^\x20-\x7e\xa0-\xff]/g, w3 = /\\([\u0000-\u007f])/g, x3 = /([\\"])/g, jb = /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g, _3 = /^[\x20-\x7e\x80-\xff]+$/, E3 = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/, S3 = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/, C3 = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/;
function T3(t, e) {
  var r = e || {}, n = r.type || "attachment", i = O3(t, r.fallback);
  return A3(new X2(n, i));
}
function O3(t, e) {
  if (t !== void 0) {
    var r = {};
    if (typeof t != "string")
      throw new TypeError("filename must be a string");
    if (e === void 0 && (e = !0), typeof e != "string" && typeof e != "boolean")
      throw new TypeError("fallback must be a string or boolean");
    if (typeof e == "string" && K2.test(e))
      throw new TypeError("fallback must be ISO-8859-1 string");
    var n = qb(t), i = _3.test(n), a = typeof e != "string" ? e && J2(n) : qb(e), s = typeof a == "string" && a !== n;
    return (s || !i || y3.test(n)) && (r["filename*"] = n), (i || s) && (r.filename = s ? a : n), r;
  }
}
function A3(t) {
  var e = t.parameters, r = t.type;
  if (!r || typeof r != "string" || !E3.test(r))
    throw new TypeError("invalid type");
  var n = String(r).toLowerCase();
  if (e && typeof e == "object")
    for (var i, a = Object.keys(e).sort(), s = 0; s < a.length; s++) {
      i = a[s];
      var o = i.substr(-1) === "*" ? L3(e[i]) : N3(e[i]);
      n += "; " + i + "=" + o;
    }
  return n;
}
function $3(t) {
  var e = S3.exec(t);
  if (!e)
    throw new TypeError("invalid extended field value");
  var r = e[1].toLowerCase(), n = e[2], i, a = n.replace(b3, k3);
  switch (r) {
    case "iso-8859-1":
      i = J2(a);
      break;
    case "utf-8":
      i = g3.from(a, "binary").toString("utf8");
      break;
    default:
      throw new TypeError("unsupported charset in extended field");
  }
  return i;
}
function J2(t) {
  return String(t).replace(K2, "?");
}
function I3(t) {
  if (!t || typeof t != "string")
    throw new TypeError("argument string is required");
  var e = C3.exec(t);
  if (!e)
    throw new TypeError("invalid type format");
  var r = e[0].length, n = e[1].toLowerCase(), i, a = [], s = {}, o;
  for (r = jb.lastIndex = e[0].substr(-1) === ";" ? r - 1 : r; e = jb.exec(t); ) {
    if (e.index !== r)
      throw new TypeError("invalid parameter format");
    if (r += e[0].length, i = e[1].toLowerCase(), o = e[2], a.indexOf(i) !== -1)
      throw new TypeError("invalid duplicate parameter");
    if (a.push(i), i.indexOf("*") + 1 === i.length) {
      i = i.slice(0, -1), o = $3(o), s[i] = o;
      continue;
    }
    typeof s[i] != "string" && (o[0] === '"' && (o = o.substr(1, o.length - 2).replace(w3, "$1")), s[i] = o);
  }
  if (r !== -1 && r !== t.length)
    throw new TypeError("invalid parameter format");
  return new X2(n, s);
}
function k3(t, e) {
  return String.fromCharCode(parseInt(e, 16));
}
function R3(t) {
  return "%" + String(t).charCodeAt(0).toString(16).toUpperCase();
}
function N3(t) {
  var e = String(t);
  return '"' + e.replace(x3, "\\$1") + '"';
}
function L3(t) {
  var e = String(t), r = encodeURIComponent(e).replace(v3, R3);
  return "UTF-8''" + r;
}
function X2(t, e) {
  this.type = t, this.parameters = e;
}
var Z2 = $g.exports, Ig = { exports: {} }, vm = { exports: {} }, ym = { exports: {} }, $a = 1e3, Ia = $a * 60, ka = Ia * 60, Ra = ka * 24, P3 = Ra * 365.25, D3 = function(t, e) {
  e = e || {};
  var r = typeof t;
  if (r === "string" && t.length > 0)
    return M3(t);
  if (r === "number" && isNaN(t) === !1)
    return e.long ? j3(t) : q3(t);
  throw new Error(
    "val is not a non-empty string or a valid number. val=" + JSON.stringify(t)
  );
};
function M3(t) {
  if (t = String(t), !(t.length > 100)) {
    var e = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
      t
    );
    if (e) {
      var r = parseFloat(e[1]), n = (e[2] || "ms").toLowerCase();
      switch (n) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return r * P3;
        case "days":
        case "day":
        case "d":
          return r * Ra;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return r * ka;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return r * Ia;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return r * $a;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return r;
        default:
          return;
      }
    }
  }
}
function q3(t) {
  return t >= Ra ? Math.round(t / Ra) + "d" : t >= ka ? Math.round(t / ka) + "h" : t >= Ia ? Math.round(t / Ia) + "m" : t >= $a ? Math.round(t / $a) + "s" : t + "ms";
}
function j3(t) {
  return Ds(t, Ra, "day") || Ds(t, ka, "hour") || Ds(t, Ia, "minute") || Ds(t, $a, "second") || t + " ms";
}
function Ds(t, e, r) {
  if (!(t < e))
    return t < e * 1.5 ? Math.floor(t / e) + " " + r : Math.ceil(t / e) + " " + r + "s";
}
(function(t, e) {
  e = t.exports = i.debug = i.default = i, e.coerce = c, e.disable = s, e.enable = a, e.enabled = o, e.humanize = D3, e.names = [], e.skips = [], e.formatters = {};
  var r;
  function n(f) {
    var u = 0, l;
    for (l in f)
      u = (u << 5) - u + f.charCodeAt(l), u |= 0;
    return e.colors[Math.abs(u) % e.colors.length];
  }
  function i(f) {
    function u() {
      if (u.enabled) {
        var l = u, p = +/* @__PURE__ */ new Date(), m = p - (r || p);
        l.diff = m, l.prev = r, l.curr = p, r = p;
        for (var h = new Array(arguments.length), g = 0; g < h.length; g++)
          h[g] = arguments[g];
        h[0] = e.coerce(h[0]), typeof h[0] != "string" && h.unshift("%O");
        var v = 0;
        h[0] = h[0].replace(/%([a-zA-Z%])/g, function(y, x) {
          if (y === "%%")
            return y;
          v++;
          var b = e.formatters[x];
          if (typeof b == "function") {
            var w = h[v];
            y = b.call(l, w), h.splice(v, 1), v--;
          }
          return y;
        }), e.formatArgs.call(l, h);
        var d = u.log || e.log || console.log.bind(console);
        d.apply(l, h);
      }
    }
    return u.namespace = f, u.enabled = e.enabled(f), u.useColors = e.useColors(), u.color = n(f), typeof e.init == "function" && e.init(u), u;
  }
  function a(f) {
    e.save(f), e.names = [], e.skips = [];
    for (var u = (typeof f == "string" ? f : "").split(/[\s,]+/), l = u.length, p = 0; p < l; p++)
      u[p] && (f = u[p].replace(/\*/g, ".*?"), f[0] === "-" ? e.skips.push(new RegExp("^" + f.substr(1) + "$")) : e.names.push(new RegExp("^" + f + "$")));
  }
  function s() {
    e.enable("");
  }
  function o(f) {
    var u, l;
    for (u = 0, l = e.skips.length; u < l; u++)
      if (e.skips[u].test(f))
        return !1;
    for (u = 0, l = e.names.length; u < l; u++)
      if (e.names[u].test(f))
        return !0;
    return !1;
  }
  function c(f) {
    return f instanceof Error ? f.stack || f.message : f;
  }
})(ym, ym.exports);
var F3 = ym.exports;
(function(t, e) {
  e = t.exports = F3, e.log = i, e.formatArgs = n, e.save = a, e.load = s, e.useColors = r, e.storage = typeof chrome < "u" && typeof chrome.storage < "u" ? chrome.storage.local : o(), e.colors = [
    "lightseagreen",
    "forestgreen",
    "goldenrod",
    "dodgerblue",
    "darkorchid",
    "crimson"
  ];
  function r() {
    return typeof window < "u" && window.process && window.process.type === "renderer" ? !0 : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  e.formatters.j = function(c) {
    try {
      return JSON.stringify(c);
    } catch (f) {
      return "[UnexpectedJSONParseError]: " + f.message;
    }
  };
  function n(c) {
    var f = this.useColors;
    if (c[0] = (f ? "%c" : "") + this.namespace + (f ? " %c" : " ") + c[0] + (f ? "%c " : " ") + "+" + e.humanize(this.diff), !!f) {
      var u = "color: " + this.color;
      c.splice(1, 0, u, "color: inherit");
      var l = 0, p = 0;
      c[0].replace(/%[a-zA-Z%]/g, function(m) {
        m !== "%%" && (l++, m === "%c" && (p = l));
      }), c.splice(p, 0, u);
    }
  }
  function i() {
    return typeof console == "object" && console.log && Function.prototype.apply.call(console.log, console, arguments);
  }
  function a(c) {
    try {
      c == null ? e.storage.removeItem("debug") : e.storage.debug = c;
    } catch {
    }
  }
  function s() {
    var c;
    try {
      c = e.storage.debug;
    } catch {
    }
    return !c && typeof process < "u" && "env" in process && (c = process.env.DEBUG), c;
  }
  e.enable(s());
  function o() {
    try {
      return window.localStorage;
    } catch {
    }
  }
})(vm, vm.exports);
var B3 = vm.exports;
/*!
 * etag
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var Y2 = H3, U3 = se, Fb = se.Stats, Bb = Object.prototype.toString;
function z3(t) {
  if (t.length === 0)
    return '"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk"';
  var e = U3.createHash("sha1").update(t, "utf8").digest("base64").substring(0, 27), r = typeof t == "string" ? Buffer.byteLength(t, "utf8") : t.length;
  return '"' + r.toString(16) + "-" + e + '"';
}
function H3(t, e) {
  if (t == null)
    throw new TypeError("argument entity is required");
  var r = W3(t), n = e && typeof e.weak == "boolean" ? e.weak : r;
  if (!r && typeof t != "string" && !Buffer.isBuffer(t))
    throw new TypeError("argument entity must be string, Buffer, or fs.Stats");
  var i = r ? G3(t) : z3(t);
  return n ? "W/" + i : i;
}
function W3(t) {
  return typeof Fb == "function" && t instanceof Fb ? !0 : t && typeof t == "object" && "ctime" in t && Bb.call(t.ctime) === "[object Date]" && "mtime" in t && Bb.call(t.mtime) === "[object Date]" && "ino" in t && typeof t.ino == "number" && "size" in t && typeof t.size == "number";
}
function G3(t) {
  var e = t.mtime.getTime().toString(16), r = t.size.toString(16);
  return '"' + r + "-" + e + '"';
}
/*!
 * fresh
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2016-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
var Q3 = /(?:^|,)\s*?no-cache\s*?(?:,|$)/, eC = V3;
function V3(t, e) {
  var r = t["if-modified-since"], n = t["if-none-match"];
  if (!r && !n)
    return !1;
  var i = t["cache-control"];
  if (i && Q3.test(i))
    return !1;
  if (n && n !== "*") {
    var a = e.etag;
    if (!a)
      return !1;
    for (var s = !0, o = K3(n), c = 0; c < o.length; c++) {
      var f = o[c];
      if (f === a || f === "W/" + a || "W/" + f === a) {
        s = !1;
        break;
      }
    }
    if (s)
      return !1;
  }
  if (r) {
    var u = e["last-modified"], l = !u || !(Ub(u) <= Ub(r));
    if (l)
      return !1;
  }
  return !0;
}
function Ub(t) {
  var e = t && Date.parse(t);
  return typeof e == "number" ? e : NaN;
}
function K3(t) {
  for (var e = 0, r = [], n = 0, i = 0, a = t.length; i < a; i++)
    switch (t.charCodeAt(i)) {
      case 32:
        n === e && (n = e = i + 1);
        break;
      case 44:
        r.push(t.substring(n, e)), n = e = i + 1;
        break;
      default:
        e = i + 1;
        break;
    }
  return r.push(t.substring(n, e)), r;
}
const J3 = {
  "application/andrew-inset": [
    "ez"
  ],
  "application/applixware": [
    "aw"
  ],
  "application/atom+xml": [
    "atom"
  ],
  "application/atomcat+xml": [
    "atomcat"
  ],
  "application/atomsvc+xml": [
    "atomsvc"
  ],
  "application/bdoc": [
    "bdoc"
  ],
  "application/ccxml+xml": [
    "ccxml"
  ],
  "application/cdmi-capability": [
    "cdmia"
  ],
  "application/cdmi-container": [
    "cdmic"
  ],
  "application/cdmi-domain": [
    "cdmid"
  ],
  "application/cdmi-object": [
    "cdmio"
  ],
  "application/cdmi-queue": [
    "cdmiq"
  ],
  "application/cu-seeme": [
    "cu"
  ],
  "application/dash+xml": [
    "mpd"
  ],
  "application/davmount+xml": [
    "davmount"
  ],
  "application/docbook+xml": [
    "dbk"
  ],
  "application/dssc+der": [
    "dssc"
  ],
  "application/dssc+xml": [
    "xdssc"
  ],
  "application/ecmascript": [
    "ecma"
  ],
  "application/emma+xml": [
    "emma"
  ],
  "application/epub+zip": [
    "epub"
  ],
  "application/exi": [
    "exi"
  ],
  "application/font-tdpfr": [
    "pfr"
  ],
  "application/font-woff": [],
  "application/font-woff2": [],
  "application/geo+json": [
    "geojson"
  ],
  "application/gml+xml": [
    "gml"
  ],
  "application/gpx+xml": [
    "gpx"
  ],
  "application/gxf": [
    "gxf"
  ],
  "application/gzip": [
    "gz"
  ],
  "application/hyperstudio": [
    "stk"
  ],
  "application/inkml+xml": [
    "ink",
    "inkml"
  ],
  "application/ipfix": [
    "ipfix"
  ],
  "application/java-archive": [
    "jar",
    "war",
    "ear"
  ],
  "application/java-serialized-object": [
    "ser"
  ],
  "application/java-vm": [
    "class"
  ],
  "application/javascript": [
    "js",
    "mjs"
  ],
  "application/json": [
    "json",
    "map"
  ],
  "application/json5": [
    "json5"
  ],
  "application/jsonml+json": [
    "jsonml"
  ],
  "application/ld+json": [
    "jsonld"
  ],
  "application/lost+xml": [
    "lostxml"
  ],
  "application/mac-binhex40": [
    "hqx"
  ],
  "application/mac-compactpro": [
    "cpt"
  ],
  "application/mads+xml": [
    "mads"
  ],
  "application/manifest+json": [
    "webmanifest"
  ],
  "application/marc": [
    "mrc"
  ],
  "application/marcxml+xml": [
    "mrcx"
  ],
  "application/mathematica": [
    "ma",
    "nb",
    "mb"
  ],
  "application/mathml+xml": [
    "mathml"
  ],
  "application/mbox": [
    "mbox"
  ],
  "application/mediaservercontrol+xml": [
    "mscml"
  ],
  "application/metalink+xml": [
    "metalink"
  ],
  "application/metalink4+xml": [
    "meta4"
  ],
  "application/mets+xml": [
    "mets"
  ],
  "application/mods+xml": [
    "mods"
  ],
  "application/mp21": [
    "m21",
    "mp21"
  ],
  "application/mp4": [
    "mp4s",
    "m4p"
  ],
  "application/msword": [
    "doc",
    "dot"
  ],
  "application/mxf": [
    "mxf"
  ],
  "application/octet-stream": [
    "bin",
    "dms",
    "lrf",
    "mar",
    "so",
    "dist",
    "distz",
    "pkg",
    "bpk",
    "dump",
    "elc",
    "deploy",
    "exe",
    "dll",
    "deb",
    "dmg",
    "iso",
    "img",
    "msi",
    "msp",
    "msm",
    "buffer"
  ],
  "application/oda": [
    "oda"
  ],
  "application/oebps-package+xml": [
    "opf"
  ],
  "application/ogg": [
    "ogx"
  ],
  "application/omdoc+xml": [
    "omdoc"
  ],
  "application/onenote": [
    "onetoc",
    "onetoc2",
    "onetmp",
    "onepkg"
  ],
  "application/oxps": [
    "oxps"
  ],
  "application/patch-ops-error+xml": [
    "xer"
  ],
  "application/pdf": [
    "pdf"
  ],
  "application/pgp-encrypted": [
    "pgp"
  ],
  "application/pgp-signature": [
    "asc",
    "sig"
  ],
  "application/pics-rules": [
    "prf"
  ],
  "application/pkcs10": [
    "p10"
  ],
  "application/pkcs7-mime": [
    "p7m",
    "p7c"
  ],
  "application/pkcs7-signature": [
    "p7s"
  ],
  "application/pkcs8": [
    "p8"
  ],
  "application/pkix-attr-cert": [
    "ac"
  ],
  "application/pkix-cert": [
    "cer"
  ],
  "application/pkix-crl": [
    "crl"
  ],
  "application/pkix-pkipath": [
    "pkipath"
  ],
  "application/pkixcmp": [
    "pki"
  ],
  "application/pls+xml": [
    "pls"
  ],
  "application/postscript": [
    "ai",
    "eps",
    "ps"
  ],
  "application/prs.cww": [
    "cww"
  ],
  "application/pskc+xml": [
    "pskcxml"
  ],
  "application/raml+yaml": [
    "raml"
  ],
  "application/rdf+xml": [
    "rdf"
  ],
  "application/reginfo+xml": [
    "rif"
  ],
  "application/relax-ng-compact-syntax": [
    "rnc"
  ],
  "application/resource-lists+xml": [
    "rl"
  ],
  "application/resource-lists-diff+xml": [
    "rld"
  ],
  "application/rls-services+xml": [
    "rs"
  ],
  "application/rpki-ghostbusters": [
    "gbr"
  ],
  "application/rpki-manifest": [
    "mft"
  ],
  "application/rpki-roa": [
    "roa"
  ],
  "application/rsd+xml": [
    "rsd"
  ],
  "application/rss+xml": [
    "rss"
  ],
  "application/rtf": [
    "rtf"
  ],
  "application/sbml+xml": [
    "sbml"
  ],
  "application/scvp-cv-request": [
    "scq"
  ],
  "application/scvp-cv-response": [
    "scs"
  ],
  "application/scvp-vp-request": [
    "spq"
  ],
  "application/scvp-vp-response": [
    "spp"
  ],
  "application/sdp": [
    "sdp"
  ],
  "application/set-payment-initiation": [
    "setpay"
  ],
  "application/set-registration-initiation": [
    "setreg"
  ],
  "application/shf+xml": [
    "shf"
  ],
  "application/smil+xml": [
    "smi",
    "smil"
  ],
  "application/sparql-query": [
    "rq"
  ],
  "application/sparql-results+xml": [
    "srx"
  ],
  "application/srgs": [
    "gram"
  ],
  "application/srgs+xml": [
    "grxml"
  ],
  "application/sru+xml": [
    "sru"
  ],
  "application/ssdl+xml": [
    "ssdl"
  ],
  "application/ssml+xml": [
    "ssml"
  ],
  "application/tei+xml": [
    "tei",
    "teicorpus"
  ],
  "application/thraud+xml": [
    "tfi"
  ],
  "application/timestamped-data": [
    "tsd"
  ],
  "application/vnd.3gpp.pic-bw-large": [
    "plb"
  ],
  "application/vnd.3gpp.pic-bw-small": [
    "psb"
  ],
  "application/vnd.3gpp.pic-bw-var": [
    "pvb"
  ],
  "application/vnd.3gpp2.tcap": [
    "tcap"
  ],
  "application/vnd.3m.post-it-notes": [
    "pwn"
  ],
  "application/vnd.accpac.simply.aso": [
    "aso"
  ],
  "application/vnd.accpac.simply.imp": [
    "imp"
  ],
  "application/vnd.acucobol": [
    "acu"
  ],
  "application/vnd.acucorp": [
    "atc",
    "acutc"
  ],
  "application/vnd.adobe.air-application-installer-package+zip": [
    "air"
  ],
  "application/vnd.adobe.formscentral.fcdt": [
    "fcdt"
  ],
  "application/vnd.adobe.fxp": [
    "fxp",
    "fxpl"
  ],
  "application/vnd.adobe.xdp+xml": [
    "xdp"
  ],
  "application/vnd.adobe.xfdf": [
    "xfdf"
  ],
  "application/vnd.ahead.space": [
    "ahead"
  ],
  "application/vnd.airzip.filesecure.azf": [
    "azf"
  ],
  "application/vnd.airzip.filesecure.azs": [
    "azs"
  ],
  "application/vnd.amazon.ebook": [
    "azw"
  ],
  "application/vnd.americandynamics.acc": [
    "acc"
  ],
  "application/vnd.amiga.ami": [
    "ami"
  ],
  "application/vnd.android.package-archive": [
    "apk"
  ],
  "application/vnd.anser-web-certificate-issue-initiation": [
    "cii"
  ],
  "application/vnd.anser-web-funds-transfer-initiation": [
    "fti"
  ],
  "application/vnd.antix.game-component": [
    "atx"
  ],
  "application/vnd.apple.installer+xml": [
    "mpkg"
  ],
  "application/vnd.apple.mpegurl": [
    "m3u8"
  ],
  "application/vnd.apple.pkpass": [
    "pkpass"
  ],
  "application/vnd.aristanetworks.swi": [
    "swi"
  ],
  "application/vnd.astraea-software.iota": [
    "iota"
  ],
  "application/vnd.audiograph": [
    "aep"
  ],
  "application/vnd.blueice.multipass": [
    "mpm"
  ],
  "application/vnd.bmi": [
    "bmi"
  ],
  "application/vnd.businessobjects": [
    "rep"
  ],
  "application/vnd.chemdraw+xml": [
    "cdxml"
  ],
  "application/vnd.chipnuts.karaoke-mmd": [
    "mmd"
  ],
  "application/vnd.cinderella": [
    "cdy"
  ],
  "application/vnd.claymore": [
    "cla"
  ],
  "application/vnd.cloanto.rp9": [
    "rp9"
  ],
  "application/vnd.clonk.c4group": [
    "c4g",
    "c4d",
    "c4f",
    "c4p",
    "c4u"
  ],
  "application/vnd.cluetrust.cartomobile-config": [
    "c11amc"
  ],
  "application/vnd.cluetrust.cartomobile-config-pkg": [
    "c11amz"
  ],
  "application/vnd.commonspace": [
    "csp"
  ],
  "application/vnd.contact.cmsg": [
    "cdbcmsg"
  ],
  "application/vnd.cosmocaller": [
    "cmc"
  ],
  "application/vnd.crick.clicker": [
    "clkx"
  ],
  "application/vnd.crick.clicker.keyboard": [
    "clkk"
  ],
  "application/vnd.crick.clicker.palette": [
    "clkp"
  ],
  "application/vnd.crick.clicker.template": [
    "clkt"
  ],
  "application/vnd.crick.clicker.wordbank": [
    "clkw"
  ],
  "application/vnd.criticaltools.wbs+xml": [
    "wbs"
  ],
  "application/vnd.ctc-posml": [
    "pml"
  ],
  "application/vnd.cups-ppd": [
    "ppd"
  ],
  "application/vnd.curl.car": [
    "car"
  ],
  "application/vnd.curl.pcurl": [
    "pcurl"
  ],
  "application/vnd.dart": [
    "dart"
  ],
  "application/vnd.data-vision.rdz": [
    "rdz"
  ],
  "application/vnd.dece.data": [
    "uvf",
    "uvvf",
    "uvd",
    "uvvd"
  ],
  "application/vnd.dece.ttml+xml": [
    "uvt",
    "uvvt"
  ],
  "application/vnd.dece.unspecified": [
    "uvx",
    "uvvx"
  ],
  "application/vnd.dece.zip": [
    "uvz",
    "uvvz"
  ],
  "application/vnd.denovo.fcselayout-link": [
    "fe_launch"
  ],
  "application/vnd.dna": [
    "dna"
  ],
  "application/vnd.dolby.mlp": [
    "mlp"
  ],
  "application/vnd.dpgraph": [
    "dpg"
  ],
  "application/vnd.dreamfactory": [
    "dfac"
  ],
  "application/vnd.ds-keypoint": [
    "kpxx"
  ],
  "application/vnd.dvb.ait": [
    "ait"
  ],
  "application/vnd.dvb.service": [
    "svc"
  ],
  "application/vnd.dynageo": [
    "geo"
  ],
  "application/vnd.ecowin.chart": [
    "mag"
  ],
  "application/vnd.enliven": [
    "nml"
  ],
  "application/vnd.epson.esf": [
    "esf"
  ],
  "application/vnd.epson.msf": [
    "msf"
  ],
  "application/vnd.epson.quickanime": [
    "qam"
  ],
  "application/vnd.epson.salt": [
    "slt"
  ],
  "application/vnd.epson.ssf": [
    "ssf"
  ],
  "application/vnd.eszigno3+xml": [
    "es3",
    "et3"
  ],
  "application/vnd.ezpix-album": [
    "ez2"
  ],
  "application/vnd.ezpix-package": [
    "ez3"
  ],
  "application/vnd.fdf": [
    "fdf"
  ],
  "application/vnd.fdsn.mseed": [
    "mseed"
  ],
  "application/vnd.fdsn.seed": [
    "seed",
    "dataless"
  ],
  "application/vnd.flographit": [
    "gph"
  ],
  "application/vnd.fluxtime.clip": [
    "ftc"
  ],
  "application/vnd.framemaker": [
    "fm",
    "frame",
    "maker",
    "book"
  ],
  "application/vnd.frogans.fnc": [
    "fnc"
  ],
  "application/vnd.frogans.ltf": [
    "ltf"
  ],
  "application/vnd.fsc.weblaunch": [
    "fsc"
  ],
  "application/vnd.fujitsu.oasys": [
    "oas"
  ],
  "application/vnd.fujitsu.oasys2": [
    "oa2"
  ],
  "application/vnd.fujitsu.oasys3": [
    "oa3"
  ],
  "application/vnd.fujitsu.oasysgp": [
    "fg5"
  ],
  "application/vnd.fujitsu.oasysprs": [
    "bh2"
  ],
  "application/vnd.fujixerox.ddd": [
    "ddd"
  ],
  "application/vnd.fujixerox.docuworks": [
    "xdw"
  ],
  "application/vnd.fujixerox.docuworks.binder": [
    "xbd"
  ],
  "application/vnd.fuzzysheet": [
    "fzs"
  ],
  "application/vnd.genomatix.tuxedo": [
    "txd"
  ],
  "application/vnd.geogebra.file": [
    "ggb"
  ],
  "application/vnd.geogebra.tool": [
    "ggt"
  ],
  "application/vnd.geometry-explorer": [
    "gex",
    "gre"
  ],
  "application/vnd.geonext": [
    "gxt"
  ],
  "application/vnd.geoplan": [
    "g2w"
  ],
  "application/vnd.geospace": [
    "g3w"
  ],
  "application/vnd.gmx": [
    "gmx"
  ],
  "application/vnd.google-apps.document": [
    "gdoc"
  ],
  "application/vnd.google-apps.presentation": [
    "gslides"
  ],
  "application/vnd.google-apps.spreadsheet": [
    "gsheet"
  ],
  "application/vnd.google-earth.kml+xml": [
    "kml"
  ],
  "application/vnd.google-earth.kmz": [
    "kmz"
  ],
  "application/vnd.grafeq": [
    "gqf",
    "gqs"
  ],
  "application/vnd.groove-account": [
    "gac"
  ],
  "application/vnd.groove-help": [
    "ghf"
  ],
  "application/vnd.groove-identity-message": [
    "gim"
  ],
  "application/vnd.groove-injector": [
    "grv"
  ],
  "application/vnd.groove-tool-message": [
    "gtm"
  ],
  "application/vnd.groove-tool-template": [
    "tpl"
  ],
  "application/vnd.groove-vcard": [
    "vcg"
  ],
  "application/vnd.hal+xml": [
    "hal"
  ],
  "application/vnd.handheld-entertainment+xml": [
    "zmm"
  ],
  "application/vnd.hbci": [
    "hbci"
  ],
  "application/vnd.hhe.lesson-player": [
    "les"
  ],
  "application/vnd.hp-hpgl": [
    "hpgl"
  ],
  "application/vnd.hp-hpid": [
    "hpid"
  ],
  "application/vnd.hp-hps": [
    "hps"
  ],
  "application/vnd.hp-jlyt": [
    "jlt"
  ],
  "application/vnd.hp-pcl": [
    "pcl"
  ],
  "application/vnd.hp-pclxl": [
    "pclxl"
  ],
  "application/vnd.hydrostatix.sof-data": [
    "sfd-hdstx"
  ],
  "application/vnd.ibm.minipay": [
    "mpy"
  ],
  "application/vnd.ibm.modcap": [
    "afp",
    "listafp",
    "list3820"
  ],
  "application/vnd.ibm.rights-management": [
    "irm"
  ],
  "application/vnd.ibm.secure-container": [
    "sc"
  ],
  "application/vnd.iccprofile": [
    "icc",
    "icm"
  ],
  "application/vnd.igloader": [
    "igl"
  ],
  "application/vnd.immervision-ivp": [
    "ivp"
  ],
  "application/vnd.immervision-ivu": [
    "ivu"
  ],
  "application/vnd.insors.igm": [
    "igm"
  ],
  "application/vnd.intercon.formnet": [
    "xpw",
    "xpx"
  ],
  "application/vnd.intergeo": [
    "i2g"
  ],
  "application/vnd.intu.qbo": [
    "qbo"
  ],
  "application/vnd.intu.qfx": [
    "qfx"
  ],
  "application/vnd.ipunplugged.rcprofile": [
    "rcprofile"
  ],
  "application/vnd.irepository.package+xml": [
    "irp"
  ],
  "application/vnd.is-xpr": [
    "xpr"
  ],
  "application/vnd.isac.fcs": [
    "fcs"
  ],
  "application/vnd.jam": [
    "jam"
  ],
  "application/vnd.jcp.javame.midlet-rms": [
    "rms"
  ],
  "application/vnd.jisp": [
    "jisp"
  ],
  "application/vnd.joost.joda-archive": [
    "joda"
  ],
  "application/vnd.kahootz": [
    "ktz",
    "ktr"
  ],
  "application/vnd.kde.karbon": [
    "karbon"
  ],
  "application/vnd.kde.kchart": [
    "chrt"
  ],
  "application/vnd.kde.kformula": [
    "kfo"
  ],
  "application/vnd.kde.kivio": [
    "flw"
  ],
  "application/vnd.kde.kontour": [
    "kon"
  ],
  "application/vnd.kde.kpresenter": [
    "kpr",
    "kpt"
  ],
  "application/vnd.kde.kspread": [
    "ksp"
  ],
  "application/vnd.kde.kword": [
    "kwd",
    "kwt"
  ],
  "application/vnd.kenameaapp": [
    "htke"
  ],
  "application/vnd.kidspiration": [
    "kia"
  ],
  "application/vnd.kinar": [
    "kne",
    "knp"
  ],
  "application/vnd.koan": [
    "skp",
    "skd",
    "skt",
    "skm"
  ],
  "application/vnd.kodak-descriptor": [
    "sse"
  ],
  "application/vnd.las.las+xml": [
    "lasxml"
  ],
  "application/vnd.llamagraphics.life-balance.desktop": [
    "lbd"
  ],
  "application/vnd.llamagraphics.life-balance.exchange+xml": [
    "lbe"
  ],
  "application/vnd.lotus-1-2-3": [
    "123"
  ],
  "application/vnd.lotus-approach": [
    "apr"
  ],
  "application/vnd.lotus-freelance": [
    "pre"
  ],
  "application/vnd.lotus-notes": [
    "nsf"
  ],
  "application/vnd.lotus-organizer": [
    "org"
  ],
  "application/vnd.lotus-screencam": [
    "scm"
  ],
  "application/vnd.lotus-wordpro": [
    "lwp"
  ],
  "application/vnd.macports.portpkg": [
    "portpkg"
  ],
  "application/vnd.mcd": [
    "mcd"
  ],
  "application/vnd.medcalcdata": [
    "mc1"
  ],
  "application/vnd.mediastation.cdkey": [
    "cdkey"
  ],
  "application/vnd.mfer": [
    "mwf"
  ],
  "application/vnd.mfmp": [
    "mfm"
  ],
  "application/vnd.micrografx.flo": [
    "flo"
  ],
  "application/vnd.micrografx.igx": [
    "igx"
  ],
  "application/vnd.mif": [
    "mif"
  ],
  "application/vnd.mobius.daf": [
    "daf"
  ],
  "application/vnd.mobius.dis": [
    "dis"
  ],
  "application/vnd.mobius.mbk": [
    "mbk"
  ],
  "application/vnd.mobius.mqy": [
    "mqy"
  ],
  "application/vnd.mobius.msl": [
    "msl"
  ],
  "application/vnd.mobius.plc": [
    "plc"
  ],
  "application/vnd.mobius.txf": [
    "txf"
  ],
  "application/vnd.mophun.application": [
    "mpn"
  ],
  "application/vnd.mophun.certificate": [
    "mpc"
  ],
  "application/vnd.mozilla.xul+xml": [
    "xul"
  ],
  "application/vnd.ms-artgalry": [
    "cil"
  ],
  "application/vnd.ms-cab-compressed": [
    "cab"
  ],
  "application/vnd.ms-excel": [
    "xls",
    "xlm",
    "xla",
    "xlc",
    "xlt",
    "xlw"
  ],
  "application/vnd.ms-excel.addin.macroenabled.12": [
    "xlam"
  ],
  "application/vnd.ms-excel.sheet.binary.macroenabled.12": [
    "xlsb"
  ],
  "application/vnd.ms-excel.sheet.macroenabled.12": [
    "xlsm"
  ],
  "application/vnd.ms-excel.template.macroenabled.12": [
    "xltm"
  ],
  "application/vnd.ms-fontobject": [
    "eot"
  ],
  "application/vnd.ms-htmlhelp": [
    "chm"
  ],
  "application/vnd.ms-ims": [
    "ims"
  ],
  "application/vnd.ms-lrm": [
    "lrm"
  ],
  "application/vnd.ms-officetheme": [
    "thmx"
  ],
  "application/vnd.ms-outlook": [
    "msg"
  ],
  "application/vnd.ms-pki.seccat": [
    "cat"
  ],
  "application/vnd.ms-pki.stl": [
    "stl"
  ],
  "application/vnd.ms-powerpoint": [
    "ppt",
    "pps",
    "pot"
  ],
  "application/vnd.ms-powerpoint.addin.macroenabled.12": [
    "ppam"
  ],
  "application/vnd.ms-powerpoint.presentation.macroenabled.12": [
    "pptm"
  ],
  "application/vnd.ms-powerpoint.slide.macroenabled.12": [
    "sldm"
  ],
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": [
    "ppsm"
  ],
  "application/vnd.ms-powerpoint.template.macroenabled.12": [
    "potm"
  ],
  "application/vnd.ms-project": [
    "mpp",
    "mpt"
  ],
  "application/vnd.ms-word.document.macroenabled.12": [
    "docm"
  ],
  "application/vnd.ms-word.template.macroenabled.12": [
    "dotm"
  ],
  "application/vnd.ms-works": [
    "wps",
    "wks",
    "wcm",
    "wdb"
  ],
  "application/vnd.ms-wpl": [
    "wpl"
  ],
  "application/vnd.ms-xpsdocument": [
    "xps"
  ],
  "application/vnd.mseq": [
    "mseq"
  ],
  "application/vnd.musician": [
    "mus"
  ],
  "application/vnd.muvee.style": [
    "msty"
  ],
  "application/vnd.mynfc": [
    "taglet"
  ],
  "application/vnd.neurolanguage.nlu": [
    "nlu"
  ],
  "application/vnd.nitf": [
    "ntf",
    "nitf"
  ],
  "application/vnd.noblenet-directory": [
    "nnd"
  ],
  "application/vnd.noblenet-sealer": [
    "nns"
  ],
  "application/vnd.noblenet-web": [
    "nnw"
  ],
  "application/vnd.nokia.n-gage.data": [
    "ngdat"
  ],
  "application/vnd.nokia.n-gage.symbian.install": [
    "n-gage"
  ],
  "application/vnd.nokia.radio-preset": [
    "rpst"
  ],
  "application/vnd.nokia.radio-presets": [
    "rpss"
  ],
  "application/vnd.novadigm.edm": [
    "edm"
  ],
  "application/vnd.novadigm.edx": [
    "edx"
  ],
  "application/vnd.novadigm.ext": [
    "ext"
  ],
  "application/vnd.oasis.opendocument.chart": [
    "odc"
  ],
  "application/vnd.oasis.opendocument.chart-template": [
    "otc"
  ],
  "application/vnd.oasis.opendocument.database": [
    "odb"
  ],
  "application/vnd.oasis.opendocument.formula": [
    "odf"
  ],
  "application/vnd.oasis.opendocument.formula-template": [
    "odft"
  ],
  "application/vnd.oasis.opendocument.graphics": [
    "odg"
  ],
  "application/vnd.oasis.opendocument.graphics-template": [
    "otg"
  ],
  "application/vnd.oasis.opendocument.image": [
    "odi"
  ],
  "application/vnd.oasis.opendocument.image-template": [
    "oti"
  ],
  "application/vnd.oasis.opendocument.presentation": [
    "odp"
  ],
  "application/vnd.oasis.opendocument.presentation-template": [
    "otp"
  ],
  "application/vnd.oasis.opendocument.spreadsheet": [
    "ods"
  ],
  "application/vnd.oasis.opendocument.spreadsheet-template": [
    "ots"
  ],
  "application/vnd.oasis.opendocument.text": [
    "odt"
  ],
  "application/vnd.oasis.opendocument.text-master": [
    "odm"
  ],
  "application/vnd.oasis.opendocument.text-template": [
    "ott"
  ],
  "application/vnd.oasis.opendocument.text-web": [
    "oth"
  ],
  "application/vnd.olpc-sugar": [
    "xo"
  ],
  "application/vnd.oma.dd2+xml": [
    "dd2"
  ],
  "application/vnd.openofficeorg.extension": [
    "oxt"
  ],
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": [
    "pptx"
  ],
  "application/vnd.openxmlformats-officedocument.presentationml.slide": [
    "sldx"
  ],
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": [
    "ppsx"
  ],
  "application/vnd.openxmlformats-officedocument.presentationml.template": [
    "potx"
  ],
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": [
    "xlsx"
  ],
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": [
    "xltx"
  ],
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": [
    "docx"
  ],
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": [
    "dotx"
  ],
  "application/vnd.osgeo.mapguide.package": [
    "mgp"
  ],
  "application/vnd.osgi.dp": [
    "dp"
  ],
  "application/vnd.osgi.subsystem": [
    "esa"
  ],
  "application/vnd.palm": [
    "pdb",
    "pqa",
    "oprc"
  ],
  "application/vnd.pawaafile": [
    "paw"
  ],
  "application/vnd.pg.format": [
    "str"
  ],
  "application/vnd.pg.osasli": [
    "ei6"
  ],
  "application/vnd.picsel": [
    "efif"
  ],
  "application/vnd.pmi.widget": [
    "wg"
  ],
  "application/vnd.pocketlearn": [
    "plf"
  ],
  "application/vnd.powerbuilder6": [
    "pbd"
  ],
  "application/vnd.previewsystems.box": [
    "box"
  ],
  "application/vnd.proteus.magazine": [
    "mgz"
  ],
  "application/vnd.publishare-delta-tree": [
    "qps"
  ],
  "application/vnd.pvi.ptid1": [
    "ptid"
  ],
  "application/vnd.quark.quarkxpress": [
    "qxd",
    "qxt",
    "qwd",
    "qwt",
    "qxl",
    "qxb"
  ],
  "application/vnd.realvnc.bed": [
    "bed"
  ],
  "application/vnd.recordare.musicxml": [
    "mxl"
  ],
  "application/vnd.recordare.musicxml+xml": [
    "musicxml"
  ],
  "application/vnd.rig.cryptonote": [
    "cryptonote"
  ],
  "application/vnd.rim.cod": [
    "cod"
  ],
  "application/vnd.rn-realmedia": [
    "rm"
  ],
  "application/vnd.rn-realmedia-vbr": [
    "rmvb"
  ],
  "application/vnd.route66.link66+xml": [
    "link66"
  ],
  "application/vnd.sailingtracker.track": [
    "st"
  ],
  "application/vnd.seemail": [
    "see"
  ],
  "application/vnd.sema": [
    "sema"
  ],
  "application/vnd.semd": [
    "semd"
  ],
  "application/vnd.semf": [
    "semf"
  ],
  "application/vnd.shana.informed.formdata": [
    "ifm"
  ],
  "application/vnd.shana.informed.formtemplate": [
    "itp"
  ],
  "application/vnd.shana.informed.interchange": [
    "iif"
  ],
  "application/vnd.shana.informed.package": [
    "ipk"
  ],
  "application/vnd.simtech-mindmapper": [
    "twd",
    "twds"
  ],
  "application/vnd.smaf": [
    "mmf"
  ],
  "application/vnd.smart.teacher": [
    "teacher"
  ],
  "application/vnd.solent.sdkm+xml": [
    "sdkm",
    "sdkd"
  ],
  "application/vnd.spotfire.dxp": [
    "dxp"
  ],
  "application/vnd.spotfire.sfs": [
    "sfs"
  ],
  "application/vnd.stardivision.calc": [
    "sdc"
  ],
  "application/vnd.stardivision.draw": [
    "sda"
  ],
  "application/vnd.stardivision.impress": [
    "sdd"
  ],
  "application/vnd.stardivision.math": [
    "smf"
  ],
  "application/vnd.stardivision.writer": [
    "sdw",
    "vor"
  ],
  "application/vnd.stardivision.writer-global": [
    "sgl"
  ],
  "application/vnd.stepmania.package": [
    "smzip"
  ],
  "application/vnd.stepmania.stepchart": [
    "sm"
  ],
  "application/vnd.sun.wadl+xml": [
    "wadl"
  ],
  "application/vnd.sun.xml.calc": [
    "sxc"
  ],
  "application/vnd.sun.xml.calc.template": [
    "stc"
  ],
  "application/vnd.sun.xml.draw": [
    "sxd"
  ],
  "application/vnd.sun.xml.draw.template": [
    "std"
  ],
  "application/vnd.sun.xml.impress": [
    "sxi"
  ],
  "application/vnd.sun.xml.impress.template": [
    "sti"
  ],
  "application/vnd.sun.xml.math": [
    "sxm"
  ],
  "application/vnd.sun.xml.writer": [
    "sxw"
  ],
  "application/vnd.sun.xml.writer.global": [
    "sxg"
  ],
  "application/vnd.sun.xml.writer.template": [
    "stw"
  ],
  "application/vnd.sus-calendar": [
    "sus",
    "susp"
  ],
  "application/vnd.svd": [
    "svd"
  ],
  "application/vnd.symbian.install": [
    "sis",
    "sisx"
  ],
  "application/vnd.syncml+xml": [
    "xsm"
  ],
  "application/vnd.syncml.dm+wbxml": [
    "bdm"
  ],
  "application/vnd.syncml.dm+xml": [
    "xdm"
  ],
  "application/vnd.tao.intent-module-archive": [
    "tao"
  ],
  "application/vnd.tcpdump.pcap": [
    "pcap",
    "cap",
    "dmp"
  ],
  "application/vnd.tmobile-livetv": [
    "tmo"
  ],
  "application/vnd.trid.tpt": [
    "tpt"
  ],
  "application/vnd.triscape.mxs": [
    "mxs"
  ],
  "application/vnd.trueapp": [
    "tra"
  ],
  "application/vnd.ufdl": [
    "ufd",
    "ufdl"
  ],
  "application/vnd.uiq.theme": [
    "utz"
  ],
  "application/vnd.umajin": [
    "umj"
  ],
  "application/vnd.unity": [
    "unityweb"
  ],
  "application/vnd.uoml+xml": [
    "uoml"
  ],
  "application/vnd.vcx": [
    "vcx"
  ],
  "application/vnd.visio": [
    "vsd",
    "vst",
    "vss",
    "vsw"
  ],
  "application/vnd.visionary": [
    "vis"
  ],
  "application/vnd.vsf": [
    "vsf"
  ],
  "application/vnd.wap.wbxml": [
    "wbxml"
  ],
  "application/vnd.wap.wmlc": [
    "wmlc"
  ],
  "application/vnd.wap.wmlscriptc": [
    "wmlsc"
  ],
  "application/vnd.webturbo": [
    "wtb"
  ],
  "application/vnd.wolfram.player": [
    "nbp"
  ],
  "application/vnd.wordperfect": [
    "wpd"
  ],
  "application/vnd.wqd": [
    "wqd"
  ],
  "application/vnd.wt.stf": [
    "stf"
  ],
  "application/vnd.xara": [
    "xar"
  ],
  "application/vnd.xfdl": [
    "xfdl"
  ],
  "application/vnd.yamaha.hv-dic": [
    "hvd"
  ],
  "application/vnd.yamaha.hv-script": [
    "hvs"
  ],
  "application/vnd.yamaha.hv-voice": [
    "hvp"
  ],
  "application/vnd.yamaha.openscoreformat": [
    "osf"
  ],
  "application/vnd.yamaha.openscoreformat.osfpvg+xml": [
    "osfpvg"
  ],
  "application/vnd.yamaha.smaf-audio": [
    "saf"
  ],
  "application/vnd.yamaha.smaf-phrase": [
    "spf"
  ],
  "application/vnd.yellowriver-custom-menu": [
    "cmp"
  ],
  "application/vnd.zul": [
    "zir",
    "zirz"
  ],
  "application/vnd.zzazz.deck+xml": [
    "zaz"
  ],
  "application/voicexml+xml": [
    "vxml"
  ],
  "application/wasm": [
    "wasm"
  ],
  "application/widget": [
    "wgt"
  ],
  "application/winhlp": [
    "hlp"
  ],
  "application/wsdl+xml": [
    "wsdl"
  ],
  "application/wspolicy+xml": [
    "wspolicy"
  ],
  "application/x-7z-compressed": [
    "7z"
  ],
  "application/x-abiword": [
    "abw"
  ],
  "application/x-ace-compressed": [
    "ace"
  ],
  "application/x-apple-diskimage": [],
  "application/x-arj": [
    "arj"
  ],
  "application/x-authorware-bin": [
    "aab",
    "x32",
    "u32",
    "vox"
  ],
  "application/x-authorware-map": [
    "aam"
  ],
  "application/x-authorware-seg": [
    "aas"
  ],
  "application/x-bcpio": [
    "bcpio"
  ],
  "application/x-bdoc": [],
  "application/x-bittorrent": [
    "torrent"
  ],
  "application/x-blorb": [
    "blb",
    "blorb"
  ],
  "application/x-bzip": [
    "bz"
  ],
  "application/x-bzip2": [
    "bz2",
    "boz"
  ],
  "application/x-cbr": [
    "cbr",
    "cba",
    "cbt",
    "cbz",
    "cb7"
  ],
  "application/x-cdlink": [
    "vcd"
  ],
  "application/x-cfs-compressed": [
    "cfs"
  ],
  "application/x-chat": [
    "chat"
  ],
  "application/x-chess-pgn": [
    "pgn"
  ],
  "application/x-chrome-extension": [
    "crx"
  ],
  "application/x-cocoa": [
    "cco"
  ],
  "application/x-conference": [
    "nsc"
  ],
  "application/x-cpio": [
    "cpio"
  ],
  "application/x-csh": [
    "csh"
  ],
  "application/x-debian-package": [
    "udeb"
  ],
  "application/x-dgc-compressed": [
    "dgc"
  ],
  "application/x-director": [
    "dir",
    "dcr",
    "dxr",
    "cst",
    "cct",
    "cxt",
    "w3d",
    "fgd",
    "swa"
  ],
  "application/x-doom": [
    "wad"
  ],
  "application/x-dtbncx+xml": [
    "ncx"
  ],
  "application/x-dtbook+xml": [
    "dtb"
  ],
  "application/x-dtbresource+xml": [
    "res"
  ],
  "application/x-dvi": [
    "dvi"
  ],
  "application/x-envoy": [
    "evy"
  ],
  "application/x-eva": [
    "eva"
  ],
  "application/x-font-bdf": [
    "bdf"
  ],
  "application/x-font-ghostscript": [
    "gsf"
  ],
  "application/x-font-linux-psf": [
    "psf"
  ],
  "application/x-font-pcf": [
    "pcf"
  ],
  "application/x-font-snf": [
    "snf"
  ],
  "application/x-font-type1": [
    "pfa",
    "pfb",
    "pfm",
    "afm"
  ],
  "application/x-freearc": [
    "arc"
  ],
  "application/x-futuresplash": [
    "spl"
  ],
  "application/x-gca-compressed": [
    "gca"
  ],
  "application/x-glulx": [
    "ulx"
  ],
  "application/x-gnumeric": [
    "gnumeric"
  ],
  "application/x-gramps-xml": [
    "gramps"
  ],
  "application/x-gtar": [
    "gtar"
  ],
  "application/x-hdf": [
    "hdf"
  ],
  "application/x-httpd-php": [
    "php"
  ],
  "application/x-install-instructions": [
    "install"
  ],
  "application/x-iso9660-image": [],
  "application/x-java-archive-diff": [
    "jardiff"
  ],
  "application/x-java-jnlp-file": [
    "jnlp"
  ],
  "application/x-latex": [
    "latex"
  ],
  "application/x-lua-bytecode": [
    "luac"
  ],
  "application/x-lzh-compressed": [
    "lzh",
    "lha"
  ],
  "application/x-makeself": [
    "run"
  ],
  "application/x-mie": [
    "mie"
  ],
  "application/x-mobipocket-ebook": [
    "prc",
    "mobi"
  ],
  "application/x-ms-application": [
    "application"
  ],
  "application/x-ms-shortcut": [
    "lnk"
  ],
  "application/x-ms-wmd": [
    "wmd"
  ],
  "application/x-ms-wmz": [
    "wmz"
  ],
  "application/x-ms-xbap": [
    "xbap"
  ],
  "application/x-msaccess": [
    "mdb"
  ],
  "application/x-msbinder": [
    "obd"
  ],
  "application/x-mscardfile": [
    "crd"
  ],
  "application/x-msclip": [
    "clp"
  ],
  "application/x-msdos-program": [],
  "application/x-msdownload": [
    "com",
    "bat"
  ],
  "application/x-msmediaview": [
    "mvb",
    "m13",
    "m14"
  ],
  "application/x-msmetafile": [
    "wmf",
    "emf",
    "emz"
  ],
  "application/x-msmoney": [
    "mny"
  ],
  "application/x-mspublisher": [
    "pub"
  ],
  "application/x-msschedule": [
    "scd"
  ],
  "application/x-msterminal": [
    "trm"
  ],
  "application/x-mswrite": [
    "wri"
  ],
  "application/x-netcdf": [
    "nc",
    "cdf"
  ],
  "application/x-ns-proxy-autoconfig": [
    "pac"
  ],
  "application/x-nzb": [
    "nzb"
  ],
  "application/x-perl": [
    "pl",
    "pm"
  ],
  "application/x-pilot": [],
  "application/x-pkcs12": [
    "p12",
    "pfx"
  ],
  "application/x-pkcs7-certificates": [
    "p7b",
    "spc"
  ],
  "application/x-pkcs7-certreqresp": [
    "p7r"
  ],
  "application/x-rar-compressed": [
    "rar"
  ],
  "application/x-redhat-package-manager": [
    "rpm"
  ],
  "application/x-research-info-systems": [
    "ris"
  ],
  "application/x-sea": [
    "sea"
  ],
  "application/x-sh": [
    "sh"
  ],
  "application/x-shar": [
    "shar"
  ],
  "application/x-shockwave-flash": [
    "swf"
  ],
  "application/x-silverlight-app": [
    "xap"
  ],
  "application/x-sql": [
    "sql"
  ],
  "application/x-stuffit": [
    "sit"
  ],
  "application/x-stuffitx": [
    "sitx"
  ],
  "application/x-subrip": [
    "srt"
  ],
  "application/x-sv4cpio": [
    "sv4cpio"
  ],
  "application/x-sv4crc": [
    "sv4crc"
  ],
  "application/x-t3vm-image": [
    "t3"
  ],
  "application/x-tads": [
    "gam"
  ],
  "application/x-tar": [
    "tar"
  ],
  "application/x-tcl": [
    "tcl",
    "tk"
  ],
  "application/x-tex": [
    "tex"
  ],
  "application/x-tex-tfm": [
    "tfm"
  ],
  "application/x-texinfo": [
    "texinfo",
    "texi"
  ],
  "application/x-tgif": [
    "obj"
  ],
  "application/x-ustar": [
    "ustar"
  ],
  "application/x-virtualbox-hdd": [
    "hdd"
  ],
  "application/x-virtualbox-ova": [
    "ova"
  ],
  "application/x-virtualbox-ovf": [
    "ovf"
  ],
  "application/x-virtualbox-vbox": [
    "vbox"
  ],
  "application/x-virtualbox-vbox-extpack": [
    "vbox-extpack"
  ],
  "application/x-virtualbox-vdi": [
    "vdi"
  ],
  "application/x-virtualbox-vhd": [
    "vhd"
  ],
  "application/x-virtualbox-vmdk": [
    "vmdk"
  ],
  "application/x-wais-source": [
    "src"
  ],
  "application/x-web-app-manifest+json": [
    "webapp"
  ],
  "application/x-x509-ca-cert": [
    "der",
    "crt",
    "pem"
  ],
  "application/x-xfig": [
    "fig"
  ],
  "application/x-xliff+xml": [
    "xlf"
  ],
  "application/x-xpinstall": [
    "xpi"
  ],
  "application/x-xz": [
    "xz"
  ],
  "application/x-zmachine": [
    "z1",
    "z2",
    "z3",
    "z4",
    "z5",
    "z6",
    "z7",
    "z8"
  ],
  "application/xaml+xml": [
    "xaml"
  ],
  "application/xcap-diff+xml": [
    "xdf"
  ],
  "application/xenc+xml": [
    "xenc"
  ],
  "application/xhtml+xml": [
    "xhtml",
    "xht"
  ],
  "application/xml": [
    "xml",
    "xsl",
    "xsd",
    "rng"
  ],
  "application/xml-dtd": [
    "dtd"
  ],
  "application/xop+xml": [
    "xop"
  ],
  "application/xproc+xml": [
    "xpl"
  ],
  "application/xslt+xml": [
    "xslt"
  ],
  "application/xspf+xml": [
    "xspf"
  ],
  "application/xv+xml": [
    "mxml",
    "xhvml",
    "xvml",
    "xvm"
  ],
  "application/yang": [
    "yang"
  ],
  "application/yin+xml": [
    "yin"
  ],
  "application/zip": [
    "zip"
  ],
  "audio/3gpp": [],
  "audio/adpcm": [
    "adp"
  ],
  "audio/basic": [
    "au",
    "snd"
  ],
  "audio/midi": [
    "mid",
    "midi",
    "kar",
    "rmi"
  ],
  "audio/mp3": [],
  "audio/mp4": [
    "m4a",
    "mp4a"
  ],
  "audio/mpeg": [
    "mpga",
    "mp2",
    "mp2a",
    "mp3",
    "m2a",
    "m3a"
  ],
  "audio/ogg": [
    "oga",
    "ogg",
    "spx"
  ],
  "audio/s3m": [
    "s3m"
  ],
  "audio/silk": [
    "sil"
  ],
  "audio/vnd.dece.audio": [
    "uva",
    "uvva"
  ],
  "audio/vnd.digital-winds": [
    "eol"
  ],
  "audio/vnd.dra": [
    "dra"
  ],
  "audio/vnd.dts": [
    "dts"
  ],
  "audio/vnd.dts.hd": [
    "dtshd"
  ],
  "audio/vnd.lucent.voice": [
    "lvp"
  ],
  "audio/vnd.ms-playready.media.pya": [
    "pya"
  ],
  "audio/vnd.nuera.ecelp4800": [
    "ecelp4800"
  ],
  "audio/vnd.nuera.ecelp7470": [
    "ecelp7470"
  ],
  "audio/vnd.nuera.ecelp9600": [
    "ecelp9600"
  ],
  "audio/vnd.rip": [
    "rip"
  ],
  "audio/wav": [
    "wav"
  ],
  "audio/wave": [],
  "audio/webm": [
    "weba"
  ],
  "audio/x-aac": [
    "aac"
  ],
  "audio/x-aiff": [
    "aif",
    "aiff",
    "aifc"
  ],
  "audio/x-caf": [
    "caf"
  ],
  "audio/x-flac": [
    "flac"
  ],
  "audio/x-m4a": [],
  "audio/x-matroska": [
    "mka"
  ],
  "audio/x-mpegurl": [
    "m3u"
  ],
  "audio/x-ms-wax": [
    "wax"
  ],
  "audio/x-ms-wma": [
    "wma"
  ],
  "audio/x-pn-realaudio": [
    "ram",
    "ra"
  ],
  "audio/x-pn-realaudio-plugin": [
    "rmp"
  ],
  "audio/x-realaudio": [],
  "audio/x-wav": [],
  "audio/xm": [
    "xm"
  ],
  "chemical/x-cdx": [
    "cdx"
  ],
  "chemical/x-cif": [
    "cif"
  ],
  "chemical/x-cmdf": [
    "cmdf"
  ],
  "chemical/x-cml": [
    "cml"
  ],
  "chemical/x-csml": [
    "csml"
  ],
  "chemical/x-xyz": [
    "xyz"
  ],
  "font/collection": [
    "ttc"
  ],
  "font/otf": [
    "otf"
  ],
  "font/ttf": [
    "ttf"
  ],
  "font/woff": [
    "woff"
  ],
  "font/woff2": [
    "woff2"
  ],
  "image/apng": [
    "apng"
  ],
  "image/bmp": [
    "bmp"
  ],
  "image/cgm": [
    "cgm"
  ],
  "image/g3fax": [
    "g3"
  ],
  "image/gif": [
    "gif"
  ],
  "image/ief": [
    "ief"
  ],
  "image/jp2": [
    "jp2",
    "jpg2"
  ],
  "image/jpeg": [
    "jpeg",
    "jpg",
    "jpe"
  ],
  "image/jpm": [
    "jpm"
  ],
  "image/jpx": [
    "jpx",
    "jpf"
  ],
  "image/ktx": [
    "ktx"
  ],
  "image/png": [
    "png"
  ],
  "image/prs.btif": [
    "btif"
  ],
  "image/sgi": [
    "sgi"
  ],
  "image/svg+xml": [
    "svg",
    "svgz"
  ],
  "image/tiff": [
    "tiff",
    "tif"
  ],
  "image/vnd.adobe.photoshop": [
    "psd"
  ],
  "image/vnd.dece.graphic": [
    "uvi",
    "uvvi",
    "uvg",
    "uvvg"
  ],
  "image/vnd.djvu": [
    "djvu",
    "djv"
  ],
  "image/vnd.dvb.subtitle": [],
  "image/vnd.dwg": [
    "dwg"
  ],
  "image/vnd.dxf": [
    "dxf"
  ],
  "image/vnd.fastbidsheet": [
    "fbs"
  ],
  "image/vnd.fpx": [
    "fpx"
  ],
  "image/vnd.fst": [
    "fst"
  ],
  "image/vnd.fujixerox.edmics-mmr": [
    "mmr"
  ],
  "image/vnd.fujixerox.edmics-rlc": [
    "rlc"
  ],
  "image/vnd.ms-modi": [
    "mdi"
  ],
  "image/vnd.ms-photo": [
    "wdp"
  ],
  "image/vnd.net-fpx": [
    "npx"
  ],
  "image/vnd.wap.wbmp": [
    "wbmp"
  ],
  "image/vnd.xiff": [
    "xif"
  ],
  "image/webp": [
    "webp"
  ],
  "image/x-3ds": [
    "3ds"
  ],
  "image/x-cmu-raster": [
    "ras"
  ],
  "image/x-cmx": [
    "cmx"
  ],
  "image/x-freehand": [
    "fh",
    "fhc",
    "fh4",
    "fh5",
    "fh7"
  ],
  "image/x-icon": [
    "ico"
  ],
  "image/x-jng": [
    "jng"
  ],
  "image/x-mrsid-image": [
    "sid"
  ],
  "image/x-ms-bmp": [],
  "image/x-pcx": [
    "pcx"
  ],
  "image/x-pict": [
    "pic",
    "pct"
  ],
  "image/x-portable-anymap": [
    "pnm"
  ],
  "image/x-portable-bitmap": [
    "pbm"
  ],
  "image/x-portable-graymap": [
    "pgm"
  ],
  "image/x-portable-pixmap": [
    "ppm"
  ],
  "image/x-rgb": [
    "rgb"
  ],
  "image/x-tga": [
    "tga"
  ],
  "image/x-xbitmap": [
    "xbm"
  ],
  "image/x-xpixmap": [
    "xpm"
  ],
  "image/x-xwindowdump": [
    "xwd"
  ],
  "message/rfc822": [
    "eml",
    "mime"
  ],
  "model/gltf+json": [
    "gltf"
  ],
  "model/gltf-binary": [
    "glb"
  ],
  "model/iges": [
    "igs",
    "iges"
  ],
  "model/mesh": [
    "msh",
    "mesh",
    "silo"
  ],
  "model/vnd.collada+xml": [
    "dae"
  ],
  "model/vnd.dwf": [
    "dwf"
  ],
  "model/vnd.gdl": [
    "gdl"
  ],
  "model/vnd.gtw": [
    "gtw"
  ],
  "model/vnd.mts": [
    "mts"
  ],
  "model/vnd.vtu": [
    "vtu"
  ],
  "model/vrml": [
    "wrl",
    "vrml"
  ],
  "model/x3d+binary": [
    "x3db",
    "x3dbz"
  ],
  "model/x3d+vrml": [
    "x3dv",
    "x3dvz"
  ],
  "model/x3d+xml": [
    "x3d",
    "x3dz"
  ],
  "text/cache-manifest": [
    "appcache",
    "manifest"
  ],
  "text/calendar": [
    "ics",
    "ifb"
  ],
  "text/coffeescript": [
    "coffee",
    "litcoffee"
  ],
  "text/css": [
    "css"
  ],
  "text/csv": [
    "csv"
  ],
  "text/hjson": [
    "hjson"
  ],
  "text/html": [
    "html",
    "htm",
    "shtml"
  ],
  "text/jade": [
    "jade"
  ],
  "text/jsx": [
    "jsx"
  ],
  "text/less": [
    "less"
  ],
  "text/markdown": [
    "markdown",
    "md"
  ],
  "text/mathml": [
    "mml"
  ],
  "text/n3": [
    "n3"
  ],
  "text/plain": [
    "txt",
    "text",
    "conf",
    "def",
    "list",
    "log",
    "in",
    "ini"
  ],
  "text/prs.lines.tag": [
    "dsc"
  ],
  "text/richtext": [
    "rtx"
  ],
  "text/rtf": [],
  "text/sgml": [
    "sgml",
    "sgm"
  ],
  "text/slim": [
    "slim",
    "slm"
  ],
  "text/stylus": [
    "stylus",
    "styl"
  ],
  "text/tab-separated-values": [
    "tsv"
  ],
  "text/troff": [
    "t",
    "tr",
    "roff",
    "man",
    "me",
    "ms"
  ],
  "text/turtle": [
    "ttl"
  ],
  "text/uri-list": [
    "uri",
    "uris",
    "urls"
  ],
  "text/vcard": [
    "vcard"
  ],
  "text/vnd.curl": [
    "curl"
  ],
  "text/vnd.curl.dcurl": [
    "dcurl"
  ],
  "text/vnd.curl.mcurl": [
    "mcurl"
  ],
  "text/vnd.curl.scurl": [
    "scurl"
  ],
  "text/vnd.dvb.subtitle": [
    "sub"
  ],
  "text/vnd.fly": [
    "fly"
  ],
  "text/vnd.fmi.flexstor": [
    "flx"
  ],
  "text/vnd.graphviz": [
    "gv"
  ],
  "text/vnd.in3d.3dml": [
    "3dml"
  ],
  "text/vnd.in3d.spot": [
    "spot"
  ],
  "text/vnd.sun.j2me.app-descriptor": [
    "jad"
  ],
  "text/vnd.wap.wml": [
    "wml"
  ],
  "text/vnd.wap.wmlscript": [
    "wmls"
  ],
  "text/vtt": [
    "vtt"
  ],
  "text/x-asm": [
    "s",
    "asm"
  ],
  "text/x-c": [
    "c",
    "cc",
    "cxx",
    "cpp",
    "h",
    "hh",
    "dic"
  ],
  "text/x-component": [
    "htc"
  ],
  "text/x-fortran": [
    "f",
    "for",
    "f77",
    "f90"
  ],
  "text/x-handlebars-template": [
    "hbs"
  ],
  "text/x-java-source": [
    "java"
  ],
  "text/x-lua": [
    "lua"
  ],
  "text/x-markdown": [
    "mkd"
  ],
  "text/x-nfo": [
    "nfo"
  ],
  "text/x-opml": [
    "opml"
  ],
  "text/x-org": [],
  "text/x-pascal": [
    "p",
    "pas"
  ],
  "text/x-processing": [
    "pde"
  ],
  "text/x-sass": [
    "sass"
  ],
  "text/x-scss": [
    "scss"
  ],
  "text/x-setext": [
    "etx"
  ],
  "text/x-sfv": [
    "sfv"
  ],
  "text/x-suse-ymp": [
    "ymp"
  ],
  "text/x-uuencode": [
    "uu"
  ],
  "text/x-vcalendar": [
    "vcs"
  ],
  "text/x-vcard": [
    "vcf"
  ],
  "text/xml": [],
  "text/yaml": [
    "yaml",
    "yml"
  ],
  "video/3gpp": [
    "3gp",
    "3gpp"
  ],
  "video/3gpp2": [
    "3g2"
  ],
  "video/h261": [
    "h261"
  ],
  "video/h263": [
    "h263"
  ],
  "video/h264": [
    "h264"
  ],
  "video/jpeg": [
    "jpgv"
  ],
  "video/jpm": [
    "jpgm"
  ],
  "video/mj2": [
    "mj2",
    "mjp2"
  ],
  "video/mp2t": [
    "ts"
  ],
  "video/mp4": [
    "mp4",
    "mp4v",
    "mpg4"
  ],
  "video/mpeg": [
    "mpeg",
    "mpg",
    "mpe",
    "m1v",
    "m2v"
  ],
  "video/ogg": [
    "ogv"
  ],
  "video/quicktime": [
    "qt",
    "mov"
  ],
  "video/vnd.dece.hd": [
    "uvh",
    "uvvh"
  ],
  "video/vnd.dece.mobile": [
    "uvm",
    "uvvm"
  ],
  "video/vnd.dece.pd": [
    "uvp",
    "uvvp"
  ],
  "video/vnd.dece.sd": [
    "uvs",
    "uvvs"
  ],
  "video/vnd.dece.video": [
    "uvv",
    "uvvv"
  ],
  "video/vnd.dvb.file": [
    "dvb"
  ],
  "video/vnd.fvt": [
    "fvt"
  ],
  "video/vnd.mpegurl": [
    "mxu",
    "m4u"
  ],
  "video/vnd.ms-playready.media.pyv": [
    "pyv"
  ],
  "video/vnd.uvvu.mp4": [
    "uvu",
    "uvvu"
  ],
  "video/vnd.vivo": [
    "viv"
  ],
  "video/webm": [
    "webm"
  ],
  "video/x-f4v": [
    "f4v"
  ],
  "video/x-fli": [
    "fli"
  ],
  "video/x-flv": [
    "flv"
  ],
  "video/x-m4v": [
    "m4v"
  ],
  "video/x-matroska": [
    "mkv",
    "mk3d",
    "mks"
  ],
  "video/x-mng": [
    "mng"
  ],
  "video/x-ms-asf": [
    "asf",
    "asx"
  ],
  "video/x-ms-vob": [
    "vob"
  ],
  "video/x-ms-wm": [
    "wm"
  ],
  "video/x-ms-wmv": [
    "wmv"
  ],
  "video/x-ms-wmx": [
    "wmx"
  ],
  "video/x-ms-wvx": [
    "wvx"
  ],
  "video/x-msvideo": [
    "avi"
  ],
  "video/x-sgi-movie": [
    "movie"
  ],
  "video/x-smv": [
    "smv"
  ],
  "x-conference/x-cooltalk": [
    "ice"
  ]
};
var X3 = se;
function Ii() {
  this.types = /* @__PURE__ */ Object.create(null), this.extensions = /* @__PURE__ */ Object.create(null);
}
Ii.prototype.define = function(t) {
  for (var e in t) {
    for (var r = t[e], n = 0; n < r.length; n++)
      process.env.DEBUG_MIME && this.types[r[n]] && console.warn((this._loading || "define()").replace(/.*\//, ""), 'changes "' + r[n] + '" extension type from ' + this.types[r[n]] + " to " + e), this.types[r[n]] = e;
    this.extensions[e] || (this.extensions[e] = r[0]);
  }
};
Ii.prototype.load = function(t) {
  this._loading = t;
  var e = {}, r = X3.readFileSync(t, "ascii"), n = r.split(/[\r\n]+/);
  n.forEach(function(i) {
    var a = i.replace(/\s*#.*|^\s*|\s*$/g, "").split(/\s+/);
    e[a.shift()] = a;
  }), this.define(e), this._loading = null;
};
Ii.prototype.lookup = function(t, e) {
  var r = t.replace(/^.*[\.\/\\]/, "").toLowerCase();
  return this.types[r] || e || this.default_type;
};
Ii.prototype.extension = function(t) {
  var e = t.match(/^\s*([^;\s]*)(?:;|\s|$)/)[1].toLowerCase();
  return this.extensions[e];
};
var di = new Ii();
di.define(J3);
di.default_type = di.lookup("bin");
di.Mime = Ii;
di.charsets = {
  lookup: function(t, e) {
    return /^text\/|^application\/(javascript|json)/.test(t) ? "UTF-8" : e;
  }
};
var Z3 = di, mi = 1e3, gi = mi * 60, vi = gi * 60, Tn = vi * 24, Y3 = Tn * 7, eR = Tn * 365.25, tR = function(t, e) {
  e = e || {};
  var r = typeof t;
  if (r === "string" && t.length > 0)
    return rR(t);
  if (r === "number" && isFinite(t))
    return e.long ? iR(t) : nR(t);
  throw new Error(
    "val is not a non-empty string or a valid number. val=" + JSON.stringify(t)
  );
};
function rR(t) {
  if (t = String(t), !(t.length > 100)) {
    var e = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      t
    );
    if (e) {
      var r = parseFloat(e[1]), n = (e[2] || "ms").toLowerCase();
      switch (n) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return r * eR;
        case "weeks":
        case "week":
        case "w":
          return r * Y3;
        case "days":
        case "day":
        case "d":
          return r * Tn;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return r * vi;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return r * gi;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return r * mi;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return r;
        default:
          return;
      }
    }
  }
}
function nR(t) {
  var e = Math.abs(t);
  return e >= Tn ? Math.round(t / Tn) + "d" : e >= vi ? Math.round(t / vi) + "h" : e >= gi ? Math.round(t / gi) + "m" : e >= mi ? Math.round(t / mi) + "s" : t + "ms";
}
function iR(t) {
  var e = Math.abs(t);
  return e >= Tn ? Ms(t, e, Tn, "day") : e >= vi ? Ms(t, e, vi, "hour") : e >= gi ? Ms(t, e, gi, "minute") : e >= mi ? Ms(t, e, mi, "second") : t + " ms";
}
function Ms(t, e, r, n) {
  var i = e >= r * 1.5;
  return Math.round(t / r) + " " + n + (i ? "s" : "");
}
/*!
 * range-parser
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var tC = aR;
function aR(t, e, r) {
  if (typeof e != "string")
    throw new TypeError("argument str must be a string");
  var n = e.indexOf("=");
  if (n === -1)
    return -2;
  var i = e.slice(n + 1).split(","), a = [];
  a.type = e.slice(0, n);
  for (var s = 0; s < i.length; s++) {
    var o = i[s].split("-"), c = parseInt(o[0], 10), f = parseInt(o[1], 10);
    isNaN(c) ? (c = t - f, f = t - 1) : isNaN(f) && (f = t - 1), f > t - 1 && (f = t - 1), !(isNaN(c) || isNaN(f) || c > f || c < 0) && a.push({
      start: c,
      end: f
    });
  }
  return a.length < 1 ? -1 : r && r.combine ? sR(a) : a;
}
function sR(t) {
  for (var e = t.map(oR).sort(lR), r = 0, n = 1; n < e.length; n++) {
    var i = e[n], a = e[r];
    i.start > a.end + 1 ? e[++r] = i : i.end > a.end && (a.end = i.end, a.index = Math.min(a.index, i.index));
  }
  e.length = r + 1;
  var s = e.sort(uR).map(cR);
  return s.type = t.type, s;
}
function oR(t, e) {
  return {
    start: t.start,
    end: t.end,
    index: e
  };
}
function cR(t) {
  return {
    start: t.start,
    end: t.end
  };
}
function uR(t, e) {
  return t.index - e.index;
}
function lR(t, e) {
  return t.start - e.start;
}
var nt = {}, pR = function(e) {
  return e && typeof e == "object" && typeof e.copy == "function" && typeof e.fill == "function" && typeof e.readUInt8 == "function";
}, bm = { exports: {} };
typeof Object.create == "function" ? bm.exports = function(e, r) {
  e.super_ = r, e.prototype = Object.create(r.prototype, {
    constructor: {
      value: e,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  });
} : bm.exports = function(e, r) {
  e.super_ = r;
  var n = function() {
  };
  n.prototype = r.prototype, e.prototype = new n(), e.prototype.constructor = e;
};
var fR = bm.exports;
(function(t) {
  var e = /%[sdj%]/g;
  t.format = function($) {
    if (!x($)) {
      for (var L = [], P = 0; P < arguments.length; P++)
        L.push(i(arguments[P]));
      return L.join(" ");
    }
    for (var P = 1, H = arguments, Q = H.length, Y = String($).replace(e, function(ue) {
      if (ue === "%%")
        return "%";
      if (P >= Q)
        return ue;
      switch (ue) {
        case "%s":
          return String(H[P++]);
        case "%d":
          return Number(H[P++]);
        case "%j":
          try {
            return JSON.stringify(H[P++]);
          } catch {
            return "[Circular]";
          }
        default:
          return ue;
      }
    }), ce = H[P]; P < Q; ce = H[++P])
      v(ce) || !T(ce) ? Y += " " + ce : Y += " " + i(ce);
    return Y;
  }, t.deprecate = function($, L) {
    if (w(ve.process))
      return function() {
        return t.deprecate($, L).apply(this, arguments);
      };
    if (process.noDeprecation === !0)
      return $;
    var P = !1;
    function H() {
      if (!P) {
        if (process.throwDeprecation)
          throw new Error(L);
        process.traceDeprecation ? console.trace(L) : console.error(L), P = !0;
      }
      return $.apply(this, arguments);
    }
    return H;
  };
  var r = {}, n;
  t.debuglog = function($) {
    if (w(n) && (n = process.env.NODE_DEBUG || ""), $ = $.toUpperCase(), !r[$])
      if (new RegExp("\\b" + $ + "\\b", "i").test(n)) {
        var L = process.pid;
        r[$] = function() {
          var P = t.format.apply(t, arguments);
          console.error("%s %d: %s", $, L, P);
        };
      } else
        r[$] = function() {
        };
    return r[$];
  };
  function i($, L) {
    var P = {
      seen: [],
      stylize: s
    };
    return arguments.length >= 3 && (P.depth = arguments[2]), arguments.length >= 4 && (P.colors = arguments[3]), g(L) ? P.showHidden = L : L && t._extend(P, L), w(P.showHidden) && (P.showHidden = !1), w(P.depth) && (P.depth = 2), w(P.colors) && (P.colors = !1), w(P.customInspect) && (P.customInspect = !0), P.colors && (P.stylize = a), c(P, $, P.depth);
  }
  t.inspect = i, i.colors = {
    bold: [1, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    white: [37, 39],
    grey: [90, 39],
    black: [30, 39],
    blue: [34, 39],
    cyan: [36, 39],
    green: [32, 39],
    magenta: [35, 39],
    red: [31, 39],
    yellow: [33, 39]
  }, i.styles = {
    special: "cyan",
    number: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    date: "magenta",
    // "name": intentionally not styling
    regexp: "red"
  };
  function a($, L) {
    var P = i.styles[L];
    return P ? "\x1B[" + i.colors[P][0] + "m" + $ + "\x1B[" + i.colors[P][1] + "m" : $;
  }
  function s($, L) {
    return $;
  }
  function o($) {
    var L = {};
    return $.forEach(function(P, H) {
      L[P] = !0;
    }), L;
  }
  function c($, L, P) {
    if ($.customInspect && L && A(L.inspect) && // Filter out the util module, it's inspect function is special
    L.inspect !== t.inspect && // Also filter out any prototype objects using the circular check.
    !(L.constructor && L.constructor.prototype === L)) {
      var H = L.inspect(P, $);
      return x(H) || (H = c($, H, P)), H;
    }
    var Q = f($, L);
    if (Q)
      return Q;
    var Y = Object.keys(L), ce = o(Y);
    if ($.showHidden && (Y = Object.getOwnPropertyNames(L)), C(L) && (Y.indexOf("message") >= 0 || Y.indexOf("description") >= 0))
      return u(L);
    if (Y.length === 0) {
      if (A(L)) {
        var ue = L.name ? ": " + L.name : "";
        return $.stylize("[Function" + ue + "]", "special");
      }
      if (S(L))
        return $.stylize(RegExp.prototype.toString.call(L), "regexp");
      if (E(L))
        return $.stylize(Date.prototype.toString.call(L), "date");
      if (C(L))
        return u(L);
    }
    var me = "", J = !1, O = ["{", "}"];
    if (h(L) && (J = !0, O = ["[", "]"]), A(L)) {
      var I = L.name ? ": " + L.name : "";
      me = " [Function" + I + "]";
    }
    if (S(L) && (me = " " + RegExp.prototype.toString.call(L)), E(L) && (me = " " + Date.prototype.toUTCString.call(L)), C(L) && (me = " " + u(L)), Y.length === 0 && (!J || L.length == 0))
      return O[0] + me + O[1];
    if (P < 0)
      return S(L) ? $.stylize(RegExp.prototype.toString.call(L), "regexp") : $.stylize("[Object]", "special");
    $.seen.push(L);
    var z;
    return J ? z = l($, L, P, ce, Y) : z = Y.map(function(G) {
      return p($, L, P, ce, G, J);
    }), $.seen.pop(), m(z, me, O);
  }
  function f($, L) {
    if (w(L))
      return $.stylize("undefined", "undefined");
    if (x(L)) {
      var P = "'" + JSON.stringify(L).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return $.stylize(P, "string");
    }
    if (y(L))
      return $.stylize("" + L, "number");
    if (g(L))
      return $.stylize("" + L, "boolean");
    if (v(L))
      return $.stylize("null", "null");
  }
  function u($) {
    return "[" + Error.prototype.toString.call($) + "]";
  }
  function l($, L, P, H, Q) {
    for (var Y = [], ce = 0, ue = L.length; ce < ue; ++ce)
      ne(L, String(ce)) ? Y.push(p(
        $,
        L,
        P,
        H,
        String(ce),
        !0
      )) : Y.push("");
    return Q.forEach(function(me) {
      me.match(/^\d+$/) || Y.push(p(
        $,
        L,
        P,
        H,
        me,
        !0
      ));
    }), Y;
  }
  function p($, L, P, H, Q, Y) {
    var ce, ue, me;
    if (me = Object.getOwnPropertyDescriptor(L, Q) || { value: L[Q] }, me.get ? me.set ? ue = $.stylize("[Getter/Setter]", "special") : ue = $.stylize("[Getter]", "special") : me.set && (ue = $.stylize("[Setter]", "special")), ne(H, Q) || (ce = "[" + Q + "]"), ue || ($.seen.indexOf(me.value) < 0 ? (v(P) ? ue = c($, me.value, null) : ue = c($, me.value, P - 1), ue.indexOf(`
`) > -1 && (Y ? ue = ue.split(`
`).map(function(J) {
      return "  " + J;
    }).join(`
`).substr(2) : ue = `
` + ue.split(`
`).map(function(J) {
      return "   " + J;
    }).join(`
`))) : ue = $.stylize("[Circular]", "special")), w(ce)) {
      if (Y && Q.match(/^\d+$/))
        return ue;
      ce = JSON.stringify("" + Q), ce.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (ce = ce.substr(1, ce.length - 2), ce = $.stylize(ce, "name")) : (ce = ce.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), ce = $.stylize(ce, "string"));
    }
    return ce + ": " + ue;
  }
  function m($, L, P) {
    var H = $.reduce(function(Q, Y) {
      return Y.indexOf(`
`) >= 0, Q + Y.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    return H > 60 ? P[0] + (L === "" ? "" : L + `
 `) + " " + $.join(`,
  `) + " " + P[1] : P[0] + L + " " + $.join(", ") + " " + P[1];
  }
  function h($) {
    return Array.isArray($);
  }
  t.isArray = h;
  function g($) {
    return typeof $ == "boolean";
  }
  t.isBoolean = g;
  function v($) {
    return $ === null;
  }
  t.isNull = v;
  function d($) {
    return $ == null;
  }
  t.isNullOrUndefined = d;
  function y($) {
    return typeof $ == "number";
  }
  t.isNumber = y;
  function x($) {
    return typeof $ == "string";
  }
  t.isString = x;
  function b($) {
    return typeof $ == "symbol";
  }
  t.isSymbol = b;
  function w($) {
    return $ === void 0;
  }
  t.isUndefined = w;
  function S($) {
    return T($) && D($) === "[object RegExp]";
  }
  t.isRegExp = S;
  function T($) {
    return typeof $ == "object" && $ !== null;
  }
  t.isObject = T;
  function E($) {
    return T($) && D($) === "[object Date]";
  }
  t.isDate = E;
  function C($) {
    return T($) && (D($) === "[object Error]" || $ instanceof Error);
  }
  t.isError = C;
  function A($) {
    return typeof $ == "function";
  }
  t.isFunction = A;
  function R($) {
    return $ === null || typeof $ == "boolean" || typeof $ == "number" || typeof $ == "string" || typeof $ == "symbol" || // ES6 symbol
    typeof $ > "u";
  }
  t.isPrimitive = R, t.isBuffer = pR;
  function D($) {
    return Object.prototype.toString.call($);
  }
  function F($) {
    return $ < 10 ? "0" + $.toString(10) : $.toString(10);
  }
  var K = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  function V() {
    var $ = /* @__PURE__ */ new Date(), L = [
      F($.getHours()),
      F($.getMinutes()),
      F($.getSeconds())
    ].join(":");
    return [$.getDate(), K[$.getMonth()], L].join(" ");
  }
  t.log = function() {
    console.log("%s - %s", V(), t.format.apply(t, arguments));
  }, t.inherits = fR, t._extend = function($, L) {
    if (!L || !T(L))
      return $;
    for (var P = Object.keys(L), H = P.length; H--; )
      $[P[H]] = L[P[H]];
    return $;
  };
  function ne($, L) {
    return Object.prototype.hasOwnProperty.call($, L);
  }
})(nt);
/*!
 * send
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var Tl = yr(), et = B3("send"), In = tr("send"), hR = xg(), dR = Cc, wm = Tc, mR = Y2, gR = eC, Po = se, xm = Z3, rC = tR, vR = es, yR = tC, ns = se, bR = yc, nC = se, wR = nt, xR = ns.extname, iC = ns.join, Ol = ns.normalize, kg = ns.resolve, bo = ns.sep, _R = /^ *bytes=/, aC = 60 * 60 * 24 * 365 * 1e3, zb = /(?:^|[\\/])\.\.(?:[\\/]|$)/;
Ig.exports = ER;
Ig.exports.mime = xm;
function ER(t, e, r) {
  return new De(t, e, r);
}
function De(t, e, r) {
  nC.call(this);
  var n = r || {};
  if (this.options = n, this.path = e, this.req = t, this._acceptRanges = n.acceptRanges !== void 0 ? !!n.acceptRanges : !0, this._cacheControl = n.cacheControl !== void 0 ? !!n.cacheControl : !0, this._etag = n.etag !== void 0 ? !!n.etag : !0, this._dotfiles = n.dotfiles !== void 0 ? n.dotfiles : "ignore", this._dotfiles !== "ignore" && this._dotfiles !== "allow" && this._dotfiles !== "deny")
    throw new TypeError('dotfiles option must be "allow", "deny", or "ignore"');
  this._hidden = !!n.hidden, n.hidden !== void 0 && In("hidden: use dotfiles: '" + (this._hidden ? "allow" : "ignore") + "' instead"), n.dotfiles === void 0 && (this._dotfiles = void 0), this._extensions = n.extensions !== void 0 ? _m(n.extensions, "extensions option") : [], this._immutable = n.immutable !== void 0 ? !!n.immutable : !1, this._index = n.index !== void 0 ? _m(n.index, "index option") : ["index.html"], this._lastModified = n.lastModified !== void 0 ? !!n.lastModified : !0, this._maxage = n.maxAge || n.maxage, this._maxage = typeof this._maxage == "string" ? rC(this._maxage) : Number(this._maxage), this._maxage = isNaN(this._maxage) ? 0 : Math.min(Math.max(0, this._maxage), aC), this._root = n.root ? kg(n.root) : null, !this._root && n.from && this.from(n.from);
}
wR.inherits(De, nC);
De.prototype.etag = In.function(function(e) {
  return this._etag = !!e, et("etag %s", this._etag), this;
}, "send.etag: pass etag as option");
De.prototype.hidden = In.function(function(e) {
  return this._hidden = !!e, this._dotfiles = void 0, et("hidden %s", this._hidden), this;
}, "send.hidden: use dotfiles option");
De.prototype.index = In.function(function(e) {
  var r = e ? _m(e, "paths argument") : [];
  return et("index %o", e), this._index = r, this;
}, "send.index: pass index as option");
De.prototype.root = function(e) {
  return this._root = kg(String(e)), et("root %s", this._root), this;
};
De.prototype.from = In.function(
  De.prototype.root,
  "send.from: pass root as option"
);
De.prototype.root = In.function(
  De.prototype.root,
  "send.root: pass root as option"
);
De.prototype.maxage = In.function(function(e) {
  return this._maxage = typeof e == "string" ? rC(e) : Number(e), this._maxage = isNaN(this._maxage) ? 0 : Math.min(Math.max(0, this._maxage), aC), et("max-age %d", this._maxage), this;
}, "send.maxage: pass maxAge as option");
De.prototype.error = function(e, r) {
  if (oC(this, "error"))
    return this.emit("error", OR(e, r));
  var n = this.res, i = bR.message[e] || String(e), a = sC("Error", wm(i));
  SR(n), r && r.headers && RR(n, r.headers), n.statusCode = e, n.setHeader("Content-Type", "text/html; charset=UTF-8"), n.setHeader("Content-Length", Buffer.byteLength(a)), n.setHeader("Content-Security-Policy", "default-src 'none'"), n.setHeader("X-Content-Type-Options", "nosniff"), n.end(a);
};
De.prototype.hasTrailingSlash = function() {
  return this.path[this.path.length - 1] === "/";
};
De.prototype.isConditionalGET = function() {
  return this.req.headers["if-match"] || this.req.headers["if-unmodified-since"] || this.req.headers["if-none-match"] || this.req.headers["if-modified-since"];
};
De.prototype.isPreconditionFailure = function() {
  var e = this.req, r = this.res, n = e.headers["if-match"];
  if (n) {
    var i = r.getHeader("ETag");
    return !i || n !== "*" && kR(n).every(function(o) {
      return o !== i && o !== "W/" + i && "W/" + o !== i;
    });
  }
  var a = Do(e.headers["if-unmodified-since"]);
  if (!isNaN(a)) {
    var s = Do(r.getHeader("Last-Modified"));
    return isNaN(s) || s > a;
  }
  return !1;
};
De.prototype.removeContentHeaderFields = function() {
  var e = this.res;
  e.removeHeader("Content-Encoding"), e.removeHeader("Content-Language"), e.removeHeader("Content-Length"), e.removeHeader("Content-Range"), e.removeHeader("Content-Type");
};
De.prototype.notModified = function() {
  var e = this.res;
  et("not modified"), this.removeContentHeaderFields(), e.statusCode = 304, e.end();
};
De.prototype.headersAlreadySent = function() {
  var e = new Error("Can't set headers after they are sent.");
  et("headers already sent"), this.error(500, e);
};
De.prototype.isCachable = function() {
  var e = this.res.statusCode;
  return e >= 200 && e < 300 || e === 304;
};
De.prototype.onStatError = function(e) {
  switch (e.code) {
    case "ENAMETOOLONG":
    case "ENOENT":
    case "ENOTDIR":
      this.error(404, e);
      break;
    default:
      this.error(500, e);
      break;
  }
};
De.prototype.isFresh = function() {
  return gR(this.req.headers, {
    etag: this.res.getHeader("ETag"),
    "last-modified": this.res.getHeader("Last-Modified")
  });
};
De.prototype.isRangeFresh = function() {
  var e = this.req.headers["if-range"];
  if (!e)
    return !0;
  if (e.indexOf('"') !== -1) {
    var r = this.res.getHeader("ETag");
    return !!(r && e.indexOf(r) !== -1);
  }
  var n = this.res.getHeader("Last-Modified");
  return Do(n) <= Do(e);
};
De.prototype.redirect = function(e) {
  var r = this.res;
  if (oC(this, "directory")) {
    this.emit("directory", r, e);
    return;
  }
  if (this.hasTrailingSlash()) {
    this.error(403);
    return;
  }
  var n = dR(CR(this.path + "/")), i = sC("Redirecting", 'Redirecting to <a href="' + wm(n) + '">' + wm(n) + "</a>");
  r.statusCode = 301, r.setHeader("Content-Type", "text/html; charset=UTF-8"), r.setHeader("Content-Length", Buffer.byteLength(i)), r.setHeader("Content-Security-Policy", "default-src 'none'"), r.setHeader("X-Content-Type-Options", "nosniff"), r.setHeader("Location", n), r.end(i);
};
De.prototype.pipe = function(e) {
  var r = this._root;
  this.res = e;
  var n = AR(this.path);
  if (n === -1)
    return this.error(400), e;
  if (~n.indexOf("\0"))
    return this.error(400), e;
  var i;
  if (r !== null) {
    if (n && (n = Ol("." + bo + n)), zb.test(n))
      return et('malicious path "%s"', n), this.error(403), e;
    i = n.split(bo), n = Ol(iC(r, n));
  } else {
    if (zb.test(n))
      return et('malicious path "%s"', n), this.error(403), e;
    i = Ol(n).split(bo), n = kg(n);
  }
  if (TR(i)) {
    var a = this._dotfiles;
    switch (a === void 0 && (a = i[i.length - 1][0] === "." ? this._hidden ? "allow" : "ignore" : "allow"), et('%s dotfile "%s"', a, n), a) {
      case "allow":
        break;
      case "deny":
        return this.error(403), e;
      case "ignore":
      default:
        return this.error(404), e;
    }
  }
  return this._index.length && this.hasTrailingSlash() ? (this.sendIndex(n), e) : (this.sendFile(n), e);
};
De.prototype.send = function(e, r) {
  var n = r.size, i = this.options, a = {}, s = this.res, o = this.req, c = o.headers.range, f = i.start || 0;
  if (IR(s)) {
    this.headersAlreadySent();
    return;
  }
  if (et('pipe "%s"', e), this.setHeader(e, r), this.type(e), this.isConditionalGET()) {
    if (this.isPreconditionFailure()) {
      this.error(412);
      return;
    }
    if (this.isCachable() && this.isFresh()) {
      this.notModified();
      return;
    }
  }
  if (n = Math.max(0, n - f), i.end !== void 0) {
    var u = i.end - f + 1;
    n > u && (n = u);
  }
  if (this._acceptRanges && _R.test(c)) {
    if (c = yR(n, c, {
      combine: !0
    }), this.isRangeFresh() || (et("range stale"), c = -2), c === -1)
      return et("range unsatisfiable"), s.setHeader("Content-Range", Hb("bytes", n)), this.error(416, {
        headers: { "Content-Range": s.getHeader("Content-Range") }
      });
    c !== -2 && c.length === 1 && (et("range %j", c), s.statusCode = 206, s.setHeader("Content-Range", Hb("bytes", n, c[0])), f += c[0].start, n = c[0].end - c[0].start + 1);
  }
  for (var l in i)
    a[l] = i[l];
  if (a.start = f, a.end = Math.max(f, f + n - 1), s.setHeader("Content-Length", n), o.method === "HEAD") {
    s.end();
    return;
  }
  this.stream(e, a);
};
De.prototype.sendFile = function(e) {
  var r = 0, n = this;
  et('stat "%s"', e), Po.stat(e, function(s, o) {
    if (s && s.code === "ENOENT" && !xR(e) && e[e.length - 1] !== bo)
      return i(s);
    if (s)
      return n.onStatError(s);
    if (o.isDirectory())
      return n.redirect(e);
    n.emit("file", e, o), n.send(e, o);
  });
  function i(a) {
    if (n._extensions.length <= r)
      return a ? n.onStatError(a) : n.error(404);
    var s = e + "." + n._extensions[r++];
    et('stat "%s"', s), Po.stat(s, function(o, c) {
      if (o)
        return i(o);
      if (c.isDirectory())
        return i();
      n.emit("file", s, c), n.send(s, c);
    });
  }
};
De.prototype.sendIndex = function(e) {
  var r = -1, n = this;
  function i(a) {
    if (++r >= n._index.length)
      return a ? n.onStatError(a) : n.error(404);
    var s = iC(e, n._index[r]);
    et('stat "%s"', s), Po.stat(s, function(o, c) {
      if (o)
        return i(o);
      if (c.isDirectory())
        return i();
      n.emit("file", s, c), n.send(s, c);
    });
  }
  i();
};
De.prototype.stream = function(e, r) {
  var n = this, i = this.res, a = Po.createReadStream(e, r);
  this.emit("stream", a), a.pipe(i);
  function s() {
    hR(a, !0);
  }
  vR(i, s), a.on("error", function(c) {
    s(), n.onStatError(c);
  }), a.on("end", function() {
    n.emit("end");
  });
};
De.prototype.type = function(e) {
  var r = this.res;
  if (!r.getHeader("Content-Type")) {
    var n = xm.lookup(e);
    if (!n) {
      et("no content-type");
      return;
    }
    var i = xm.charsets.lookup(n);
    et("content-type %s", n), r.setHeader("Content-Type", n + (i ? "; charset=" + i : ""));
  }
};
De.prototype.setHeader = function(e, r) {
  var n = this.res;
  if (this.emit("headers", n, e, r), this._acceptRanges && !n.getHeader("Accept-Ranges") && (et("accept ranges"), n.setHeader("Accept-Ranges", "bytes")), this._cacheControl && !n.getHeader("Cache-Control")) {
    var i = "public, max-age=" + Math.floor(this._maxage / 1e3);
    this._immutable && (i += ", immutable"), et("cache-control %s", i), n.setHeader("Cache-Control", i);
  }
  if (this._lastModified && !n.getHeader("Last-Modified")) {
    var a = r.mtime.toUTCString();
    et("modified %s", a), n.setHeader("Last-Modified", a);
  }
  if (this._etag && !n.getHeader("ETag")) {
    var s = mR(r);
    et("etag %s", s), n.setHeader("ETag", s);
  }
};
function SR(t) {
  for (var e = $R(t), r = 0; r < e.length; r++)
    t.removeHeader(e[r]);
}
function CR(t) {
  for (var e = 0; e < t.length && t[e] === "/"; e++)
    ;
  return e > 1 ? "/" + t.substr(e) : t;
}
function TR(t) {
  for (var e = 0; e < t.length; e++) {
    var r = t[e];
    if (r.length > 1 && r[0] === ".")
      return !0;
  }
  return !1;
}
function Hb(t, e, r) {
  return t + " " + (r ? r.start + "-" + r.end : "*") + "/" + e;
}
function sC(t, e) {
  return `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>` + t + `</title>
</head>
<body>
<pre>` + e + `</pre>
</body>
</html>
`;
}
function OR(t, e) {
  return e ? e instanceof Error ? Tl(t, e, { expose: !1 }) : Tl(t, e) : Tl(t);
}
function AR(t) {
  try {
    return decodeURIComponent(t);
  } catch {
    return -1;
  }
}
function $R(t) {
  return typeof t.getHeaderNames != "function" ? Object.keys(t._headers || {}) : t.getHeaderNames();
}
function oC(t, e) {
  var r = typeof t.listenerCount != "function" ? t.listeners(e).length : t.listenerCount(e);
  return r > 0;
}
function IR(t) {
  return typeof t.headersSent != "boolean" ? !!t._header : t.headersSent;
}
function _m(t, e) {
  for (var r = [].concat(t || []), n = 0; n < r.length; n++)
    if (typeof r[n] != "string")
      throw new TypeError(e + " must be array of strings or false");
  return r;
}
function Do(t) {
  var e = t && Date.parse(t);
  return typeof e == "number" ? e : NaN;
}
function kR(t) {
  for (var e = 0, r = [], n = 0, i = 0, a = t.length; i < a; i++)
    switch (t.charCodeAt(i)) {
      case 32:
        n === e && (n = e = i + 1);
        break;
      case 44:
        n !== e && r.push(t.substring(n, e)), n = e = i + 1;
        break;
      default:
        e = i + 1;
        break;
    }
  return n !== e && r.push(t.substring(n, e)), r;
}
function RR(t, e) {
  for (var r = Object.keys(e), n = 0; n < r.length; n++) {
    var i = r[n];
    t.setHeader(i, e[i]);
  }
}
var Rg = Ig.exports, kc = { exports: {} };
/*!
 * forwarded
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
var NR = LR;
function LR(t) {
  if (!t)
    throw new TypeError("argument req is required");
  var e = DR(t.headers["x-forwarded-for"] || ""), r = PR(t), n = [r].concat(e);
  return n;
}
function PR(t) {
  return t.socket ? t.socket.remoteAddress : t.connection.remoteAddress;
}
function DR(t) {
  for (var e = t.length, r = [], n = t.length, i = t.length - 1; i >= 0; i--)
    switch (t.charCodeAt(i)) {
      case 32:
        n === e && (n = e = i);
        break;
      case 44:
        n !== e && r.push(t.substring(n, e)), n = e = i;
        break;
      default:
        n = i;
        break;
    }
  return n !== e && r.push(t.substring(n, e)), r;
}
var Ng = { exports: {} };
Ng.exports;
(function(t) {
  (function() {
    var e, r, n, i, a, s, o, c, f;
    r = {}, c = this, t !== null && t.exports ? t.exports = r : c.ipaddr = r, o = function(u, l, p, m) {
      var h, g;
      if (u.length !== l.length)
        throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
      for (h = 0; m > 0; ) {
        if (g = p - m, g < 0 && (g = 0), u[h] >> g !== l[h] >> g)
          return !1;
        m -= p, h += 1;
      }
      return !0;
    }, r.subnetMatch = function(u, l, p) {
      var m, h, g, v, d;
      p == null && (p = "unicast");
      for (g in l)
        for (v = l[g], v[0] && !(v[0] instanceof Array) && (v = [v]), m = 0, h = v.length; m < h; m++)
          if (d = v[m], u.kind() === d[0].kind() && u.match.apply(u, d))
            return g;
      return p;
    }, r.IPv4 = function() {
      function u(l) {
        var p, m, h;
        if (l.length !== 4)
          throw new Error("ipaddr: ipv4 octet count should be 4");
        for (p = 0, m = l.length; p < m; p++)
          if (h = l[p], !(0 <= h && h <= 255))
            throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
        this.octets = l;
      }
      return u.prototype.kind = function() {
        return "ipv4";
      }, u.prototype.toString = function() {
        return this.octets.join(".");
      }, u.prototype.toNormalizedString = function() {
        return this.toString();
      }, u.prototype.toByteArray = function() {
        return this.octets.slice(0);
      }, u.prototype.match = function(l, p) {
        var m;
        if (p === void 0 && (m = l, l = m[0], p = m[1]), l.kind() !== "ipv4")
          throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
        return o(this.octets, l.octets, 8, p);
      }, u.prototype.SpecialRanges = {
        unspecified: [[new u([0, 0, 0, 0]), 8]],
        broadcast: [[new u([255, 255, 255, 255]), 32]],
        multicast: [[new u([224, 0, 0, 0]), 4]],
        linkLocal: [[new u([169, 254, 0, 0]), 16]],
        loopback: [[new u([127, 0, 0, 0]), 8]],
        carrierGradeNat: [[new u([100, 64, 0, 0]), 10]],
        private: [[new u([10, 0, 0, 0]), 8], [new u([172, 16, 0, 0]), 12], [new u([192, 168, 0, 0]), 16]],
        reserved: [[new u([192, 0, 0, 0]), 24], [new u([192, 0, 2, 0]), 24], [new u([192, 88, 99, 0]), 24], [new u([198, 51, 100, 0]), 24], [new u([203, 0, 113, 0]), 24], [new u([240, 0, 0, 0]), 4]]
      }, u.prototype.range = function() {
        return r.subnetMatch(this, this.SpecialRanges);
      }, u.prototype.toIPv4MappedAddress = function() {
        return r.IPv6.parse("::ffff:" + this.toString());
      }, u.prototype.prefixLengthFromSubnetMask = function() {
        var l, p, m, h, g, v, d;
        for (d = {
          0: 8,
          128: 7,
          192: 6,
          224: 5,
          240: 4,
          248: 3,
          252: 2,
          254: 1,
          255: 0
        }, l = 0, g = !1, p = m = 3; m >= 0; p = m += -1)
          if (h = this.octets[p], h in d) {
            if (v = d[h], g && v !== 0)
              return null;
            v !== 8 && (g = !0), l += v;
          } else
            return null;
        return 32 - l;
      }, u;
    }(), n = "(0?\\d+|0x[a-f0-9]+)", i = {
      fourOctet: new RegExp("^" + n + "\\." + n + "\\." + n + "\\." + n + "$", "i"),
      longValue: new RegExp("^" + n + "$", "i")
    }, r.IPv4.parser = function(u) {
      var l, p, m, h, g;
      if (p = function(v) {
        return v[0] === "0" && v[1] !== "x" ? parseInt(v, 8) : parseInt(v);
      }, l = u.match(i.fourOctet))
        return function() {
          var v, d, y, x;
          for (y = l.slice(1, 6), x = [], v = 0, d = y.length; v < d; v++)
            m = y[v], x.push(p(m));
          return x;
        }();
      if (l = u.match(i.longValue)) {
        if (g = p(l[1]), g > 4294967295 || g < 0)
          throw new Error("ipaddr: address outside defined range");
        return function() {
          var v, d;
          for (d = [], h = v = 0; v <= 24; h = v += 8)
            d.push(g >> h & 255);
          return d;
        }().reverse();
      } else
        return null;
    }, r.IPv6 = function() {
      function u(l, p) {
        var m, h, g, v, d, y;
        if (l.length === 16)
          for (this.parts = [], m = h = 0; h <= 14; m = h += 2)
            this.parts.push(l[m] << 8 | l[m + 1]);
        else if (l.length === 8)
          this.parts = l;
        else
          throw new Error("ipaddr: ipv6 part count should be 8 or 16");
        for (y = this.parts, g = 0, v = y.length; g < v; g++)
          if (d = y[g], !(0 <= d && d <= 65535))
            throw new Error("ipaddr: ipv6 part should fit in 16 bits");
        p && (this.zoneId = p);
      }
      return u.prototype.kind = function() {
        return "ipv6";
      }, u.prototype.toString = function() {
        return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, "::");
      }, u.prototype.toRFC5952String = function() {
        var l, p, m, h, g;
        for (h = /((^|:)(0(:|$)){2,})/g, g = this.toNormalizedString(), l = 0, p = -1; m = h.exec(g); )
          m[0].length > p && (l = m.index, p = m[0].length);
        return p < 0 ? g : g.substring(0, l) + "::" + g.substring(l + p);
      }, u.prototype.toByteArray = function() {
        var l, p, m, h, g;
        for (l = [], g = this.parts, p = 0, m = g.length; p < m; p++)
          h = g[p], l.push(h >> 8), l.push(h & 255);
        return l;
      }, u.prototype.toNormalizedString = function() {
        var l, p, m;
        return l = function() {
          var h, g, v, d;
          for (v = this.parts, d = [], h = 0, g = v.length; h < g; h++)
            p = v[h], d.push(p.toString(16));
          return d;
        }.call(this).join(":"), m = "", this.zoneId && (m = "%" + this.zoneId), l + m;
      }, u.prototype.toFixedLengthString = function() {
        var l, p, m;
        return l = function() {
          var h, g, v, d;
          for (v = this.parts, d = [], h = 0, g = v.length; h < g; h++)
            p = v[h], d.push(p.toString(16).padStart(4, "0"));
          return d;
        }.call(this).join(":"), m = "", this.zoneId && (m = "%" + this.zoneId), l + m;
      }, u.prototype.match = function(l, p) {
        var m;
        if (p === void 0 && (m = l, l = m[0], p = m[1]), l.kind() !== "ipv6")
          throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
        return o(this.parts, l.parts, 16, p);
      }, u.prototype.SpecialRanges = {
        unspecified: [new u([0, 0, 0, 0, 0, 0, 0, 0]), 128],
        linkLocal: [new u([65152, 0, 0, 0, 0, 0, 0, 0]), 10],
        multicast: [new u([65280, 0, 0, 0, 0, 0, 0, 0]), 8],
        loopback: [new u([0, 0, 0, 0, 0, 0, 0, 1]), 128],
        uniqueLocal: [new u([64512, 0, 0, 0, 0, 0, 0, 0]), 7],
        ipv4Mapped: [new u([0, 0, 0, 0, 0, 65535, 0, 0]), 96],
        rfc6145: [new u([0, 0, 0, 0, 65535, 0, 0, 0]), 96],
        rfc6052: [new u([100, 65435, 0, 0, 0, 0, 0, 0]), 96],
        "6to4": [new u([8194, 0, 0, 0, 0, 0, 0, 0]), 16],
        teredo: [new u([8193, 0, 0, 0, 0, 0, 0, 0]), 32],
        reserved: [[new u([8193, 3512, 0, 0, 0, 0, 0, 0]), 32]]
      }, u.prototype.range = function() {
        return r.subnetMatch(this, this.SpecialRanges);
      }, u.prototype.isIPv4MappedAddress = function() {
        return this.range() === "ipv4Mapped";
      }, u.prototype.toIPv4Address = function() {
        var l, p, m;
        if (!this.isIPv4MappedAddress())
          throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
        return m = this.parts.slice(-2), l = m[0], p = m[1], new r.IPv4([l >> 8, l & 255, p >> 8, p & 255]);
      }, u.prototype.prefixLengthFromSubnetMask = function() {
        var l, p, m, h, g, v, d;
        for (d = {
          0: 16,
          32768: 15,
          49152: 14,
          57344: 13,
          61440: 12,
          63488: 11,
          64512: 10,
          65024: 9,
          65280: 8,
          65408: 7,
          65472: 6,
          65504: 5,
          65520: 4,
          65528: 3,
          65532: 2,
          65534: 1,
          65535: 0
        }, l = 0, g = !1, p = m = 7; m >= 0; p = m += -1)
          if (h = this.parts[p], h in d) {
            if (v = d[h], g && v !== 0)
              return null;
            v !== 16 && (g = !0), l += v;
          } else
            return null;
        return 128 - l;
      }, u;
    }(), a = "(?:[0-9a-f]+::?)+", f = "%[0-9a-z]{1,}", s = {
      zoneIndex: new RegExp(f, "i"),
      native: new RegExp("^(::)?(" + a + ")?([0-9a-f]+)?(::)?(" + f + ")?$", "i"),
      transitional: new RegExp("^((?:" + a + ")|(?:::)(?:" + a + ")?)" + (n + "\\." + n + "\\." + n + "\\." + n) + ("(" + f + ")?$"), "i")
    }, e = function(u, l) {
      var p, m, h, g, v, d;
      if (u.indexOf("::") !== u.lastIndexOf("::"))
        return null;
      for (d = (u.match(s.zoneIndex) || [])[0], d && (d = d.substring(1), u = u.replace(/%.+$/, "")), p = 0, m = -1; (m = u.indexOf(":", m + 1)) >= 0; )
        p++;
      if (u.substr(0, 2) === "::" && p--, u.substr(-2, 2) === "::" && p--, p > l)
        return null;
      for (v = l - p, g = ":"; v--; )
        g += "0:";
      return u = u.replace("::", g), u[0] === ":" && (u = u.slice(1)), u[u.length - 1] === ":" && (u = u.slice(0, -1)), l = function() {
        var y, x, b, w;
        for (b = u.split(":"), w = [], y = 0, x = b.length; y < x; y++)
          h = b[y], w.push(parseInt(h, 16));
        return w;
      }(), {
        parts: l,
        zoneId: d
      };
    }, r.IPv6.parser = function(u) {
      var l, p, m, h, g, v, d;
      if (s.native.test(u))
        return e(u, 8);
      if ((h = u.match(s.transitional)) && (d = h[6] || "", l = e(h[1].slice(0, -1) + d, 6), l.parts)) {
        for (v = [parseInt(h[2]), parseInt(h[3]), parseInt(h[4]), parseInt(h[5])], p = 0, m = v.length; p < m; p++)
          if (g = v[p], !(0 <= g && g <= 255))
            return null;
        return l.parts.push(v[0] << 8 | v[1]), l.parts.push(v[2] << 8 | v[3]), {
          parts: l.parts,
          zoneId: l.zoneId
        };
      }
      return null;
    }, r.IPv4.isIPv4 = r.IPv6.isIPv6 = function(u) {
      return this.parser(u) !== null;
    }, r.IPv4.isValid = function(u) {
      try {
        return new this(this.parser(u)), !0;
      } catch {
        return !1;
      }
    }, r.IPv4.isValidFourPartDecimal = function(u) {
      return !!(r.IPv4.isValid(u) && u.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/));
    }, r.IPv6.isValid = function(u) {
      var l;
      if (typeof u == "string" && u.indexOf(":") === -1)
        return !1;
      try {
        return l = this.parser(u), new this(l.parts, l.zoneId), !0;
      } catch {
        return !1;
      }
    }, r.IPv4.parse = function(u) {
      var l;
      if (l = this.parser(u), l === null)
        throw new Error("ipaddr: string is not formatted like ip address");
      return new this(l);
    }, r.IPv6.parse = function(u) {
      var l;
      if (l = this.parser(u), l.parts === null)
        throw new Error("ipaddr: string is not formatted like ip address");
      return new this(l.parts, l.zoneId);
    }, r.IPv4.parseCIDR = function(u) {
      var l, p, m;
      if ((p = u.match(/^(.+)\/(\d+)$/)) && (l = parseInt(p[2]), l >= 0 && l <= 32))
        return m = [this.parse(p[1]), l], Object.defineProperty(m, "toString", {
          value: function() {
            return this.join("/");
          }
        }), m;
      throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
    }, r.IPv4.subnetMaskFromPrefixLength = function(u) {
      var l, p, m;
      if (u = parseInt(u), u < 0 || u > 32)
        throw new Error("ipaddr: invalid IPv4 prefix length");
      for (m = [0, 0, 0, 0], p = 0, l = Math.floor(u / 8); p < l; )
        m[p] = 255, p++;
      return l < 4 && (m[l] = Math.pow(2, u % 8) - 1 << 8 - u % 8), new this(m);
    }, r.IPv4.broadcastAddressFromCIDR = function(u) {
      var l, p, m, h, g;
      try {
        for (l = this.parseCIDR(u), m = l[0].toByteArray(), g = this.subnetMaskFromPrefixLength(l[1]).toByteArray(), h = [], p = 0; p < 4; )
          h.push(parseInt(m[p], 10) | parseInt(g[p], 10) ^ 255), p++;
        return new this(h);
      } catch {
        throw new Error("ipaddr: the address does not have IPv4 CIDR format");
      }
    }, r.IPv4.networkAddressFromCIDR = function(u) {
      var l, p, m, h, g;
      try {
        for (l = this.parseCIDR(u), m = l[0].toByteArray(), g = this.subnetMaskFromPrefixLength(l[1]).toByteArray(), h = [], p = 0; p < 4; )
          h.push(parseInt(m[p], 10) & parseInt(g[p], 10)), p++;
        return new this(h);
      } catch {
        throw new Error("ipaddr: the address does not have IPv4 CIDR format");
      }
    }, r.IPv6.parseCIDR = function(u) {
      var l, p, m;
      if ((p = u.match(/^(.+)\/(\d+)$/)) && (l = parseInt(p[2]), l >= 0 && l <= 128))
        return m = [this.parse(p[1]), l], Object.defineProperty(m, "toString", {
          value: function() {
            return this.join("/");
          }
        }), m;
      throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
    }, r.isValid = function(u) {
      return r.IPv6.isValid(u) || r.IPv4.isValid(u);
    }, r.parse = function(u) {
      if (r.IPv6.isValid(u))
        return r.IPv6.parse(u);
      if (r.IPv4.isValid(u))
        return r.IPv4.parse(u);
      throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
    }, r.parseCIDR = function(u) {
      try {
        return r.IPv6.parseCIDR(u);
      } catch {
        try {
          return r.IPv4.parseCIDR(u);
        } catch {
          throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
        }
      }
    }, r.fromByteArray = function(u) {
      var l;
      if (l = u.length, l === 4)
        return new r.IPv4(u);
      if (l === 16)
        return new r.IPv6(u);
      throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
    }, r.process = function(u) {
      var l;
      return l = this.parse(u), l.kind() === "ipv6" && l.isIPv4MappedAddress() ? l.toIPv4Address() : l;
    };
  }).call(ve);
})(Ng);
var MR = Ng.exports;
/*!
 * proxy-addr
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
kc.exports = HR;
kc.exports.all = uC;
kc.exports.compile = lC;
var qR = NR, cC = MR, jR = /^[0-9]+$/, Mo = cC.isValid, Rc = cC.parse, Wb = {
  linklocal: ["169.254.0.0/16", "fe80::/10"],
  loopback: ["127.0.0.1/8", "::1/128"],
  uniquelocal: ["10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "fc00::/7"]
};
function uC(t, e) {
  var r = qR(t);
  if (!e)
    return r;
  typeof e != "function" && (e = lC(e));
  for (var n = 0; n < r.length - 1; n++)
    e(r[n], n) || (r.length = n + 1);
  return r;
}
function lC(t) {
  if (!t)
    throw new TypeError("argument is required");
  var e;
  if (typeof t == "string")
    e = [t];
  else if (Array.isArray(t))
    e = t.slice();
  else
    throw new TypeError("unsupported trust argument");
  for (var r = 0; r < e.length; r++)
    t = e[r], Object.prototype.hasOwnProperty.call(Wb, t) && (t = Wb[t], e.splice.apply(e, [r, 1].concat(t)), r += t.length - 1);
  return BR(FR(e));
}
function FR(t) {
  for (var e = new Array(t.length), r = 0; r < t.length; r++)
    e[r] = UR(t[r]);
  return e;
}
function BR(t) {
  var e = t.length;
  return e === 0 ? WR : e === 1 ? QR(t[0]) : GR(t);
}
function UR(t) {
  var e = t.lastIndexOf("/"), r = e !== -1 ? t.substring(0, e) : t;
  if (!Mo(r))
    throw new TypeError("invalid IP address: " + r);
  var n = Rc(r);
  e === -1 && n.kind() === "ipv6" && n.isIPv4MappedAddress() && (n = n.toIPv4Address());
  var i = n.kind() === "ipv6" ? 128 : 32, a = e !== -1 ? t.substring(e + 1, t.length) : null;
  if (a === null ? a = i : jR.test(a) ? a = parseInt(a, 10) : n.kind() === "ipv4" && Mo(a) ? a = zR(a) : a = null, a <= 0 || a > i)
    throw new TypeError("invalid range on address: " + t);
  return [n, a];
}
function zR(t) {
  var e = Rc(t), r = e.kind();
  return r === "ipv4" ? e.prefixLengthFromSubnetMask() : null;
}
function HR(t, e) {
  if (!t)
    throw new TypeError("req argument is required");
  if (!e)
    throw new TypeError("trust argument is required");
  var r = uC(t, e), n = r[r.length - 1];
  return n;
}
function WR() {
  return !1;
}
function GR(t) {
  return function(r) {
    if (!Mo(r))
      return !1;
    for (var n = Rc(r), i, a = n.kind(), s = 0; s < t.length; s++) {
      var o = t[s], c = o[0], f = c.kind(), u = o[1], l = n;
      if (a !== f) {
        if (f === "ipv4" && !n.isIPv4MappedAddress())
          continue;
        i || (i = f === "ipv4" ? n.toIPv4Address() : n.toIPv4MappedAddress()), l = i;
      }
      if (l.match(c, u))
        return !0;
    }
    return !1;
  };
}
function QR(t) {
  var e = t[0], r = e.kind(), n = r === "ipv4", i = t[1];
  return function(s) {
    if (!Mo(s))
      return !1;
    var o = Rc(s), c = o.kind();
    if (c !== r) {
      if (n && !o.isIPv4MappedAddress())
        return !1;
      o = n ? o.toIPv4Address() : o.toIPv4MappedAddress();
    }
    return o.match(e, i);
  };
}
var pC = kc.exports;
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
(function(t) {
  var e = xc.Buffer, r = Z2, n = An(), i = tr("express"), a = Oc, s = Rg.mime, o = Y2, c = pC, f = Sc(), u = se;
  t.etag = p({ weak: !1 }), t.wetag = p({ weak: !0 }), t.isAbsolute = function(g) {
    if (g[0] === "/" || g[1] === ":" && (g[2] === "\\" || g[2] === "/") || g.substring(0, 2) === "\\\\")
      return !0;
  }, t.flatten = i.function(
    a,
    "utils.flatten: use array-flatten npm module instead"
  ), t.normalizeType = function(g) {
    return ~g.indexOf("/") ? l(g) : { value: s.lookup(g), params: {} };
  }, t.normalizeTypes = function(g) {
    for (var v = [], d = 0; d < g.length; ++d)
      v.push(t.normalizeType(g[d]));
    return v;
  }, t.contentDisposition = i.function(
    r,
    "utils.contentDisposition: use content-disposition npm module instead"
  );
  function l(g, v) {
    for (var d = g.split(/ *; */), y = { value: d[0], quality: 1, params: {}, originalIndex: v }, x = 1; x < d.length; ++x) {
      var b = d[x].split(/ *= */);
      b[0] === "q" ? y.quality = parseFloat(b[1]) : y.params[b[0]] = b[1];
    }
    return y;
  }
  t.compileETag = function(g) {
    var v;
    if (typeof g == "function")
      return g;
    switch (g) {
      case !0:
      case "weak":
        v = t.wetag;
        break;
      case !1:
        break;
      case "strong":
        v = t.etag;
        break;
      default:
        throw new TypeError("unknown value for etag function: " + g);
    }
    return v;
  }, t.compileQueryParser = function(v) {
    var d;
    if (typeof v == "function")
      return v;
    switch (v) {
      case !0:
      case "simple":
        d = u.parse;
        break;
      case !1:
        d = h;
        break;
      case "extended":
        d = m;
        break;
      default:
        throw new TypeError("unknown value for query parser function: " + v);
    }
    return d;
  }, t.compileTrust = function(g) {
    return typeof g == "function" ? g : g === !0 ? function() {
      return !0;
    } : typeof g == "number" ? function(v, d) {
      return d < g;
    } : (typeof g == "string" && (g = g.split(",").map(function(v) {
      return v.trim();
    })), c.compile(g || []));
  }, t.setCharset = function(v, d) {
    if (!v || !d)
      return v;
    var y = n.parse(v);
    return y.parameters.charset = d, n.format(y);
  };
  function p(g) {
    return function(d, y) {
      var x = e.isBuffer(d) ? d : e.from(d, y);
      return o(x, g);
    };
  }
  function m(g) {
    return f.parse(g, {
      allowPrototypes: !0
    });
  }
  function h() {
    return {};
  }
})(tn);
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
(function(t, e) {
  var r = Ok, n = W2, i = Ag, a = G2, s = Q2, o = Mr("express:application"), c = m3, f = se, u = tn.compileETag, l = tn.compileQueryParser, p = tn.compileTrust, m = tr("express"), h = Oc, g = Ac, v = se.resolve, d = vc, y = Object.prototype.hasOwnProperty, x = Array.prototype.slice, b = t.exports = {}, w = "@@symbol:trust_proxy_default";
  b.init = function() {
    this.cache = {}, this.engines = {}, this.settings = {}, this.defaultConfiguration();
  }, b.defaultConfiguration = function() {
    var C = process.env.NODE_ENV || "development";
    this.enable("x-powered-by"), this.set("etag", "weak"), this.set("env", C), this.set("query parser", "extended"), this.set("subdomain offset", 2), this.set("trust proxy", !1), Object.defineProperty(this.settings, w, {
      configurable: !0,
      value: !0
    }), o("booting in %s mode", C), this.on("mount", function(R) {
      this.settings[w] === !0 && typeof R.settings["trust proxy fn"] == "function" && (delete this.settings["trust proxy"], delete this.settings["trust proxy fn"]), d(this.request, R.request), d(this.response, R.response), d(this.engines, R.engines), d(this.settings, R.settings);
    }), this.locals = /* @__PURE__ */ Object.create(null), this.mountpath = "/", this.locals.settings = this.settings, this.set("view", c), this.set("views", v("views")), this.set("jsonp callback name", "callback"), C === "production" && this.enable("view cache"), Object.defineProperty(this, "router", {
      get: function() {
        throw new Error(`'app.router' is deprecated!
Please see the 3.x to 4.x migration guide for details on how to update your app.`);
      }
    });
  }, b.lazyrouter = function() {
    this._router || (this._router = new n({
      caseSensitive: this.enabled("case sensitive routing"),
      strict: this.enabled("strict routing")
    }), this._router.use(s(this.get("query parser fn"))), this._router.use(a.init(this)));
  }, b.handle = function(C, A, R) {
    var D = this._router, F = R || r(C, A, {
      env: this.get("env"),
      onerror: S.bind(this)
    });
    if (!D) {
      o("no routes defined on app"), F();
      return;
    }
    D.handle(C, A, F);
  }, b.use = function(C) {
    var A = 0, R = "/";
    if (typeof C != "function") {
      for (var D = C; Array.isArray(D) && D.length !== 0; )
        D = D[0];
      typeof D != "function" && (A = 1, R = C);
    }
    var F = h(x.call(arguments, A));
    if (F.length === 0)
      throw new TypeError("app.use() requires a middleware function");
    this.lazyrouter();
    var K = this._router;
    return F.forEach(function(V) {
      if (!V || !V.handle || !V.set)
        return K.use(R, V);
      o(".use app under %s", R), V.mountpath = R, V.parent = this, K.use(R, function($, L, P) {
        var H = $.app;
        V.handle($, L, function(Q) {
          d($, H.request), d(L, H.response), P(Q);
        });
      }), V.emit("mount", this);
    }, this), this;
  }, b.route = function(C) {
    return this.lazyrouter(), this._router.route(C);
  }, b.engine = function(C, A) {
    if (typeof A != "function")
      throw new Error("callback function required");
    var R = C[0] !== "." ? "." + C : C;
    return this.engines[R] = A, this;
  }, b.param = function(C, A) {
    if (this.lazyrouter(), Array.isArray(C)) {
      for (var R = 0; R < C.length; R++)
        this.param(C[R], A);
      return this;
    }
    return this._router.param(C, A), this;
  }, b.set = function(C, A) {
    if (arguments.length === 1) {
      for (var R = this.settings; R && R !== Object.prototype; ) {
        if (y.call(R, C))
          return R[C];
        R = Object.getPrototypeOf(R);
      }
      return;
    }
    switch (o('set "%s" to %o', C, A), this.settings[C] = A, C) {
      case "etag":
        this.set("etag fn", u(A));
        break;
      case "query parser":
        this.set("query parser fn", l(A));
        break;
      case "trust proxy":
        this.set("trust proxy fn", p(A)), Object.defineProperty(this.settings, w, {
          configurable: !0,
          value: !1
        });
        break;
    }
    return this;
  }, b.path = function() {
    return this.parent ? this.parent.path() + this.mountpath : "";
  }, b.enabled = function(C) {
    return !!this.set(C);
  }, b.disabled = function(C) {
    return !this.set(C);
  }, b.enable = function(C) {
    return this.set(C, !0);
  }, b.disable = function(C) {
    return this.set(C, !1);
  }, i.forEach(function(E) {
    b[E] = function(C) {
      if (E === "get" && arguments.length === 1)
        return this.set(C);
      this.lazyrouter();
      var A = this._router.route(C);
      return A[E].apply(A, x.call(arguments, 1)), this;
    };
  }), b.all = function(C) {
    this.lazyrouter();
    for (var A = this._router.route(C), R = x.call(arguments, 1), D = 0; D < i.length; D++)
      A[i[D]].apply(A, R);
    return this;
  }, b.del = m.function(b.delete, "app.del: Use app.delete instead"), b.render = function(C, A, R) {
    var D = this.cache, F = R, K = this.engines, V = A, ne = {}, $;
    if (typeof A == "function" && (F = A, V = {}), g(ne, this.locals), V._locals && g(ne, V._locals), g(ne, V), ne.cache == null && (ne.cache = this.enabled("view cache")), ne.cache && ($ = D[C]), !$) {
      var L = this.get("view");
      if ($ = new L(C, {
        defaultEngine: this.get("view engine"),
        root: this.get("views"),
        engines: K
      }), !$.path) {
        var P = Array.isArray($.root) && $.root.length > 1 ? 'directories "' + $.root.slice(0, -1).join('", "') + '" or "' + $.root[$.root.length - 1] + '"' : 'directory "' + $.root + '"', H = new Error('Failed to lookup view "' + C + '" in views ' + P);
        return H.view = $, F(H);
      }
      ne.cache && (D[C] = $);
    }
    T($, ne, F);
  }, b.listen = function() {
    var C = f.createServer(this);
    return C.listen.apply(C, arguments);
  };
  function S(E) {
    this.get("env") !== "test" && console.error(E.stack || E.toString());
  }
  function T(E, C, A) {
    try {
      E.render(C, A);
    } catch (R) {
      A(R);
    }
  }
})(S2);
var VR = S2.exports, Lg = { exports: {} }, Pg = { exports: {} };
Pg.exports = fC;
Pg.exports.preferredCharsets = fC;
var KR = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
function JR(t) {
  for (var e = t.split(","), r = 0, n = 0; r < e.length; r++) {
    var i = XR(e[r].trim(), r);
    i && (e[n++] = i);
  }
  return e.length = n, e;
}
function XR(t, e) {
  var r = KR.exec(t);
  if (!r)
    return null;
  var n = r[1], i = 1;
  if (r[2])
    for (var a = r[2].split(";"), s = 0; s < a.length; s++) {
      var o = a[s].trim().split("=");
      if (o[0] === "q") {
        i = parseFloat(o[1]);
        break;
      }
    }
  return {
    charset: n,
    q: i,
    i: e
  };
}
function ZR(t, e, r) {
  for (var n = { o: -1, q: 0, s: 0 }, i = 0; i < e.length; i++) {
    var a = YR(t, e[i], r);
    a && (n.s - a.s || n.q - a.q || n.o - a.o) < 0 && (n = a);
  }
  return n;
}
function YR(t, e, r) {
  var n = 0;
  if (e.charset.toLowerCase() === t.toLowerCase())
    n |= 1;
  else if (e.charset !== "*")
    return null;
  return {
    i: r,
    o: e.i,
    q: e.q,
    s: n
  };
}
function fC(t, e) {
  var r = JR(t === void 0 ? "*" : t || "");
  if (!e)
    return r.filter(Qb).sort(Gb).map(eN);
  var n = e.map(function(a, s) {
    return ZR(a, r, s);
  });
  return n.filter(Qb).sort(Gb).map(function(a) {
    return e[n.indexOf(a)];
  });
}
function Gb(t, e) {
  return e.q - t.q || e.s - t.s || t.o - e.o || t.i - e.i || 0;
}
function eN(t) {
  return t.charset;
}
function Qb(t) {
  return t.q > 0;
}
var tN = Pg.exports, Dg = { exports: {} };
Dg.exports = dC;
Dg.exports.preferredEncodings = dC;
var rN = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
function nN(t) {
  for (var e = t.split(","), r = !1, n = 1, i = 0, a = 0; i < e.length; i++) {
    var s = iN(e[i].trim(), i);
    s && (e[a++] = s, r = r || hC("identity", s), n = Math.min(n, s.q || 1));
  }
  return r || (e[a++] = {
    encoding: "identity",
    q: n,
    i
  }), e.length = a, e;
}
function iN(t, e) {
  var r = rN.exec(t);
  if (!r)
    return null;
  var n = r[1], i = 1;
  if (r[2])
    for (var a = r[2].split(";"), s = 0; s < a.length; s++) {
      var o = a[s].trim().split("=");
      if (o[0] === "q") {
        i = parseFloat(o[1]);
        break;
      }
    }
  return {
    encoding: n,
    q: i,
    i: e
  };
}
function aN(t, e, r) {
  for (var n = { o: -1, q: 0, s: 0 }, i = 0; i < e.length; i++) {
    var a = hC(t, e[i], r);
    a && (n.s - a.s || n.q - a.q || n.o - a.o) < 0 && (n = a);
  }
  return n;
}
function hC(t, e, r) {
  var n = 0;
  if (e.encoding.toLowerCase() === t.toLowerCase())
    n |= 1;
  else if (e.encoding !== "*")
    return null;
  return {
    i: r,
    o: e.i,
    q: e.q,
    s: n
  };
}
function dC(t, e) {
  var r = nN(t || "");
  if (!e)
    return r.filter(Kb).sort(Vb).map(sN);
  var n = e.map(function(a, s) {
    return aN(a, r, s);
  });
  return n.filter(Kb).sort(Vb).map(function(a) {
    return e[n.indexOf(a)];
  });
}
function Vb(t, e) {
  return e.q - t.q || e.s - t.s || t.o - e.o || t.i - e.i || 0;
}
function sN(t) {
  return t.encoding;
}
function Kb(t) {
  return t.q > 0;
}
var oN = Dg.exports, Mg = { exports: {} };
Mg.exports = gC;
Mg.exports.preferredLanguages = gC;
var cN = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
function uN(t) {
  for (var e = t.split(","), r = 0, n = 0; r < e.length; r++) {
    var i = mC(e[r].trim(), r);
    i && (e[n++] = i);
  }
  return e.length = n, e;
}
function mC(t, e) {
  var r = cN.exec(t);
  if (!r)
    return null;
  var n = r[1], i = r[2], a = n;
  i && (a += "-" + i);
  var s = 1;
  if (r[3])
    for (var o = r[3].split(";"), c = 0; c < o.length; c++) {
      var f = o[c].split("=");
      f[0] === "q" && (s = parseFloat(f[1]));
    }
  return {
    prefix: n,
    suffix: i,
    q: s,
    i: e,
    full: a
  };
}
function lN(t, e, r) {
  for (var n = { o: -1, q: 0, s: 0 }, i = 0; i < e.length; i++) {
    var a = pN(t, e[i], r);
    a && (n.s - a.s || n.q - a.q || n.o - a.o) < 0 && (n = a);
  }
  return n;
}
function pN(t, e, r) {
  var n = mC(t);
  if (!n)
    return null;
  var i = 0;
  if (e.full.toLowerCase() === n.full.toLowerCase())
    i |= 4;
  else if (e.prefix.toLowerCase() === n.full.toLowerCase())
    i |= 2;
  else if (e.full.toLowerCase() === n.prefix.toLowerCase())
    i |= 1;
  else if (e.full !== "*")
    return null;
  return {
    i: r,
    o: e.i,
    q: e.q,
    s: i
  };
}
function gC(t, e) {
  var r = uN(t === void 0 ? "*" : t || "");
  if (!e)
    return r.filter(Xb).sort(Jb).map(fN);
  var n = e.map(function(a, s) {
    return lN(a, r, s);
  });
  return n.filter(Xb).sort(Jb).map(function(a) {
    return e[n.indexOf(a)];
  });
}
function Jb(t, e) {
  return e.q - t.q || e.s - t.s || t.o - e.o || t.i - e.i || 0;
}
function fN(t) {
  return t.full;
}
function Xb(t) {
  return t.q > 0;
}
var hN = Mg.exports, qg = { exports: {} };
qg.exports = yC;
qg.exports.preferredMediaTypes = yC;
var dN = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
function mN(t) {
  for (var e = wN(t), r = 0, n = 0; r < e.length; r++) {
    var i = vC(e[r].trim(), r);
    i && (e[n++] = i);
  }
  return e.length = n, e;
}
function vC(t, e) {
  var r = dN.exec(t);
  if (!r)
    return null;
  var n = /* @__PURE__ */ Object.create(null), i = 1, a = r[2], s = r[1];
  if (r[3])
    for (var o = xN(r[3]).map(bN), c = 0; c < o.length; c++) {
      var f = o[c], u = f[0].toLowerCase(), l = f[1], p = l && l[0] === '"' && l[l.length - 1] === '"' ? l.substr(1, l.length - 2) : l;
      if (u === "q") {
        i = parseFloat(p);
        break;
      }
      n[u] = p;
    }
  return {
    type: s,
    subtype: a,
    params: n,
    q: i,
    i: e
  };
}
function gN(t, e, r) {
  for (var n = { o: -1, q: 0, s: 0 }, i = 0; i < e.length; i++) {
    var a = vN(t, e[i], r);
    a && (n.s - a.s || n.q - a.q || n.o - a.o) < 0 && (n = a);
  }
  return n;
}
function vN(t, e, r) {
  var n = vC(t), i = 0;
  if (!n)
    return null;
  if (e.type.toLowerCase() == n.type.toLowerCase())
    i |= 4;
  else if (e.type != "*")
    return null;
  if (e.subtype.toLowerCase() == n.subtype.toLowerCase())
    i |= 2;
  else if (e.subtype != "*")
    return null;
  var a = Object.keys(e.params);
  if (a.length > 0)
    if (a.every(function(s) {
      return e.params[s] == "*" || (e.params[s] || "").toLowerCase() == (n.params[s] || "").toLowerCase();
    }))
      i |= 1;
    else
      return null;
  return {
    i: r,
    o: e.i,
    q: e.q,
    s: i
  };
}
function yC(t, e) {
  var r = mN(t === void 0 ? "*/*" : t || "");
  if (!e)
    return r.filter(Yb).sort(Zb).map(yN);
  var n = e.map(function(a, s) {
    return gN(a, r, s);
  });
  return n.filter(Yb).sort(Zb).map(function(a) {
    return e[n.indexOf(a)];
  });
}
function Zb(t, e) {
  return e.q - t.q || e.s - t.s || t.o - e.o || t.i - e.i || 0;
}
function yN(t) {
  return t.type + "/" + t.subtype;
}
function Yb(t) {
  return t.q > 0;
}
function bC(t) {
  for (var e = 0, r = 0; (r = t.indexOf('"', r)) !== -1; )
    e++, r++;
  return e;
}
function bN(t) {
  var e = t.indexOf("="), r, n;
  return e === -1 ? r = t : (r = t.substr(0, e), n = t.substr(e + 1)), [r, n];
}
function wN(t) {
  for (var e = t.split(","), r = 1, n = 0; r < e.length; r++)
    bC(e[n]) % 2 == 0 ? e[++n] = e[r] : e[n] += "," + e[r];
  return e.length = n + 1, e;
}
function xN(t) {
  for (var e = t.split(";"), r = 1, n = 0; r < e.length; r++)
    bC(e[n]) % 2 == 0 ? e[++n] = e[r] : e[n] += ";" + e[r];
  e.length = n + 1;
  for (var r = 0; r < e.length; r++)
    e[r] = e[r].trim();
  return e;
}
var _N = qg.exports;
/*!
 * negotiator
 * Copyright(c) 2012 Federico Romero
 * Copyright(c) 2012-2014 Isaac Z. Schlueter
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var EN = tN, SN = oN, CN = hN, TN = _N;
Lg.exports = je;
Lg.exports.Negotiator = je;
function je(t) {
  if (!(this instanceof je))
    return new je(t);
  this.request = t;
}
je.prototype.charset = function(e) {
  var r = this.charsets(e);
  return r && r[0];
};
je.prototype.charsets = function(e) {
  return EN(this.request.headers["accept-charset"], e);
};
je.prototype.encoding = function(e) {
  var r = this.encodings(e);
  return r && r[0];
};
je.prototype.encodings = function(e) {
  return SN(this.request.headers["accept-encoding"], e);
};
je.prototype.language = function(e) {
  var r = this.languages(e);
  return r && r[0];
};
je.prototype.languages = function(e) {
  return CN(this.request.headers["accept-language"], e);
};
je.prototype.mediaType = function(e) {
  var r = this.mediaTypes(e);
  return r && r[0];
};
je.prototype.mediaTypes = function(e) {
  return TN(this.request.headers.accept, e);
};
je.prototype.preferredCharset = je.prototype.charset;
je.prototype.preferredCharsets = je.prototype.charsets;
je.prototype.preferredEncoding = je.prototype.encoding;
je.prototype.preferredEncodings = je.prototype.encodings;
je.prototype.preferredLanguage = je.prototype.language;
je.prototype.preferredLanguages = je.prototype.languages;
je.prototype.preferredMediaType = je.prototype.mediaType;
je.prototype.preferredMediaTypes = je.prototype.mediaTypes;
var ON = Lg.exports;
/*!
 * accepts
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var AN = ON, $N = _2(), IN = Dt;
function Dt(t) {
  if (!(this instanceof Dt))
    return new Dt(t);
  this.headers = t.headers, this.negotiator = new AN(t);
}
Dt.prototype.type = Dt.prototype.types = function(t) {
  var e = t;
  if (e && !Array.isArray(e)) {
    e = new Array(arguments.length);
    for (var r = 0; r < e.length; r++)
      e[r] = arguments[r];
  }
  if (!e || e.length === 0)
    return this.negotiator.mediaTypes();
  if (!this.headers.accept)
    return e[0];
  var n = e.map(kN), i = this.negotiator.mediaTypes(n.filter(RN)), a = i[0];
  return a ? e[n.indexOf(a)] : !1;
};
Dt.prototype.encoding = Dt.prototype.encodings = function(t) {
  var e = t;
  if (e && !Array.isArray(e)) {
    e = new Array(arguments.length);
    for (var r = 0; r < e.length; r++)
      e[r] = arguments[r];
  }
  return !e || e.length === 0 ? this.negotiator.encodings() : this.negotiator.encodings(e)[0] || !1;
};
Dt.prototype.charset = Dt.prototype.charsets = function(t) {
  var e = t;
  if (e && !Array.isArray(e)) {
    e = new Array(arguments.length);
    for (var r = 0; r < e.length; r++)
      e[r] = arguments[r];
  }
  return !e || e.length === 0 ? this.negotiator.charsets() : this.negotiator.charsets(e)[0] || !1;
};
Dt.prototype.lang = Dt.prototype.langs = Dt.prototype.language = Dt.prototype.languages = function(t) {
  var e = t;
  if (e && !Array.isArray(e)) {
    e = new Array(arguments.length);
    for (var r = 0; r < e.length; r++)
      e[r] = arguments[r];
  }
  return !e || e.length === 0 ? this.negotiator.languages() : this.negotiator.languages(e)[0] || !1;
};
function kN(t) {
  return t.indexOf("/") === -1 ? $N.lookup(t) : t;
}
function RN(t) {
  return typeof t == "string";
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var Nc = IN, Lc = tr("express"), NN = se.isIP, LN = qr(), PN = se, DN = eC, MN = tC, qN = ts, wC = pC, Ue = Object.create(PN.IncomingMessage.prototype), jN = Ue;
Ue.get = Ue.header = function(e) {
  if (!e)
    throw new TypeError("name argument is required to req.get");
  if (typeof e != "string")
    throw new TypeError("name must be a string to req.get");
  var r = e.toLowerCase();
  switch (r) {
    case "referer":
    case "referrer":
      return this.headers.referrer || this.headers.referer;
    default:
      return this.headers[r];
  }
};
Ue.accepts = function() {
  var t = Nc(this);
  return t.types.apply(t, arguments);
};
Ue.acceptsEncodings = function() {
  var t = Nc(this);
  return t.encodings.apply(t, arguments);
};
Ue.acceptsEncoding = Lc.function(
  Ue.acceptsEncodings,
  "req.acceptsEncoding: Use acceptsEncodings instead"
);
Ue.acceptsCharsets = function() {
  var t = Nc(this);
  return t.charsets.apply(t, arguments);
};
Ue.acceptsCharset = Lc.function(
  Ue.acceptsCharsets,
  "req.acceptsCharset: Use acceptsCharsets instead"
);
Ue.acceptsLanguages = function() {
  var t = Nc(this);
  return t.languages.apply(t, arguments);
};
Ue.acceptsLanguage = Lc.function(
  Ue.acceptsLanguages,
  "req.acceptsLanguage: Use acceptsLanguages instead"
);
Ue.range = function(e, r) {
  var n = this.get("Range");
  if (n)
    return MN(e, n, r);
};
Ue.param = function(e, r) {
  var n = this.params || {}, i = this.body || {}, a = this.query || {};
  return n[e] != null && n.hasOwnProperty(e) ? n[e] : i[e] != null ? i[e] : a[e] != null ? a[e] : r;
};
Ue.is = function(e) {
  var r = e;
  if (!Array.isArray(e)) {
    r = new Array(arguments.length);
    for (var n = 0; n < r.length; n++)
      r[n] = arguments[n];
  }
  return LN(this, r);
};
nr(Ue, "protocol", function() {
  var e = this.connection.encrypted ? "https" : "http", r = this.app.get("trust proxy fn");
  if (!r(this.connection.remoteAddress, 0))
    return e;
  var n = this.get("X-Forwarded-Proto") || e, i = n.indexOf(",");
  return i !== -1 ? n.substring(0, i).trim() : n.trim();
});
nr(Ue, "secure", function() {
  return this.protocol === "https";
});
nr(Ue, "ip", function() {
  var e = this.app.get("trust proxy fn");
  return wC(this, e);
});
nr(Ue, "ips", function() {
  var e = this.app.get("trust proxy fn"), r = wC.all(this, e);
  return r.reverse().pop(), r;
});
nr(Ue, "subdomains", function() {
  var e = this.hostname;
  if (!e)
    return [];
  var r = this.app.get("subdomain offset"), n = NN(e) ? [e] : e.split(".").reverse();
  return n.slice(r);
});
nr(Ue, "path", function() {
  return qN(this).pathname;
});
nr(Ue, "hostname", function() {
  var e = this.app.get("trust proxy fn"), r = this.get("X-Forwarded-Host");
  if (!r || !e(this.connection.remoteAddress, 0) ? r = this.get("Host") : r.indexOf(",") !== -1 && (r = r.substring(0, r.indexOf(",")).trimRight()), !!r) {
    var n = r[0] === "[" ? r.indexOf("]") + 1 : 0, i = r.indexOf(":", n);
    return i !== -1 ? r.substring(0, i) : r;
  }
});
nr(Ue, "host", Lc.function(function() {
  return this.hostname;
}, "req.host: Use req.hostname instead"));
nr(Ue, "fresh", function() {
  var t = this.method, e = this.res, r = e.statusCode;
  return t !== "GET" && t !== "HEAD" ? !1 : r >= 200 && r < 300 || r === 304 ? DN(this.headers, {
    etag: e.get("ETag"),
    "last-modified": e.get("Last-Modified")
  }) : !1;
});
nr(Ue, "stale", function() {
  return !this.fresh;
});
nr(Ue, "xhr", function() {
  var e = this.get("X-Requested-With") || "";
  return e.toLowerCase() === "xmlhttprequest";
});
function nr(t, e, r) {
  Object.defineProperty(t, e, {
    configurable: !0,
    enumerable: !0,
    get: r
  });
}
var xC = {};
(function(t) {
  var e = se;
  t.sign = function(n, i) {
    if (typeof n != "string")
      throw new TypeError("Cookie value must be provided as a string.");
    if (typeof i != "string")
      throw new TypeError("Secret string must be provided.");
    return n + "." + e.createHmac("sha256", i).update(n).digest("base64").replace(/\=+$/, "");
  }, t.unsign = function(n, i) {
    if (typeof n != "string")
      throw new TypeError("Signed cookie string must be provided.");
    if (typeof i != "string")
      throw new TypeError("Secret string must be provided.");
    var a = n.slice(0, n.lastIndexOf(".")), s = t.sign(a, i);
    return r(s) == r(n) ? a : !1;
  };
  function r(n) {
    return e.createHash("sha1").update(n).digest("hex");
  }
})(xC);
var jg = {};
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
jg.parse = BN;
jg.serialize = UN;
var FN = Object.prototype.toString, qs = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
function BN(t, e) {
  if (typeof t != "string")
    throw new TypeError("argument str must be a string");
  for (var r = {}, n = e || {}, i = n.decode || zN, a = 0; a < t.length; ) {
    var s = t.indexOf("=", a);
    if (s === -1)
      break;
    var o = t.indexOf(";", a);
    if (o === -1)
      o = t.length;
    else if (o < s) {
      a = t.lastIndexOf(";", s - 1) + 1;
      continue;
    }
    var c = t.slice(a, s).trim();
    if (r[c] === void 0) {
      var f = t.slice(s + 1, o).trim();
      f.charCodeAt(0) === 34 && (f = f.slice(1, -1)), r[c] = GN(f, i);
    }
    a = o + 1;
  }
  return r;
}
function UN(t, e, r) {
  var n = r || {}, i = n.encode || HN;
  if (typeof i != "function")
    throw new TypeError("option encode is invalid");
  if (!qs.test(t))
    throw new TypeError("argument name is invalid");
  var a = i(e);
  if (a && !qs.test(a))
    throw new TypeError("argument val is invalid");
  var s = t + "=" + a;
  if (n.maxAge != null) {
    var o = n.maxAge - 0;
    if (isNaN(o) || !isFinite(o))
      throw new TypeError("option maxAge is invalid");
    s += "; Max-Age=" + Math.floor(o);
  }
  if (n.domain) {
    if (!qs.test(n.domain))
      throw new TypeError("option domain is invalid");
    s += "; Domain=" + n.domain;
  }
  if (n.path) {
    if (!qs.test(n.path))
      throw new TypeError("option path is invalid");
    s += "; Path=" + n.path;
  }
  if (n.expires) {
    var c = n.expires;
    if (!WN(c) || isNaN(c.valueOf()))
      throw new TypeError("option expires is invalid");
    s += "; Expires=" + c.toUTCString();
  }
  if (n.httpOnly && (s += "; HttpOnly"), n.secure && (s += "; Secure"), n.priority) {
    var f = typeof n.priority == "string" ? n.priority.toLowerCase() : n.priority;
    switch (f) {
      case "low":
        s += "; Priority=Low";
        break;
      case "medium":
        s += "; Priority=Medium";
        break;
      case "high":
        s += "; Priority=High";
        break;
      default:
        throw new TypeError("option priority is invalid");
    }
  }
  if (n.sameSite) {
    var u = typeof n.sameSite == "string" ? n.sameSite.toLowerCase() : n.sameSite;
    switch (u) {
      case !0:
        s += "; SameSite=Strict";
        break;
      case "lax":
        s += "; SameSite=Lax";
        break;
      case "strict":
        s += "; SameSite=Strict";
        break;
      case "none":
        s += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return s;
}
function zN(t) {
  return t.indexOf("%") !== -1 ? decodeURIComponent(t) : t;
}
function HN(t) {
  return encodeURIComponent(t);
}
function WN(t) {
  return FN.call(t) === "[object Date]" || t instanceof Date;
}
function GN(t, e) {
  try {
    return e(t);
  } catch {
    return t;
  }
}
var Fg = { exports: {} };
/*!
 * vary
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
Fg.exports = VN;
Fg.exports.append = _C;
var QN = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
function _C(t, e) {
  if (typeof t != "string")
    throw new TypeError("header argument is required");
  if (!e)
    throw new TypeError("field argument is required");
  for (var r = Array.isArray(e) ? e : e0(String(e)), n = 0; n < r.length; n++)
    if (!QN.test(r[n]))
      throw new TypeError("field argument contains an invalid header name");
  if (t === "*")
    return t;
  var i = t, a = e0(t.toLowerCase());
  if (r.indexOf("*") !== -1 || a.indexOf("*") !== -1)
    return "*";
  for (var s = 0; s < r.length; s++) {
    var o = r[s].toLowerCase();
    a.indexOf(o) === -1 && (a.push(o), i = i ? i + ", " + r[s] : r[s]);
  }
  return i;
}
function e0(t) {
  for (var e = 0, r = [], n = 0, i = 0, a = t.length; i < a; i++)
    switch (t.charCodeAt(i)) {
      case 32:
        n === e && (n = e = i + 1);
        break;
      case 44:
        r.push(t.substring(n, e)), n = e = i + 1;
        break;
      default:
        e = i + 1;
        break;
    }
  return r.push(t.substring(n, e)), r;
}
function VN(t, e) {
  if (!t || !t.getHeader || !t.setHeader)
    throw new TypeError("res argument is required");
  var r = t.getHeader("Vary") || "", n = Array.isArray(r) ? r.join(", ") : String(r);
  (r = _C(n, e)) && t.setHeader("Vary", r);
}
var EC = Fg.exports;
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var pa = xc.Buffer, SC = Z2, KN = yr(), CC = tr("express"), JN = Cc, XN = Tc, ZN = se, YN = tn.isAbsolute, eL = es, TC = se, qo = yc, OC = Ac, tL = xC.sign, rL = tn.normalizeType, nL = tn.normalizeTypes, iL = tn.setCharset, aL = jg, Bg = Rg, sL = TC.extname, AC = Bg.mime, oL = TC.resolve, cL = EC, We = Object.create(ZN.ServerResponse.prototype), uL = We, lL = /;\s*charset\s*=/;
We.status = function(e) {
  return (typeof e == "string" || Math.floor(e) !== e) && e > 99 && e < 1e3 && CC("res.status(" + JSON.stringify(e) + "): use res.status(" + Math.floor(e) + ") instead"), this.statusCode = e, this;
};
We.links = function(t) {
  var e = this.get("Link") || "";
  return e && (e += ", "), this.set("Link", e + Object.keys(t).map(function(r) {
    return "<" + t[r] + '>; rel="' + r + '"';
  }).join(", "));
};
We.send = function(e) {
  var r = e, n, i = this.req, a, s = this.app;
  switch (arguments.length === 2 && (typeof arguments[0] != "number" && typeof arguments[1] == "number" ? this.statusCode = arguments[1] : (this.statusCode = arguments[0], r = arguments[1])), typeof r == "number" && arguments.length === 1 && (this.get("Content-Type") || this.type("txt"), this.statusCode = r, r = qo.message[r]), typeof r) {
    case "string":
      this.get("Content-Type") || this.type("html");
      break;
    case "boolean":
    case "number":
    case "object":
      if (r === null)
        r = "";
      else if (pa.isBuffer(r))
        this.get("Content-Type") || this.type("bin");
      else
        return this.json(r);
      break;
  }
  typeof r == "string" && (n = "utf8", a = this.get("Content-Type"), typeof a == "string" && this.set("Content-Type", iL(a, "utf-8")));
  var o = s.get("etag fn"), c = !this.get("ETag") && typeof o == "function", f;
  r !== void 0 && (pa.isBuffer(r) ? f = r.length : !c && r.length < 1e3 ? f = pa.byteLength(r, n) : (r = pa.from(r, n), n = void 0, f = r.length), this.set("Content-Length", f));
  var u;
  return c && f !== void 0 && (u = o(r, n)) && this.set("ETag", u), i.fresh && (this.statusCode = 304), (this.statusCode === 204 || this.statusCode === 304) && (this.removeHeader("Content-Type"), this.removeHeader("Content-Length"), this.removeHeader("Transfer-Encoding"), r = ""), this.statusCode === 205 && (this.set("Content-Length", "0"), this.removeHeader("Transfer-Encoding"), r = ""), i.method === "HEAD" ? this.end() : this.end(r, n), this;
};
We.json = function(e) {
  var r = e;
  arguments.length === 2 && (typeof arguments[1] == "number" ? this.statusCode = arguments[1] : (this.statusCode = arguments[0], r = arguments[1]));
  var n = this.app, i = n.get("json escape"), a = n.get("json replacer"), s = n.get("json spaces"), o = IC(r, a, s, i);
  return this.get("Content-Type") || this.set("Content-Type", "application/json"), this.send(o);
};
We.jsonp = function(e) {
  var r = e;
  arguments.length === 2 && (typeof arguments[1] == "number" ? this.statusCode = arguments[1] : (this.statusCode = arguments[0], r = arguments[1]));
  var n = this.app, i = n.get("json escape"), a = n.get("json replacer"), s = n.get("json spaces"), o = IC(r, a, s, i), c = this.req.query[n.get("jsonp callback name")];
  return this.get("Content-Type") || (this.set("X-Content-Type-Options", "nosniff"), this.set("Content-Type", "application/json")), Array.isArray(c) && (c = c[0]), typeof c == "string" && c.length !== 0 && (this.set("X-Content-Type-Options", "nosniff"), this.set("Content-Type", "text/javascript"), c = c.replace(/[^\[\]\w$.]/g, ""), o === void 0 ? o = "" : typeof o == "string" && (o = o.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029")), o = "/**/ typeof " + c + " === 'function' && " + c + "(" + o + ");"), this.send(o);
};
We.sendStatus = function(e) {
  var r = qo.message[e] || String(e);
  return this.statusCode = e, this.type("txt"), this.send(r);
};
We.sendFile = function(e, r, n) {
  var i = n, a = this.req, s = this, o = a.next, c = r || {};
  if (!e)
    throw new TypeError("path argument is required to res.sendFile");
  if (typeof e != "string")
    throw new TypeError("path must be a string to res.sendFile");
  if (typeof r == "function" && (i = r, c = {}), !c.root && !YN(e))
    throw new TypeError("path must be absolute or specify root to res.sendFile");
  var f = encodeURI(e), u = Bg(a, f, c);
  $C(s, u, c, function(l) {
    if (i)
      return i(l);
    if (l && l.code === "EISDIR")
      return o();
    l && l.code !== "ECONNABORTED" && l.syscall !== "write" && o(l);
  });
};
We.sendfile = function(t, e, r) {
  var n = r, i = this.req, a = this, s = i.next, o = e || {};
  typeof e == "function" && (n = e, o = {});
  var c = Bg(i, t, o);
  $C(a, c, o, function(f) {
    if (n)
      return n(f);
    if (f && f.code === "EISDIR")
      return s();
    f && f.code !== "ECONNABORTED" && f.syscall !== "write" && s(f);
  });
};
We.sendfile = CC.function(
  We.sendfile,
  "res.sendfile: Use res.sendFile instead"
);
We.download = function(e, r, n, i) {
  var a = i, s = r, o = n || null;
  typeof r == "function" ? (a = r, s = null, o = null) : typeof n == "function" && (a = n, o = null), typeof r == "object" && (typeof n == "function" || n === void 0) && (s = null, o = r);
  var c = {
    "Content-Disposition": SC(s || e)
  };
  if (o && o.headers)
    for (var f = Object.keys(o.headers), u = 0; u < f.length; u++) {
      var l = f[u];
      l.toLowerCase() !== "content-disposition" && (c[l] = o.headers[l]);
    }
  o = Object.create(o), o.headers = c;
  var p = o.root ? e : oL(e);
  return this.sendFile(p, o, a);
};
We.contentType = We.type = function(e) {
  var r = e.indexOf("/") === -1 ? AC.lookup(e) : e;
  return this.set("Content-Type", r);
};
We.format = function(t) {
  var e = this.req, r = e.next, n = Object.keys(t).filter(function(a) {
    return a !== "default";
  }), i = n.length > 0 ? e.accepts(n) : !1;
  return this.vary("Accept"), i ? (this.set("Content-Type", rL(i).value), t[i](e, this, r)) : t.default ? t.default(e, this, r) : r(KN(406, {
    types: nL(n).map(function(a) {
      return a.value;
    })
  })), this;
};
We.attachment = function(e) {
  return e && this.type(sL(e)), this.set("Content-Disposition", SC(e)), this;
};
We.append = function(e, r) {
  var n = this.get(e), i = r;
  return n && (i = Array.isArray(n) ? n.concat(r) : Array.isArray(r) ? [n].concat(r) : [n, r]), this.set(e, i);
};
We.set = We.header = function(e, r) {
  if (arguments.length === 2) {
    var n = Array.isArray(r) ? r.map(String) : String(r);
    if (e.toLowerCase() === "content-type") {
      if (Array.isArray(n))
        throw new TypeError("Content-Type cannot be set to an Array");
      if (!lL.test(n)) {
        var i = AC.charsets.lookup(n.split(";")[0]);
        i && (n += "; charset=" + i.toLowerCase());
      }
    }
    this.setHeader(e, n);
  } else
    for (var a in e)
      this.set(a, e[a]);
  return this;
};
We.get = function(t) {
  return this.getHeader(t);
};
We.clearCookie = function(e, r) {
  var n = OC({ expires: /* @__PURE__ */ new Date(1), path: "/" }, r);
  return this.cookie(e, "", n);
};
We.cookie = function(t, e, r) {
  var n = OC({}, r), i = this.req.secret, a = n.signed;
  if (a && !i)
    throw new Error('cookieParser("secret") required for signed cookies');
  var s = typeof e == "object" ? "j:" + JSON.stringify(e) : String(e);
  if (a && (s = "s:" + tL(s, i)), n.maxAge != null) {
    var o = n.maxAge - 0;
    isNaN(o) || (n.expires = new Date(Date.now() + o), n.maxAge = Math.floor(o / 1e3));
  }
  return n.path == null && (n.path = "/"), this.append("Set-Cookie", aL.serialize(t, String(s), n)), this;
};
We.location = function(e) {
  var r = e;
  return e === "back" && (r = this.req.get("Referrer") || "/"), this.set("Location", JN(r));
};
We.redirect = function(e) {
  var r = e, n, i = 302;
  arguments.length === 2 && (typeof arguments[0] == "number" ? (i = arguments[0], r = arguments[1]) : i = arguments[1]), r = this.location(r).get("Location"), this.format({
    text: function() {
      n = qo.message[i] + ". Redirecting to " + r;
    },
    html: function() {
      var a = XN(r);
      n = "<p>" + qo.message[i] + '. Redirecting to <a href="' + a + '">' + a + "</a></p>";
    },
    default: function() {
      n = "";
    }
  }), this.statusCode = i, this.set("Content-Length", pa.byteLength(n)), this.req.method === "HEAD" ? this.end() : this.end(n);
};
We.vary = function(t) {
  return !t || Array.isArray(t) && !t.length ? this : (cL(this, t), this);
};
We.render = function(e, r, n) {
  var i = this.req.app, a = n, s = r || {}, o = this.req, c = this;
  typeof r == "function" && (a = r, s = {}), s._locals = c.locals, a = a || function(f, u) {
    if (f)
      return o.next(f);
    c.send(u);
  }, i.render(e, s, a);
};
function $C(t, e, r, n) {
  var i = !1, a;
  function s() {
    if (!i) {
      i = !0;
      var m = new Error("Request aborted");
      m.code = "ECONNABORTED", n(m);
    }
  }
  function o() {
    if (!i) {
      i = !0;
      var m = new Error("EISDIR, read");
      m.code = "EISDIR", n(m);
    }
  }
  function c(m) {
    i || (i = !0, n(m));
  }
  function f() {
    i || (i = !0, n());
  }
  function u() {
    a = !1;
  }
  function l(m) {
    if (m && m.code === "ECONNRESET")
      return s();
    if (m)
      return c(m);
    i || setImmediate(function() {
      if (a !== !1 && !i) {
        s();
        return;
      }
      i || (i = !0, n());
    });
  }
  function p() {
    a = !0;
  }
  e.on("directory", o), e.on("end", f), e.on("error", c), e.on("file", u), e.on("stream", p), eL(t, l), r.headers && e.on("headers", function(h) {
    for (var g = r.headers, v = Object.keys(g), d = 0; d < v.length; d++) {
      var y = v[d];
      h.setHeader(y, g[y]);
    }
  }), e.pipe(t);
}
function IC(t, e, r, n) {
  var i = e || r ? JSON.stringify(t, e, r) : JSON.stringify(t);
  return n && typeof i == "string" && (i = i.replace(/[<>&]/g, function(a) {
    switch (a.charCodeAt(0)) {
      case 60:
        return "\\u003c";
      case 62:
        return "\\u003e";
      case 38:
        return "\\u0026";
      default:
        return a;
    }
  })), i;
}
var js = { exports: {} };
/*!
 * serve-static
 * Copyright(c) 2010 Sencha Inc.
 * Copyright(c) 2011 TJ Holowaychuk
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var t0;
function pL() {
  if (t0)
    return js.exports;
  t0 = 1;
  var t = Cc, e = Tc, r = ts, n = se.resolve, i = Rg, a = se;
  js.exports = s, js.exports.mime = i.mime;
  function s(l, p) {
    if (!l)
      throw new TypeError("root path required");
    if (typeof l != "string")
      throw new TypeError("root path must be a string");
    var m = Object.create(p || null), h = m.fallthrough !== !1, g = m.redirect !== !1, v = m.setHeaders;
    if (v && typeof v != "function")
      throw new TypeError("option setHeaders must be function");
    m.maxage = m.maxage || m.maxAge || 0, m.root = n(l);
    var d = g ? u() : f();
    return function(x, b, w) {
      if (x.method !== "GET" && x.method !== "HEAD") {
        if (h)
          return w();
        b.statusCode = 405, b.setHeader("Allow", "GET, HEAD"), b.setHeader("Content-Length", "0"), b.end();
        return;
      }
      var S = !h, T = r.original(x), E = r(x).pathname;
      E === "/" && T.pathname.substr(-1) !== "/" && (E = "");
      var C = i(x, E, m);
      C.on("directory", d), v && C.on("headers", v), h && C.on("file", function() {
        S = !0;
      }), C.on("error", function(R) {
        if (S || !(R.statusCode < 500)) {
          w(R);
          return;
        }
        w();
      }), C.pipe(b);
    };
  }
  function o(l) {
    for (var p = 0; p < l.length && l.charCodeAt(p) === 47; p++)
      ;
    return p > 1 ? "/" + l.substr(p) : l;
  }
  function c(l, p) {
    return `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>` + l + `</title>
</head>
<body>
<pre>` + p + `</pre>
</body>
</html>
`;
  }
  function f() {
    return function() {
      this.error(404);
    };
  }
  function u() {
    return function(p) {
      if (this.hasTrailingSlash()) {
        this.error(404);
        return;
      }
      var m = r.original(this.req);
      m.path = null, m.pathname = o(m.pathname + "/");
      var h = t(a.format(m)), g = c("Redirecting", 'Redirecting to <a href="' + e(h) + '">' + e(h) + "</a>");
      p.statusCode = 301, p.setHeader("Content-Type", "text/html; charset=UTF-8"), p.setHeader("Content-Length", Buffer.byteLength(g)), p.setHeader("Content-Security-Policy", "default-src 'none'"), p.setHeader("X-Content-Type-Options", "nosniff"), p.setHeader("Location", h), p.end(g);
    };
  }
  return js.exports;
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
(function(t, e) {
  var r = ek, n = bt.EventEmitter, i = tk, a = VR, s = B2, o = W2, c = jN, f = uL;
  e = t.exports = u;
  function u() {
    var p = function(m, h, g) {
      p.handle(m, h, g);
    };
    return i(p, n.prototype, !1), i(p, a, !1), p.request = Object.create(c, {
      app: { configurable: !0, enumerable: !0, writable: !0, value: p }
    }), p.response = Object.create(f, {
      app: { configurable: !0, enumerable: !0, writable: !0, value: p }
    }), p.init(), p;
  }
  e.application = a, e.request = c, e.response = f, e.Route = s, e.Router = o, e.json = r.json, e.query = Q2, e.raw = r.raw, e.static = pL(), e.text = r.text, e.urlencoded = r.urlencoded;
  var l = [
    "bodyParser",
    "compress",
    "cookieSession",
    "session",
    "logger",
    "cookieParser",
    "favicon",
    "responseTime",
    "errorHandler",
    "timeout",
    "methodOverride",
    "vhost",
    "csrf",
    "directory",
    "limit",
    "multipart",
    "staticCache"
  ];
  l.forEach(function(p) {
    Object.defineProperty(e, p, {
      get: function() {
        throw new Error("Most middleware (like " + p + ") is no longer bundled with Express and must be installed separately. Please see https://github.com/senchalabs/connect#middleware.");
      },
      configurable: !0
    });
  });
})(lm, lm.exports);
var fL = lm.exports;
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hL = fL;
const Ug = /* @__PURE__ */ Oi(hL);
var kC = { exports: {} };
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var r0 = Object.getOwnPropertySymbols, dL = Object.prototype.hasOwnProperty, mL = Object.prototype.propertyIsEnumerable;
function gL(t) {
  if (t == null)
    throw new TypeError("Object.assign cannot be called with null or undefined");
  return Object(t);
}
function vL() {
  try {
    if (!Object.assign)
      return !1;
    var t = new String("abc");
    if (t[5] = "de", Object.getOwnPropertyNames(t)[0] === "5")
      return !1;
    for (var e = {}, r = 0; r < 10; r++)
      e["_" + String.fromCharCode(r)] = r;
    var n = Object.getOwnPropertyNames(e).map(function(a) {
      return e[a];
    });
    if (n.join("") !== "0123456789")
      return !1;
    var i = {};
    return "abcdefghijklmnopqrst".split("").forEach(function(a) {
      i[a] = a;
    }), Object.keys(Object.assign({}, i)).join("") === "abcdefghijklmnopqrst";
  } catch {
    return !1;
  }
}
var yL = vL() ? Object.assign : function(t, e) {
  for (var r, n = gL(t), i, a = 1; a < arguments.length; a++) {
    r = Object(arguments[a]);
    for (var s in r)
      dL.call(r, s) && (n[s] = r[s]);
    if (r0) {
      i = r0(r);
      for (var o = 0; o < i.length; o++)
        mL.call(r, i[o]) && (n[i[o]] = r[i[o]]);
    }
  }
  return n;
};
(function() {
  var t = yL, e = EC, r = {
    origin: "*",
    methods: "GET,HEAD,PUT,PATCH,POST,DELETE",
    preflightContinue: !1,
    optionsSuccessStatus: 204
  };
  function n(h) {
    return typeof h == "string" || h instanceof String;
  }
  function i(h, g) {
    if (Array.isArray(g)) {
      for (var v = 0; v < g.length; ++v)
        if (i(h, g[v]))
          return !0;
      return !1;
    } else
      return n(g) ? h === g : g instanceof RegExp ? g.test(h) : !!g;
  }
  function a(h, g) {
    var v = g.headers.origin, d = [], y;
    return !h.origin || h.origin === "*" ? d.push([{
      key: "Access-Control-Allow-Origin",
      value: "*"
    }]) : n(h.origin) ? (d.push([{
      key: "Access-Control-Allow-Origin",
      value: h.origin
    }]), d.push([{
      key: "Vary",
      value: "Origin"
    }])) : (y = i(v, h.origin), d.push([{
      key: "Access-Control-Allow-Origin",
      value: y ? v : !1
    }]), d.push([{
      key: "Vary",
      value: "Origin"
    }])), d;
  }
  function s(h) {
    var g = h.methods;
    return g.join && (g = h.methods.join(",")), {
      key: "Access-Control-Allow-Methods",
      value: g
    };
  }
  function o(h) {
    return h.credentials === !0 ? {
      key: "Access-Control-Allow-Credentials",
      value: "true"
    } : null;
  }
  function c(h, g) {
    var v = h.allowedHeaders || h.headers, d = [];
    return v ? v.join && (v = v.join(",")) : (v = g.headers["access-control-request-headers"], d.push([{
      key: "Vary",
      value: "Access-Control-Request-Headers"
    }])), v && v.length && d.push([{
      key: "Access-Control-Allow-Headers",
      value: v
    }]), d;
  }
  function f(h) {
    var g = h.exposedHeaders;
    if (g)
      g.join && (g = g.join(","));
    else
      return null;
    return g && g.length ? {
      key: "Access-Control-Expose-Headers",
      value: g
    } : null;
  }
  function u(h) {
    var g = (typeof h.maxAge == "number" || h.maxAge) && h.maxAge.toString();
    return g && g.length ? {
      key: "Access-Control-Max-Age",
      value: g
    } : null;
  }
  function l(h, g) {
    for (var v = 0, d = h.length; v < d; v++) {
      var y = h[v];
      y && (Array.isArray(y) ? l(y, g) : y.key === "Vary" && y.value ? e(g, y.value) : y.value && g.setHeader(y.key, y.value));
    }
  }
  function p(h, g, v, d) {
    var y = [], x = g.method && g.method.toUpperCase && g.method.toUpperCase();
    x === "OPTIONS" ? (y.push(a(h, g)), y.push(o(h)), y.push(s(h)), y.push(c(h, g)), y.push(u(h)), y.push(f(h)), l(y, v), h.preflightContinue ? d() : (v.statusCode = h.optionsSuccessStatus, v.setHeader("Content-Length", "0"), v.end())) : (y.push(a(h, g)), y.push(o(h)), y.push(f(h)), l(y, v), d());
  }
  function m(h) {
    var g = null;
    return typeof h == "function" ? g = h : g = function(v, d) {
      d(null, h);
    }, function(d, y, x) {
      g(d, function(b, w) {
        if (b)
          x(b);
        else {
          var S = t({}, r, w), T = null;
          S.origin && typeof S.origin == "function" ? T = S.origin : S.origin && (T = function(E, C) {
            C(null, S.origin);
          }), T ? T(d.headers.origin, function(E, C) {
            E || !C ? x(E) : (S.origin = C, p(S, d, y, x));
          }) : x();
        }
      });
    };
  }
  kC.exports = m;
})();
var bL = kC.exports;
const wL = /* @__PURE__ */ Oi(bL);
var Em = { exports: {} }, Fs = { exports: {} }, Bs = { exports: {} }, Al, n0;
function xL() {
  if (n0)
    return Al;
  n0 = 1;
  var t = 1e3, e = t * 60, r = e * 60, n = r * 24, i = n * 365.25;
  Al = function(f, u) {
    u = u || {};
    var l = typeof f;
    if (l === "string" && f.length > 0)
      return a(f);
    if (l === "number" && isNaN(f) === !1)
      return u.long ? o(f) : s(f);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(f)
    );
  };
  function a(f) {
    if (f = String(f), !(f.length > 100)) {
      var u = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
        f
      );
      if (u) {
        var l = parseFloat(u[1]), p = (u[2] || "ms").toLowerCase();
        switch (p) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return l * i;
          case "days":
          case "day":
          case "d":
            return l * n;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return l * r;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return l * e;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return l * t;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return l;
          default:
            return;
        }
      }
    }
  }
  function s(f) {
    return f >= n ? Math.round(f / n) + "d" : f >= r ? Math.round(f / r) + "h" : f >= e ? Math.round(f / e) + "m" : f >= t ? Math.round(f / t) + "s" : f + "ms";
  }
  function o(f) {
    return c(f, n, "day") || c(f, r, "hour") || c(f, e, "minute") || c(f, t, "second") || f + " ms";
  }
  function c(f, u, l) {
    if (!(f < u))
      return f < u * 1.5 ? Math.floor(f / u) + " " + l : Math.ceil(f / u) + " " + l + "s";
  }
  return Al;
}
var i0;
function _L() {
  return i0 || (i0 = 1, function(t, e) {
    e = t.exports = i.debug = i.default = i, e.coerce = c, e.disable = s, e.enable = a, e.enabled = o, e.humanize = xL(), e.names = [], e.skips = [], e.formatters = {};
    var r;
    function n(f) {
      var u = 0, l;
      for (l in f)
        u = (u << 5) - u + f.charCodeAt(l), u |= 0;
      return e.colors[Math.abs(u) % e.colors.length];
    }
    function i(f) {
      function u() {
        if (u.enabled) {
          var l = u, p = +/* @__PURE__ */ new Date(), m = p - (r || p);
          l.diff = m, l.prev = r, l.curr = p, r = p;
          for (var h = new Array(arguments.length), g = 0; g < h.length; g++)
            h[g] = arguments[g];
          h[0] = e.coerce(h[0]), typeof h[0] != "string" && h.unshift("%O");
          var v = 0;
          h[0] = h[0].replace(/%([a-zA-Z%])/g, function(y, x) {
            if (y === "%%")
              return y;
            v++;
            var b = e.formatters[x];
            if (typeof b == "function") {
              var w = h[v];
              y = b.call(l, w), h.splice(v, 1), v--;
            }
            return y;
          }), e.formatArgs.call(l, h);
          var d = u.log || e.log || console.log.bind(console);
          d.apply(l, h);
        }
      }
      return u.namespace = f, u.enabled = e.enabled(f), u.useColors = e.useColors(), u.color = n(f), typeof e.init == "function" && e.init(u), u;
    }
    function a(f) {
      e.save(f), e.names = [], e.skips = [];
      for (var u = (typeof f == "string" ? f : "").split(/[\s,]+/), l = u.length, p = 0; p < l; p++)
        u[p] && (f = u[p].replace(/\*/g, ".*?"), f[0] === "-" ? e.skips.push(new RegExp("^" + f.substr(1) + "$")) : e.names.push(new RegExp("^" + f + "$")));
    }
    function s() {
      e.enable("");
    }
    function o(f) {
      var u, l;
      for (u = 0, l = e.skips.length; u < l; u++)
        if (e.skips[u].test(f))
          return !1;
      for (u = 0, l = e.names.length; u < l; u++)
        if (e.names[u].test(f))
          return !0;
      return !1;
    }
    function c(f) {
      return f instanceof Error ? f.stack || f.message : f;
    }
  }(Bs, Bs.exports)), Bs.exports;
}
var a0;
function Pc() {
  return a0 || (a0 = 1, function(t, e) {
    e = t.exports = _L(), e.log = i, e.formatArgs = n, e.save = a, e.load = s, e.useColors = r, e.storage = typeof chrome < "u" && typeof chrome.storage < "u" ? chrome.storage.local : o(), e.colors = [
      "lightseagreen",
      "forestgreen",
      "goldenrod",
      "dodgerblue",
      "darkorchid",
      "crimson"
    ];
    function r() {
      return typeof window < "u" && window.process && window.process.type === "renderer" ? !0 : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
      typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
      typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    e.formatters.j = function(c) {
      try {
        return JSON.stringify(c);
      } catch (f) {
        return "[UnexpectedJSONParseError]: " + f.message;
      }
    };
    function n(c) {
      var f = this.useColors;
      if (c[0] = (f ? "%c" : "") + this.namespace + (f ? " %c" : " ") + c[0] + (f ? "%c " : " ") + "+" + e.humanize(this.diff), !!f) {
        var u = "color: " + this.color;
        c.splice(1, 0, u, "color: inherit");
        var l = 0, p = 0;
        c[0].replace(/%[a-zA-Z%]/g, function(m) {
          m !== "%%" && (l++, m === "%c" && (p = l));
        }), c.splice(p, 0, u);
      }
    }
    function i() {
      return typeof console == "object" && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function a(c) {
      try {
        c == null ? e.storage.removeItem("debug") : e.storage.debug = c;
      } catch {
      }
    }
    function s() {
      var c;
      try {
        c = e.storage.debug;
      } catch {
      }
      return !c && typeof process < "u" && "env" in process && (c = process.env.DEBUG), c;
    }
    e.enable(s());
    function o() {
      try {
        return window.localStorage;
      } catch {
      }
    }
  }(Fs, Fs.exports)), Fs.exports;
}
/*!
 * raw-body
 * Copyright(c) 2013-2014 Jonathan Ong
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var $l, s0;
function EL() {
  if (s0)
    return $l;
  s0 = 1;
  var t = u(), e = vr(), r = yr(), n = _c(), i = Ya();
  $l = o;
  var a = /^Encoding not recognized: /;
  function s(p) {
    if (!p)
      return null;
    try {
      return n.getDecoder(p);
    } catch (m) {
      throw a.test(m.message) ? r(415, "specified encoding unsupported", {
        encoding: p,
        type: "encoding.unsupported"
      }) : m;
    }
  }
  function o(p, m, h) {
    var g = h, v = m || {};
    if (p === void 0)
      throw new TypeError("argument stream is required");
    if (typeof p != "object" || p === null || typeof p.on != "function")
      throw new TypeError("argument stream must be a stream");
    if ((m === !0 || typeof m == "string") && (v = {
      encoding: m
    }), typeof m == "function" && (g = m, v = {}), g !== void 0 && typeof g != "function")
      throw new TypeError("argument callback must be a function");
    if (!g && !ve.Promise)
      throw new TypeError("argument callback is required");
    var d = v.encoding !== !0 ? v.encoding : "utf-8", y = e.parse(v.limit), x = v.length != null && !isNaN(v.length) ? parseInt(v.length, 10) : null;
    return g ? f(p, d, x, y, l(g)) : new Promise(function(w, S) {
      f(p, d, x, y, function(E, C) {
        if (E)
          return S(E);
        w(C);
      });
    });
  }
  function c(p) {
    i(p), typeof p.pause == "function" && p.pause();
  }
  function f(p, m, h, g, v) {
    var d = !1, y = !0;
    if (g !== null && h !== null && h > g)
      return T(r(413, "request entity too large", {
        expected: h,
        length: h,
        limit: g,
        type: "entity.too.large"
      }));
    var x = p._readableState;
    if (p._decoder || x && (x.encoding || x.decoder))
      return T(r(500, "stream encoding should not be set", {
        type: "stream.encoding.set"
      }));
    if (typeof p.readable < "u" && !p.readable)
      return T(r(500, "stream is not readable", {
        type: "stream.not.readable"
      }));
    var b = 0, w;
    try {
      w = s(m);
    } catch (D) {
      return T(D);
    }
    var S = w ? "" : [];
    p.on("aborted", E), p.on("close", R), p.on("data", C), p.on("end", A), p.on("error", A), y = !1;
    function T() {
      for (var D = new Array(arguments.length), F = 0; F < D.length; F++)
        D[F] = arguments[F];
      d = !0, y ? process.nextTick(K) : K();
      function K() {
        R(), D[0] && c(p), v.apply(null, D);
      }
    }
    function E() {
      d || T(r(400, "request aborted", {
        code: "ECONNABORTED",
        expected: h,
        length: h,
        received: b,
        type: "request.aborted"
      }));
    }
    function C(D) {
      d || (b += D.length, g !== null && b > g ? T(r(413, "request entity too large", {
        limit: g,
        received: b,
        type: "entity.too.large"
      })) : w ? S += w.write(D) : S.push(D));
    }
    function A(D) {
      if (!d) {
        if (D)
          return T(D);
        if (h !== null && b !== h)
          T(r(400, "request size did not match content length", {
            expected: h,
            length: h,
            received: b,
            type: "request.size.invalid"
          }));
        else {
          var F = w ? S + (w.end() || "") : Buffer.concat(S);
          T(null, F);
        }
      }
    }
    function R() {
      S = null, p.removeListener("aborted", E), p.removeListener("data", C), p.removeListener("end", A), p.removeListener("error", A), p.removeListener("close", R);
    }
  }
  function u() {
    try {
      return se;
    } catch {
      return {};
    }
  }
  function l(p) {
    var m;
    return t.AsyncResource && (m = new t.AsyncResource(p.name || "bound-anonymous-fn")), !m || !m.runInAsyncScope ? p : m.runInAsyncScope.bind(m, p, null);
  }
  return $l;
}
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var Il, o0;
function Dc() {
  if (o0)
    return Il;
  o0 = 1;
  var t = yr(), e = xg(), r = EL(), n = _c(), i = es, a = Ya(), s = se;
  Il = o;
  function o(u, l, p, m, h, g) {
    var v, d = g, y;
    u._body = !0;
    var x = d.encoding !== null ? d.encoding : null, b = d.verify;
    try {
      y = c(u, h, d.inflate), v = y.length, y.length = void 0;
    } catch (w) {
      return p(w);
    }
    if (d.length = v, d.encoding = b ? null : x, d.encoding === null && x !== null && !n.encodingExists(x))
      return p(t(415, 'unsupported charset "' + x.toUpperCase() + '"', {
        charset: x.toLowerCase(),
        type: "charset.unsupported"
      }));
    h("read body"), r(y, d, function(w, S) {
      if (w) {
        var T;
        w.type === "encoding.unsupported" ? T = t(415, 'unsupported charset "' + x.toUpperCase() + '"', {
          charset: x.toLowerCase(),
          type: "charset.unsupported"
        }) : T = t(400, w), y !== u && (a(u), e(y, !0)), f(u, function() {
          p(t(400, T));
        });
        return;
      }
      if (b)
        try {
          h("verify body"), b(u, l, S, x);
        } catch (C) {
          p(t(403, C, {
            body: S,
            type: C.type || "entity.verify.failed"
          }));
          return;
        }
      var E = S;
      try {
        h("parse body"), E = typeof S != "string" && x !== null ? n.decode(S, x) : S, u.body = m(E);
      } catch (C) {
        p(t(400, C, {
          body: E,
          type: C.type || "entity.parse.failed"
        }));
        return;
      }
      p();
    });
  }
  function c(u, l, p) {
    var m = (u.headers["content-encoding"] || "identity").toLowerCase(), h = u.headers["content-length"], g;
    if (l('content-encoding "%s"', m), p === !1 && m !== "identity")
      throw t(415, "content encoding unsupported", {
        encoding: m,
        type: "encoding.unsupported"
      });
    switch (m) {
      case "deflate":
        g = s.createInflate(), l("inflate body"), u.pipe(g);
        break;
      case "gzip":
        g = s.createGunzip(), l("gunzip body"), u.pipe(g);
        break;
      case "identity":
        g = u, g.length = h;
        break;
      default:
        throw t(415, 'unsupported content encoding "' + m + '"', {
          encoding: m,
          type: "encoding.unsupported"
        });
    }
    return g;
  }
  function f(u, l) {
    i.isFinished(u) ? l(null) : (i(u, l), u.resume());
  }
  return Il;
}
/*!
 * body-parser
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var kl, c0;
function SL() {
  if (c0)
    return kl;
  c0 = 1;
  var t = vr(), e = An(), r = yr(), n = Pc()("body-parser:json"), i = Dc(), a = qr();
  kl = f;
  var s = /^[\x20\x09\x0a\x0d]*([^\x20\x09\x0a\x0d])/, o = "#", c = /#+/g;
  function f(g) {
    var v = g || {}, d = typeof v.limit != "number" ? t.parse(v.limit || "100kb") : v.limit, y = v.inflate !== !1, x = v.reviver, b = v.strict !== !1, w = v.type || "application/json", S = v.verify || !1;
    if (S !== !1 && typeof S != "function")
      throw new TypeError("option verify must be function");
    var T = typeof w != "function" ? h(w) : w;
    function E(C) {
      if (C.length === 0)
        return {};
      if (b) {
        var A = l(C);
        if (A !== "{" && A !== "[")
          throw n("strict violation"), u(C, A);
      }
      try {
        return n("parse json"), JSON.parse(C, x);
      } catch (R) {
        throw m(R, {
          message: R.message,
          stack: R.stack
        });
      }
    }
    return function(A, R, D) {
      if (A._body) {
        n("body already parsed"), D();
        return;
      }
      if (A.body = A.body || {}, !a.hasBody(A)) {
        n("skip empty body"), D();
        return;
      }
      if (n("content-type %j", A.headers["content-type"]), !T(A)) {
        n("skip parsing"), D();
        return;
      }
      var F = p(A) || "utf-8";
      if (F.slice(0, 4) !== "utf-") {
        n("invalid charset"), D(r(415, 'unsupported charset "' + F.toUpperCase() + '"', {
          charset: F,
          type: "charset.unsupported"
        }));
        return;
      }
      i(A, R, D, E, n, {
        encoding: F,
        inflate: y,
        limit: d,
        verify: S
      });
    };
  }
  function u(g, v) {
    var d = g.indexOf(v), y = "";
    if (d !== -1) {
      y = g.substring(0, d) + o;
      for (var x = d + 1; x < g.length; x++)
        y += o;
    }
    try {
      throw JSON.parse(y), new SyntaxError("strict violation");
    } catch (b) {
      return m(b, {
        message: b.message.replace(c, function(w) {
          return g.substring(d, d + w.length);
        }),
        stack: b.stack
      });
    }
  }
  function l(g) {
    var v = s.exec(g);
    return v ? v[1] : void 0;
  }
  function p(g) {
    try {
      return (e.parse(g).parameters.charset || "").toLowerCase();
    } catch {
      return;
    }
  }
  function m(g, v) {
    for (var d = Object.getOwnPropertyNames(g), y = 0; y < d.length; y++) {
      var x = d[y];
      x !== "stack" && x !== "message" && delete g[x];
    }
    return g.stack = v.stack.replace(g.message, v.message), g.message = v.message, g;
  }
  function h(g) {
    return function(d) {
      return !!a(d, g);
    };
  }
  return kl;
}
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var Rl, u0;
function CL() {
  if (u0)
    return Rl;
  u0 = 1;
  var t = vr(), e = Pc()("body-parser:raw"), r = Dc(), n = qr();
  Rl = i;
  function i(s) {
    var o = s || {}, c = o.inflate !== !1, f = typeof o.limit != "number" ? t.parse(o.limit || "100kb") : o.limit, u = o.type || "application/octet-stream", l = o.verify || !1;
    if (l !== !1 && typeof l != "function")
      throw new TypeError("option verify must be function");
    var p = typeof u != "function" ? a(u) : u;
    function m(h) {
      return h;
    }
    return function(g, v, d) {
      if (g._body) {
        e("body already parsed"), d();
        return;
      }
      if (g.body = g.body || {}, !n.hasBody(g)) {
        e("skip empty body"), d();
        return;
      }
      if (e("content-type %j", g.headers["content-type"]), !p(g)) {
        e("skip parsing"), d();
        return;
      }
      r(g, v, d, m, e, {
        encoding: null,
        inflate: c,
        limit: f,
        verify: l
      });
    };
  }
  function a(s) {
    return function(c) {
      return !!n(c, s);
    };
  }
  return Rl;
}
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var Nl, l0;
function TL() {
  if (l0)
    return Nl;
  l0 = 1;
  var t = vr(), e = An(), r = Pc()("body-parser:text"), n = Dc(), i = qr();
  Nl = a;
  function a(c) {
    var f = c || {}, u = f.defaultCharset || "utf-8", l = f.inflate !== !1, p = typeof f.limit != "number" ? t.parse(f.limit || "100kb") : f.limit, m = f.type || "text/plain", h = f.verify || !1;
    if (h !== !1 && typeof h != "function")
      throw new TypeError("option verify must be function");
    var g = typeof m != "function" ? o(m) : m;
    function v(d) {
      return d;
    }
    return function(y, x, b) {
      if (y._body) {
        r("body already parsed"), b();
        return;
      }
      if (y.body = y.body || {}, !i.hasBody(y)) {
        r("skip empty body"), b();
        return;
      }
      if (r("content-type %j", y.headers["content-type"]), !g(y)) {
        r("skip parsing"), b();
        return;
      }
      var w = s(y) || u;
      n(y, x, b, v, r, {
        encoding: w,
        inflate: l,
        limit: p,
        verify: h
      });
    };
  }
  function s(c) {
    try {
      return (e.parse(c).parameters.charset || "").toLowerCase();
    } catch {
      return;
    }
  }
  function o(c) {
    return function(u) {
      return !!i(u, c);
    };
  }
  return Nl;
}
/*!
 * body-parser
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var Ll, p0;
function OL() {
  if (p0)
    return Ll;
  p0 = 1;
  var t = vr(), e = An(), r = yr(), n = Pc()("body-parser:urlencoded");
  tr("body-parser");
  var i = Dc(), a = qr();
  Ll = o;
  var s = /* @__PURE__ */ Object.create(null);
  function o(h) {
    var g = h || {};
    g.extended;
    var v = g.extended !== !1, d = g.inflate !== !1, y = typeof g.limit != "number" ? t.parse(g.limit || "100kb") : g.limit, x = g.type || "application/x-www-form-urlencoded", b = g.verify || !1;
    if (b !== !1 && typeof b != "function")
      throw new TypeError("option verify must be function");
    var w = v ? c(g) : p(g), S = typeof x != "function" ? m(x) : x;
    function T(E) {
      return E.length ? w(E) : {};
    }
    return function(C, A, R) {
      if (C._body) {
        n("body already parsed"), R();
        return;
      }
      if (C.body = C.body || {}, !a.hasBody(C)) {
        n("skip empty body"), R();
        return;
      }
      if (n("content-type %j", C.headers["content-type"]), !S(C)) {
        n("skip parsing"), R();
        return;
      }
      var D = f(C) || "utf-8";
      if (D !== "utf-8") {
        n("invalid charset"), R(r(415, 'unsupported charset "' + D.toUpperCase() + '"', {
          charset: D,
          type: "charset.unsupported"
        }));
        return;
      }
      i(C, A, R, T, n, {
        debug: n,
        encoding: D,
        inflate: d,
        limit: y,
        verify: b
      });
    };
  }
  function c(h) {
    var g = h.parameterLimit !== void 0 ? h.parameterLimit : 1e3, v = l("qs");
    if (isNaN(g) || g < 1)
      throw new TypeError("option parameterLimit must be a positive number");
    return isFinite(g) && (g = g | 0), function(y) {
      var x = u(y, g);
      if (x === void 0)
        throw n("too many parameters"), r(413, "too many parameters", {
          type: "parameters.too.many"
        });
      var b = Math.max(100, x);
      return n("parse extended urlencoding"), v(y, {
        allowPrototypes: !0,
        arrayLimit: b,
        depth: 1 / 0,
        parameterLimit: g
      });
    };
  }
  function f(h) {
    try {
      return (e.parse(h).parameters.charset || "").toLowerCase();
    } catch {
      return;
    }
  }
  function u(h, g) {
    for (var v = 0, d = 0; (d = h.indexOf("&", d)) !== -1; )
      if (v++, d++, v === g)
        return;
    return v;
  }
  function l(h) {
    var g = s[h];
    if (g !== void 0)
      return g.parse;
    switch (h) {
      case "qs":
        g = Sc();
        break;
      case "querystring":
        g = se;
        break;
    }
    return s[h] = g, g.parse;
  }
  function p(h) {
    var g = h.parameterLimit !== void 0 ? h.parameterLimit : 1e3, v = l("querystring");
    if (isNaN(g) || g < 1)
      throw new TypeError("option parameterLimit must be a positive number");
    return isFinite(g) && (g = g | 0), function(y) {
      var x = u(y, g);
      if (x === void 0)
        throw n("too many parameters"), r(413, "too many parameters", {
          type: "parameters.too.many"
        });
      return n("parse urlencoding"), v(y, void 0, void 0, { maxKeys: g });
    };
  }
  function m(h) {
    return function(v) {
      return !!a(v, h);
    };
  }
  return Ll;
}
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
(function(t, e) {
  var r = tr("body-parser"), n = /* @__PURE__ */ Object.create(null);
  e = t.exports = r.function(
    i,
    "bodyParser: use individual json/urlencoded middlewares"
  ), Object.defineProperty(e, "json", {
    configurable: !0,
    enumerable: !0,
    get: a("json")
  }), Object.defineProperty(e, "raw", {
    configurable: !0,
    enumerable: !0,
    get: a("raw")
  }), Object.defineProperty(e, "text", {
    configurable: !0,
    enumerable: !0,
    get: a("text")
  }), Object.defineProperty(e, "urlencoded", {
    configurable: !0,
    enumerable: !0,
    get: a("urlencoded")
  });
  function i(o) {
    var c = Object.create(o || null, {
      type: {
        configurable: !0,
        enumerable: !0,
        value: void 0,
        writable: !0
      }
    }), f = e.urlencoded(c), u = e.json(c);
    return function(p, m, h) {
      u(p, m, function(g) {
        if (g)
          return h(g);
        f(p, m, h);
      });
    };
  }
  function a(o) {
    return function() {
      return s(o);
    };
  }
  function s(o) {
    var c = n[o];
    if (c !== void 0)
      return c;
    switch (o) {
      case "json":
        c = SL();
        break;
      case "raw":
        c = CL();
        break;
      case "text":
        c = TL();
        break;
      case "urlencoded":
        c = OL();
        break;
    }
    return n[o] = c;
  }
})(Em, Em.exports);
var AL = Em.exports;
const RC = /* @__PURE__ */ Oi(AL);
var kn = {}, ze = {};
ze.fromCallback = function(t) {
  return Object.defineProperty(function(...e) {
    if (typeof e[e.length - 1] == "function")
      t.apply(this, e);
    else
      return new Promise((r, n) => {
        t.call(
          this,
          ...e,
          (i, a) => i != null ? n(i) : r(a)
        );
      });
  }, "name", { value: t.name });
};
ze.fromPromise = function(t) {
  return Object.defineProperty(function(...e) {
    const r = e[e.length - 1];
    if (typeof r != "function")
      return t.apply(this, e);
    t.apply(this, e.slice(0, -1)).then((n) => r(null, n), r);
  }, "name", { value: t.name });
};
var Hr = se, $L = process.cwd, wo = null, IL = process.env.GRACEFUL_FS_PLATFORM || process.platform;
process.cwd = function() {
  return wo || (wo = $L.call(process)), wo;
};
try {
  process.cwd();
} catch {
}
if (typeof process.chdir == "function") {
  var f0 = process.chdir;
  process.chdir = function(t) {
    wo = null, f0.call(process, t);
  }, Object.setPrototypeOf && Object.setPrototypeOf(process.chdir, f0);
}
var kL = RL;
function RL(t) {
  Hr.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./) && e(t), t.lutimes || r(t), t.chown = a(t.chown), t.fchown = a(t.fchown), t.lchown = a(t.lchown), t.chmod = n(t.chmod), t.fchmod = n(t.fchmod), t.lchmod = n(t.lchmod), t.chownSync = s(t.chownSync), t.fchownSync = s(t.fchownSync), t.lchownSync = s(t.lchownSync), t.chmodSync = i(t.chmodSync), t.fchmodSync = i(t.fchmodSync), t.lchmodSync = i(t.lchmodSync), t.stat = o(t.stat), t.fstat = o(t.fstat), t.lstat = o(t.lstat), t.statSync = c(t.statSync), t.fstatSync = c(t.fstatSync), t.lstatSync = c(t.lstatSync), t.chmod && !t.lchmod && (t.lchmod = function(u, l, p) {
    p && process.nextTick(p);
  }, t.lchmodSync = function() {
  }), t.chown && !t.lchown && (t.lchown = function(u, l, p, m) {
    m && process.nextTick(m);
  }, t.lchownSync = function() {
  }), IL === "win32" && (t.rename = typeof t.rename != "function" ? t.rename : function(u) {
    function l(p, m, h) {
      var g = Date.now(), v = 0;
      u(p, m, function d(y) {
        if (y && (y.code === "EACCES" || y.code === "EPERM" || y.code === "EBUSY") && Date.now() - g < 6e4) {
          setTimeout(function() {
            t.stat(m, function(x, b) {
              x && x.code === "ENOENT" ? u(p, m, d) : h(y);
            });
          }, v), v < 100 && (v += 10);
          return;
        }
        h && h(y);
      });
    }
    return Object.setPrototypeOf && Object.setPrototypeOf(l, u), l;
  }(t.rename)), t.read = typeof t.read != "function" ? t.read : function(u) {
    function l(p, m, h, g, v, d) {
      var y;
      if (d && typeof d == "function") {
        var x = 0;
        y = function(b, w, S) {
          if (b && b.code === "EAGAIN" && x < 10)
            return x++, u.call(t, p, m, h, g, v, y);
          d.apply(this, arguments);
        };
      }
      return u.call(t, p, m, h, g, v, y);
    }
    return Object.setPrototypeOf && Object.setPrototypeOf(l, u), l;
  }(t.read), t.readSync = typeof t.readSync != "function" ? t.readSync : function(u) {
    return function(l, p, m, h, g) {
      for (var v = 0; ; )
        try {
          return u.call(t, l, p, m, h, g);
        } catch (d) {
          if (d.code === "EAGAIN" && v < 10) {
            v++;
            continue;
          }
          throw d;
        }
    };
  }(t.readSync);
  function e(u) {
    u.lchmod = function(l, p, m) {
      u.open(
        l,
        Hr.O_WRONLY | Hr.O_SYMLINK,
        p,
        function(h, g) {
          if (h) {
            m && m(h);
            return;
          }
          u.fchmod(g, p, function(v) {
            u.close(g, function(d) {
              m && m(v || d);
            });
          });
        }
      );
    }, u.lchmodSync = function(l, p) {
      var m = u.openSync(l, Hr.O_WRONLY | Hr.O_SYMLINK, p), h = !0, g;
      try {
        g = u.fchmodSync(m, p), h = !1;
      } finally {
        if (h)
          try {
            u.closeSync(m);
          } catch {
          }
        else
          u.closeSync(m);
      }
      return g;
    };
  }
  function r(u) {
    Hr.hasOwnProperty("O_SYMLINK") && u.futimes ? (u.lutimes = function(l, p, m, h) {
      u.open(l, Hr.O_SYMLINK, function(g, v) {
        if (g) {
          h && h(g);
          return;
        }
        u.futimes(v, p, m, function(d) {
          u.close(v, function(y) {
            h && h(d || y);
          });
        });
      });
    }, u.lutimesSync = function(l, p, m) {
      var h = u.openSync(l, Hr.O_SYMLINK), g, v = !0;
      try {
        g = u.futimesSync(h, p, m), v = !1;
      } finally {
        if (v)
          try {
            u.closeSync(h);
          } catch {
          }
        else
          u.closeSync(h);
      }
      return g;
    }) : u.futimes && (u.lutimes = function(l, p, m, h) {
      h && process.nextTick(h);
    }, u.lutimesSync = function() {
    });
  }
  function n(u) {
    return u && function(l, p, m) {
      return u.call(t, l, p, function(h) {
        f(h) && (h = null), m && m.apply(this, arguments);
      });
    };
  }
  function i(u) {
    return u && function(l, p) {
      try {
        return u.call(t, l, p);
      } catch (m) {
        if (!f(m))
          throw m;
      }
    };
  }
  function a(u) {
    return u && function(l, p, m, h) {
      return u.call(t, l, p, m, function(g) {
        f(g) && (g = null), h && h.apply(this, arguments);
      });
    };
  }
  function s(u) {
    return u && function(l, p, m) {
      try {
        return u.call(t, l, p, m);
      } catch (h) {
        if (!f(h))
          throw h;
      }
    };
  }
  function o(u) {
    return u && function(l, p, m) {
      typeof p == "function" && (m = p, p = null);
      function h(g, v) {
        v && (v.uid < 0 && (v.uid += 4294967296), v.gid < 0 && (v.gid += 4294967296)), m && m.apply(this, arguments);
      }
      return p ? u.call(t, l, p, h) : u.call(t, l, h);
    };
  }
  function c(u) {
    return u && function(l, p) {
      var m = p ? u.call(t, l, p) : u.call(t, l);
      return m && (m.uid < 0 && (m.uid += 4294967296), m.gid < 0 && (m.gid += 4294967296)), m;
    };
  }
  function f(u) {
    if (!u || u.code === "ENOSYS")
      return !0;
    var l = !process.getuid || process.getuid() !== 0;
    return !!(l && (u.code === "EINVAL" || u.code === "EPERM"));
  }
}
var h0 = se.Stream, NL = LL;
function LL(t) {
  return {
    ReadStream: e,
    WriteStream: r
  };
  function e(n, i) {
    if (!(this instanceof e))
      return new e(n, i);
    h0.call(this);
    var a = this;
    this.path = n, this.fd = null, this.readable = !0, this.paused = !1, this.flags = "r", this.mode = 438, this.bufferSize = 64 * 1024, i = i || {};
    for (var s = Object.keys(i), o = 0, c = s.length; o < c; o++) {
      var f = s[o];
      this[f] = i[f];
    }
    if (this.encoding && this.setEncoding(this.encoding), this.start !== void 0) {
      if (typeof this.start != "number")
        throw TypeError("start must be a Number");
      if (this.end === void 0)
        this.end = 1 / 0;
      else if (typeof this.end != "number")
        throw TypeError("end must be a Number");
      if (this.start > this.end)
        throw new Error("start must be <= end");
      this.pos = this.start;
    }
    if (this.fd !== null) {
      process.nextTick(function() {
        a._read();
      });
      return;
    }
    t.open(this.path, this.flags, this.mode, function(u, l) {
      if (u) {
        a.emit("error", u), a.readable = !1;
        return;
      }
      a.fd = l, a.emit("open", l), a._read();
    });
  }
  function r(n, i) {
    if (!(this instanceof r))
      return new r(n, i);
    h0.call(this), this.path = n, this.fd = null, this.writable = !0, this.flags = "w", this.encoding = "binary", this.mode = 438, this.bytesWritten = 0, i = i || {};
    for (var a = Object.keys(i), s = 0, o = a.length; s < o; s++) {
      var c = a[s];
      this[c] = i[c];
    }
    if (this.start !== void 0) {
      if (typeof this.start != "number")
        throw TypeError("start must be a Number");
      if (this.start < 0)
        throw new Error("start must be >= zero");
      this.pos = this.start;
    }
    this.busy = !1, this._queue = [], this.fd === null && (this._open = t.open, this._queue.push([this._open, this.path, this.flags, this.mode, void 0]), this.flush());
  }
}
var PL = ML, DL = Object.getPrototypeOf || function(t) {
  return t.__proto__;
};
function ML(t) {
  if (t === null || typeof t != "object")
    return t;
  if (t instanceof Object)
    var e = { __proto__: DL(t) };
  else
    var e = /* @__PURE__ */ Object.create(null);
  return Object.getOwnPropertyNames(t).forEach(function(r) {
    Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
  }), e;
}
var Ye = se, qL = kL, jL = NL, FL = PL, Us = nt, vt, jo;
typeof Symbol == "function" && typeof Symbol.for == "function" ? (vt = Symbol.for("graceful-fs.queue"), jo = Symbol.for("graceful-fs.previous")) : (vt = "___graceful-fs.queue", jo = "___graceful-fs.previous");
function BL() {
}
function NC(t, e) {
  Object.defineProperty(t, vt, {
    get: function() {
      return e;
    }
  });
}
var En = BL;
Us.debuglog ? En = Us.debuglog("gfs4") : /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && (En = function() {
  var t = Us.format.apply(Us, arguments);
  t = "GFS4: " + t.split(/\n/).join(`
GFS4: `), console.error(t);
});
if (!Ye[vt]) {
  var UL = ve[vt] || [];
  NC(Ye, UL), Ye.close = function(t) {
    function e(r, n) {
      return t.call(Ye, r, function(i) {
        i || d0(), typeof n == "function" && n.apply(this, arguments);
      });
    }
    return Object.defineProperty(e, jo, {
      value: t
    }), e;
  }(Ye.close), Ye.closeSync = function(t) {
    function e(r) {
      t.apply(Ye, arguments), d0();
    }
    return Object.defineProperty(e, jo, {
      value: t
    }), e;
  }(Ye.closeSync), /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && process.on("exit", function() {
    En(Ye[vt]), se.equal(Ye[vt].length, 0);
  });
}
ve[vt] || NC(ve, Ye[vt]);
var Me = zg(FL(Ye));
process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !Ye.__patched && (Me = zg(Ye), Ye.__patched = !0);
function zg(t) {
  qL(t), t.gracefulify = zg, t.createReadStream = w, t.createWriteStream = S;
  var e = t.readFile;
  t.readFile = r;
  function r(C, A, R) {
    return typeof A == "function" && (R = A, A = null), D(C, A, R);
    function D(F, K, V, ne) {
      return e(F, K, function($) {
        $ && ($.code === "EMFILE" || $.code === "ENFILE") ? ei([D, [F, K, V], $, ne || Date.now(), Date.now()]) : typeof V == "function" && V.apply(this, arguments);
      });
    }
  }
  var n = t.writeFile;
  t.writeFile = i;
  function i(C, A, R, D) {
    return typeof R == "function" && (D = R, R = null), F(C, A, R, D);
    function F(K, V, ne, $, L) {
      return n(K, V, ne, function(P) {
        P && (P.code === "EMFILE" || P.code === "ENFILE") ? ei([F, [K, V, ne, $], P, L || Date.now(), Date.now()]) : typeof $ == "function" && $.apply(this, arguments);
      });
    }
  }
  var a = t.appendFile;
  a && (t.appendFile = s);
  function s(C, A, R, D) {
    return typeof R == "function" && (D = R, R = null), F(C, A, R, D);
    function F(K, V, ne, $, L) {
      return a(K, V, ne, function(P) {
        P && (P.code === "EMFILE" || P.code === "ENFILE") ? ei([F, [K, V, ne, $], P, L || Date.now(), Date.now()]) : typeof $ == "function" && $.apply(this, arguments);
      });
    }
  }
  var o = t.copyFile;
  o && (t.copyFile = c);
  function c(C, A, R, D) {
    return typeof R == "function" && (D = R, R = 0), F(C, A, R, D);
    function F(K, V, ne, $, L) {
      return o(K, V, ne, function(P) {
        P && (P.code === "EMFILE" || P.code === "ENFILE") ? ei([F, [K, V, ne, $], P, L || Date.now(), Date.now()]) : typeof $ == "function" && $.apply(this, arguments);
      });
    }
  }
  var f = t.readdir;
  t.readdir = l;
  var u = /^v[0-5]\./;
  function l(C, A, R) {
    typeof A == "function" && (R = A, A = null);
    var D = u.test(process.version) ? function(V, ne, $, L) {
      return f(V, F(
        V,
        ne,
        $,
        L
      ));
    } : function(V, ne, $, L) {
      return f(V, ne, F(
        V,
        ne,
        $,
        L
      ));
    };
    return D(C, A, R);
    function F(K, V, ne, $) {
      return function(L, P) {
        L && (L.code === "EMFILE" || L.code === "ENFILE") ? ei([
          D,
          [K, V, ne],
          L,
          $ || Date.now(),
          Date.now()
        ]) : (P && P.sort && P.sort(), typeof ne == "function" && ne.call(this, L, P));
      };
    }
  }
  if (process.version.substr(0, 4) === "v0.8") {
    var p = jL(t);
    d = p.ReadStream, x = p.WriteStream;
  }
  var m = t.ReadStream;
  m && (d.prototype = Object.create(m.prototype), d.prototype.open = y);
  var h = t.WriteStream;
  h && (x.prototype = Object.create(h.prototype), x.prototype.open = b), Object.defineProperty(t, "ReadStream", {
    get: function() {
      return d;
    },
    set: function(C) {
      d = C;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t, "WriteStream", {
    get: function() {
      return x;
    },
    set: function(C) {
      x = C;
    },
    enumerable: !0,
    configurable: !0
  });
  var g = d;
  Object.defineProperty(t, "FileReadStream", {
    get: function() {
      return g;
    },
    set: function(C) {
      g = C;
    },
    enumerable: !0,
    configurable: !0
  });
  var v = x;
  Object.defineProperty(t, "FileWriteStream", {
    get: function() {
      return v;
    },
    set: function(C) {
      v = C;
    },
    enumerable: !0,
    configurable: !0
  });
  function d(C, A) {
    return this instanceof d ? (m.apply(this, arguments), this) : d.apply(Object.create(d.prototype), arguments);
  }
  function y() {
    var C = this;
    E(C.path, C.flags, C.mode, function(A, R) {
      A ? (C.autoClose && C.destroy(), C.emit("error", A)) : (C.fd = R, C.emit("open", R), C.read());
    });
  }
  function x(C, A) {
    return this instanceof x ? (h.apply(this, arguments), this) : x.apply(Object.create(x.prototype), arguments);
  }
  function b() {
    var C = this;
    E(C.path, C.flags, C.mode, function(A, R) {
      A ? (C.destroy(), C.emit("error", A)) : (C.fd = R, C.emit("open", R));
    });
  }
  function w(C, A) {
    return new t.ReadStream(C, A);
  }
  function S(C, A) {
    return new t.WriteStream(C, A);
  }
  var T = t.open;
  t.open = E;
  function E(C, A, R, D) {
    return typeof R == "function" && (D = R, R = null), F(C, A, R, D);
    function F(K, V, ne, $, L) {
      return T(K, V, ne, function(P, H) {
        P && (P.code === "EMFILE" || P.code === "ENFILE") ? ei([F, [K, V, ne, $], P, L || Date.now(), Date.now()]) : typeof $ == "function" && $.apply(this, arguments);
      });
    }
  }
  return t;
}
function ei(t) {
  En("ENQUEUE", t[0].name, t[1]), Ye[vt].push(t), Hg();
}
var zs;
function d0() {
  for (var t = Date.now(), e = 0; e < Ye[vt].length; ++e)
    Ye[vt][e].length > 2 && (Ye[vt][e][3] = t, Ye[vt][e][4] = t);
  Hg();
}
function Hg() {
  if (clearTimeout(zs), zs = void 0, Ye[vt].length !== 0) {
    var t = Ye[vt].shift(), e = t[0], r = t[1], n = t[2], i = t[3], a = t[4];
    if (i === void 0)
      En("RETRY", e.name, r), e.apply(null, r);
    else if (Date.now() - i >= 6e4) {
      En("TIMEOUT", e.name, r);
      var s = r.pop();
      typeof s == "function" && s.call(null, n);
    } else {
      var o = Date.now() - a, c = Math.max(a - i, 1), f = Math.min(c * 1.2, 100);
      o >= f ? (En("RETRY", e.name, r), e.apply(null, r.concat([i]))) : Ye[vt].push(t);
    }
    zs === void 0 && (zs = setTimeout(Hg, 0));
  }
}
(function(t) {
  const e = ze.fromCallback, r = Me, n = [
    "access",
    "appendFile",
    "chmod",
    "chown",
    "close",
    "copyFile",
    "fchmod",
    "fchown",
    "fdatasync",
    "fstat",
    "fsync",
    "ftruncate",
    "futimes",
    "lchmod",
    "lchown",
    "link",
    "lstat",
    "mkdir",
    "mkdtemp",
    "open",
    "opendir",
    "readdir",
    "readFile",
    "readlink",
    "realpath",
    "rename",
    "rm",
    "rmdir",
    "stat",
    "symlink",
    "truncate",
    "unlink",
    "utimes",
    "writeFile"
  ].filter((i) => typeof r[i] == "function");
  Object.assign(t, r), n.forEach((i) => {
    t[i] = e(r[i]);
  }), t.exists = function(i, a) {
    return typeof a == "function" ? r.exists(i, a) : new Promise((s) => r.exists(i, s));
  }, t.read = function(i, a, s, o, c, f) {
    return typeof f == "function" ? r.read(i, a, s, o, c, f) : new Promise((u, l) => {
      r.read(i, a, s, o, c, (p, m, h) => {
        if (p)
          return l(p);
        u({ bytesRead: m, buffer: h });
      });
    });
  }, t.write = function(i, a, ...s) {
    return typeof s[s.length - 1] == "function" ? r.write(i, a, ...s) : new Promise((o, c) => {
      r.write(i, a, ...s, (f, u, l) => {
        if (f)
          return c(f);
        o({ bytesWritten: u, buffer: l });
      });
    });
  }, typeof r.writev == "function" && (t.writev = function(i, a, ...s) {
    return typeof s[s.length - 1] == "function" ? r.writev(i, a, ...s) : new Promise((o, c) => {
      r.writev(i, a, ...s, (f, u, l) => {
        if (f)
          return c(f);
        o({ bytesWritten: u, buffers: l });
      });
    });
  }), typeof r.realpath.native == "function" ? t.realpath.native = e(r.realpath.native) : process.emitWarning(
    "fs.realpath.native is not a function. Is fs being monkey-patched?",
    "Warning",
    "fs-extra-WARN0003"
  );
})(kn);
var Wg = {}, LC = {};
const zL = se;
LC.checkPath = function(e) {
  if (process.platform === "win32" && /[<>:"|?*]/.test(e.replace(zL.parse(e).root, ""))) {
    const n = new Error(`Path contains invalid characters: ${e}`);
    throw n.code = "EINVAL", n;
  }
};
const PC = kn, { checkPath: DC } = LC, MC = (t) => {
  const e = { mode: 511 };
  return typeof t == "number" ? t : { ...e, ...t }.mode;
};
Wg.makeDir = async (t, e) => (DC(t), PC.mkdir(t, {
  mode: MC(e),
  recursive: !0
}));
Wg.makeDirSync = (t, e) => (DC(t), PC.mkdirSync(t, {
  mode: MC(e),
  recursive: !0
}));
const HL = ze.fromPromise, { makeDir: WL, makeDirSync: Pl } = Wg, Dl = HL(WL);
var br = {
  mkdirs: Dl,
  mkdirsSync: Pl,
  // alias
  mkdirp: Dl,
  mkdirpSync: Pl,
  ensureDir: Dl,
  ensureDirSync: Pl
};
const GL = ze.fromPromise, qC = kn;
function QL(t) {
  return qC.access(t).then(() => !0).catch(() => !1);
}
var Rn = {
  pathExists: GL(QL),
  pathExistsSync: qC.existsSync
};
const pi = Me;
function VL(t, e, r, n) {
  pi.open(t, "r+", (i, a) => {
    if (i)
      return n(i);
    pi.futimes(a, e, r, (s) => {
      pi.close(a, (o) => {
        n && n(s || o);
      });
    });
  });
}
function KL(t, e, r) {
  const n = pi.openSync(t, "r+");
  return pi.futimesSync(n, e, r), pi.closeSync(n);
}
var jC = {
  utimesMillis: VL,
  utimesMillisSync: KL
};
const yi = kn, pt = se, JL = nt;
function XL(t, e, r) {
  const n = r.dereference ? (i) => yi.stat(i, { bigint: !0 }) : (i) => yi.lstat(i, { bigint: !0 });
  return Promise.all([
    n(t),
    n(e).catch((i) => {
      if (i.code === "ENOENT")
        return null;
      throw i;
    })
  ]).then(([i, a]) => ({ srcStat: i, destStat: a }));
}
function ZL(t, e, r) {
  let n;
  const i = r.dereference ? (s) => yi.statSync(s, { bigint: !0 }) : (s) => yi.lstatSync(s, { bigint: !0 }), a = i(t);
  try {
    n = i(e);
  } catch (s) {
    if (s.code === "ENOENT")
      return { srcStat: a, destStat: null };
    throw s;
  }
  return { srcStat: a, destStat: n };
}
function YL(t, e, r, n, i) {
  JL.callbackify(XL)(t, e, n, (a, s) => {
    if (a)
      return i(a);
    const { srcStat: o, destStat: c } = s;
    if (c) {
      if (is(o, c)) {
        const f = pt.basename(t), u = pt.basename(e);
        return r === "move" && f !== u && f.toLowerCase() === u.toLowerCase() ? i(null, { srcStat: o, destStat: c, isChangingCase: !0 }) : i(new Error("Source and destination must not be the same."));
      }
      if (o.isDirectory() && !c.isDirectory())
        return i(new Error(`Cannot overwrite non-directory '${e}' with directory '${t}'.`));
      if (!o.isDirectory() && c.isDirectory())
        return i(new Error(`Cannot overwrite directory '${e}' with non-directory '${t}'.`));
    }
    return o.isDirectory() && Gg(t, e) ? i(new Error(Mc(t, e, r))) : i(null, { srcStat: o, destStat: c });
  });
}
function e6(t, e, r, n) {
  const { srcStat: i, destStat: a } = ZL(t, e, n);
  if (a) {
    if (is(i, a)) {
      const s = pt.basename(t), o = pt.basename(e);
      if (r === "move" && s !== o && s.toLowerCase() === o.toLowerCase())
        return { srcStat: i, destStat: a, isChangingCase: !0 };
      throw new Error("Source and destination must not be the same.");
    }
    if (i.isDirectory() && !a.isDirectory())
      throw new Error(`Cannot overwrite non-directory '${e}' with directory '${t}'.`);
    if (!i.isDirectory() && a.isDirectory())
      throw new Error(`Cannot overwrite directory '${e}' with non-directory '${t}'.`);
  }
  if (i.isDirectory() && Gg(t, e))
    throw new Error(Mc(t, e, r));
  return { srcStat: i, destStat: a };
}
function FC(t, e, r, n, i) {
  const a = pt.resolve(pt.dirname(t)), s = pt.resolve(pt.dirname(r));
  if (s === a || s === pt.parse(s).root)
    return i();
  yi.stat(s, { bigint: !0 }, (o, c) => o ? o.code === "ENOENT" ? i() : i(o) : is(e, c) ? i(new Error(Mc(t, r, n))) : FC(t, e, s, n, i));
}
function BC(t, e, r, n) {
  const i = pt.resolve(pt.dirname(t)), a = pt.resolve(pt.dirname(r));
  if (a === i || a === pt.parse(a).root)
    return;
  let s;
  try {
    s = yi.statSync(a, { bigint: !0 });
  } catch (o) {
    if (o.code === "ENOENT")
      return;
    throw o;
  }
  if (is(e, s))
    throw new Error(Mc(t, r, n));
  return BC(t, e, a, n);
}
function is(t, e) {
  return e.ino && e.dev && e.ino === t.ino && e.dev === t.dev;
}
function Gg(t, e) {
  const r = pt.resolve(t).split(pt.sep).filter((i) => i), n = pt.resolve(e).split(pt.sep).filter((i) => i);
  return r.reduce((i, a, s) => i && n[s] === a, !0);
}
function Mc(t, e, r) {
  return `Cannot ${r} '${t}' to a subdirectory of itself, '${e}'.`;
}
var ki = {
  checkPaths: YL,
  checkPathsSync: e6,
  checkParentPaths: FC,
  checkParentPathsSync: BC,
  isSrcSubdir: Gg,
  areIdentical: is
};
const kt = Me, Na = se, t6 = br.mkdirs, r6 = Rn.pathExists, n6 = jC.utimesMillis, La = ki;
function i6(t, e, r, n) {
  typeof r == "function" && !n ? (n = r, r = {}) : typeof r == "function" && (r = { filter: r }), n = n || function() {
  }, r = r || {}, r.clobber = "clobber" in r ? !!r.clobber : !0, r.overwrite = "overwrite" in r ? !!r.overwrite : r.clobber, r.preserveTimestamps && process.arch === "ia32" && process.emitWarning(
    `Using the preserveTimestamps option in 32-bit node is not recommended;

	see https://github.com/jprichardson/node-fs-extra/issues/269`,
    "Warning",
    "fs-extra-WARN0001"
  ), La.checkPaths(t, e, "copy", r, (i, a) => {
    if (i)
      return n(i);
    const { srcStat: s, destStat: o } = a;
    La.checkParentPaths(t, s, e, "copy", (c) => c ? n(c) : r.filter ? UC(m0, o, t, e, r, n) : m0(o, t, e, r, n));
  });
}
function m0(t, e, r, n, i) {
  const a = Na.dirname(r);
  r6(a, (s, o) => {
    if (s)
      return i(s);
    if (o)
      return Fo(t, e, r, n, i);
    t6(a, (c) => c ? i(c) : Fo(t, e, r, n, i));
  });
}
function UC(t, e, r, n, i, a) {
  Promise.resolve(i.filter(r, n)).then((s) => s ? t(e, r, n, i, a) : a(), (s) => a(s));
}
function a6(t, e, r, n, i) {
  return n.filter ? UC(Fo, t, e, r, n, i) : Fo(t, e, r, n, i);
}
function Fo(t, e, r, n, i) {
  (n.dereference ? kt.stat : kt.lstat)(e, (s, o) => s ? i(s) : o.isDirectory() ? f6(o, t, e, r, n, i) : o.isFile() || o.isCharacterDevice() || o.isBlockDevice() ? s6(o, t, e, r, n, i) : o.isSymbolicLink() ? m6(t, e, r, n, i) : o.isSocket() ? i(new Error(`Cannot copy a socket file: ${e}`)) : o.isFIFO() ? i(new Error(`Cannot copy a FIFO pipe: ${e}`)) : i(new Error(`Unknown file: ${e}`)));
}
function s6(t, e, r, n, i, a) {
  return e ? o6(t, r, n, i, a) : zC(t, r, n, i, a);
}
function o6(t, e, r, n, i) {
  if (n.overwrite)
    kt.unlink(r, (a) => a ? i(a) : zC(t, e, r, n, i));
  else
    return n.errorOnExist ? i(new Error(`'${r}' already exists`)) : i();
}
function zC(t, e, r, n, i) {
  kt.copyFile(e, r, (a) => a ? i(a) : n.preserveTimestamps ? c6(t.mode, e, r, i) : qc(r, t.mode, i));
}
function c6(t, e, r, n) {
  return u6(t) ? l6(r, t, (i) => i ? n(i) : g0(t, e, r, n)) : g0(t, e, r, n);
}
function u6(t) {
  return (t & 128) === 0;
}
function l6(t, e, r) {
  return qc(t, e | 128, r);
}
function g0(t, e, r, n) {
  p6(e, r, (i) => i ? n(i) : qc(r, t, n));
}
function qc(t, e, r) {
  return kt.chmod(t, e, r);
}
function p6(t, e, r) {
  kt.stat(t, (n, i) => n ? r(n) : n6(e, i.atime, i.mtime, r));
}
function f6(t, e, r, n, i, a) {
  return e ? HC(r, n, i, a) : h6(t.mode, r, n, i, a);
}
function h6(t, e, r, n, i) {
  kt.mkdir(r, (a) => {
    if (a)
      return i(a);
    HC(e, r, n, (s) => s ? i(s) : qc(r, t, i));
  });
}
function HC(t, e, r, n) {
  kt.readdir(t, (i, a) => i ? n(i) : WC(a, t, e, r, n));
}
function WC(t, e, r, n, i) {
  const a = t.pop();
  return a ? d6(t, a, e, r, n, i) : i();
}
function d6(t, e, r, n, i, a) {
  const s = Na.join(r, e), o = Na.join(n, e);
  La.checkPaths(s, o, "copy", i, (c, f) => {
    if (c)
      return a(c);
    const { destStat: u } = f;
    a6(u, s, o, i, (l) => l ? a(l) : WC(t, r, n, i, a));
  });
}
function m6(t, e, r, n, i) {
  kt.readlink(e, (a, s) => {
    if (a)
      return i(a);
    if (n.dereference && (s = Na.resolve(process.cwd(), s)), t)
      kt.readlink(r, (o, c) => o ? o.code === "EINVAL" || o.code === "UNKNOWN" ? kt.symlink(s, r, i) : i(o) : (n.dereference && (c = Na.resolve(process.cwd(), c)), La.isSrcSubdir(s, c) ? i(new Error(`Cannot copy '${s}' to a subdirectory of itself, '${c}'.`)) : t.isDirectory() && La.isSrcSubdir(c, s) ? i(new Error(`Cannot overwrite '${c}' with '${s}'.`)) : g6(s, r, i)));
    else
      return kt.symlink(s, r, i);
  });
}
function g6(t, e, r) {
  kt.unlink(e, (n) => n ? r(n) : kt.symlink(t, e, r));
}
var v6 = i6;
const Et = Me, Pa = se, y6 = br.mkdirsSync, b6 = jC.utimesMillisSync, Da = ki;
function w6(t, e, r) {
  typeof r == "function" && (r = { filter: r }), r = r || {}, r.clobber = "clobber" in r ? !!r.clobber : !0, r.overwrite = "overwrite" in r ? !!r.overwrite : r.clobber, r.preserveTimestamps && process.arch === "ia32" && process.emitWarning(
    `Using the preserveTimestamps option in 32-bit node is not recommended;

	see https://github.com/jprichardson/node-fs-extra/issues/269`,
    "Warning",
    "fs-extra-WARN0002"
  );
  const { srcStat: n, destStat: i } = Da.checkPathsSync(t, e, "copy", r);
  return Da.checkParentPathsSync(t, n, e, "copy"), x6(i, t, e, r);
}
function x6(t, e, r, n) {
  if (n.filter && !n.filter(e, r))
    return;
  const i = Pa.dirname(r);
  return Et.existsSync(i) || y6(i), GC(t, e, r, n);
}
function _6(t, e, r, n) {
  if (!(n.filter && !n.filter(e, r)))
    return GC(t, e, r, n);
}
function GC(t, e, r, n) {
  const a = (n.dereference ? Et.statSync : Et.lstatSync)(e);
  if (a.isDirectory())
    return $6(a, t, e, r, n);
  if (a.isFile() || a.isCharacterDevice() || a.isBlockDevice())
    return E6(a, t, e, r, n);
  if (a.isSymbolicLink())
    return R6(t, e, r, n);
  throw a.isSocket() ? new Error(`Cannot copy a socket file: ${e}`) : a.isFIFO() ? new Error(`Cannot copy a FIFO pipe: ${e}`) : new Error(`Unknown file: ${e}`);
}
function E6(t, e, r, n, i) {
  return e ? S6(t, r, n, i) : QC(t, r, n, i);
}
function S6(t, e, r, n) {
  if (n.overwrite)
    return Et.unlinkSync(r), QC(t, e, r, n);
  if (n.errorOnExist)
    throw new Error(`'${r}' already exists`);
}
function QC(t, e, r, n) {
  return Et.copyFileSync(e, r), n.preserveTimestamps && C6(t.mode, e, r), Qg(r, t.mode);
}
function C6(t, e, r) {
  return T6(t) && O6(r, t), A6(e, r);
}
function T6(t) {
  return (t & 128) === 0;
}
function O6(t, e) {
  return Qg(t, e | 128);
}
function Qg(t, e) {
  return Et.chmodSync(t, e);
}
function A6(t, e) {
  const r = Et.statSync(t);
  return b6(e, r.atime, r.mtime);
}
function $6(t, e, r, n, i) {
  return e ? VC(r, n, i) : I6(t.mode, r, n, i);
}
function I6(t, e, r, n) {
  return Et.mkdirSync(r), VC(e, r, n), Qg(r, t);
}
function VC(t, e, r) {
  Et.readdirSync(t).forEach((n) => k6(n, t, e, r));
}
function k6(t, e, r, n) {
  const i = Pa.join(e, t), a = Pa.join(r, t), { destStat: s } = Da.checkPathsSync(i, a, "copy", n);
  return _6(s, i, a, n);
}
function R6(t, e, r, n) {
  let i = Et.readlinkSync(e);
  if (n.dereference && (i = Pa.resolve(process.cwd(), i)), t) {
    let a;
    try {
      a = Et.readlinkSync(r);
    } catch (s) {
      if (s.code === "EINVAL" || s.code === "UNKNOWN")
        return Et.symlinkSync(i, r);
      throw s;
    }
    if (n.dereference && (a = Pa.resolve(process.cwd(), a)), Da.isSrcSubdir(i, a))
      throw new Error(`Cannot copy '${i}' to a subdirectory of itself, '${a}'.`);
    if (Et.statSync(r).isDirectory() && Da.isSrcSubdir(a, i))
      throw new Error(`Cannot overwrite '${a}' with '${i}'.`);
    return N6(i, r);
  } else
    return Et.symlinkSync(i, r);
}
function N6(t, e) {
  return Et.unlinkSync(e), Et.symlinkSync(t, e);
}
var L6 = w6;
const P6 = ze.fromCallback;
var Vg = {
  copy: P6(v6),
  copySync: L6
};
const v0 = Me, KC = se, Fe = se, Ma = process.platform === "win32";
function JC(t) {
  [
    "unlink",
    "chmod",
    "stat",
    "lstat",
    "rmdir",
    "readdir"
  ].forEach((r) => {
    t[r] = t[r] || v0[r], r = r + "Sync", t[r] = t[r] || v0[r];
  }), t.maxBusyTries = t.maxBusyTries || 3;
}
function Kg(t, e, r) {
  let n = 0;
  typeof e == "function" && (r = e, e = {}), Fe(t, "rimraf: missing path"), Fe.strictEqual(typeof t, "string", "rimraf: path should be a string"), Fe.strictEqual(typeof r, "function", "rimraf: callback function required"), Fe(e, "rimraf: invalid options argument provided"), Fe.strictEqual(typeof e, "object", "rimraf: options should be object"), JC(e), y0(t, e, function i(a) {
    if (a) {
      if ((a.code === "EBUSY" || a.code === "ENOTEMPTY" || a.code === "EPERM") && n < e.maxBusyTries) {
        n++;
        const s = n * 100;
        return setTimeout(() => y0(t, e, i), s);
      }
      a.code === "ENOENT" && (a = null);
    }
    r(a);
  });
}
function y0(t, e, r) {
  Fe(t), Fe(e), Fe(typeof r == "function"), e.lstat(t, (n, i) => {
    if (n && n.code === "ENOENT")
      return r(null);
    if (n && n.code === "EPERM" && Ma)
      return b0(t, e, n, r);
    if (i && i.isDirectory())
      return xo(t, e, n, r);
    e.unlink(t, (a) => {
      if (a) {
        if (a.code === "ENOENT")
          return r(null);
        if (a.code === "EPERM")
          return Ma ? b0(t, e, a, r) : xo(t, e, a, r);
        if (a.code === "EISDIR")
          return xo(t, e, a, r);
      }
      return r(a);
    });
  });
}
function b0(t, e, r, n) {
  Fe(t), Fe(e), Fe(typeof n == "function"), e.chmod(t, 438, (i) => {
    i ? n(i.code === "ENOENT" ? null : r) : e.stat(t, (a, s) => {
      a ? n(a.code === "ENOENT" ? null : r) : s.isDirectory() ? xo(t, e, r, n) : e.unlink(t, n);
    });
  });
}
function w0(t, e, r) {
  let n;
  Fe(t), Fe(e);
  try {
    e.chmodSync(t, 438);
  } catch (i) {
    if (i.code === "ENOENT")
      return;
    throw r;
  }
  try {
    n = e.statSync(t);
  } catch (i) {
    if (i.code === "ENOENT")
      return;
    throw r;
  }
  n.isDirectory() ? _o(t, e, r) : e.unlinkSync(t);
}
function xo(t, e, r, n) {
  Fe(t), Fe(e), Fe(typeof n == "function"), e.rmdir(t, (i) => {
    i && (i.code === "ENOTEMPTY" || i.code === "EEXIST" || i.code === "EPERM") ? D6(t, e, n) : i && i.code === "ENOTDIR" ? n(r) : n(i);
  });
}
function D6(t, e, r) {
  Fe(t), Fe(e), Fe(typeof r == "function"), e.readdir(t, (n, i) => {
    if (n)
      return r(n);
    let a = i.length, s;
    if (a === 0)
      return e.rmdir(t, r);
    i.forEach((o) => {
      Kg(KC.join(t, o), e, (c) => {
        if (!s) {
          if (c)
            return r(s = c);
          --a === 0 && e.rmdir(t, r);
        }
      });
    });
  });
}
function XC(t, e) {
  let r;
  e = e || {}, JC(e), Fe(t, "rimraf: missing path"), Fe.strictEqual(typeof t, "string", "rimraf: path should be a string"), Fe(e, "rimraf: missing options"), Fe.strictEqual(typeof e, "object", "rimraf: options should be object");
  try {
    r = e.lstatSync(t);
  } catch (n) {
    if (n.code === "ENOENT")
      return;
    n.code === "EPERM" && Ma && w0(t, e, n);
  }
  try {
    r && r.isDirectory() ? _o(t, e, null) : e.unlinkSync(t);
  } catch (n) {
    if (n.code === "ENOENT")
      return;
    if (n.code === "EPERM")
      return Ma ? w0(t, e, n) : _o(t, e, n);
    if (n.code !== "EISDIR")
      throw n;
    _o(t, e, n);
  }
}
function _o(t, e, r) {
  Fe(t), Fe(e);
  try {
    e.rmdirSync(t);
  } catch (n) {
    if (n.code === "ENOTDIR")
      throw r;
    if (n.code === "ENOTEMPTY" || n.code === "EEXIST" || n.code === "EPERM")
      M6(t, e);
    else if (n.code !== "ENOENT")
      throw n;
  }
}
function M6(t, e) {
  if (Fe(t), Fe(e), e.readdirSync(t).forEach((r) => XC(KC.join(t, r), e)), Ma) {
    const r = Date.now();
    do
      try {
        return e.rmdirSync(t, e);
      } catch {
      }
    while (Date.now() - r < 500);
  } else
    return e.rmdirSync(t, e);
}
var q6 = Kg;
Kg.sync = XC;
const Bo = Me, j6 = ze.fromCallback, ZC = q6;
function F6(t, e) {
  if (Bo.rm)
    return Bo.rm(t, { recursive: !0, force: !0 }, e);
  ZC(t, e);
}
function B6(t) {
  if (Bo.rmSync)
    return Bo.rmSync(t, { recursive: !0, force: !0 });
  ZC.sync(t);
}
var jc = {
  remove: j6(F6),
  removeSync: B6
};
const U6 = ze.fromPromise, YC = kn, eT = se, tT = br, rT = jc, x0 = U6(async function(e) {
  let r;
  try {
    r = await YC.readdir(e);
  } catch {
    return tT.mkdirs(e);
  }
  return Promise.all(r.map((n) => rT.remove(eT.join(e, n))));
});
function _0(t) {
  let e;
  try {
    e = YC.readdirSync(t);
  } catch {
    return tT.mkdirsSync(t);
  }
  e.forEach((r) => {
    r = eT.join(t, r), rT.removeSync(r);
  });
}
var z6 = {
  emptyDirSync: _0,
  emptydirSync: _0,
  emptyDir: x0,
  emptydir: x0
};
const H6 = ze.fromCallback, nT = se, Vr = Me, iT = br;
function W6(t, e) {
  function r() {
    Vr.writeFile(t, "", (n) => {
      if (n)
        return e(n);
      e();
    });
  }
  Vr.stat(t, (n, i) => {
    if (!n && i.isFile())
      return e();
    const a = nT.dirname(t);
    Vr.stat(a, (s, o) => {
      if (s)
        return s.code === "ENOENT" ? iT.mkdirs(a, (c) => {
          if (c)
            return e(c);
          r();
        }) : e(s);
      o.isDirectory() ? r() : Vr.readdir(a, (c) => {
        if (c)
          return e(c);
      });
    });
  });
}
function G6(t) {
  let e;
  try {
    e = Vr.statSync(t);
  } catch {
  }
  if (e && e.isFile())
    return;
  const r = nT.dirname(t);
  try {
    Vr.statSync(r).isDirectory() || Vr.readdirSync(r);
  } catch (n) {
    if (n && n.code === "ENOENT")
      iT.mkdirsSync(r);
    else
      throw n;
  }
  Vr.writeFileSync(t, "");
}
var Q6 = {
  createFile: H6(W6),
  createFileSync: G6
};
const V6 = ze.fromCallback, aT = se, Gr = Me, sT = br, K6 = Rn.pathExists, { areIdentical: oT } = ki;
function J6(t, e, r) {
  function n(i, a) {
    Gr.link(i, a, (s) => {
      if (s)
        return r(s);
      r(null);
    });
  }
  Gr.lstat(e, (i, a) => {
    Gr.lstat(t, (s, o) => {
      if (s)
        return s.message = s.message.replace("lstat", "ensureLink"), r(s);
      if (a && oT(o, a))
        return r(null);
      const c = aT.dirname(e);
      K6(c, (f, u) => {
        if (f)
          return r(f);
        if (u)
          return n(t, e);
        sT.mkdirs(c, (l) => {
          if (l)
            return r(l);
          n(t, e);
        });
      });
    });
  });
}
function X6(t, e) {
  let r;
  try {
    r = Gr.lstatSync(e);
  } catch {
  }
  try {
    const a = Gr.lstatSync(t);
    if (r && oT(a, r))
      return;
  } catch (a) {
    throw a.message = a.message.replace("lstat", "ensureLink"), a;
  }
  const n = aT.dirname(e);
  return Gr.existsSync(n) || sT.mkdirsSync(n), Gr.linkSync(t, e);
}
var Z6 = {
  createLink: V6(J6),
  createLinkSync: X6
};
const Kr = se, ma = Me, Y6 = Rn.pathExists;
function eP(t, e, r) {
  if (Kr.isAbsolute(t))
    return ma.lstat(t, (n) => n ? (n.message = n.message.replace("lstat", "ensureSymlink"), r(n)) : r(null, {
      toCwd: t,
      toDst: t
    }));
  {
    const n = Kr.dirname(e), i = Kr.join(n, t);
    return Y6(i, (a, s) => a ? r(a) : s ? r(null, {
      toCwd: i,
      toDst: t
    }) : ma.lstat(t, (o) => o ? (o.message = o.message.replace("lstat", "ensureSymlink"), r(o)) : r(null, {
      toCwd: t,
      toDst: Kr.relative(n, t)
    })));
  }
}
function tP(t, e) {
  let r;
  if (Kr.isAbsolute(t)) {
    if (r = ma.existsSync(t), !r)
      throw new Error("absolute srcpath does not exist");
    return {
      toCwd: t,
      toDst: t
    };
  } else {
    const n = Kr.dirname(e), i = Kr.join(n, t);
    if (r = ma.existsSync(i), r)
      return {
        toCwd: i,
        toDst: t
      };
    if (r = ma.existsSync(t), !r)
      throw new Error("relative srcpath does not exist");
    return {
      toCwd: t,
      toDst: Kr.relative(n, t)
    };
  }
}
var rP = {
  symlinkPaths: eP,
  symlinkPathsSync: tP
};
const cT = Me;
function nP(t, e, r) {
  if (r = typeof e == "function" ? e : r, e = typeof e == "function" ? !1 : e, e)
    return r(null, e);
  cT.lstat(t, (n, i) => {
    if (n)
      return r(null, "file");
    e = i && i.isDirectory() ? "dir" : "file", r(null, e);
  });
}
function iP(t, e) {
  let r;
  if (e)
    return e;
  try {
    r = cT.lstatSync(t);
  } catch {
    return "file";
  }
  return r && r.isDirectory() ? "dir" : "file";
}
var aP = {
  symlinkType: nP,
  symlinkTypeSync: iP
};
const sP = ze.fromCallback, uT = se, Kt = kn, lT = br, oP = lT.mkdirs, cP = lT.mkdirsSync, pT = rP, uP = pT.symlinkPaths, lP = pT.symlinkPathsSync, fT = aP, pP = fT.symlinkType, fP = fT.symlinkTypeSync, hP = Rn.pathExists, { areIdentical: hT } = ki;
function dP(t, e, r, n) {
  n = typeof r == "function" ? r : n, r = typeof r == "function" ? !1 : r, Kt.lstat(e, (i, a) => {
    !i && a.isSymbolicLink() ? Promise.all([
      Kt.stat(t),
      Kt.stat(e)
    ]).then(([s, o]) => {
      if (hT(s, o))
        return n(null);
      E0(t, e, r, n);
    }) : E0(t, e, r, n);
  });
}
function E0(t, e, r, n) {
  uP(t, e, (i, a) => {
    if (i)
      return n(i);
    t = a.toDst, pP(a.toCwd, r, (s, o) => {
      if (s)
        return n(s);
      const c = uT.dirname(e);
      hP(c, (f, u) => {
        if (f)
          return n(f);
        if (u)
          return Kt.symlink(t, e, o, n);
        oP(c, (l) => {
          if (l)
            return n(l);
          Kt.symlink(t, e, o, n);
        });
      });
    });
  });
}
function mP(t, e, r) {
  let n;
  try {
    n = Kt.lstatSync(e);
  } catch {
  }
  if (n && n.isSymbolicLink()) {
    const o = Kt.statSync(t), c = Kt.statSync(e);
    if (hT(o, c))
      return;
  }
  const i = lP(t, e);
  t = i.toDst, r = fP(i.toCwd, r);
  const a = uT.dirname(e);
  return Kt.existsSync(a) || cP(a), Kt.symlinkSync(t, e, r);
}
var gP = {
  createSymlink: sP(dP),
  createSymlinkSync: mP
};
const { createFile: S0, createFileSync: C0 } = Q6, { createLink: T0, createLinkSync: O0 } = Z6, { createSymlink: A0, createSymlinkSync: $0 } = gP;
var vP = {
  // file
  createFile: S0,
  createFileSync: C0,
  ensureFile: S0,
  ensureFileSync: C0,
  // link
  createLink: T0,
  createLinkSync: O0,
  ensureLink: T0,
  ensureLinkSync: O0,
  // symlink
  createSymlink: A0,
  createSymlinkSync: $0,
  ensureSymlink: A0,
  ensureSymlinkSync: $0
};
function yP(t, { EOL: e = `
`, finalEOL: r = !0, replacer: n = null, spaces: i } = {}) {
  const a = r ? e : "";
  return JSON.stringify(t, n, i).replace(/\n/g, e) + a;
}
function bP(t) {
  return Buffer.isBuffer(t) && (t = t.toString("utf8")), t.replace(/^\uFEFF/, "");
}
var as = { stringify: yP, stripBom: bP };
let bi;
try {
  bi = Me;
} catch {
  bi = se;
}
const Fc = ze, { stringify: dT, stripBom: mT } = as;
async function wP(t, e = {}) {
  typeof e == "string" && (e = { encoding: e });
  const r = e.fs || bi, n = "throws" in e ? e.throws : !0;
  let i = await Fc.fromCallback(r.readFile)(t, e);
  i = mT(i);
  let a;
  try {
    a = JSON.parse(i, e ? e.reviver : null);
  } catch (s) {
    if (n)
      throw s.message = `${t}: ${s.message}`, s;
    return null;
  }
  return a;
}
const xP = Fc.fromPromise(wP);
function _P(t, e = {}) {
  typeof e == "string" && (e = { encoding: e });
  const r = e.fs || bi, n = "throws" in e ? e.throws : !0;
  try {
    let i = r.readFileSync(t, e);
    return i = mT(i), JSON.parse(i, e.reviver);
  } catch (i) {
    if (n)
      throw i.message = `${t}: ${i.message}`, i;
    return null;
  }
}
async function EP(t, e, r = {}) {
  const n = r.fs || bi, i = dT(e, r);
  await Fc.fromCallback(n.writeFile)(t, i, r);
}
const SP = Fc.fromPromise(EP);
function CP(t, e, r = {}) {
  const n = r.fs || bi, i = dT(e, r);
  return n.writeFileSync(t, i, r);
}
const TP = {
  readFile: xP,
  readFileSync: _P,
  writeFile: SP,
  writeFileSync: CP
};
var gT = TP;
const Hs = gT;
var OP = {
  // jsonfile exports
  readJson: Hs.readFile,
  readJsonSync: Hs.readFileSync,
  writeJson: Hs.writeFile,
  writeJsonSync: Hs.writeFileSync
};
const AP = ze.fromCallback, ga = Me, vT = se, yT = br, $P = Rn.pathExists;
function IP(t, e, r, n) {
  typeof r == "function" && (n = r, r = "utf8");
  const i = vT.dirname(t);
  $P(i, (a, s) => {
    if (a)
      return n(a);
    if (s)
      return ga.writeFile(t, e, r, n);
    yT.mkdirs(i, (o) => {
      if (o)
        return n(o);
      ga.writeFile(t, e, r, n);
    });
  });
}
function kP(t, ...e) {
  const r = vT.dirname(t);
  if (ga.existsSync(r))
    return ga.writeFileSync(t, ...e);
  yT.mkdirsSync(r), ga.writeFileSync(t, ...e);
}
var Jg = {
  outputFile: AP(IP),
  outputFileSync: kP
};
const { stringify: RP } = as, { outputFile: NP } = Jg;
async function LP(t, e, r = {}) {
  const n = RP(e, r);
  await NP(t, n, r);
}
var PP = LP;
const { stringify: DP } = as, { outputFileSync: MP } = Jg;
function qP(t, e, r) {
  const n = DP(e, r);
  MP(t, n, r);
}
var jP = qP;
const FP = ze.fromPromise, At = OP;
At.outputJson = FP(PP);
At.outputJsonSync = jP;
At.outputJSON = At.outputJson;
At.outputJSONSync = At.outputJsonSync;
At.writeJSON = At.writeJson;
At.writeJSONSync = At.writeJsonSync;
At.readJSON = At.readJson;
At.readJSONSync = At.readJsonSync;
var BP = At;
const UP = Me, Sm = se, zP = Vg.copy, bT = jc.remove, HP = br.mkdirp, WP = Rn.pathExists, I0 = ki;
function GP(t, e, r, n) {
  typeof r == "function" && (n = r, r = {}), r = r || {};
  const i = r.overwrite || r.clobber || !1;
  I0.checkPaths(t, e, "move", r, (a, s) => {
    if (a)
      return n(a);
    const { srcStat: o, isChangingCase: c = !1 } = s;
    I0.checkParentPaths(t, o, e, "move", (f) => {
      if (f)
        return n(f);
      if (QP(e))
        return k0(t, e, i, c, n);
      HP(Sm.dirname(e), (u) => u ? n(u) : k0(t, e, i, c, n));
    });
  });
}
function QP(t) {
  const e = Sm.dirname(t);
  return Sm.parse(e).root === e;
}
function k0(t, e, r, n, i) {
  if (n)
    return Ml(t, e, r, i);
  if (r)
    return bT(e, (a) => a ? i(a) : Ml(t, e, r, i));
  WP(e, (a, s) => a ? i(a) : s ? i(new Error("dest already exists.")) : Ml(t, e, r, i));
}
function Ml(t, e, r, n) {
  UP.rename(t, e, (i) => i ? i.code !== "EXDEV" ? n(i) : VP(t, e, r, n) : n());
}
function VP(t, e, r, n) {
  zP(t, e, {
    overwrite: r,
    errorOnExist: !0
  }, (a) => a ? n(a) : bT(t, n));
}
var KP = GP;
const wT = Me, Cm = se, JP = Vg.copySync, xT = jc.removeSync, XP = br.mkdirpSync, R0 = ki;
function ZP(t, e, r) {
  r = r || {};
  const n = r.overwrite || r.clobber || !1, { srcStat: i, isChangingCase: a = !1 } = R0.checkPathsSync(t, e, "move", r);
  return R0.checkParentPathsSync(t, i, e, "move"), YP(e) || XP(Cm.dirname(e)), eD(t, e, n, a);
}
function YP(t) {
  const e = Cm.dirname(t);
  return Cm.parse(e).root === e;
}
function eD(t, e, r, n) {
  if (n)
    return ql(t, e, r);
  if (r)
    return xT(e), ql(t, e, r);
  if (wT.existsSync(e))
    throw new Error("dest already exists.");
  return ql(t, e, r);
}
function ql(t, e, r) {
  try {
    wT.renameSync(t, e);
  } catch (n) {
    if (n.code !== "EXDEV")
      throw n;
    return tD(t, e, r);
  }
}
function tD(t, e, r) {
  return JP(t, e, {
    overwrite: r,
    errorOnExist: !0
  }), xT(t);
}
var rD = ZP;
const nD = ze.fromCallback;
var iD = {
  move: nD(KP),
  moveSync: rD
}, aD = {
  // Export promiseified graceful-fs:
  ...kn,
  // Export extra methods:
  ...Vg,
  ...z6,
  ...vP,
  ...BP,
  ...br,
  ...iD,
  ...Jg,
  ...Rn,
  ...jc
};
const Nn = /* @__PURE__ */ Oi(aD), _T = process.env.PWD, sD = mr.join(_T || "", "src", "server"), oD = mr.tmpdir(), Xg = (t) => mr.normalize(t), cD = (...t) => mr.normalize(mr.join.apply(null, t)), Zg = (t) => /.json$/.test(t) || /.project$/.test(t), uD = (t, e) => mr.basename(t, e), lD = (t) => mr.extname(t), ss = (t) => {
  try {
    return {
      error: !1,
      data: {
        exists: Nn.pathExistsSync(t)
      }
    };
  } catch (e) {
    return {
      error: !0,
      message: e && typeof e == "string" ? e : `Unable to check file existance: ${t} - unknown reason`
    };
  }
}, Re = {
  basePath: _T,
  rootPath: sD,
  tempPath: oD,
  normalize: Xg,
  getFilename: uD,
  getExt: lD,
  exists: ss,
  isJSON: Zg,
  join: cD
}, pD = (t, e = "utf8") => {
  const r = ss(t);
  if (r.error)
    return {
      error: !0,
      message: r.message
    };
  e === void 0 && (e = "utf8");
  const n = Xg(t);
  try {
    let i;
    const a = Nn.readFileSync(n, { encoding: e, flag: "r" });
    return Zg(n) ? i = JSON.parse(a) : i = a, {
      error: !1,
      data: {
        filename: n,
        contents: i
      }
    };
  } catch (i) {
    return {
      error: !0,
      message: i && typeof i == "string" ? i : `Unable to read file: ${t} - unknown reason`
    };
  }
}, fD = (t, e) => {
  const r = Xg(t);
  if (!e)
    return {
      error: !0,
      message: `Unable to write file: ${t} - contents required`
    };
  try {
    return Zg(t) && (typeof e != "string" ? e = JSON.stringify(e, null, 2) : e = JSON.stringify(JSON.parse(e), null, 2)), Nn.outputFileSync(r, e), {
      error: !1,
      data: {
        filename: r
      }
    };
  } catch (n) {
    return {
      error: !0,
      message: n && typeof n == "string" ? n : `Unable to write file: ${t} - unknown reason`
    };
  }
}, ET = (t) => {
  const e = ss(t);
  if (e.error)
    return e;
  if (!e.data.exists)
    return console.warn(`unable to remove ${t}: path does not exists`), {
      error: !1,
      data: {
        remove: !1,
        pathname: t
      }
    };
  try {
    return Nn.removeSync(t), {
      error: !1,
      data: {
        remove: !0,
        pathname: t
      }
    };
  } catch (r) {
    return {
      error: !0,
      message: r && typeof r == "string" ? r : `Unable to remove: ${t} - unknown reason`
    };
  }
}, hD = (t, e, r) => {
  if (!t)
    return {
      error: !0,
      message: "Unable to copy: source required"
    };
  if (!e)
    return {
      error: !0,
      message: "Unable to copy: dest required"
    };
  const n = ss(t);
  if (n.error)
    return n;
  if (!n.data.exists)
    return {
      error: !1,
      message: `Unable to copy: source ${t} does not exists`,
      data: {
        copied: !1,
        source: t,
        dest: e
      }
    };
  try {
    return Nn.copySync(t, e, r), {
      error: !1,
      data: {
        source: t,
        dest: e
      }
    };
  } catch (i) {
    return {
      error: !0,
      message: "Unable to copy: unexpected error",
      data: {
        trace: i
      }
    };
  }
}, dD = (t, e) => {
  const r = ss(t);
  if (r.error)
    return r;
  try {
    return Nn.renameSync(t, e), {
      error: !1,
      data: {
        src: t,
        filename: e
      }
    };
  } catch (n) {
    return {
      error: !0,
      message: "unable to rename: unexpected error",
      data: {
        trace: n
      }
    };
  }
}, mD = Re.join(Re.rootPath, "../", "main", "assets"), Uo = Re.join(mD, "project"), Vt = {
  css: "text/css",
  json: "application/json",
  js: "text/javascript",
  html: "text/html",
  text: "text/plain",
  webp: "image/webp",
  svg: "image/svg+xml",
  mp4: "video/mp4",
  mp3: "audio/mpeg"
}, gD = (t) => {
  switch (Re.getExt(t)) {
    case ".json":
      return Vt.json;
    case ".js":
    case ".mjs":
      return Vt.js;
    case ".html":
      return Vt.html;
    case ".css":
      return Vt.css;
    case ".webp":
      return Vt.webp;
    case ".svg":
      return Vt.svg;
    case ".mp4":
      return Vt.mp4;
    case ".mp3":
      return Vt.mp3;
    default:
      return Vt.text;
  }
}, vD = (t, e, r) => {
  try {
    const n = Nn.createReadStream(t);
    r.setHeader("Content-Type", e), r.writeHead(200), n.pipe(r);
  } catch (n) {
    Tm(n, r);
  }
}, yD = (t, e) => {
  e.setHeader("Content-Type", Vt.text), e.writeHead(404), e.end(`Unable to find resource: ${t}`, "utf-8");
}, Tm = (t, e) => {
  e.setHeader("Content-Type", Vt.text), e.writeHead(500), e.end(`${t}`, "utf-8");
}, bD = (t, e) => {
  const r = Re.exists(e);
  if (r.error) {
    console.log("path error", e), Tm(r, t);
    return;
  }
  if (!r.data.exists) {
    console.log("path not found", e), yD(e, t);
    return;
  }
  try {
    vD(e, gD(e), t);
  } catch (n) {
    Tm(n, t);
  }
}, Eo = [], wD = (t, e) => {
  switch (e.type) {
    case "invoke":
      if (!e.fn || typeof e.fn != "function") {
        console.warn(
          `Unable to register endpoint: ${e.name} - ${e.type} requires a callback function`
        );
        return;
      }
      switch (Eo.push(e), e.method) {
        case "POST":
          t.post(e.name, e.fn);
          break;
        case "GET":
        default:
          t.get(e.name, e.fn);
          break;
      }
      break;
    case "on":
      if (!e.fn || typeof e.fn != "function") {
        console.warn(
          `Unable to register endpoint: ${e.name} - ${e.type} requires a callback function`
        );
        return;
      }
      Eo.push(e);
      break;
    case "send":
      Eo.push(e);
      break;
  }
}, Ws = (t, e) => {
  for (const r in e)
    wD(t, e[r]);
};
var Om = { exports: {} }, Am = { exports: {} }, Bt = {}, Ge = {};
Ge.__esModule = !0;
Ge.extend = ST;
Ge.indexOf = CD;
Ge.escapeExpression = TD;
Ge.isEmpty = OD;
Ge.createFrame = AD;
Ge.blockParams = $D;
Ge.appendContextPath = ID;
var xD = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#x27;",
  "`": "&#x60;",
  "=": "&#x3D;"
}, _D = /[&<>"'`=]/g, ED = /[&<>"'`=]/;
function SD(t) {
  return xD[t];
}
function ST(t) {
  for (var e = 1; e < arguments.length; e++)
    for (var r in arguments[e])
      Object.prototype.hasOwnProperty.call(arguments[e], r) && (t[r] = arguments[e][r]);
  return t;
}
var Yg = Object.prototype.toString;
Ge.toString = Yg;
var $m = function(e) {
  return typeof e == "function";
};
$m(/x/) && (Ge.isFunction = $m = function(t) {
  return typeof t == "function" && Yg.call(t) === "[object Function]";
});
Ge.isFunction = $m;
var CT = Array.isArray || function(t) {
  return t && typeof t == "object" ? Yg.call(t) === "[object Array]" : !1;
};
Ge.isArray = CT;
function CD(t, e) {
  for (var r = 0, n = t.length; r < n; r++)
    if (t[r] === e)
      return r;
  return -1;
}
function TD(t) {
  if (typeof t != "string") {
    if (t && t.toHTML)
      return t.toHTML();
    if (t == null)
      return "";
    if (!t)
      return t + "";
    t = "" + t;
  }
  return ED.test(t) ? t.replace(_D, SD) : t;
}
function OD(t) {
  return !t && t !== 0 ? !0 : !!(CT(t) && t.length === 0);
}
function AD(t) {
  var e = ST({}, t);
  return e._parent = t, e;
}
function $D(t, e) {
  return t.path = e, t;
}
function ID(t, e) {
  return (t ? t + "." : "") + e;
}
var Im = { exports: {} };
(function(t, e) {
  e.__esModule = !0;
  var r = ["description", "fileName", "lineNumber", "endLineNumber", "message", "name", "number", "stack"];
  function n(i, a) {
    var s = a && a.loc, o = void 0, c = void 0, f = void 0, u = void 0;
    s && (o = s.start.line, c = s.end.line, f = s.start.column, u = s.end.column, i += " - " + o + ":" + f);
    for (var l = Error.prototype.constructor.call(this, i), p = 0; p < r.length; p++)
      this[r[p]] = l[r[p]];
    Error.captureStackTrace && Error.captureStackTrace(this, n);
    try {
      s && (this.lineNumber = o, this.endLineNumber = c, Object.defineProperty ? (Object.defineProperty(this, "column", {
        value: f,
        enumerable: !0
      }), Object.defineProperty(this, "endColumn", {
        value: u,
        enumerable: !0
      })) : (this.column = f, this.endColumn = u));
    } catch {
    }
  }
  n.prototype = new Error(), e.default = n, t.exports = e.default;
})(Im, Im.exports);
var ir = Im.exports, os = {}, km = { exports: {} };
(function(t, e) {
  e.__esModule = !0;
  var r = Ge;
  e.default = function(n) {
    n.registerHelper("blockHelperMissing", function(i, a) {
      var s = a.inverse, o = a.fn;
      if (i === !0)
        return o(this);
      if (i === !1 || i == null)
        return s(this);
      if (r.isArray(i))
        return i.length > 0 ? (a.ids && (a.ids = [a.name]), n.helpers.each(i, a)) : s(this);
      if (a.data && a.ids) {
        var c = r.createFrame(a.data);
        c.contextPath = r.appendContextPath(a.data.contextPath, a.name), a = { data: c };
      }
      return o(i, a);
    });
  }, t.exports = e.default;
})(km, km.exports);
var kD = km.exports, Rm = { exports: {} };
(function(t, e) {
  e.__esModule = !0;
  function r(s) {
    return s && s.__esModule ? s : { default: s };
  }
  var n = Ge, i = ir, a = r(i);
  e.default = function(s) {
    s.registerHelper("each", function(o, c) {
      if (!c)
        throw new a.default("Must pass iterator to #each");
      var f = c.fn, u = c.inverse, l = 0, p = "", m = void 0, h = void 0;
      c.data && c.ids && (h = n.appendContextPath(c.data.contextPath, c.ids[0]) + "."), n.isFunction(o) && (o = o.call(this)), c.data && (m = n.createFrame(c.data));
      function g(b, w, S) {
        m && (m.key = b, m.index = w, m.first = w === 0, m.last = !!S, h && (m.contextPath = h + b)), p = p + f(o[b], {
          data: m,
          blockParams: n.blockParams([o[b], b], [h + b, null])
        });
      }
      if (o && typeof o == "object")
        if (n.isArray(o))
          for (var v = o.length; l < v; l++)
            l in o && g(l, l, l === o.length - 1);
        else if (ve.Symbol && o[ve.Symbol.iterator]) {
          for (var d = [], y = o[ve.Symbol.iterator](), x = y.next(); !x.done; x = y.next())
            d.push(x.value);
          o = d;
          for (var v = o.length; l < v; l++)
            g(l, l, l === o.length - 1);
        } else
          (function() {
            var b = void 0;
            Object.keys(o).forEach(function(w) {
              b !== void 0 && g(b, l - 1), b = w, l++;
            }), b !== void 0 && g(b, l - 1, !0);
          })();
      return l === 0 && (p = u(this)), p;
    });
  }, t.exports = e.default;
})(Rm, Rm.exports);
var RD = Rm.exports, Nm = { exports: {} };
(function(t, e) {
  e.__esModule = !0;
  function r(a) {
    return a && a.__esModule ? a : { default: a };
  }
  var n = ir, i = r(n);
  e.default = function(a) {
    a.registerHelper("helperMissing", function() {
      if (arguments.length !== 1)
        throw new i.default('Missing helper: "' + arguments[arguments.length - 1].name + '"');
    });
  }, t.exports = e.default;
})(Nm, Nm.exports);
var ND = Nm.exports, Lm = { exports: {} };
(function(t, e) {
  e.__esModule = !0;
  function r(s) {
    return s && s.__esModule ? s : { default: s };
  }
  var n = Ge, i = ir, a = r(i);
  e.default = function(s) {
    s.registerHelper("if", function(o, c) {
      if (arguments.length != 2)
        throw new a.default("#if requires exactly one argument");
      return n.isFunction(o) && (o = o.call(this)), !c.hash.includeZero && !o || n.isEmpty(o) ? c.inverse(this) : c.fn(this);
    }), s.registerHelper("unless", function(o, c) {
      if (arguments.length != 2)
        throw new a.default("#unless requires exactly one argument");
      return s.helpers.if.call(this, o, {
        fn: c.inverse,
        inverse: c.fn,
        hash: c.hash
      });
    });
  }, t.exports = e.default;
})(Lm, Lm.exports);
var LD = Lm.exports, Pm = { exports: {} };
(function(t, e) {
  e.__esModule = !0, e.default = function(r) {
    r.registerHelper("log", function() {
      for (var n = [void 0], i = arguments[arguments.length - 1], a = 0; a < arguments.length - 1; a++)
        n.push(arguments[a]);
      var s = 1;
      i.hash.level != null ? s = i.hash.level : i.data && i.data.level != null && (s = i.data.level), n[0] = s, r.log.apply(r, n);
    });
  }, t.exports = e.default;
})(Pm, Pm.exports);
var PD = Pm.exports, Dm = { exports: {} };
(function(t, e) {
  e.__esModule = !0, e.default = function(r) {
    r.registerHelper("lookup", function(n, i, a) {
      return n && a.lookupProperty(n, i);
    });
  }, t.exports = e.default;
})(Dm, Dm.exports);
var DD = Dm.exports, Mm = { exports: {} };
(function(t, e) {
  e.__esModule = !0;
  function r(s) {
    return s && s.__esModule ? s : { default: s };
  }
  var n = Ge, i = ir, a = r(i);
  e.default = function(s) {
    s.registerHelper("with", function(o, c) {
      if (arguments.length != 2)
        throw new a.default("#with requires exactly one argument");
      n.isFunction(o) && (o = o.call(this));
      var f = c.fn;
      if (n.isEmpty(o))
        return c.inverse(this);
      var u = c.data;
      return c.data && c.ids && (u = n.createFrame(c.data), u.contextPath = n.appendContextPath(c.data.contextPath, c.ids[0])), f(o, {
        data: u,
        blockParams: n.blockParams([o], [u && u.contextPath])
      });
    });
  }, t.exports = e.default;
})(Mm, Mm.exports);
var MD = Mm.exports;
os.__esModule = !0;
os.registerDefaultHelpers = ZD;
os.moveHelperToHooks = YD;
function Ln(t) {
  return t && t.__esModule ? t : { default: t };
}
var qD = kD, jD = Ln(qD), FD = RD, BD = Ln(FD), UD = ND, zD = Ln(UD), HD = LD, WD = Ln(HD), GD = PD, QD = Ln(GD), VD = DD, KD = Ln(VD), JD = MD, XD = Ln(JD);
function ZD(t) {
  jD.default(t), BD.default(t), zD.default(t), WD.default(t), QD.default(t), KD.default(t), XD.default(t);
}
function YD(t, e, r) {
  t.helpers[e] && (t.hooks[e] = t.helpers[e], r || delete t.helpers[e]);
}
var ev = {}, qm = { exports: {} };
(function(t, e) {
  e.__esModule = !0;
  var r = Ge;
  e.default = function(n) {
    n.registerDecorator("inline", function(i, a, s, o) {
      var c = i;
      return a.partials || (a.partials = {}, c = function(f, u) {
        var l = s.partials;
        s.partials = r.extend({}, l, a.partials);
        var p = i(f, u);
        return s.partials = l, p;
      }), a.partials[o.args[0]] = o.fn, c;
    });
  }, t.exports = e.default;
})(qm, qm.exports);
var eM = qm.exports;
ev.__esModule = !0;
ev.registerDefaultDecorators = iM;
function tM(t) {
  return t && t.__esModule ? t : { default: t };
}
var rM = eM, nM = tM(rM);
function iM(t) {
  nM.default(t);
}
var jm = { exports: {} };
(function(t, e) {
  e.__esModule = !0;
  var r = Ge, n = {
    methodMap: ["debug", "info", "warn", "error"],
    level: "info",
    // Maps a given level value to the `methodMap` indexes above.
    lookupLevel: function(a) {
      if (typeof a == "string") {
        var s = r.indexOf(n.methodMap, a.toLowerCase());
        s >= 0 ? a = s : a = parseInt(a, 10);
      }
      return a;
    },
    // Can be overridden in the host environment
    log: function(a) {
      if (a = n.lookupLevel(a), typeof console < "u" && n.lookupLevel(n.level) <= a) {
        var s = n.methodMap[a];
        console[s] || (s = "log");
        for (var o = arguments.length, c = Array(o > 1 ? o - 1 : 0), f = 1; f < o; f++)
          c[f - 1] = arguments[f];
        console[s].apply(console, c);
      }
    }
  };
  e.default = n, t.exports = e.default;
})(jm, jm.exports);
var TT = jm.exports, Ri = {}, tv = {};
tv.__esModule = !0;
tv.createNewLookupObject = sM;
var aM = Ge;
function sM() {
  for (var t = arguments.length, e = Array(t), r = 0; r < t; r++)
    e[r] = arguments[r];
  return aM.extend.apply(void 0, [/* @__PURE__ */ Object.create(null)].concat(e));
}
Ri.__esModule = !0;
Ri.createProtoAccessControl = lM;
Ri.resultIsAllowed = pM;
Ri.resetLoggedProperties = hM;
function oM(t) {
  if (t && t.__esModule)
    return t;
  var e = {};
  if (t != null)
    for (var r in t)
      Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
  return e.default = t, e;
}
var N0 = tv, cM = TT, uM = oM(cM), zo = /* @__PURE__ */ Object.create(null);
function lM(t) {
  var e = /* @__PURE__ */ Object.create(null);
  e.constructor = !1, e.__defineGetter__ = !1, e.__defineSetter__ = !1, e.__lookupGetter__ = !1;
  var r = /* @__PURE__ */ Object.create(null);
  return r.__proto__ = !1, {
    properties: {
      whitelist: N0.createNewLookupObject(r, t.allowedProtoProperties),
      defaultValue: t.allowProtoPropertiesByDefault
    },
    methods: {
      whitelist: N0.createNewLookupObject(e, t.allowedProtoMethods),
      defaultValue: t.allowProtoMethodsByDefault
    }
  };
}
function pM(t, e, r) {
  return L0(typeof t == "function" ? e.methods : e.properties, r);
}
function L0(t, e) {
  return t.whitelist[e] !== void 0 ? t.whitelist[e] === !0 : t.defaultValue !== void 0 ? t.defaultValue : (fM(e), !1);
}
function fM(t) {
  zo[t] !== !0 && (zo[t] = !0, uM.log("error", 'Handlebars: Access has been denied to resolve the property "' + t + `" because it is not an "own property" of its parent.
You can add a runtime option to disable the check or this warning:
See https://handlebarsjs.com/api-reference/runtime-options.html#options-to-control-prototype-access for details`));
}
function hM() {
  Object.keys(zo).forEach(function(t) {
    delete zo[t];
  });
}
Bt.__esModule = !0;
Bt.HandlebarsEnvironment = Fm;
function OT(t) {
  return t && t.__esModule ? t : { default: t };
}
var xn = Ge, dM = ir, jl = OT(dM), mM = os, gM = ev, vM = TT, Ho = OT(vM), yM = Ri, bM = "4.7.7";
Bt.VERSION = bM;
var wM = 8;
Bt.COMPILER_REVISION = wM;
var xM = 7;
Bt.LAST_COMPATIBLE_COMPILER_REVISION = xM;
var _M = {
  1: "<= 1.0.rc.2",
  // 1.0.rc.2 is actually rev2 but doesn't report it
  2: "== 1.0.0-rc.3",
  3: "== 1.0.0-rc.4",
  4: "== 1.x.x",
  5: "== 2.0.0-alpha.x",
  6: ">= 2.0.0-beta.1",
  7: ">= 4.0.0 <4.3.0",
  8: ">= 4.3.0"
};
Bt.REVISION_CHANGES = _M;
var Fl = "[object Object]";
function Fm(t, e, r) {
  this.helpers = t || {}, this.partials = e || {}, this.decorators = r || {}, mM.registerDefaultHelpers(this), gM.registerDefaultDecorators(this);
}
Fm.prototype = {
  constructor: Fm,
  logger: Ho.default,
  log: Ho.default.log,
  registerHelper: function(e, r) {
    if (xn.toString.call(e) === Fl) {
      if (r)
        throw new jl.default("Arg not supported with multiple helpers");
      xn.extend(this.helpers, e);
    } else
      this.helpers[e] = r;
  },
  unregisterHelper: function(e) {
    delete this.helpers[e];
  },
  registerPartial: function(e, r) {
    if (xn.toString.call(e) === Fl)
      xn.extend(this.partials, e);
    else {
      if (typeof r > "u")
        throw new jl.default('Attempting to register a partial called "' + e + '" as undefined');
      this.partials[e] = r;
    }
  },
  unregisterPartial: function(e) {
    delete this.partials[e];
  },
  registerDecorator: function(e, r) {
    if (xn.toString.call(e) === Fl) {
      if (r)
        throw new jl.default("Arg not supported with multiple decorators");
      xn.extend(this.decorators, e);
    } else
      this.decorators[e] = r;
  },
  unregisterDecorator: function(e) {
    delete this.decorators[e];
  },
  /**
   * Reset the memory of illegal property accesses that have already been logged.
   * @deprecated should only be used in handlebars test-cases
   */
  resetLoggedPropertyAccesses: function() {
    yM.resetLoggedProperties();
  }
};
var EM = Ho.default.log;
Bt.log = EM;
Bt.createFrame = xn.createFrame;
Bt.logger = Ho.default;
var Bm = { exports: {} };
(function(t, e) {
  e.__esModule = !0;
  function r(n) {
    this.string = n;
  }
  r.prototype.toString = r.prototype.toHTML = function() {
    return "" + this.string;
  }, e.default = r, t.exports = e.default;
})(Bm, Bm.exports);
var SM = Bm.exports, sn = {}, rv = {};
rv.__esModule = !0;
rv.wrapHelper = CM;
function CM(t, e) {
  if (typeof t != "function")
    return t;
  var r = function() {
    var i = arguments[arguments.length - 1];
    return arguments[arguments.length - 1] = e(i), t.apply(this, arguments);
  };
  return r;
}
sn.__esModule = !0;
sn.checkRevision = kM;
sn.template = RM;
sn.wrapProgram = So;
sn.resolvePartial = NM;
sn.invokePartial = LM;
sn.noop = AT;
function TM(t) {
  return t && t.__esModule ? t : { default: t };
}
function OM(t) {
  if (t && t.__esModule)
    return t;
  var e = {};
  if (t != null)
    for (var r in t)
      Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
  return e.default = t, e;
}
var AM = Ge, Nr = OM(AM), $M = ir, Lr = TM($M), Pr = Bt, P0 = os, IM = rv, D0 = Ri;
function kM(t) {
  var e = t && t[0] || 1, r = Pr.COMPILER_REVISION;
  if (!(e >= Pr.LAST_COMPATIBLE_COMPILER_REVISION && e <= Pr.COMPILER_REVISION))
    if (e < Pr.LAST_COMPATIBLE_COMPILER_REVISION) {
      var n = Pr.REVISION_CHANGES[r], i = Pr.REVISION_CHANGES[e];
      throw new Lr.default("Template was precompiled with an older version of Handlebars than the current runtime. Please update your precompiler to a newer version (" + n + ") or downgrade your runtime to an older version (" + i + ").");
    } else
      throw new Lr.default("Template was precompiled with a newer version of Handlebars than the current runtime. Please update your runtime to a newer version (" + t[1] + ").");
}
function RM(t, e) {
  if (!e)
    throw new Lr.default("No environment passed to template");
  if (!t || !t.main)
    throw new Lr.default("Unknown template object: " + typeof t);
  t.main.decorator = t.main_d, e.VM.checkRevision(t.compiler);
  var r = t.compiler && t.compiler[0] === 7;
  function n(s, o, c) {
    c.hash && (o = Nr.extend({}, o, c.hash), c.ids && (c.ids[0] = !0)), s = e.VM.resolvePartial.call(this, s, o, c);
    var f = Nr.extend({}, c, {
      hooks: this.hooks,
      protoAccessControl: this.protoAccessControl
    }), u = e.VM.invokePartial.call(this, s, o, f);
    if (u == null && e.compile && (c.partials[c.name] = e.compile(s, t.compilerOptions, e), u = c.partials[c.name](o, f)), u != null) {
      if (c.indent) {
        for (var l = u.split(`
`), p = 0, m = l.length; p < m && !(!l[p] && p + 1 === m); p++)
          l[p] = c.indent + l[p];
        u = l.join(`
`);
      }
      return u;
    } else
      throw new Lr.default("The partial " + c.name + " could not be compiled when running in runtime-only mode");
  }
  var i = {
    strict: function(o, c, f) {
      if (!o || !(c in o))
        throw new Lr.default('"' + c + '" not defined in ' + o, {
          loc: f
        });
      return i.lookupProperty(o, c);
    },
    lookupProperty: function(o, c) {
      var f = o[c];
      if (f == null || Object.prototype.hasOwnProperty.call(o, c) || D0.resultIsAllowed(f, i.protoAccessControl, c))
        return f;
    },
    lookup: function(o, c) {
      for (var f = o.length, u = 0; u < f; u++) {
        var l = o[u] && i.lookupProperty(o[u], c);
        if (l != null)
          return o[u][c];
      }
    },
    lambda: function(o, c) {
      return typeof o == "function" ? o.call(c) : o;
    },
    escapeExpression: Nr.escapeExpression,
    invokePartial: n,
    fn: function(o) {
      var c = t[o];
      return c.decorator = t[o + "_d"], c;
    },
    programs: [],
    program: function(o, c, f, u, l) {
      var p = this.programs[o], m = this.fn(o);
      return c || l || u || f ? p = So(this, o, m, c, f, u, l) : p || (p = this.programs[o] = So(this, o, m)), p;
    },
    data: function(o, c) {
      for (; o && c--; )
        o = o._parent;
      return o;
    },
    mergeIfNeeded: function(o, c) {
      var f = o || c;
      return o && c && o !== c && (f = Nr.extend({}, c, o)), f;
    },
    // An empty object to use as replacement for null-contexts
    nullContext: Object.seal({}),
    noop: e.VM.noop,
    compilerInfo: t.compiler
  };
  function a(s) {
    var o = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1], c = o.data;
    a._setup(o), !o.partial && t.useData && (c = PM(s, c));
    var f = void 0, u = t.useBlockParams ? [] : void 0;
    t.useDepths && (o.depths ? f = s != o.depths[0] ? [s].concat(o.depths) : o.depths : f = [s]);
    function l(p) {
      return "" + t.main(i, p, i.helpers, i.partials, c, u, f);
    }
    return l = $T(t.main, l, i, o.depths || [], c, u), l(s, o);
  }
  return a.isTop = !0, a._setup = function(s) {
    if (s.partial)
      i.protoAccessControl = s.protoAccessControl, i.helpers = s.helpers, i.partials = s.partials, i.decorators = s.decorators, i.hooks = s.hooks;
    else {
      var o = Nr.extend({}, e.helpers, s.helpers);
      DM(o, i), i.helpers = o, t.usePartial && (i.partials = i.mergeIfNeeded(s.partials, e.partials)), (t.usePartial || t.useDecorators) && (i.decorators = Nr.extend({}, e.decorators, s.decorators)), i.hooks = {}, i.protoAccessControl = D0.createProtoAccessControl(s);
      var c = s.allowCallsToHelperMissing || r;
      P0.moveHelperToHooks(i, "helperMissing", c), P0.moveHelperToHooks(i, "blockHelperMissing", c);
    }
  }, a._child = function(s, o, c, f) {
    if (t.useBlockParams && !c)
      throw new Lr.default("must pass block params");
    if (t.useDepths && !f)
      throw new Lr.default("must pass parent depths");
    return So(i, s, t[s], o, 0, c, f);
  }, a;
}
function So(t, e, r, n, i, a, s) {
  function o(c) {
    var f = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1], u = s;
    return s && c != s[0] && !(c === t.nullContext && s[0] === null) && (u = [c].concat(s)), r(t, c, t.helpers, t.partials, f.data || n, a && [f.blockParams].concat(a), u);
  }
  return o = $T(r, o, t, s, n, a), o.program = e, o.depth = s ? s.length : 0, o.blockParams = i || 0, o;
}
function NM(t, e, r) {
  return t ? !t.call && !r.name && (r.name = t, t = r.partials[t]) : r.name === "@partial-block" ? t = r.data["partial-block"] : t = r.partials[r.name], t;
}
function LM(t, e, r) {
  var n = r.data && r.data["partial-block"];
  r.partial = !0, r.ids && (r.data.contextPath = r.ids[0] || r.data.contextPath);
  var i = void 0;
  if (r.fn && r.fn !== AT && function() {
    r.data = Pr.createFrame(r.data);
    var a = r.fn;
    i = r.data["partial-block"] = function(o) {
      var c = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
      return c.data = Pr.createFrame(c.data), c.data["partial-block"] = n, a(o, c);
    }, a.partials && (r.partials = Nr.extend({}, r.partials, a.partials));
  }(), t === void 0 && i && (t = i), t === void 0)
    throw new Lr.default("The partial " + r.name + " could not be found");
  if (t instanceof Function)
    return t(e, r);
}
function AT() {
  return "";
}
function PM(t, e) {
  return (!e || !("root" in e)) && (e = e ? Pr.createFrame(e) : {}, e.root = t), e;
}
function $T(t, e, r, n, i, a) {
  if (t.decorator) {
    var s = {};
    e = t.decorator(e, s, r, n && n[0], i, a, n), Nr.extend(e, s);
  }
  return e;
}
function DM(t, e) {
  Object.keys(t).forEach(function(r) {
    var n = t[r];
    t[r] = MM(n, e);
  });
}
function MM(t, e) {
  var r = e.lookupProperty;
  return IM.wrapHelper(t, function(n) {
    return Nr.extend({ lookupProperty: r }, n);
  });
}
var Um = { exports: {} };
(function(t, e) {
  e.__esModule = !0, e.default = function(r) {
    var n = typeof ve < "u" ? ve : window, i = n.Handlebars;
    r.noConflict = function() {
      return n.Handlebars === r && (n.Handlebars = i), r;
    };
  }, t.exports = e.default;
})(Um, Um.exports);
var IT = Um.exports;
(function(t, e) {
  e.__esModule = !0;
  function r(y) {
    return y && y.__esModule ? y : { default: y };
  }
  function n(y) {
    if (y && y.__esModule)
      return y;
    var x = {};
    if (y != null)
      for (var b in y)
        Object.prototype.hasOwnProperty.call(y, b) && (x[b] = y[b]);
    return x.default = y, x;
  }
  var i = Bt, a = n(i), s = SM, o = r(s), c = ir, f = r(c), u = Ge, l = n(u), p = sn, m = n(p), h = IT, g = r(h);
  function v() {
    var y = new a.HandlebarsEnvironment();
    return l.extend(y, a), y.SafeString = o.default, y.Exception = f.default, y.Utils = l, y.escapeExpression = l.escapeExpression, y.VM = m, y.template = function(x) {
      return m.template(x, y);
    }, y;
  }
  var d = v();
  d.create = v, g.default(d), d.default = d, e.default = d, t.exports = e.default;
})(Am, Am.exports);
var qM = Am.exports, zm = { exports: {} };
(function(t, e) {
  e.__esModule = !0;
  var r = {
    // Public API used to evaluate derived attributes regarding AST nodes
    helpers: {
      // a mustache is definitely a helper if:
      // * it is an eligible helper, and
      // * it has at least one parameter or hash segment
      helperExpression: function(i) {
        return i.type === "SubExpression" || (i.type === "MustacheStatement" || i.type === "BlockStatement") && !!(i.params && i.params.length || i.hash);
      },
      scopedId: function(i) {
        return /^\.|this\b/.test(i.original);
      },
      // an ID is simple if it only has one part, and that part is not
      // `..` or `this`.
      simpleId: function(i) {
        return i.parts.length === 1 && !r.helpers.scopedId(i) && !i.depth;
      }
    }
  };
  e.default = r, t.exports = e.default;
})(zm, zm.exports);
var kT = zm.exports, cs = {}, Hm = { exports: {} };
(function(t, e) {
  e.__esModule = !0;
  var r = function() {
    var n = {
      trace: function() {
      },
      yy: {},
      symbols_: { error: 2, root: 3, program: 4, EOF: 5, program_repetition0: 6, statement: 7, mustache: 8, block: 9, rawBlock: 10, partial: 11, partialBlock: 12, content: 13, COMMENT: 14, CONTENT: 15, openRawBlock: 16, rawBlock_repetition0: 17, END_RAW_BLOCK: 18, OPEN_RAW_BLOCK: 19, helperName: 20, openRawBlock_repetition0: 21, openRawBlock_option0: 22, CLOSE_RAW_BLOCK: 23, openBlock: 24, block_option0: 25, closeBlock: 26, openInverse: 27, block_option1: 28, OPEN_BLOCK: 29, openBlock_repetition0: 30, openBlock_option0: 31, openBlock_option1: 32, CLOSE: 33, OPEN_INVERSE: 34, openInverse_repetition0: 35, openInverse_option0: 36, openInverse_option1: 37, openInverseChain: 38, OPEN_INVERSE_CHAIN: 39, openInverseChain_repetition0: 40, openInverseChain_option0: 41, openInverseChain_option1: 42, inverseAndProgram: 43, INVERSE: 44, inverseChain: 45, inverseChain_option0: 46, OPEN_ENDBLOCK: 47, OPEN: 48, mustache_repetition0: 49, mustache_option0: 50, OPEN_UNESCAPED: 51, mustache_repetition1: 52, mustache_option1: 53, CLOSE_UNESCAPED: 54, OPEN_PARTIAL: 55, partialName: 56, partial_repetition0: 57, partial_option0: 58, openPartialBlock: 59, OPEN_PARTIAL_BLOCK: 60, openPartialBlock_repetition0: 61, openPartialBlock_option0: 62, param: 63, sexpr: 64, OPEN_SEXPR: 65, sexpr_repetition0: 66, sexpr_option0: 67, CLOSE_SEXPR: 68, hash: 69, hash_repetition_plus0: 70, hashSegment: 71, ID: 72, EQUALS: 73, blockParams: 74, OPEN_BLOCK_PARAMS: 75, blockParams_repetition_plus0: 76, CLOSE_BLOCK_PARAMS: 77, path: 78, dataName: 79, STRING: 80, NUMBER: 81, BOOLEAN: 82, UNDEFINED: 83, NULL: 84, DATA: 85, pathSegments: 86, SEP: 87, $accept: 0, $end: 1 },
      terminals_: { 2: "error", 5: "EOF", 14: "COMMENT", 15: "CONTENT", 18: "END_RAW_BLOCK", 19: "OPEN_RAW_BLOCK", 23: "CLOSE_RAW_BLOCK", 29: "OPEN_BLOCK", 33: "CLOSE", 34: "OPEN_INVERSE", 39: "OPEN_INVERSE_CHAIN", 44: "INVERSE", 47: "OPEN_ENDBLOCK", 48: "OPEN", 51: "OPEN_UNESCAPED", 54: "CLOSE_UNESCAPED", 55: "OPEN_PARTIAL", 60: "OPEN_PARTIAL_BLOCK", 65: "OPEN_SEXPR", 68: "CLOSE_SEXPR", 72: "ID", 73: "EQUALS", 75: "OPEN_BLOCK_PARAMS", 77: "CLOSE_BLOCK_PARAMS", 80: "STRING", 81: "NUMBER", 82: "BOOLEAN", 83: "UNDEFINED", 84: "NULL", 85: "DATA", 87: "SEP" },
      productions_: [0, [3, 2], [4, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [13, 1], [10, 3], [16, 5], [9, 4], [9, 4], [24, 6], [27, 6], [38, 6], [43, 2], [45, 3], [45, 1], [26, 3], [8, 5], [8, 5], [11, 5], [12, 3], [59, 5], [63, 1], [63, 1], [64, 5], [69, 1], [71, 3], [74, 3], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [56, 1], [56, 1], [79, 2], [78, 1], [86, 3], [86, 1], [6, 0], [6, 2], [17, 0], [17, 2], [21, 0], [21, 2], [22, 0], [22, 1], [25, 0], [25, 1], [28, 0], [28, 1], [30, 0], [30, 2], [31, 0], [31, 1], [32, 0], [32, 1], [35, 0], [35, 2], [36, 0], [36, 1], [37, 0], [37, 1], [40, 0], [40, 2], [41, 0], [41, 1], [42, 0], [42, 1], [46, 0], [46, 1], [49, 0], [49, 2], [50, 0], [50, 1], [52, 0], [52, 2], [53, 0], [53, 1], [57, 0], [57, 2], [58, 0], [58, 1], [61, 0], [61, 2], [62, 0], [62, 1], [66, 0], [66, 2], [67, 0], [67, 1], [70, 1], [70, 2], [76, 1], [76, 2]],
      performAction: function(o, c, f, u, l, p, m) {
        var h = p.length - 1;
        switch (l) {
          case 1:
            return p[h - 1];
          case 2:
            this.$ = u.prepareProgram(p[h]);
            break;
          case 3:
            this.$ = p[h];
            break;
          case 4:
            this.$ = p[h];
            break;
          case 5:
            this.$ = p[h];
            break;
          case 6:
            this.$ = p[h];
            break;
          case 7:
            this.$ = p[h];
            break;
          case 8:
            this.$ = p[h];
            break;
          case 9:
            this.$ = {
              type: "CommentStatement",
              value: u.stripComment(p[h]),
              strip: u.stripFlags(p[h], p[h]),
              loc: u.locInfo(this._$)
            };
            break;
          case 10:
            this.$ = {
              type: "ContentStatement",
              original: p[h],
              value: p[h],
              loc: u.locInfo(this._$)
            };
            break;
          case 11:
            this.$ = u.prepareRawBlock(p[h - 2], p[h - 1], p[h], this._$);
            break;
          case 12:
            this.$ = { path: p[h - 3], params: p[h - 2], hash: p[h - 1] };
            break;
          case 13:
            this.$ = u.prepareBlock(p[h - 3], p[h - 2], p[h - 1], p[h], !1, this._$);
            break;
          case 14:
            this.$ = u.prepareBlock(p[h - 3], p[h - 2], p[h - 1], p[h], !0, this._$);
            break;
          case 15:
            this.$ = { open: p[h - 5], path: p[h - 4], params: p[h - 3], hash: p[h - 2], blockParams: p[h - 1], strip: u.stripFlags(p[h - 5], p[h]) };
            break;
          case 16:
            this.$ = { path: p[h - 4], params: p[h - 3], hash: p[h - 2], blockParams: p[h - 1], strip: u.stripFlags(p[h - 5], p[h]) };
            break;
          case 17:
            this.$ = { path: p[h - 4], params: p[h - 3], hash: p[h - 2], blockParams: p[h - 1], strip: u.stripFlags(p[h - 5], p[h]) };
            break;
          case 18:
            this.$ = { strip: u.stripFlags(p[h - 1], p[h - 1]), program: p[h] };
            break;
          case 19:
            var g = u.prepareBlock(p[h - 2], p[h - 1], p[h], p[h], !1, this._$), v = u.prepareProgram([g], p[h - 1].loc);
            v.chained = !0, this.$ = { strip: p[h - 2].strip, program: v, chain: !0 };
            break;
          case 20:
            this.$ = p[h];
            break;
          case 21:
            this.$ = { path: p[h - 1], strip: u.stripFlags(p[h - 2], p[h]) };
            break;
          case 22:
            this.$ = u.prepareMustache(p[h - 3], p[h - 2], p[h - 1], p[h - 4], u.stripFlags(p[h - 4], p[h]), this._$);
            break;
          case 23:
            this.$ = u.prepareMustache(p[h - 3], p[h - 2], p[h - 1], p[h - 4], u.stripFlags(p[h - 4], p[h]), this._$);
            break;
          case 24:
            this.$ = {
              type: "PartialStatement",
              name: p[h - 3],
              params: p[h - 2],
              hash: p[h - 1],
              indent: "",
              strip: u.stripFlags(p[h - 4], p[h]),
              loc: u.locInfo(this._$)
            };
            break;
          case 25:
            this.$ = u.preparePartialBlock(p[h - 2], p[h - 1], p[h], this._$);
            break;
          case 26:
            this.$ = { path: p[h - 3], params: p[h - 2], hash: p[h - 1], strip: u.stripFlags(p[h - 4], p[h]) };
            break;
          case 27:
            this.$ = p[h];
            break;
          case 28:
            this.$ = p[h];
            break;
          case 29:
            this.$ = {
              type: "SubExpression",
              path: p[h - 3],
              params: p[h - 2],
              hash: p[h - 1],
              loc: u.locInfo(this._$)
            };
            break;
          case 30:
            this.$ = { type: "Hash", pairs: p[h], loc: u.locInfo(this._$) };
            break;
          case 31:
            this.$ = { type: "HashPair", key: u.id(p[h - 2]), value: p[h], loc: u.locInfo(this._$) };
            break;
          case 32:
            this.$ = u.id(p[h - 1]);
            break;
          case 33:
            this.$ = p[h];
            break;
          case 34:
            this.$ = p[h];
            break;
          case 35:
            this.$ = { type: "StringLiteral", value: p[h], original: p[h], loc: u.locInfo(this._$) };
            break;
          case 36:
            this.$ = { type: "NumberLiteral", value: Number(p[h]), original: Number(p[h]), loc: u.locInfo(this._$) };
            break;
          case 37:
            this.$ = { type: "BooleanLiteral", value: p[h] === "true", original: p[h] === "true", loc: u.locInfo(this._$) };
            break;
          case 38:
            this.$ = { type: "UndefinedLiteral", original: void 0, value: void 0, loc: u.locInfo(this._$) };
            break;
          case 39:
            this.$ = { type: "NullLiteral", original: null, value: null, loc: u.locInfo(this._$) };
            break;
          case 40:
            this.$ = p[h];
            break;
          case 41:
            this.$ = p[h];
            break;
          case 42:
            this.$ = u.preparePath(!0, p[h], this._$);
            break;
          case 43:
            this.$ = u.preparePath(!1, p[h], this._$);
            break;
          case 44:
            p[h - 2].push({ part: u.id(p[h]), original: p[h], separator: p[h - 1] }), this.$ = p[h - 2];
            break;
          case 45:
            this.$ = [{ part: u.id(p[h]), original: p[h] }];
            break;
          case 46:
            this.$ = [];
            break;
          case 47:
            p[h - 1].push(p[h]);
            break;
          case 48:
            this.$ = [];
            break;
          case 49:
            p[h - 1].push(p[h]);
            break;
          case 50:
            this.$ = [];
            break;
          case 51:
            p[h - 1].push(p[h]);
            break;
          case 58:
            this.$ = [];
            break;
          case 59:
            p[h - 1].push(p[h]);
            break;
          case 64:
            this.$ = [];
            break;
          case 65:
            p[h - 1].push(p[h]);
            break;
          case 70:
            this.$ = [];
            break;
          case 71:
            p[h - 1].push(p[h]);
            break;
          case 78:
            this.$ = [];
            break;
          case 79:
            p[h - 1].push(p[h]);
            break;
          case 82:
            this.$ = [];
            break;
          case 83:
            p[h - 1].push(p[h]);
            break;
          case 86:
            this.$ = [];
            break;
          case 87:
            p[h - 1].push(p[h]);
            break;
          case 90:
            this.$ = [];
            break;
          case 91:
            p[h - 1].push(p[h]);
            break;
          case 94:
            this.$ = [];
            break;
          case 95:
            p[h - 1].push(p[h]);
            break;
          case 98:
            this.$ = [p[h]];
            break;
          case 99:
            p[h - 1].push(p[h]);
            break;
          case 100:
            this.$ = [p[h]];
            break;
          case 101:
            p[h - 1].push(p[h]);
            break;
        }
      },
      table: [{ 3: 1, 4: 2, 5: [2, 46], 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 1: [3] }, { 5: [1, 4] }, { 5: [2, 2], 7: 5, 8: 6, 9: 7, 10: 8, 11: 9, 12: 10, 13: 11, 14: [1, 12], 15: [1, 20], 16: 17, 19: [1, 23], 24: 15, 27: 16, 29: [1, 21], 34: [1, 22], 39: [2, 2], 44: [2, 2], 47: [2, 2], 48: [1, 13], 51: [1, 14], 55: [1, 18], 59: 19, 60: [1, 24] }, { 1: [2, 1] }, { 5: [2, 47], 14: [2, 47], 15: [2, 47], 19: [2, 47], 29: [2, 47], 34: [2, 47], 39: [2, 47], 44: [2, 47], 47: [2, 47], 48: [2, 47], 51: [2, 47], 55: [2, 47], 60: [2, 47] }, { 5: [2, 3], 14: [2, 3], 15: [2, 3], 19: [2, 3], 29: [2, 3], 34: [2, 3], 39: [2, 3], 44: [2, 3], 47: [2, 3], 48: [2, 3], 51: [2, 3], 55: [2, 3], 60: [2, 3] }, { 5: [2, 4], 14: [2, 4], 15: [2, 4], 19: [2, 4], 29: [2, 4], 34: [2, 4], 39: [2, 4], 44: [2, 4], 47: [2, 4], 48: [2, 4], 51: [2, 4], 55: [2, 4], 60: [2, 4] }, { 5: [2, 5], 14: [2, 5], 15: [2, 5], 19: [2, 5], 29: [2, 5], 34: [2, 5], 39: [2, 5], 44: [2, 5], 47: [2, 5], 48: [2, 5], 51: [2, 5], 55: [2, 5], 60: [2, 5] }, { 5: [2, 6], 14: [2, 6], 15: [2, 6], 19: [2, 6], 29: [2, 6], 34: [2, 6], 39: [2, 6], 44: [2, 6], 47: [2, 6], 48: [2, 6], 51: [2, 6], 55: [2, 6], 60: [2, 6] }, { 5: [2, 7], 14: [2, 7], 15: [2, 7], 19: [2, 7], 29: [2, 7], 34: [2, 7], 39: [2, 7], 44: [2, 7], 47: [2, 7], 48: [2, 7], 51: [2, 7], 55: [2, 7], 60: [2, 7] }, { 5: [2, 8], 14: [2, 8], 15: [2, 8], 19: [2, 8], 29: [2, 8], 34: [2, 8], 39: [2, 8], 44: [2, 8], 47: [2, 8], 48: [2, 8], 51: [2, 8], 55: [2, 8], 60: [2, 8] }, { 5: [2, 9], 14: [2, 9], 15: [2, 9], 19: [2, 9], 29: [2, 9], 34: [2, 9], 39: [2, 9], 44: [2, 9], 47: [2, 9], 48: [2, 9], 51: [2, 9], 55: [2, 9], 60: [2, 9] }, { 20: 25, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 36, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 37, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 4: 38, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 15: [2, 48], 17: 39, 18: [2, 48] }, { 20: 41, 56: 40, 64: 42, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 44, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 5: [2, 10], 14: [2, 10], 15: [2, 10], 18: [2, 10], 19: [2, 10], 29: [2, 10], 34: [2, 10], 39: [2, 10], 44: [2, 10], 47: [2, 10], 48: [2, 10], 51: [2, 10], 55: [2, 10], 60: [2, 10] }, { 20: 45, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 46, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 47, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 41, 56: 48, 64: 42, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [2, 78], 49: 49, 65: [2, 78], 72: [2, 78], 80: [2, 78], 81: [2, 78], 82: [2, 78], 83: [2, 78], 84: [2, 78], 85: [2, 78] }, { 23: [2, 33], 33: [2, 33], 54: [2, 33], 65: [2, 33], 68: [2, 33], 72: [2, 33], 75: [2, 33], 80: [2, 33], 81: [2, 33], 82: [2, 33], 83: [2, 33], 84: [2, 33], 85: [2, 33] }, { 23: [2, 34], 33: [2, 34], 54: [2, 34], 65: [2, 34], 68: [2, 34], 72: [2, 34], 75: [2, 34], 80: [2, 34], 81: [2, 34], 82: [2, 34], 83: [2, 34], 84: [2, 34], 85: [2, 34] }, { 23: [2, 35], 33: [2, 35], 54: [2, 35], 65: [2, 35], 68: [2, 35], 72: [2, 35], 75: [2, 35], 80: [2, 35], 81: [2, 35], 82: [2, 35], 83: [2, 35], 84: [2, 35], 85: [2, 35] }, { 23: [2, 36], 33: [2, 36], 54: [2, 36], 65: [2, 36], 68: [2, 36], 72: [2, 36], 75: [2, 36], 80: [2, 36], 81: [2, 36], 82: [2, 36], 83: [2, 36], 84: [2, 36], 85: [2, 36] }, { 23: [2, 37], 33: [2, 37], 54: [2, 37], 65: [2, 37], 68: [2, 37], 72: [2, 37], 75: [2, 37], 80: [2, 37], 81: [2, 37], 82: [2, 37], 83: [2, 37], 84: [2, 37], 85: [2, 37] }, { 23: [2, 38], 33: [2, 38], 54: [2, 38], 65: [2, 38], 68: [2, 38], 72: [2, 38], 75: [2, 38], 80: [2, 38], 81: [2, 38], 82: [2, 38], 83: [2, 38], 84: [2, 38], 85: [2, 38] }, { 23: [2, 39], 33: [2, 39], 54: [2, 39], 65: [2, 39], 68: [2, 39], 72: [2, 39], 75: [2, 39], 80: [2, 39], 81: [2, 39], 82: [2, 39], 83: [2, 39], 84: [2, 39], 85: [2, 39] }, { 23: [2, 43], 33: [2, 43], 54: [2, 43], 65: [2, 43], 68: [2, 43], 72: [2, 43], 75: [2, 43], 80: [2, 43], 81: [2, 43], 82: [2, 43], 83: [2, 43], 84: [2, 43], 85: [2, 43], 87: [1, 50] }, { 72: [1, 35], 86: 51 }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 52: 52, 54: [2, 82], 65: [2, 82], 72: [2, 82], 80: [2, 82], 81: [2, 82], 82: [2, 82], 83: [2, 82], 84: [2, 82], 85: [2, 82] }, { 25: 53, 38: 55, 39: [1, 57], 43: 56, 44: [1, 58], 45: 54, 47: [2, 54] }, { 28: 59, 43: 60, 44: [1, 58], 47: [2, 56] }, { 13: 62, 15: [1, 20], 18: [1, 61] }, { 33: [2, 86], 57: 63, 65: [2, 86], 72: [2, 86], 80: [2, 86], 81: [2, 86], 82: [2, 86], 83: [2, 86], 84: [2, 86], 85: [2, 86] }, { 33: [2, 40], 65: [2, 40], 72: [2, 40], 80: [2, 40], 81: [2, 40], 82: [2, 40], 83: [2, 40], 84: [2, 40], 85: [2, 40] }, { 33: [2, 41], 65: [2, 41], 72: [2, 41], 80: [2, 41], 81: [2, 41], 82: [2, 41], 83: [2, 41], 84: [2, 41], 85: [2, 41] }, { 20: 64, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 65, 47: [1, 66] }, { 30: 67, 33: [2, 58], 65: [2, 58], 72: [2, 58], 75: [2, 58], 80: [2, 58], 81: [2, 58], 82: [2, 58], 83: [2, 58], 84: [2, 58], 85: [2, 58] }, { 33: [2, 64], 35: 68, 65: [2, 64], 72: [2, 64], 75: [2, 64], 80: [2, 64], 81: [2, 64], 82: [2, 64], 83: [2, 64], 84: [2, 64], 85: [2, 64] }, { 21: 69, 23: [2, 50], 65: [2, 50], 72: [2, 50], 80: [2, 50], 81: [2, 50], 82: [2, 50], 83: [2, 50], 84: [2, 50], 85: [2, 50] }, { 33: [2, 90], 61: 70, 65: [2, 90], 72: [2, 90], 80: [2, 90], 81: [2, 90], 82: [2, 90], 83: [2, 90], 84: [2, 90], 85: [2, 90] }, { 20: 74, 33: [2, 80], 50: 71, 63: 72, 64: 75, 65: [1, 43], 69: 73, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 72: [1, 79] }, { 23: [2, 42], 33: [2, 42], 54: [2, 42], 65: [2, 42], 68: [2, 42], 72: [2, 42], 75: [2, 42], 80: [2, 42], 81: [2, 42], 82: [2, 42], 83: [2, 42], 84: [2, 42], 85: [2, 42], 87: [1, 50] }, { 20: 74, 53: 80, 54: [2, 84], 63: 81, 64: 75, 65: [1, 43], 69: 82, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 83, 47: [1, 66] }, { 47: [2, 55] }, { 4: 84, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 47: [2, 20] }, { 20: 85, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 86, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 26: 87, 47: [1, 66] }, { 47: [2, 57] }, { 5: [2, 11], 14: [2, 11], 15: [2, 11], 19: [2, 11], 29: [2, 11], 34: [2, 11], 39: [2, 11], 44: [2, 11], 47: [2, 11], 48: [2, 11], 51: [2, 11], 55: [2, 11], 60: [2, 11] }, { 15: [2, 49], 18: [2, 49] }, { 20: 74, 33: [2, 88], 58: 88, 63: 89, 64: 75, 65: [1, 43], 69: 90, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 65: [2, 94], 66: 91, 68: [2, 94], 72: [2, 94], 80: [2, 94], 81: [2, 94], 82: [2, 94], 83: [2, 94], 84: [2, 94], 85: [2, 94] }, { 5: [2, 25], 14: [2, 25], 15: [2, 25], 19: [2, 25], 29: [2, 25], 34: [2, 25], 39: [2, 25], 44: [2, 25], 47: [2, 25], 48: [2, 25], 51: [2, 25], 55: [2, 25], 60: [2, 25] }, { 20: 92, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 31: 93, 33: [2, 60], 63: 94, 64: 75, 65: [1, 43], 69: 95, 70: 76, 71: 77, 72: [1, 78], 75: [2, 60], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 33: [2, 66], 36: 96, 63: 97, 64: 75, 65: [1, 43], 69: 98, 70: 76, 71: 77, 72: [1, 78], 75: [2, 66], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 22: 99, 23: [2, 52], 63: 100, 64: 75, 65: [1, 43], 69: 101, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 33: [2, 92], 62: 102, 63: 103, 64: 75, 65: [1, 43], 69: 104, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 105] }, { 33: [2, 79], 65: [2, 79], 72: [2, 79], 80: [2, 79], 81: [2, 79], 82: [2, 79], 83: [2, 79], 84: [2, 79], 85: [2, 79] }, { 33: [2, 81] }, { 23: [2, 27], 33: [2, 27], 54: [2, 27], 65: [2, 27], 68: [2, 27], 72: [2, 27], 75: [2, 27], 80: [2, 27], 81: [2, 27], 82: [2, 27], 83: [2, 27], 84: [2, 27], 85: [2, 27] }, { 23: [2, 28], 33: [2, 28], 54: [2, 28], 65: [2, 28], 68: [2, 28], 72: [2, 28], 75: [2, 28], 80: [2, 28], 81: [2, 28], 82: [2, 28], 83: [2, 28], 84: [2, 28], 85: [2, 28] }, { 23: [2, 30], 33: [2, 30], 54: [2, 30], 68: [2, 30], 71: 106, 72: [1, 107], 75: [2, 30] }, { 23: [2, 98], 33: [2, 98], 54: [2, 98], 68: [2, 98], 72: [2, 98], 75: [2, 98] }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 73: [1, 108], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 23: [2, 44], 33: [2, 44], 54: [2, 44], 65: [2, 44], 68: [2, 44], 72: [2, 44], 75: [2, 44], 80: [2, 44], 81: [2, 44], 82: [2, 44], 83: [2, 44], 84: [2, 44], 85: [2, 44], 87: [2, 44] }, { 54: [1, 109] }, { 54: [2, 83], 65: [2, 83], 72: [2, 83], 80: [2, 83], 81: [2, 83], 82: [2, 83], 83: [2, 83], 84: [2, 83], 85: [2, 83] }, { 54: [2, 85] }, { 5: [2, 13], 14: [2, 13], 15: [2, 13], 19: [2, 13], 29: [2, 13], 34: [2, 13], 39: [2, 13], 44: [2, 13], 47: [2, 13], 48: [2, 13], 51: [2, 13], 55: [2, 13], 60: [2, 13] }, { 38: 55, 39: [1, 57], 43: 56, 44: [1, 58], 45: 111, 46: 110, 47: [2, 76] }, { 33: [2, 70], 40: 112, 65: [2, 70], 72: [2, 70], 75: [2, 70], 80: [2, 70], 81: [2, 70], 82: [2, 70], 83: [2, 70], 84: [2, 70], 85: [2, 70] }, { 47: [2, 18] }, { 5: [2, 14], 14: [2, 14], 15: [2, 14], 19: [2, 14], 29: [2, 14], 34: [2, 14], 39: [2, 14], 44: [2, 14], 47: [2, 14], 48: [2, 14], 51: [2, 14], 55: [2, 14], 60: [2, 14] }, { 33: [1, 113] }, { 33: [2, 87], 65: [2, 87], 72: [2, 87], 80: [2, 87], 81: [2, 87], 82: [2, 87], 83: [2, 87], 84: [2, 87], 85: [2, 87] }, { 33: [2, 89] }, { 20: 74, 63: 115, 64: 75, 65: [1, 43], 67: 114, 68: [2, 96], 69: 116, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 117] }, { 32: 118, 33: [2, 62], 74: 119, 75: [1, 120] }, { 33: [2, 59], 65: [2, 59], 72: [2, 59], 75: [2, 59], 80: [2, 59], 81: [2, 59], 82: [2, 59], 83: [2, 59], 84: [2, 59], 85: [2, 59] }, { 33: [2, 61], 75: [2, 61] }, { 33: [2, 68], 37: 121, 74: 122, 75: [1, 120] }, { 33: [2, 65], 65: [2, 65], 72: [2, 65], 75: [2, 65], 80: [2, 65], 81: [2, 65], 82: [2, 65], 83: [2, 65], 84: [2, 65], 85: [2, 65] }, { 33: [2, 67], 75: [2, 67] }, { 23: [1, 123] }, { 23: [2, 51], 65: [2, 51], 72: [2, 51], 80: [2, 51], 81: [2, 51], 82: [2, 51], 83: [2, 51], 84: [2, 51], 85: [2, 51] }, { 23: [2, 53] }, { 33: [1, 124] }, { 33: [2, 91], 65: [2, 91], 72: [2, 91], 80: [2, 91], 81: [2, 91], 82: [2, 91], 83: [2, 91], 84: [2, 91], 85: [2, 91] }, { 33: [2, 93] }, { 5: [2, 22], 14: [2, 22], 15: [2, 22], 19: [2, 22], 29: [2, 22], 34: [2, 22], 39: [2, 22], 44: [2, 22], 47: [2, 22], 48: [2, 22], 51: [2, 22], 55: [2, 22], 60: [2, 22] }, { 23: [2, 99], 33: [2, 99], 54: [2, 99], 68: [2, 99], 72: [2, 99], 75: [2, 99] }, { 73: [1, 108] }, { 20: 74, 63: 125, 64: 75, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 23], 14: [2, 23], 15: [2, 23], 19: [2, 23], 29: [2, 23], 34: [2, 23], 39: [2, 23], 44: [2, 23], 47: [2, 23], 48: [2, 23], 51: [2, 23], 55: [2, 23], 60: [2, 23] }, { 47: [2, 19] }, { 47: [2, 77] }, { 20: 74, 33: [2, 72], 41: 126, 63: 127, 64: 75, 65: [1, 43], 69: 128, 70: 76, 71: 77, 72: [1, 78], 75: [2, 72], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 24], 14: [2, 24], 15: [2, 24], 19: [2, 24], 29: [2, 24], 34: [2, 24], 39: [2, 24], 44: [2, 24], 47: [2, 24], 48: [2, 24], 51: [2, 24], 55: [2, 24], 60: [2, 24] }, { 68: [1, 129] }, { 65: [2, 95], 68: [2, 95], 72: [2, 95], 80: [2, 95], 81: [2, 95], 82: [2, 95], 83: [2, 95], 84: [2, 95], 85: [2, 95] }, { 68: [2, 97] }, { 5: [2, 21], 14: [2, 21], 15: [2, 21], 19: [2, 21], 29: [2, 21], 34: [2, 21], 39: [2, 21], 44: [2, 21], 47: [2, 21], 48: [2, 21], 51: [2, 21], 55: [2, 21], 60: [2, 21] }, { 33: [1, 130] }, { 33: [2, 63] }, { 72: [1, 132], 76: 131 }, { 33: [1, 133] }, { 33: [2, 69] }, { 15: [2, 12], 18: [2, 12] }, { 14: [2, 26], 15: [2, 26], 19: [2, 26], 29: [2, 26], 34: [2, 26], 47: [2, 26], 48: [2, 26], 51: [2, 26], 55: [2, 26], 60: [2, 26] }, { 23: [2, 31], 33: [2, 31], 54: [2, 31], 68: [2, 31], 72: [2, 31], 75: [2, 31] }, { 33: [2, 74], 42: 134, 74: 135, 75: [1, 120] }, { 33: [2, 71], 65: [2, 71], 72: [2, 71], 75: [2, 71], 80: [2, 71], 81: [2, 71], 82: [2, 71], 83: [2, 71], 84: [2, 71], 85: [2, 71] }, { 33: [2, 73], 75: [2, 73] }, { 23: [2, 29], 33: [2, 29], 54: [2, 29], 65: [2, 29], 68: [2, 29], 72: [2, 29], 75: [2, 29], 80: [2, 29], 81: [2, 29], 82: [2, 29], 83: [2, 29], 84: [2, 29], 85: [2, 29] }, { 14: [2, 15], 15: [2, 15], 19: [2, 15], 29: [2, 15], 34: [2, 15], 39: [2, 15], 44: [2, 15], 47: [2, 15], 48: [2, 15], 51: [2, 15], 55: [2, 15], 60: [2, 15] }, { 72: [1, 137], 77: [1, 136] }, { 72: [2, 100], 77: [2, 100] }, { 14: [2, 16], 15: [2, 16], 19: [2, 16], 29: [2, 16], 34: [2, 16], 44: [2, 16], 47: [2, 16], 48: [2, 16], 51: [2, 16], 55: [2, 16], 60: [2, 16] }, { 33: [1, 138] }, { 33: [2, 75] }, { 33: [2, 32] }, { 72: [2, 101], 77: [2, 101] }, { 14: [2, 17], 15: [2, 17], 19: [2, 17], 29: [2, 17], 34: [2, 17], 39: [2, 17], 44: [2, 17], 47: [2, 17], 48: [2, 17], 51: [2, 17], 55: [2, 17], 60: [2, 17] }],
      defaultActions: { 4: [2, 1], 54: [2, 55], 56: [2, 20], 60: [2, 57], 73: [2, 81], 82: [2, 85], 86: [2, 18], 90: [2, 89], 101: [2, 53], 104: [2, 93], 110: [2, 19], 111: [2, 77], 116: [2, 97], 119: [2, 63], 122: [2, 69], 135: [2, 75], 136: [2, 32] },
      parseError: function(o, c) {
        throw new Error(o);
      },
      parse: function(o) {
        var c = this, f = [0], u = [null], l = [], p = this.table, m = "", h = 0, g = 0;
        this.lexer.setInput(o), this.lexer.yy = this.yy, this.yy.lexer = this.lexer, this.yy.parser = this, typeof this.lexer.yylloc > "u" && (this.lexer.yylloc = {});
        var v = this.lexer.yylloc;
        l.push(v);
        var d = this.lexer.options && this.lexer.options.ranges;
        typeof this.yy.parseError == "function" && (this.parseError = this.yy.parseError);
        function y() {
          var F;
          return F = c.lexer.lex() || 1, typeof F != "number" && (F = c.symbols_[F] || F), F;
        }
        for (var x, b, w, S, T = {}, E, C, A, R; ; ) {
          if (b = f[f.length - 1], this.defaultActions[b] ? w = this.defaultActions[b] : ((x === null || typeof x > "u") && (x = y()), w = p[b] && p[b][x]), typeof w > "u" || !w.length || !w[0]) {
            var D = "";
            {
              R = [];
              for (E in p[b])
                this.terminals_[E] && E > 2 && R.push("'" + this.terminals_[E] + "'");
              this.lexer.showPosition ? D = "Parse error on line " + (h + 1) + `:
` + this.lexer.showPosition() + `
Expecting ` + R.join(", ") + ", got '" + (this.terminals_[x] || x) + "'" : D = "Parse error on line " + (h + 1) + ": Unexpected " + (x == 1 ? "end of input" : "'" + (this.terminals_[x] || x) + "'"), this.parseError(D, { text: this.lexer.match, token: this.terminals_[x] || x, line: this.lexer.yylineno, loc: v, expected: R });
            }
          }
          if (w[0] instanceof Array && w.length > 1)
            throw new Error("Parse Error: multiple actions possible at state: " + b + ", token: " + x);
          switch (w[0]) {
            case 1:
              f.push(x), u.push(this.lexer.yytext), l.push(this.lexer.yylloc), f.push(w[1]), x = null, g = this.lexer.yyleng, m = this.lexer.yytext, h = this.lexer.yylineno, v = this.lexer.yylloc;
              break;
            case 2:
              if (C = this.productions_[w[1]][1], T.$ = u[u.length - C], T._$ = { first_line: l[l.length - (C || 1)].first_line, last_line: l[l.length - 1].last_line, first_column: l[l.length - (C || 1)].first_column, last_column: l[l.length - 1].last_column }, d && (T._$.range = [l[l.length - (C || 1)].range[0], l[l.length - 1].range[1]]), S = this.performAction.call(T, m, g, h, this.yy, w[1], u, l), typeof S < "u")
                return S;
              C && (f = f.slice(0, -1 * C * 2), u = u.slice(0, -1 * C), l = l.slice(0, -1 * C)), f.push(this.productions_[w[1]][0]), u.push(T.$), l.push(T._$), A = p[f[f.length - 2]][f[f.length - 1]], f.push(A);
              break;
            case 3:
              return !0;
          }
        }
        return !0;
      }
    }, i = function() {
      var s = {
        EOF: 1,
        parseError: function(c, f) {
          if (this.yy.parser)
            this.yy.parser.parseError(c, f);
          else
            throw new Error(c);
        },
        setInput: function(c) {
          return this._input = c, this._more = this._less = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
        },
        input: function() {
          var c = this._input[0];
          this.yytext += c, this.yyleng++, this.offset++, this.match += c, this.matched += c;
          var f = c.match(/(?:\r\n?|\n).*/g);
          return f ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), c;
        },
        unput: function(c) {
          var f = c.length, u = c.split(/(?:\r\n?|\n)/g);
          this._input = c + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - f - 1), this.offset -= f;
          var l = this.match.split(/(?:\r\n?|\n)/g);
          this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), u.length - 1 && (this.yylineno -= u.length - 1);
          var p = this.yylloc.range;
          return this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: u ? (u.length === l.length ? this.yylloc.first_column : 0) + l[l.length - u.length].length - u[0].length : this.yylloc.first_column - f
          }, this.options.ranges && (this.yylloc.range = [p[0], p[0] + this.yyleng - f]), this;
        },
        more: function() {
          return this._more = !0, this;
        },
        less: function(c) {
          this.unput(this.match.slice(c));
        },
        pastInput: function() {
          var c = this.matched.substr(0, this.matched.length - this.match.length);
          return (c.length > 20 ? "..." : "") + c.substr(-20).replace(/\n/g, "");
        },
        upcomingInput: function() {
          var c = this.match;
          return c.length < 20 && (c += this._input.substr(0, 20 - c.length)), (c.substr(0, 20) + (c.length > 20 ? "..." : "")).replace(/\n/g, "");
        },
        showPosition: function() {
          var c = this.pastInput(), f = new Array(c.length + 1).join("-");
          return c + this.upcomingInput() + `
` + f + "^";
        },
        next: function() {
          if (this.done)
            return this.EOF;
          this._input || (this.done = !0);
          var c, f, u, l, p;
          this._more || (this.yytext = "", this.match = "");
          for (var m = this._currentRules(), h = 0; h < m.length && (u = this._input.match(this.rules[m[h]]), !(u && (!f || u[0].length > f[0].length) && (f = u, l = h, !this.options.flex))); h++)
            ;
          return f ? (p = f[0].match(/(?:\r\n?|\n).*/g), p && (this.yylineno += p.length), this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: p ? p[p.length - 1].length - p[p.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + f[0].length
          }, this.yytext += f[0], this.match += f[0], this.matches = f, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._input = this._input.slice(f[0].length), this.matched += f[0], c = this.performAction.call(this, this.yy, this, m[l], this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), c || void 0) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), { text: "", token: null, line: this.yylineno });
        },
        lex: function() {
          var c = this.next();
          return typeof c < "u" ? c : this.lex();
        },
        begin: function(c) {
          this.conditionStack.push(c);
        },
        popState: function() {
          return this.conditionStack.pop();
        },
        _currentRules: function() {
          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        },
        topState: function() {
          return this.conditionStack[this.conditionStack.length - 2];
        },
        pushState: function(c) {
          this.begin(c);
        }
      };
      return s.options = {}, s.performAction = function(c, f, u, l) {
        function p(m, h) {
          return f.yytext = f.yytext.substring(m, f.yyleng - h + m);
        }
        switch (u) {
          case 0:
            if (f.yytext.slice(-2) === "\\\\" ? (p(0, 1), this.begin("mu")) : f.yytext.slice(-1) === "\\" ? (p(0, 1), this.begin("emu")) : this.begin("mu"), f.yytext)
              return 15;
            break;
          case 1:
            return 15;
          case 2:
            return this.popState(), 15;
          case 3:
            return this.begin("raw"), 15;
          case 4:
            return this.popState(), this.conditionStack[this.conditionStack.length - 1] === "raw" ? 15 : (p(5, 9), "END_RAW_BLOCK");
          case 5:
            return 15;
          case 6:
            return this.popState(), 14;
          case 7:
            return 65;
          case 8:
            return 68;
          case 9:
            return 19;
          case 10:
            return this.popState(), this.begin("raw"), 23;
          case 11:
            return 55;
          case 12:
            return 60;
          case 13:
            return 29;
          case 14:
            return 47;
          case 15:
            return this.popState(), 44;
          case 16:
            return this.popState(), 44;
          case 17:
            return 34;
          case 18:
            return 39;
          case 19:
            return 51;
          case 20:
            return 48;
          case 21:
            this.unput(f.yytext), this.popState(), this.begin("com");
            break;
          case 22:
            return this.popState(), 14;
          case 23:
            return 48;
          case 24:
            return 73;
          case 25:
            return 72;
          case 26:
            return 72;
          case 27:
            return 87;
          case 28:
            break;
          case 29:
            return this.popState(), 54;
          case 30:
            return this.popState(), 33;
          case 31:
            return f.yytext = p(1, 2).replace(/\\"/g, '"'), 80;
          case 32:
            return f.yytext = p(1, 2).replace(/\\'/g, "'"), 80;
          case 33:
            return 85;
          case 34:
            return 82;
          case 35:
            return 82;
          case 36:
            return 83;
          case 37:
            return 84;
          case 38:
            return 81;
          case 39:
            return 75;
          case 40:
            return 77;
          case 41:
            return 72;
          case 42:
            return f.yytext = f.yytext.replace(/\\([\\\]])/g, "$1"), 72;
          case 43:
            return "INVALID";
          case 44:
            return 5;
        }
      }, s.rules = [/^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/, /^(?:\{\{\{\{(?=[^\/]))/, /^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/, /^(?:[^\x00]+?(?=(\{\{\{\{)))/, /^(?:[\s\S]*?--(~)?\}\})/, /^(?:\()/, /^(?:\))/, /^(?:\{\{\{\{)/, /^(?:\}\}\}\})/, /^(?:\{\{(~)?>)/, /^(?:\{\{(~)?#>)/, /^(?:\{\{(~)?#\*?)/, /^(?:\{\{(~)?\/)/, /^(?:\{\{(~)?\^\s*(~)?\}\})/, /^(?:\{\{(~)?\s*else\s*(~)?\}\})/, /^(?:\{\{(~)?\^)/, /^(?:\{\{(~)?\s*else\b)/, /^(?:\{\{(~)?\{)/, /^(?:\{\{(~)?&)/, /^(?:\{\{(~)?!--)/, /^(?:\{\{(~)?![\s\S]*?\}\})/, /^(?:\{\{(~)?\*?)/, /^(?:=)/, /^(?:\.\.)/, /^(?:\.(?=([=~}\s\/.)|])))/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}(~)?\}\})/, /^(?:(~)?\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\s)])))/, /^(?:false(?=([~}\s)])))/, /^(?:undefined(?=([~}\s)])))/, /^(?:null(?=([~}\s)])))/, /^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/, /^(?:as\s+\|)/, /^(?:\|)/, /^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)|]))))/, /^(?:\[(\\\]|[^\]])*\])/, /^(?:.)/, /^(?:$)/], s.conditions = { mu: { rules: [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44], inclusive: !1 }, emu: { rules: [2], inclusive: !1 }, com: { rules: [6], inclusive: !1 }, raw: { rules: [3, 4, 5], inclusive: !1 }, INITIAL: { rules: [0, 1, 44], inclusive: !0 } }, s;
    }();
    n.lexer = i;
    function a() {
      this.yy = {};
    }
    return a.prototype = n, n.Parser = a, new a();
  }();
  e.default = r, t.exports = e.default;
})(Hm, Hm.exports);
var jM = Hm.exports, Wm = { exports: {} }, Gm = { exports: {} };
(function(t, e) {
  e.__esModule = !0;
  function r(f) {
    return f && f.__esModule ? f : { default: f };
  }
  var n = ir, i = r(n);
  function a() {
    this.parents = [];
  }
  a.prototype = {
    constructor: a,
    mutating: !1,
    // Visits a given value. If mutating, will replace the value if necessary.
    acceptKey: function(u, l) {
      var p = this.accept(u[l]);
      if (this.mutating) {
        if (p && !a.prototype[p.type])
          throw new i.default('Unexpected node type "' + p.type + '" found when accepting ' + l + " on " + u.type);
        u[l] = p;
      }
    },
    // Performs an accept operation with added sanity check to ensure
    // required keys are not removed.
    acceptRequired: function(u, l) {
      if (this.acceptKey(u, l), !u[l])
        throw new i.default(u.type + " requires " + l);
    },
    // Traverses a given array. If mutating, empty respnses will be removed
    // for child elements.
    acceptArray: function(u) {
      for (var l = 0, p = u.length; l < p; l++)
        this.acceptKey(u, l), u[l] || (u.splice(l, 1), l--, p--);
    },
    accept: function(u) {
      if (u) {
        if (!this[u.type])
          throw new i.default("Unknown type: " + u.type, u);
        this.current && this.parents.unshift(this.current), this.current = u;
        var l = this[u.type](u);
        if (this.current = this.parents.shift(), !this.mutating || l)
          return l;
        if (l !== !1)
          return u;
      }
    },
    Program: function(u) {
      this.acceptArray(u.body);
    },
    MustacheStatement: s,
    Decorator: s,
    BlockStatement: o,
    DecoratorBlock: o,
    PartialStatement: c,
    PartialBlockStatement: function(u) {
      c.call(this, u), this.acceptKey(u, "program");
    },
    ContentStatement: function() {
    },
    CommentStatement: function() {
    },
    SubExpression: s,
    PathExpression: function() {
    },
    StringLiteral: function() {
    },
    NumberLiteral: function() {
    },
    BooleanLiteral: function() {
    },
    UndefinedLiteral: function() {
    },
    NullLiteral: function() {
    },
    Hash: function(u) {
      this.acceptArray(u.pairs);
    },
    HashPair: function(u) {
      this.acceptRequired(u, "value");
    }
  };
  function s(f) {
    this.acceptRequired(f, "path"), this.acceptArray(f.params), this.acceptKey(f, "hash");
  }
  function o(f) {
    s.call(this, f), this.acceptKey(f, "program"), this.acceptKey(f, "inverse");
  }
  function c(f) {
    this.acceptRequired(f, "name"), this.acceptArray(f.params), this.acceptKey(f, "hash");
  }
  e.default = a, t.exports = e.default;
})(Gm, Gm.exports);
var RT = Gm.exports;
(function(t, e) {
  e.__esModule = !0;
  function r(u) {
    return u && u.__esModule ? u : { default: u };
  }
  var n = RT, i = r(n);
  function a() {
    var u = arguments.length <= 0 || arguments[0] === void 0 ? {} : arguments[0];
    this.options = u;
  }
  a.prototype = new i.default(), a.prototype.Program = function(u) {
    var l = !this.options.ignoreStandalone, p = !this.isRootSeen;
    this.isRootSeen = !0;
    for (var m = u.body, h = 0, g = m.length; h < g; h++) {
      var v = m[h], d = this.accept(v);
      if (d) {
        var y = s(m, h, p), x = o(m, h, p), b = d.openStandalone && y, w = d.closeStandalone && x, S = d.inlineStandalone && y && x;
        d.close && c(m, h, !0), d.open && f(m, h, !0), l && S && (c(m, h), f(m, h) && v.type === "PartialStatement" && (v.indent = /([ \t]+$)/.exec(m[h - 1].original)[1])), l && b && (c((v.program || v.inverse).body), f(m, h)), l && w && (c(m, h), f((v.inverse || v.program).body));
      }
    }
    return u;
  }, a.prototype.BlockStatement = a.prototype.DecoratorBlock = a.prototype.PartialBlockStatement = function(u) {
    this.accept(u.program), this.accept(u.inverse);
    var l = u.program || u.inverse, p = u.program && u.inverse, m = p, h = p;
    if (p && p.chained)
      for (m = p.body[0].program; h.chained; )
        h = h.body[h.body.length - 1].program;
    var g = {
      open: u.openStrip.open,
      close: u.closeStrip.close,
      // Determine the standalone candiacy. Basically flag our content as being possibly standalone
      // so our parent can determine if we actually are standalone
      openStandalone: o(l.body),
      closeStandalone: s((m || l).body)
    };
    if (u.openStrip.close && c(l.body, null, !0), p) {
      var v = u.inverseStrip;
      v.open && f(l.body, null, !0), v.close && c(m.body, null, !0), u.closeStrip.open && f(h.body, null, !0), !this.options.ignoreStandalone && s(l.body) && o(m.body) && (f(l.body), c(m.body));
    } else
      u.closeStrip.open && f(l.body, null, !0);
    return g;
  }, a.prototype.Decorator = a.prototype.MustacheStatement = function(u) {
    return u.strip;
  }, a.prototype.PartialStatement = a.prototype.CommentStatement = function(u) {
    var l = u.strip || {};
    return {
      inlineStandalone: !0,
      open: l.open,
      close: l.close
    };
  };
  function s(u, l, p) {
    l === void 0 && (l = u.length);
    var m = u[l - 1], h = u[l - 2];
    if (!m)
      return p;
    if (m.type === "ContentStatement")
      return (h || !p ? /\r?\n\s*?$/ : /(^|\r?\n)\s*?$/).test(m.original);
  }
  function o(u, l, p) {
    l === void 0 && (l = -1);
    var m = u[l + 1], h = u[l + 2];
    if (!m)
      return p;
    if (m.type === "ContentStatement")
      return (h || !p ? /^\s*?\r?\n/ : /^\s*?(\r?\n|$)/).test(m.original);
  }
  function c(u, l, p) {
    var m = u[l == null ? 0 : l + 1];
    if (!(!m || m.type !== "ContentStatement" || !p && m.rightStripped)) {
      var h = m.value;
      m.value = m.value.replace(p ? /^\s+/ : /^[ \t]*\r?\n?/, ""), m.rightStripped = m.value !== h;
    }
  }
  function f(u, l, p) {
    var m = u[l == null ? u.length - 1 : l - 1];
    if (!(!m || m.type !== "ContentStatement" || !p && m.leftStripped)) {
      var h = m.value;
      return m.value = m.value.replace(p ? /\s+$/ : /[ \t]+$/, ""), m.leftStripped = m.value !== h, m.leftStripped;
    }
  }
  e.default = a, t.exports = e.default;
})(Wm, Wm.exports);
var FM = Wm.exports, Ut = {};
Ut.__esModule = !0;
Ut.SourceLocation = zM;
Ut.id = HM;
Ut.stripFlags = WM;
Ut.stripComment = GM;
Ut.preparePath = QM;
Ut.prepareMustache = VM;
Ut.prepareRawBlock = KM;
Ut.prepareBlock = JM;
Ut.prepareProgram = XM;
Ut.preparePartialBlock = ZM;
function BM(t) {
  return t && t.__esModule ? t : { default: t };
}
var UM = ir, nv = BM(UM);
function iv(t, e) {
  if (e = e.path ? e.path.original : e, t.path.original !== e) {
    var r = { loc: t.path.loc };
    throw new nv.default(t.path.original + " doesn't match " + e, r);
  }
}
function zM(t, e) {
  this.source = t, this.start = {
    line: e.first_line,
    column: e.first_column
  }, this.end = {
    line: e.last_line,
    column: e.last_column
  };
}
function HM(t) {
  return /^\[.*\]$/.test(t) ? t.substring(1, t.length - 1) : t;
}
function WM(t, e) {
  return {
    open: t.charAt(2) === "~",
    close: e.charAt(e.length - 3) === "~"
  };
}
function GM(t) {
  return t.replace(/^\{\{~?!-?-?/, "").replace(/-?-?~?\}\}$/, "");
}
function QM(t, e, r) {
  r = this.locInfo(r);
  for (var n = t ? "@" : "", i = [], a = 0, s = 0, o = e.length; s < o; s++) {
    var c = e[s].part, f = e[s].original !== c;
    if (n += (e[s].separator || "") + c, !f && (c === ".." || c === "." || c === "this")) {
      if (i.length > 0)
        throw new nv.default("Invalid path: " + n, { loc: r });
      c === ".." && a++;
    } else
      i.push(c);
  }
  return {
    type: "PathExpression",
    data: t,
    depth: a,
    parts: i,
    original: n,
    loc: r
  };
}
function VM(t, e, r, n, i, a) {
  var s = n.charAt(3) || n.charAt(2), o = s !== "{" && s !== "&", c = /\*/.test(n);
  return {
    type: c ? "Decorator" : "MustacheStatement",
    path: t,
    params: e,
    hash: r,
    escaped: o,
    strip: i,
    loc: this.locInfo(a)
  };
}
function KM(t, e, r, n) {
  iv(t, r), n = this.locInfo(n);
  var i = {
    type: "Program",
    body: e,
    strip: {},
    loc: n
  };
  return {
    type: "BlockStatement",
    path: t.path,
    params: t.params,
    hash: t.hash,
    program: i,
    openStrip: {},
    inverseStrip: {},
    closeStrip: {},
    loc: n
  };
}
function JM(t, e, r, n, i, a) {
  n && n.path && iv(t, n);
  var s = /\*/.test(t.open);
  e.blockParams = t.blockParams;
  var o = void 0, c = void 0;
  if (r) {
    if (s)
      throw new nv.default("Unexpected inverse block on decorator", r);
    r.chain && (r.program.body[0].closeStrip = n.strip), c = r.strip, o = r.program;
  }
  return i && (i = o, o = e, e = i), {
    type: s ? "DecoratorBlock" : "BlockStatement",
    path: t.path,
    params: t.params,
    hash: t.hash,
    program: e,
    inverse: o,
    openStrip: t.strip,
    inverseStrip: c,
    closeStrip: n && n.strip,
    loc: this.locInfo(a)
  };
}
function XM(t, e) {
  if (!e && t.length) {
    var r = t[0].loc, n = t[t.length - 1].loc;
    r && n && (e = {
      source: r.source,
      start: {
        line: r.start.line,
        column: r.start.column
      },
      end: {
        line: n.end.line,
        column: n.end.column
      }
    });
  }
  return {
    type: "Program",
    body: t,
    strip: {},
    loc: e
  };
}
function ZM(t, e, r, n) {
  return iv(t, r), {
    type: "PartialBlockStatement",
    name: t.path,
    params: t.params,
    hash: t.hash,
    program: e,
    openStrip: t.strip,
    closeStrip: r && r.strip,
    loc: this.locInfo(n)
  };
}
cs.__esModule = !0;
cs.parseWithoutProcessing = LT;
cs.parse = s5;
function YM(t) {
  if (t && t.__esModule)
    return t;
  var e = {};
  if (t != null)
    for (var r in t)
      Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
  return e.default = t, e;
}
function NT(t) {
  return t && t.__esModule ? t : { default: t };
}
var e5 = jM, Qm = NT(e5), t5 = FM, r5 = NT(t5), n5 = Ut, i5 = YM(n5), a5 = Ge;
cs.parser = Qm.default;
var Co = {};
a5.extend(Co, i5);
function LT(t, e) {
  if (t.type === "Program")
    return t;
  Qm.default.yy = Co, Co.locInfo = function(n) {
    return new Co.SourceLocation(e && e.srcName, n);
  };
  var r = Qm.default.parse(t);
  return r;
}
function s5(t, e) {
  var r = LT(t, e), n = new r5.default(e);
  return n.accept(r);
}
var us = {};
us.__esModule = !0;
us.Compiler = Vm;
us.precompile = l5;
us.compile = p5;
function PT(t) {
  return t && t.__esModule ? t : { default: t };
}
var o5 = ir, va = PT(o5), qa = Ge, c5 = kT, Yi = PT(c5), u5 = [].slice;
function Vm() {
}
Vm.prototype = {
  compiler: Vm,
  equals: function(e) {
    var r = this.opcodes.length;
    if (e.opcodes.length !== r)
      return !1;
    for (var n = 0; n < r; n++) {
      var i = this.opcodes[n], a = e.opcodes[n];
      if (i.opcode !== a.opcode || !DT(i.args, a.args))
        return !1;
    }
    r = this.children.length;
    for (var n = 0; n < r; n++)
      if (!this.children[n].equals(e.children[n]))
        return !1;
    return !0;
  },
  guid: 0,
  compile: function(e, r) {
    return this.sourceNode = [], this.opcodes = [], this.children = [], this.options = r, this.stringParams = r.stringParams, this.trackIds = r.trackIds, r.blockParams = r.blockParams || [], r.knownHelpers = qa.extend(/* @__PURE__ */ Object.create(null), {
      helperMissing: !0,
      blockHelperMissing: !0,
      each: !0,
      if: !0,
      unless: !0,
      with: !0,
      log: !0,
      lookup: !0
    }, r.knownHelpers), this.accept(e);
  },
  compileProgram: function(e) {
    var r = new this.compiler(), n = r.compile(e, this.options), i = this.guid++;
    return this.usePartial = this.usePartial || n.usePartial, this.children[i] = n, this.useDepths = this.useDepths || n.useDepths, i;
  },
  accept: function(e) {
    if (!this[e.type])
      throw new va.default("Unknown type: " + e.type, e);
    this.sourceNode.unshift(e);
    var r = this[e.type](e);
    return this.sourceNode.shift(), r;
  },
  Program: function(e) {
    this.options.blockParams.unshift(e.blockParams);
    for (var r = e.body, n = r.length, i = 0; i < n; i++)
      this.accept(r[i]);
    return this.options.blockParams.shift(), this.isSimple = n === 1, this.blockParams = e.blockParams ? e.blockParams.length : 0, this;
  },
  BlockStatement: function(e) {
    M0(e);
    var r = e.program, n = e.inverse;
    r = r && this.compileProgram(r), n = n && this.compileProgram(n);
    var i = this.classifySexpr(e);
    i === "helper" ? this.helperSexpr(e, r, n) : i === "simple" ? (this.simpleSexpr(e), this.opcode("pushProgram", r), this.opcode("pushProgram", n), this.opcode("emptyHash"), this.opcode("blockValue", e.path.original)) : (this.ambiguousSexpr(e, r, n), this.opcode("pushProgram", r), this.opcode("pushProgram", n), this.opcode("emptyHash"), this.opcode("ambiguousBlockValue")), this.opcode("append");
  },
  DecoratorBlock: function(e) {
    var r = e.program && this.compileProgram(e.program), n = this.setupFullMustacheParams(e, r, void 0), i = e.path;
    this.useDecorators = !0, this.opcode("registerDecorator", n.length, i.original);
  },
  PartialStatement: function(e) {
    this.usePartial = !0;
    var r = e.program;
    r && (r = this.compileProgram(e.program));
    var n = e.params;
    if (n.length > 1)
      throw new va.default("Unsupported number of partial arguments: " + n.length, e);
    n.length || (this.options.explicitPartialContext ? this.opcode("pushLiteral", "undefined") : n.push({ type: "PathExpression", parts: [], depth: 0 }));
    var i = e.name.original, a = e.name.type === "SubExpression";
    a && this.accept(e.name), this.setupFullMustacheParams(e, r, void 0, !0);
    var s = e.indent || "";
    this.options.preventIndent && s && (this.opcode("appendContent", s), s = ""), this.opcode("invokePartial", a, i, s), this.opcode("append");
  },
  PartialBlockStatement: function(e) {
    this.PartialStatement(e);
  },
  MustacheStatement: function(e) {
    this.SubExpression(e), e.escaped && !this.options.noEscape ? this.opcode("appendEscaped") : this.opcode("append");
  },
  Decorator: function(e) {
    this.DecoratorBlock(e);
  },
  ContentStatement: function(e) {
    e.value && this.opcode("appendContent", e.value);
  },
  CommentStatement: function() {
  },
  SubExpression: function(e) {
    M0(e);
    var r = this.classifySexpr(e);
    r === "simple" ? this.simpleSexpr(e) : r === "helper" ? this.helperSexpr(e) : this.ambiguousSexpr(e);
  },
  ambiguousSexpr: function(e, r, n) {
    var i = e.path, a = i.parts[0], s = r != null || n != null;
    this.opcode("getContext", i.depth), this.opcode("pushProgram", r), this.opcode("pushProgram", n), i.strict = !0, this.accept(i), this.opcode("invokeAmbiguous", a, s);
  },
  simpleSexpr: function(e) {
    var r = e.path;
    r.strict = !0, this.accept(r), this.opcode("resolvePossibleLambda");
  },
  helperSexpr: function(e, r, n) {
    var i = this.setupFullMustacheParams(e, r, n), a = e.path, s = a.parts[0];
    if (this.options.knownHelpers[s])
      this.opcode("invokeKnownHelper", i.length, s);
    else {
      if (this.options.knownHelpersOnly)
        throw new va.default("You specified knownHelpersOnly, but used the unknown helper " + s, e);
      a.strict = !0, a.falsy = !0, this.accept(a), this.opcode("invokeHelper", i.length, a.original, Yi.default.helpers.simpleId(a));
    }
  },
  PathExpression: function(e) {
    this.addDepth(e.depth), this.opcode("getContext", e.depth);
    var r = e.parts[0], n = Yi.default.helpers.scopedId(e), i = !e.depth && !n && this.blockParamIndex(r);
    i ? this.opcode("lookupBlockParam", i, e.parts) : r ? e.data ? (this.options.data = !0, this.opcode("lookupData", e.depth, e.parts, e.strict)) : this.opcode("lookupOnContext", e.parts, e.falsy, e.strict, n) : this.opcode("pushContext");
  },
  StringLiteral: function(e) {
    this.opcode("pushString", e.value);
  },
  NumberLiteral: function(e) {
    this.opcode("pushLiteral", e.value);
  },
  BooleanLiteral: function(e) {
    this.opcode("pushLiteral", e.value);
  },
  UndefinedLiteral: function() {
    this.opcode("pushLiteral", "undefined");
  },
  NullLiteral: function() {
    this.opcode("pushLiteral", "null");
  },
  Hash: function(e) {
    var r = e.pairs, n = 0, i = r.length;
    for (this.opcode("pushHash"); n < i; n++)
      this.pushParam(r[n].value);
    for (; n--; )
      this.opcode("assignToHash", r[n].key);
    this.opcode("popHash");
  },
  // HELPERS
  opcode: function(e) {
    this.opcodes.push({
      opcode: e,
      args: u5.call(arguments, 1),
      loc: this.sourceNode[0].loc
    });
  },
  addDepth: function(e) {
    e && (this.useDepths = !0);
  },
  classifySexpr: function(e) {
    var r = Yi.default.helpers.simpleId(e.path), n = r && !!this.blockParamIndex(e.path.parts[0]), i = !n && Yi.default.helpers.helperExpression(e), a = !n && (i || r);
    if (a && !i) {
      var s = e.path.parts[0], o = this.options;
      o.knownHelpers[s] ? i = !0 : o.knownHelpersOnly && (a = !1);
    }
    return i ? "helper" : a ? "ambiguous" : "simple";
  },
  pushParams: function(e) {
    for (var r = 0, n = e.length; r < n; r++)
      this.pushParam(e[r]);
  },
  pushParam: function(e) {
    var r = e.value != null ? e.value : e.original || "";
    if (this.stringParams)
      r.replace && (r = r.replace(/^(\.?\.\/)*/g, "").replace(/\//g, ".")), e.depth && this.addDepth(e.depth), this.opcode("getContext", e.depth || 0), this.opcode("pushStringParam", r, e.type), e.type === "SubExpression" && this.accept(e);
    else {
      if (this.trackIds) {
        var n = void 0;
        if (e.parts && !Yi.default.helpers.scopedId(e) && !e.depth && (n = this.blockParamIndex(e.parts[0])), n) {
          var i = e.parts.slice(1).join(".");
          this.opcode("pushId", "BlockParam", n, i);
        } else
          r = e.original || r, r.replace && (r = r.replace(/^this(?:\.|$)/, "").replace(/^\.\//, "").replace(/^\.$/, "")), this.opcode("pushId", e.type, r);
      }
      this.accept(e);
    }
  },
  setupFullMustacheParams: function(e, r, n, i) {
    var a = e.params;
    return this.pushParams(a), this.opcode("pushProgram", r), this.opcode("pushProgram", n), e.hash ? this.accept(e.hash) : this.opcode("emptyHash", i), a;
  },
  blockParamIndex: function(e) {
    for (var r = 0, n = this.options.blockParams.length; r < n; r++) {
      var i = this.options.blockParams[r], a = i && qa.indexOf(i, e);
      if (i && a >= 0)
        return [r, a];
    }
  }
};
function l5(t, e, r) {
  if (t == null || typeof t != "string" && t.type !== "Program")
    throw new va.default("You must pass a string or Handlebars AST to Handlebars.precompile. You passed " + t);
  e = e || {}, "data" in e || (e.data = !0), e.compat && (e.useDepths = !0);
  var n = r.parse(t, e), i = new r.Compiler().compile(n, e);
  return new r.JavaScriptCompiler().compile(i, e);
}
function p5(t, e, r) {
  if (e === void 0 && (e = {}), t == null || typeof t != "string" && t.type !== "Program")
    throw new va.default("You must pass a string or Handlebars AST to Handlebars.compile. You passed " + t);
  e = qa.extend({}, e), "data" in e || (e.data = !0), e.compat && (e.useDepths = !0);
  var n = void 0;
  function i() {
    var s = r.parse(t, e), o = new r.Compiler().compile(s, e), c = new r.JavaScriptCompiler().compile(o, e, void 0, !0);
    return r.template(c);
  }
  function a(s, o) {
    return n || (n = i()), n.call(this, s, o);
  }
  return a._setup = function(s) {
    return n || (n = i()), n._setup(s);
  }, a._child = function(s, o, c, f) {
    return n || (n = i()), n._child(s, o, c, f);
  }, a;
}
function DT(t, e) {
  if (t === e)
    return !0;
  if (qa.isArray(t) && qa.isArray(e) && t.length === e.length) {
    for (var r = 0; r < t.length; r++)
      if (!DT(t[r], e[r]))
        return !1;
    return !0;
  }
}
function M0(t) {
  if (!t.path.parts) {
    var e = t.path;
    t.path = {
      type: "PathExpression",
      data: !1,
      depth: 0,
      parts: [e.original + ""],
      original: e.original + "",
      loc: e.loc
    };
  }
}
var Km = { exports: {} }, Jm = { exports: {} }, ea = {}, Bl = {}, Gs = {}, Qs = {}, q0;
function f5() {
  if (q0)
    return Qs;
  q0 = 1;
  var t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
  return Qs.encode = function(e) {
    if (0 <= e && e < t.length)
      return t[e];
    throw new TypeError("Must be between 0 and 63: " + e);
  }, Qs.decode = function(e) {
    var r = 65, n = 90, i = 97, a = 122, s = 48, o = 57, c = 43, f = 47, u = 26, l = 52;
    return r <= e && e <= n ? e - r : i <= e && e <= a ? e - i + u : s <= e && e <= o ? e - s + l : e == c ? 62 : e == f ? 63 : -1;
  }, Qs;
}
var j0;
function MT() {
  if (j0)
    return Gs;
  j0 = 1;
  var t = f5(), e = 5, r = 1 << e, n = r - 1, i = r;
  function a(o) {
    return o < 0 ? (-o << 1) + 1 : (o << 1) + 0;
  }
  function s(o) {
    var c = (o & 1) === 1, f = o >> 1;
    return c ? -f : f;
  }
  return Gs.encode = function(c) {
    var f = "", u, l = a(c);
    do
      u = l & n, l >>>= e, l > 0 && (u |= i), f += t.encode(u);
    while (l > 0);
    return f;
  }, Gs.decode = function(c, f, u) {
    var l = c.length, p = 0, m = 0, h, g;
    do {
      if (f >= l)
        throw new Error("Expected more digits in base 64 VLQ value.");
      if (g = t.decode(c.charCodeAt(f++)), g === -1)
        throw new Error("Invalid base64 digit: " + c.charAt(f - 1));
      h = !!(g & i), g &= n, p = p + (g << m), m += e;
    } while (h);
    u.value = s(p), u.rest = f;
  }, Gs;
}
var Ul = {}, F0;
function ls() {
  return F0 || (F0 = 1, function(t) {
    function e(b, w, S) {
      if (w in b)
        return b[w];
      if (arguments.length === 3)
        return S;
      throw new Error('"' + w + '" is a required argument.');
    }
    t.getArg = e;
    var r = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/, n = /^data:.+\,.+$/;
    function i(b) {
      var w = b.match(r);
      return w ? {
        scheme: w[1],
        auth: w[2],
        host: w[3],
        port: w[4],
        path: w[5]
      } : null;
    }
    t.urlParse = i;
    function a(b) {
      var w = "";
      return b.scheme && (w += b.scheme + ":"), w += "//", b.auth && (w += b.auth + "@"), b.host && (w += b.host), b.port && (w += ":" + b.port), b.path && (w += b.path), w;
    }
    t.urlGenerate = a;
    function s(b) {
      var w = b, S = i(b);
      if (S) {
        if (!S.path)
          return b;
        w = S.path;
      }
      for (var T = t.isAbsolute(w), E = w.split(/\/+/), C, A = 0, R = E.length - 1; R >= 0; R--)
        C = E[R], C === "." ? E.splice(R, 1) : C === ".." ? A++ : A > 0 && (C === "" ? (E.splice(R + 1, A), A = 0) : (E.splice(R, 2), A--));
      return w = E.join("/"), w === "" && (w = T ? "/" : "."), S ? (S.path = w, a(S)) : w;
    }
    t.normalize = s;
    function o(b, w) {
      b === "" && (b = "."), w === "" && (w = ".");
      var S = i(w), T = i(b);
      if (T && (b = T.path || "/"), S && !S.scheme)
        return T && (S.scheme = T.scheme), a(S);
      if (S || w.match(n))
        return w;
      if (T && !T.host && !T.path)
        return T.host = w, a(T);
      var E = w.charAt(0) === "/" ? w : s(b.replace(/\/+$/, "") + "/" + w);
      return T ? (T.path = E, a(T)) : E;
    }
    t.join = o, t.isAbsolute = function(b) {
      return b.charAt(0) === "/" || r.test(b);
    };
    function c(b, w) {
      b === "" && (b = "."), b = b.replace(/\/$/, "");
      for (var S = 0; w.indexOf(b + "/") !== 0; ) {
        var T = b.lastIndexOf("/");
        if (T < 0 || (b = b.slice(0, T), b.match(/^([^\/]+:\/)?\/*$/)))
          return w;
        ++S;
      }
      return Array(S + 1).join("../") + w.substr(b.length + 1);
    }
    t.relative = c;
    var f = function() {
      var b = /* @__PURE__ */ Object.create(null);
      return !("__proto__" in b);
    }();
    function u(b) {
      return b;
    }
    function l(b) {
      return m(b) ? "$" + b : b;
    }
    t.toSetString = f ? u : l;
    function p(b) {
      return m(b) ? b.slice(1) : b;
    }
    t.fromSetString = f ? u : p;
    function m(b) {
      if (!b)
        return !1;
      var w = b.length;
      if (w < 9 || b.charCodeAt(w - 1) !== 95 || b.charCodeAt(w - 2) !== 95 || b.charCodeAt(w - 3) !== 111 || b.charCodeAt(w - 4) !== 116 || b.charCodeAt(w - 5) !== 111 || b.charCodeAt(w - 6) !== 114 || b.charCodeAt(w - 7) !== 112 || b.charCodeAt(w - 8) !== 95 || b.charCodeAt(w - 9) !== 95)
        return !1;
      for (var S = w - 10; S >= 0; S--)
        if (b.charCodeAt(S) !== 36)
          return !1;
      return !0;
    }
    function h(b, w, S) {
      var T = v(b.source, w.source);
      return T !== 0 || (T = b.originalLine - w.originalLine, T !== 0) || (T = b.originalColumn - w.originalColumn, T !== 0 || S) || (T = b.generatedColumn - w.generatedColumn, T !== 0) || (T = b.generatedLine - w.generatedLine, T !== 0) ? T : v(b.name, w.name);
    }
    t.compareByOriginalPositions = h;
    function g(b, w, S) {
      var T = b.generatedLine - w.generatedLine;
      return T !== 0 || (T = b.generatedColumn - w.generatedColumn, T !== 0 || S) || (T = v(b.source, w.source), T !== 0) || (T = b.originalLine - w.originalLine, T !== 0) || (T = b.originalColumn - w.originalColumn, T !== 0) ? T : v(b.name, w.name);
    }
    t.compareByGeneratedPositionsDeflated = g;
    function v(b, w) {
      return b === w ? 0 : b === null ? 1 : w === null ? -1 : b > w ? 1 : -1;
    }
    function d(b, w) {
      var S = b.generatedLine - w.generatedLine;
      return S !== 0 || (S = b.generatedColumn - w.generatedColumn, S !== 0) || (S = v(b.source, w.source), S !== 0) || (S = b.originalLine - w.originalLine, S !== 0) || (S = b.originalColumn - w.originalColumn, S !== 0) ? S : v(b.name, w.name);
    }
    t.compareByGeneratedPositionsInflated = d;
    function y(b) {
      return JSON.parse(b.replace(/^\)]}'[^\n]*\n/, ""));
    }
    t.parseSourceMapInput = y;
    function x(b, w, S) {
      if (w = w || "", b && (b[b.length - 1] !== "/" && w[0] !== "/" && (b += "/"), w = b + w), S) {
        var T = i(S);
        if (!T)
          throw new Error("sourceMapURL could not be parsed");
        if (T.path) {
          var E = T.path.lastIndexOf("/");
          E >= 0 && (T.path = T.path.substring(0, E + 1));
        }
        w = o(a(T), w);
      }
      return s(w);
    }
    t.computeSourceURL = x;
  }(Ul)), Ul;
}
var zl = {}, B0;
function qT() {
  if (B0)
    return zl;
  B0 = 1;
  var t = ls(), e = Object.prototype.hasOwnProperty, r = typeof Map < "u";
  function n() {
    this._array = [], this._set = r ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
  }
  return n.fromArray = function(a, s) {
    for (var o = new n(), c = 0, f = a.length; c < f; c++)
      o.add(a[c], s);
    return o;
  }, n.prototype.size = function() {
    return r ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  }, n.prototype.add = function(a, s) {
    var o = r ? a : t.toSetString(a), c = r ? this.has(a) : e.call(this._set, o), f = this._array.length;
    (!c || s) && this._array.push(a), c || (r ? this._set.set(a, f) : this._set[o] = f);
  }, n.prototype.has = function(a) {
    if (r)
      return this._set.has(a);
    var s = t.toSetString(a);
    return e.call(this._set, s);
  }, n.prototype.indexOf = function(a) {
    if (r) {
      var s = this._set.get(a);
      if (s >= 0)
        return s;
    } else {
      var o = t.toSetString(a);
      if (e.call(this._set, o))
        return this._set[o];
    }
    throw new Error('"' + a + '" is not in the set.');
  }, n.prototype.at = function(a) {
    if (a >= 0 && a < this._array.length)
      return this._array[a];
    throw new Error("No element indexed by " + a);
  }, n.prototype.toArray = function() {
    return this._array.slice();
  }, zl.ArraySet = n, zl;
}
var Hl = {}, U0;
function h5() {
  if (U0)
    return Hl;
  U0 = 1;
  var t = ls();
  function e(n, i) {
    var a = n.generatedLine, s = i.generatedLine, o = n.generatedColumn, c = i.generatedColumn;
    return s > a || s == a && c >= o || t.compareByGeneratedPositionsInflated(n, i) <= 0;
  }
  function r() {
    this._array = [], this._sorted = !0, this._last = { generatedLine: -1, generatedColumn: 0 };
  }
  return r.prototype.unsortedForEach = function(i, a) {
    this._array.forEach(i, a);
  }, r.prototype.add = function(i) {
    e(this._last, i) ? (this._last = i, this._array.push(i)) : (this._sorted = !1, this._array.push(i));
  }, r.prototype.toArray = function() {
    return this._sorted || (this._array.sort(t.compareByGeneratedPositionsInflated), this._sorted = !0), this._array;
  }, Hl.MappingList = r, Hl;
}
var z0;
function jT() {
  if (z0)
    return Bl;
  z0 = 1;
  var t = MT(), e = ls(), r = qT().ArraySet, n = h5().MappingList;
  function i(a) {
    a || (a = {}), this._file = e.getArg(a, "file", null), this._sourceRoot = e.getArg(a, "sourceRoot", null), this._skipValidation = e.getArg(a, "skipValidation", !1), this._sources = new r(), this._names = new r(), this._mappings = new n(), this._sourcesContents = null;
  }
  return i.prototype._version = 3, i.fromSourceMap = function(s) {
    var o = s.sourceRoot, c = new i({
      file: s.file,
      sourceRoot: o
    });
    return s.eachMapping(function(f) {
      var u = {
        generated: {
          line: f.generatedLine,
          column: f.generatedColumn
        }
      };
      f.source != null && (u.source = f.source, o != null && (u.source = e.relative(o, u.source)), u.original = {
        line: f.originalLine,
        column: f.originalColumn
      }, f.name != null && (u.name = f.name)), c.addMapping(u);
    }), s.sources.forEach(function(f) {
      var u = f;
      o !== null && (u = e.relative(o, f)), c._sources.has(u) || c._sources.add(u);
      var l = s.sourceContentFor(f);
      l != null && c.setSourceContent(f, l);
    }), c;
  }, i.prototype.addMapping = function(s) {
    var o = e.getArg(s, "generated"), c = e.getArg(s, "original", null), f = e.getArg(s, "source", null), u = e.getArg(s, "name", null);
    this._skipValidation || this._validateMapping(o, c, f, u), f != null && (f = String(f), this._sources.has(f) || this._sources.add(f)), u != null && (u = String(u), this._names.has(u) || this._names.add(u)), this._mappings.add({
      generatedLine: o.line,
      generatedColumn: o.column,
      originalLine: c != null && c.line,
      originalColumn: c != null && c.column,
      source: f,
      name: u
    });
  }, i.prototype.setSourceContent = function(s, o) {
    var c = s;
    this._sourceRoot != null && (c = e.relative(this._sourceRoot, c)), o != null ? (this._sourcesContents || (this._sourcesContents = /* @__PURE__ */ Object.create(null)), this._sourcesContents[e.toSetString(c)] = o) : this._sourcesContents && (delete this._sourcesContents[e.toSetString(c)], Object.keys(this._sourcesContents).length === 0 && (this._sourcesContents = null));
  }, i.prototype.applySourceMap = function(s, o, c) {
    var f = o;
    if (o == null) {
      if (s.file == null)
        throw new Error(
          `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
        );
      f = s.file;
    }
    var u = this._sourceRoot;
    u != null && (f = e.relative(u, f));
    var l = new r(), p = new r();
    this._mappings.unsortedForEach(function(m) {
      if (m.source === f && m.originalLine != null) {
        var h = s.originalPositionFor({
          line: m.originalLine,
          column: m.originalColumn
        });
        h.source != null && (m.source = h.source, c != null && (m.source = e.join(c, m.source)), u != null && (m.source = e.relative(u, m.source)), m.originalLine = h.line, m.originalColumn = h.column, h.name != null && (m.name = h.name));
      }
      var g = m.source;
      g != null && !l.has(g) && l.add(g);
      var v = m.name;
      v != null && !p.has(v) && p.add(v);
    }, this), this._sources = l, this._names = p, s.sources.forEach(function(m) {
      var h = s.sourceContentFor(m);
      h != null && (c != null && (m = e.join(c, m)), u != null && (m = e.relative(u, m)), this.setSourceContent(m, h));
    }, this);
  }, i.prototype._validateMapping = function(s, o, c, f) {
    if (o && typeof o.line != "number" && typeof o.column != "number")
      throw new Error(
        "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
      );
    if (!(s && "line" in s && "column" in s && s.line > 0 && s.column >= 0 && !o && !c && !f)) {
      if (s && "line" in s && "column" in s && o && "line" in o && "column" in o && s.line > 0 && s.column >= 0 && o.line > 0 && o.column >= 0 && c)
        return;
      throw new Error("Invalid mapping: " + JSON.stringify({
        generated: s,
        source: c,
        original: o,
        name: f
      }));
    }
  }, i.prototype._serializeMappings = function() {
    for (var s = 0, o = 1, c = 0, f = 0, u = 0, l = 0, p = "", m, h, g, v, d = this._mappings.toArray(), y = 0, x = d.length; y < x; y++) {
      if (h = d[y], m = "", h.generatedLine !== o)
        for (s = 0; h.generatedLine !== o; )
          m += ";", o++;
      else if (y > 0) {
        if (!e.compareByGeneratedPositionsInflated(h, d[y - 1]))
          continue;
        m += ",";
      }
      m += t.encode(h.generatedColumn - s), s = h.generatedColumn, h.source != null && (v = this._sources.indexOf(h.source), m += t.encode(v - l), l = v, m += t.encode(h.originalLine - 1 - f), f = h.originalLine - 1, m += t.encode(h.originalColumn - c), c = h.originalColumn, h.name != null && (g = this._names.indexOf(h.name), m += t.encode(g - u), u = g)), p += m;
    }
    return p;
  }, i.prototype._generateSourcesContent = function(s, o) {
    return s.map(function(c) {
      if (!this._sourcesContents)
        return null;
      o != null && (c = e.relative(o, c));
      var f = e.toSetString(c);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, f) ? this._sourcesContents[f] : null;
    }, this);
  }, i.prototype.toJSON = function() {
    var s = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    return this._file != null && (s.file = this._file), this._sourceRoot != null && (s.sourceRoot = this._sourceRoot), this._sourcesContents && (s.sourcesContent = this._generateSourcesContent(s.sources, s.sourceRoot)), s;
  }, i.prototype.toString = function() {
    return JSON.stringify(this.toJSON());
  }, Bl.SourceMapGenerator = i, Bl;
}
var ta = {}, Wl = {}, H0;
function d5() {
  return H0 || (H0 = 1, function(t) {
    t.GREATEST_LOWER_BOUND = 1, t.LEAST_UPPER_BOUND = 2;
    function e(r, n, i, a, s, o) {
      var c = Math.floor((n - r) / 2) + r, f = s(i, a[c], !0);
      return f === 0 ? c : f > 0 ? n - c > 1 ? e(c, n, i, a, s, o) : o == t.LEAST_UPPER_BOUND ? n < a.length ? n : -1 : c : c - r > 1 ? e(r, c, i, a, s, o) : o == t.LEAST_UPPER_BOUND ? c : r < 0 ? -1 : r;
    }
    t.search = function(n, i, a, s) {
      if (i.length === 0)
        return -1;
      var o = e(
        -1,
        i.length,
        n,
        i,
        a,
        s || t.GREATEST_LOWER_BOUND
      );
      if (o < 0)
        return -1;
      for (; o - 1 >= 0 && a(i[o], i[o - 1], !0) === 0; )
        --o;
      return o;
    };
  }(Wl)), Wl;
}
var Gl = {}, W0;
function m5() {
  if (W0)
    return Gl;
  W0 = 1;
  function t(n, i, a) {
    var s = n[i];
    n[i] = n[a], n[a] = s;
  }
  function e(n, i) {
    return Math.round(n + Math.random() * (i - n));
  }
  function r(n, i, a, s) {
    if (a < s) {
      var o = e(a, s), c = a - 1;
      t(n, o, s);
      for (var f = n[s], u = a; u < s; u++)
        i(n[u], f) <= 0 && (c += 1, t(n, c, u));
      t(n, c + 1, u);
      var l = c + 1;
      r(n, i, a, l - 1), r(n, i, l + 1, s);
    }
  }
  return Gl.quickSort = function(n, i) {
    r(n, i, 0, n.length - 1);
  }, Gl;
}
var G0;
function g5() {
  if (G0)
    return ta;
  G0 = 1;
  var t = ls(), e = d5(), r = qT().ArraySet, n = MT(), i = m5().quickSort;
  function a(f, u) {
    var l = f;
    return typeof f == "string" && (l = t.parseSourceMapInput(f)), l.sections != null ? new c(l, u) : new s(l, u);
  }
  a.fromSourceMap = function(f, u) {
    return s.fromSourceMap(f, u);
  }, a.prototype._version = 3, a.prototype.__generatedMappings = null, Object.defineProperty(a.prototype, "_generatedMappings", {
    configurable: !0,
    enumerable: !0,
    get: function() {
      return this.__generatedMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__generatedMappings;
    }
  }), a.prototype.__originalMappings = null, Object.defineProperty(a.prototype, "_originalMappings", {
    configurable: !0,
    enumerable: !0,
    get: function() {
      return this.__originalMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__originalMappings;
    }
  }), a.prototype._charIsMappingSeparator = function(u, l) {
    var p = u.charAt(l);
    return p === ";" || p === ",";
  }, a.prototype._parseMappings = function(u, l) {
    throw new Error("Subclasses must implement _parseMappings");
  }, a.GENERATED_ORDER = 1, a.ORIGINAL_ORDER = 2, a.GREATEST_LOWER_BOUND = 1, a.LEAST_UPPER_BOUND = 2, a.prototype.eachMapping = function(u, l, p) {
    var m = l || null, h = p || a.GENERATED_ORDER, g;
    switch (h) {
      case a.GENERATED_ORDER:
        g = this._generatedMappings;
        break;
      case a.ORIGINAL_ORDER:
        g = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
    }
    var v = this.sourceRoot;
    g.map(function(d) {
      var y = d.source === null ? null : this._sources.at(d.source);
      return y = t.computeSourceURL(v, y, this._sourceMapURL), {
        source: y,
        generatedLine: d.generatedLine,
        generatedColumn: d.generatedColumn,
        originalLine: d.originalLine,
        originalColumn: d.originalColumn,
        name: d.name === null ? null : this._names.at(d.name)
      };
    }, this).forEach(u, m);
  }, a.prototype.allGeneratedPositionsFor = function(u) {
    var l = t.getArg(u, "line"), p = {
      source: t.getArg(u, "source"),
      originalLine: l,
      originalColumn: t.getArg(u, "column", 0)
    };
    if (p.source = this._findSourceIndex(p.source), p.source < 0)
      return [];
    var m = [], h = this._findMapping(
      p,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      t.compareByOriginalPositions,
      e.LEAST_UPPER_BOUND
    );
    if (h >= 0) {
      var g = this._originalMappings[h];
      if (u.column === void 0)
        for (var v = g.originalLine; g && g.originalLine === v; )
          m.push({
            line: t.getArg(g, "generatedLine", null),
            column: t.getArg(g, "generatedColumn", null),
            lastColumn: t.getArg(g, "lastGeneratedColumn", null)
          }), g = this._originalMappings[++h];
      else
        for (var d = g.originalColumn; g && g.originalLine === l && g.originalColumn == d; )
          m.push({
            line: t.getArg(g, "generatedLine", null),
            column: t.getArg(g, "generatedColumn", null),
            lastColumn: t.getArg(g, "lastGeneratedColumn", null)
          }), g = this._originalMappings[++h];
    }
    return m;
  }, ta.SourceMapConsumer = a;
  function s(f, u) {
    var l = f;
    typeof f == "string" && (l = t.parseSourceMapInput(f));
    var p = t.getArg(l, "version"), m = t.getArg(l, "sources"), h = t.getArg(l, "names", []), g = t.getArg(l, "sourceRoot", null), v = t.getArg(l, "sourcesContent", null), d = t.getArg(l, "mappings"), y = t.getArg(l, "file", null);
    if (p != this._version)
      throw new Error("Unsupported version: " + p);
    g && (g = t.normalize(g)), m = m.map(String).map(t.normalize).map(function(x) {
      return g && t.isAbsolute(g) && t.isAbsolute(x) ? t.relative(g, x) : x;
    }), this._names = r.fromArray(h.map(String), !0), this._sources = r.fromArray(m, !0), this._absoluteSources = this._sources.toArray().map(function(x) {
      return t.computeSourceURL(g, x, u);
    }), this.sourceRoot = g, this.sourcesContent = v, this._mappings = d, this._sourceMapURL = u, this.file = y;
  }
  s.prototype = Object.create(a.prototype), s.prototype.consumer = a, s.prototype._findSourceIndex = function(f) {
    var u = f;
    if (this.sourceRoot != null && (u = t.relative(this.sourceRoot, u)), this._sources.has(u))
      return this._sources.indexOf(u);
    var l;
    for (l = 0; l < this._absoluteSources.length; ++l)
      if (this._absoluteSources[l] == f)
        return l;
    return -1;
  }, s.fromSourceMap = function(u, l) {
    var p = Object.create(s.prototype), m = p._names = r.fromArray(u._names.toArray(), !0), h = p._sources = r.fromArray(u._sources.toArray(), !0);
    p.sourceRoot = u._sourceRoot, p.sourcesContent = u._generateSourcesContent(
      p._sources.toArray(),
      p.sourceRoot
    ), p.file = u._file, p._sourceMapURL = l, p._absoluteSources = p._sources.toArray().map(function(S) {
      return t.computeSourceURL(p.sourceRoot, S, l);
    });
    for (var g = u._mappings.toArray().slice(), v = p.__generatedMappings = [], d = p.__originalMappings = [], y = 0, x = g.length; y < x; y++) {
      var b = g[y], w = new o();
      w.generatedLine = b.generatedLine, w.generatedColumn = b.generatedColumn, b.source && (w.source = h.indexOf(b.source), w.originalLine = b.originalLine, w.originalColumn = b.originalColumn, b.name && (w.name = m.indexOf(b.name)), d.push(w)), v.push(w);
    }
    return i(p.__originalMappings, t.compareByOriginalPositions), p;
  }, s.prototype._version = 3, Object.defineProperty(s.prototype, "sources", {
    get: function() {
      return this._absoluteSources.slice();
    }
  });
  function o() {
    this.generatedLine = 0, this.generatedColumn = 0, this.source = null, this.originalLine = null, this.originalColumn = null, this.name = null;
  }
  s.prototype._parseMappings = function(u, l) {
    for (var p = 1, m = 0, h = 0, g = 0, v = 0, d = 0, y = u.length, x = 0, b = {}, w = {}, S = [], T = [], E, C, A, R, D; x < y; )
      if (u.charAt(x) === ";")
        p++, x++, m = 0;
      else if (u.charAt(x) === ",")
        x++;
      else {
        for (E = new o(), E.generatedLine = p, R = x; R < y && !this._charIsMappingSeparator(u, R); R++)
          ;
        if (C = u.slice(x, R), A = b[C], A)
          x += C.length;
        else {
          for (A = []; x < R; )
            n.decode(u, x, w), D = w.value, x = w.rest, A.push(D);
          if (A.length === 2)
            throw new Error("Found a source, but no line and column");
          if (A.length === 3)
            throw new Error("Found a source and line, but no column");
          b[C] = A;
        }
        E.generatedColumn = m + A[0], m = E.generatedColumn, A.length > 1 && (E.source = v + A[1], v += A[1], E.originalLine = h + A[2], h = E.originalLine, E.originalLine += 1, E.originalColumn = g + A[3], g = E.originalColumn, A.length > 4 && (E.name = d + A[4], d += A[4])), T.push(E), typeof E.originalLine == "number" && S.push(E);
      }
    i(T, t.compareByGeneratedPositionsDeflated), this.__generatedMappings = T, i(S, t.compareByOriginalPositions), this.__originalMappings = S;
  }, s.prototype._findMapping = function(u, l, p, m, h, g) {
    if (u[p] <= 0)
      throw new TypeError("Line must be greater than or equal to 1, got " + u[p]);
    if (u[m] < 0)
      throw new TypeError("Column must be greater than or equal to 0, got " + u[m]);
    return e.search(u, l, h, g);
  }, s.prototype.computeColumnSpans = function() {
    for (var u = 0; u < this._generatedMappings.length; ++u) {
      var l = this._generatedMappings[u];
      if (u + 1 < this._generatedMappings.length) {
        var p = this._generatedMappings[u + 1];
        if (l.generatedLine === p.generatedLine) {
          l.lastGeneratedColumn = p.generatedColumn - 1;
          continue;
        }
      }
      l.lastGeneratedColumn = 1 / 0;
    }
  }, s.prototype.originalPositionFor = function(u) {
    var l = {
      generatedLine: t.getArg(u, "line"),
      generatedColumn: t.getArg(u, "column")
    }, p = this._findMapping(
      l,
      this._generatedMappings,
      "generatedLine",
      "generatedColumn",
      t.compareByGeneratedPositionsDeflated,
      t.getArg(u, "bias", a.GREATEST_LOWER_BOUND)
    );
    if (p >= 0) {
      var m = this._generatedMappings[p];
      if (m.generatedLine === l.generatedLine) {
        var h = t.getArg(m, "source", null);
        h !== null && (h = this._sources.at(h), h = t.computeSourceURL(this.sourceRoot, h, this._sourceMapURL));
        var g = t.getArg(m, "name", null);
        return g !== null && (g = this._names.at(g)), {
          source: h,
          line: t.getArg(m, "originalLine", null),
          column: t.getArg(m, "originalColumn", null),
          name: g
        };
      }
    }
    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  }, s.prototype.hasContentsOfAllSources = function() {
    return this.sourcesContent ? this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(u) {
      return u == null;
    }) : !1;
  }, s.prototype.sourceContentFor = function(u, l) {
    if (!this.sourcesContent)
      return null;
    var p = this._findSourceIndex(u);
    if (p >= 0)
      return this.sourcesContent[p];
    var m = u;
    this.sourceRoot != null && (m = t.relative(this.sourceRoot, m));
    var h;
    if (this.sourceRoot != null && (h = t.urlParse(this.sourceRoot))) {
      var g = m.replace(/^file:\/\//, "");
      if (h.scheme == "file" && this._sources.has(g))
        return this.sourcesContent[this._sources.indexOf(g)];
      if ((!h.path || h.path == "/") && this._sources.has("/" + m))
        return this.sourcesContent[this._sources.indexOf("/" + m)];
    }
    if (l)
      return null;
    throw new Error('"' + m + '" is not in the SourceMap.');
  }, s.prototype.generatedPositionFor = function(u) {
    var l = t.getArg(u, "source");
    if (l = this._findSourceIndex(l), l < 0)
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    var p = {
      source: l,
      originalLine: t.getArg(u, "line"),
      originalColumn: t.getArg(u, "column")
    }, m = this._findMapping(
      p,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      t.compareByOriginalPositions,
      t.getArg(u, "bias", a.GREATEST_LOWER_BOUND)
    );
    if (m >= 0) {
      var h = this._originalMappings[m];
      if (h.source === p.source)
        return {
          line: t.getArg(h, "generatedLine", null),
          column: t.getArg(h, "generatedColumn", null),
          lastColumn: t.getArg(h, "lastGeneratedColumn", null)
        };
    }
    return {
      line: null,
      column: null,
      lastColumn: null
    };
  }, ta.BasicSourceMapConsumer = s;
  function c(f, u) {
    var l = f;
    typeof f == "string" && (l = t.parseSourceMapInput(f));
    var p = t.getArg(l, "version"), m = t.getArg(l, "sections");
    if (p != this._version)
      throw new Error("Unsupported version: " + p);
    this._sources = new r(), this._names = new r();
    var h = {
      line: -1,
      column: 0
    };
    this._sections = m.map(function(g) {
      if (g.url)
        throw new Error("Support for url field in sections not implemented.");
      var v = t.getArg(g, "offset"), d = t.getArg(v, "line"), y = t.getArg(v, "column");
      if (d < h.line || d === h.line && y < h.column)
        throw new Error("Section offsets must be ordered and non-overlapping.");
      return h = v, {
        generatedOffset: {
          // The offset fields are 0-based, but we use 1-based indices when
          // encoding/decoding from VLQ.
          generatedLine: d + 1,
          generatedColumn: y + 1
        },
        consumer: new a(t.getArg(g, "map"), u)
      };
    });
  }
  return c.prototype = Object.create(a.prototype), c.prototype.constructor = a, c.prototype._version = 3, Object.defineProperty(c.prototype, "sources", {
    get: function() {
      for (var f = [], u = 0; u < this._sections.length; u++)
        for (var l = 0; l < this._sections[u].consumer.sources.length; l++)
          f.push(this._sections[u].consumer.sources[l]);
      return f;
    }
  }), c.prototype.originalPositionFor = function(u) {
    var l = {
      generatedLine: t.getArg(u, "line"),
      generatedColumn: t.getArg(u, "column")
    }, p = e.search(
      l,
      this._sections,
      function(h, g) {
        var v = h.generatedLine - g.generatedOffset.generatedLine;
        return v || h.generatedColumn - g.generatedOffset.generatedColumn;
      }
    ), m = this._sections[p];
    return m ? m.consumer.originalPositionFor({
      line: l.generatedLine - (m.generatedOffset.generatedLine - 1),
      column: l.generatedColumn - (m.generatedOffset.generatedLine === l.generatedLine ? m.generatedOffset.generatedColumn - 1 : 0),
      bias: u.bias
    }) : {
      source: null,
      line: null,
      column: null,
      name: null
    };
  }, c.prototype.hasContentsOfAllSources = function() {
    return this._sections.every(function(u) {
      return u.consumer.hasContentsOfAllSources();
    });
  }, c.prototype.sourceContentFor = function(u, l) {
    for (var p = 0; p < this._sections.length; p++) {
      var m = this._sections[p], h = m.consumer.sourceContentFor(u, !0);
      if (h)
        return h;
    }
    if (l)
      return null;
    throw new Error('"' + u + '" is not in the SourceMap.');
  }, c.prototype.generatedPositionFor = function(u) {
    for (var l = 0; l < this._sections.length; l++) {
      var p = this._sections[l];
      if (p.consumer._findSourceIndex(t.getArg(u, "source")) !== -1) {
        var m = p.consumer.generatedPositionFor(u);
        if (m) {
          var h = {
            line: m.line + (p.generatedOffset.generatedLine - 1),
            column: m.column + (p.generatedOffset.generatedLine === m.line ? p.generatedOffset.generatedColumn - 1 : 0)
          };
          return h;
        }
      }
    }
    return {
      line: null,
      column: null
    };
  }, c.prototype._parseMappings = function(u, l) {
    this.__generatedMappings = [], this.__originalMappings = [];
    for (var p = 0; p < this._sections.length; p++)
      for (var m = this._sections[p], h = m.consumer._generatedMappings, g = 0; g < h.length; g++) {
        var v = h[g], d = m.consumer._sources.at(v.source);
        d = t.computeSourceURL(m.consumer.sourceRoot, d, this._sourceMapURL), this._sources.add(d), d = this._sources.indexOf(d);
        var y = null;
        v.name && (y = m.consumer._names.at(v.name), this._names.add(y), y = this._names.indexOf(y));
        var x = {
          source: d,
          generatedLine: v.generatedLine + (m.generatedOffset.generatedLine - 1),
          generatedColumn: v.generatedColumn + (m.generatedOffset.generatedLine === v.generatedLine ? m.generatedOffset.generatedColumn - 1 : 0),
          originalLine: v.originalLine,
          originalColumn: v.originalColumn,
          name: y
        };
        this.__generatedMappings.push(x), typeof x.originalLine == "number" && this.__originalMappings.push(x);
      }
    i(this.__generatedMappings, t.compareByGeneratedPositionsDeflated), i(this.__originalMappings, t.compareByOriginalPositions);
  }, ta.IndexedSourceMapConsumer = c, ta;
}
var Ql = {}, Q0;
function v5() {
  if (Q0)
    return Ql;
  Q0 = 1;
  var t = jT().SourceMapGenerator, e = ls(), r = /(\r?\n)/, n = 10, i = "$$$isSourceNode$$$";
  function a(s, o, c, f, u) {
    this.children = [], this.sourceContents = {}, this.line = s ?? null, this.column = o ?? null, this.source = c ?? null, this.name = u ?? null, this[i] = !0, f != null && this.add(f);
  }
  return a.fromStringWithSourceMap = function(o, c, f) {
    var u = new a(), l = o.split(r), p = 0, m = function() {
      var y = b(), x = b() || "";
      return y + x;
      function b() {
        return p < l.length ? l[p++] : void 0;
      }
    }, h = 1, g = 0, v = null;
    return c.eachMapping(function(y) {
      if (v !== null)
        if (h < y.generatedLine)
          d(v, m()), h++, g = 0;
        else {
          var x = l[p] || "", b = x.substr(0, y.generatedColumn - g);
          l[p] = x.substr(y.generatedColumn - g), g = y.generatedColumn, d(v, b), v = y;
          return;
        }
      for (; h < y.generatedLine; )
        u.add(m()), h++;
      if (g < y.generatedColumn) {
        var x = l[p] || "";
        u.add(x.substr(0, y.generatedColumn)), l[p] = x.substr(y.generatedColumn), g = y.generatedColumn;
      }
      v = y;
    }, this), p < l.length && (v && d(v, m()), u.add(l.splice(p).join(""))), c.sources.forEach(function(y) {
      var x = c.sourceContentFor(y);
      x != null && (f != null && (y = e.join(f, y)), u.setSourceContent(y, x));
    }), u;
    function d(y, x) {
      if (y === null || y.source === void 0)
        u.add(x);
      else {
        var b = f ? e.join(f, y.source) : y.source;
        u.add(new a(
          y.originalLine,
          y.originalColumn,
          b,
          x,
          y.name
        ));
      }
    }
  }, a.prototype.add = function(o) {
    if (Array.isArray(o))
      o.forEach(function(c) {
        this.add(c);
      }, this);
    else if (o[i] || typeof o == "string")
      o && this.children.push(o);
    else
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + o
      );
    return this;
  }, a.prototype.prepend = function(o) {
    if (Array.isArray(o))
      for (var c = o.length - 1; c >= 0; c--)
        this.prepend(o[c]);
    else if (o[i] || typeof o == "string")
      this.children.unshift(o);
    else
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + o
      );
    return this;
  }, a.prototype.walk = function(o) {
    for (var c, f = 0, u = this.children.length; f < u; f++)
      c = this.children[f], c[i] ? c.walk(o) : c !== "" && o(c, {
        source: this.source,
        line: this.line,
        column: this.column,
        name: this.name
      });
  }, a.prototype.join = function(o) {
    var c, f, u = this.children.length;
    if (u > 0) {
      for (c = [], f = 0; f < u - 1; f++)
        c.push(this.children[f]), c.push(o);
      c.push(this.children[f]), this.children = c;
    }
    return this;
  }, a.prototype.replaceRight = function(o, c) {
    var f = this.children[this.children.length - 1];
    return f[i] ? f.replaceRight(o, c) : typeof f == "string" ? this.children[this.children.length - 1] = f.replace(o, c) : this.children.push("".replace(o, c)), this;
  }, a.prototype.setSourceContent = function(o, c) {
    this.sourceContents[e.toSetString(o)] = c;
  }, a.prototype.walkSourceContents = function(o) {
    for (var c = 0, f = this.children.length; c < f; c++)
      this.children[c][i] && this.children[c].walkSourceContents(o);
    for (var u = Object.keys(this.sourceContents), c = 0, f = u.length; c < f; c++)
      o(e.fromSetString(u[c]), this.sourceContents[u[c]]);
  }, a.prototype.toString = function() {
    var o = "";
    return this.walk(function(c) {
      o += c;
    }), o;
  }, a.prototype.toStringWithSourceMap = function(o) {
    var c = {
      code: "",
      line: 1,
      column: 0
    }, f = new t(o), u = !1, l = null, p = null, m = null, h = null;
    return this.walk(function(g, v) {
      c.code += g, v.source !== null && v.line !== null && v.column !== null ? ((l !== v.source || p !== v.line || m !== v.column || h !== v.name) && f.addMapping({
        source: v.source,
        original: {
          line: v.line,
          column: v.column
        },
        generated: {
          line: c.line,
          column: c.column
        },
        name: v.name
      }), l = v.source, p = v.line, m = v.column, h = v.name, u = !0) : u && (f.addMapping({
        generated: {
          line: c.line,
          column: c.column
        }
      }), l = null, u = !1);
      for (var d = 0, y = g.length; d < y; d++)
        g.charCodeAt(d) === n ? (c.line++, c.column = 0, d + 1 === y ? (l = null, u = !1) : u && f.addMapping({
          source: v.source,
          original: {
            line: v.line,
            column: v.column
          },
          generated: {
            line: c.line,
            column: c.column
          },
          name: v.name
        })) : c.column++;
    }), this.walkSourceContents(function(g, v) {
      f.setSourceContent(g, v);
    }), { code: c.code, map: f };
  }, Ql.SourceNode = a, Ql;
}
var V0;
function y5() {
  return V0 || (V0 = 1, ea.SourceMapGenerator = jT().SourceMapGenerator, ea.SourceMapConsumer = g5().SourceMapConsumer, ea.SourceNode = v5().SourceNode), ea;
}
(function(t, e) {
  e.__esModule = !0;
  var r = Ge, n = void 0;
  try {
    var i = y5();
    n = i.SourceNode;
  } catch {
  }
  n || (n = function(o, c, f, u) {
    this.src = "", u && this.add(u);
  }, n.prototype = {
    add: function(c) {
      r.isArray(c) && (c = c.join("")), this.src += c;
    },
    prepend: function(c) {
      r.isArray(c) && (c = c.join("")), this.src = c + this.src;
    },
    toStringWithSourceMap: function() {
      return { code: this.toString() };
    },
    toString: function() {
      return this.src;
    }
  });
  function a(o, c, f) {
    if (r.isArray(o)) {
      for (var u = [], l = 0, p = o.length; l < p; l++)
        u.push(c.wrap(o[l], f));
      return u;
    } else if (typeof o == "boolean" || typeof o == "number")
      return o + "";
    return o;
  }
  function s(o) {
    this.srcFile = o, this.source = [];
  }
  s.prototype = {
    isEmpty: function() {
      return !this.source.length;
    },
    prepend: function(c, f) {
      this.source.unshift(this.wrap(c, f));
    },
    push: function(c, f) {
      this.source.push(this.wrap(c, f));
    },
    merge: function() {
      var c = this.empty();
      return this.each(function(f) {
        c.add(["  ", f, `
`]);
      }), c;
    },
    each: function(c) {
      for (var f = 0, u = this.source.length; f < u; f++)
        c(this.source[f]);
    },
    empty: function() {
      var c = this.currentLocation || { start: {} };
      return new n(c.start.line, c.start.column, this.srcFile);
    },
    wrap: function(c) {
      var f = arguments.length <= 1 || arguments[1] === void 0 ? this.currentLocation || { start: {} } : arguments[1];
      return c instanceof n ? c : (c = a(c, this, f), new n(f.start.line, f.start.column, this.srcFile, c));
    },
    functionCall: function(c, f, u) {
      return u = this.generateList(u), this.wrap([c, f ? "." + f + "(" : "(", u, ")"]);
    },
    quotedString: function(c) {
      return '"' + (c + "").replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029") + '"';
    },
    objectLiteral: function(c) {
      var f = this, u = [];
      Object.keys(c).forEach(function(p) {
        var m = a(c[p], f);
        m !== "undefined" && u.push([f.quotedString(p), ":", m]);
      });
      var l = this.generateList(u);
      return l.prepend("{"), l.add("}"), l;
    },
    generateList: function(c) {
      for (var f = this.empty(), u = 0, l = c.length; u < l; u++)
        u && f.add(","), f.add(a(c[u], this));
      return f;
    },
    generateArray: function(c) {
      var f = this.generateList(c);
      return f.prepend("["), f.add("]"), f;
    }
  }, e.default = s, t.exports = e.default;
})(Jm, Jm.exports);
var b5 = Jm.exports;
(function(t, e) {
  e.__esModule = !0;
  function r(p) {
    return p && p.__esModule ? p : { default: p };
  }
  var n = Bt, i = ir, a = r(i), s = Ge, o = b5, c = r(o);
  function f(p) {
    this.value = p;
  }
  function u() {
  }
  u.prototype = {
    // PUBLIC API: You can override these methods in a subclass to provide
    // alternative compiled forms for name lookup and buffering semantics
    nameLookup: function(m, h) {
      return this.internalNameLookup(m, h);
    },
    depthedLookup: function(m) {
      return [this.aliasable("container.lookup"), "(depths, ", JSON.stringify(m), ")"];
    },
    compilerInfo: function() {
      var m = n.COMPILER_REVISION, h = n.REVISION_CHANGES[m];
      return [m, h];
    },
    appendToBuffer: function(m, h, g) {
      return s.isArray(m) || (m = [m]), m = this.source.wrap(m, h), this.environment.isSimple ? ["return ", m, ";"] : g ? ["buffer += ", m, ";"] : (m.appendToBuffer = !0, m);
    },
    initializeBuffer: function() {
      return this.quotedString("");
    },
    // END PUBLIC API
    internalNameLookup: function(m, h) {
      return this.lookupPropertyFunctionIsUsed = !0, ["lookupProperty(", m, ",", JSON.stringify(h), ")"];
    },
    lookupPropertyFunctionIsUsed: !1,
    compile: function(m, h, g, v) {
      this.environment = m, this.options = h, this.stringParams = this.options.stringParams, this.trackIds = this.options.trackIds, this.precompile = !v, this.name = this.environment.name, this.isChild = !!g, this.context = g || {
        decorators: [],
        programs: [],
        environments: []
      }, this.preamble(), this.stackSlot = 0, this.stackVars = [], this.aliases = {}, this.registers = { list: [] }, this.hashes = [], this.compileStack = [], this.inlineStack = [], this.blockParams = [], this.compileChildren(m, h), this.useDepths = this.useDepths || m.useDepths || m.useDecorators || this.options.compat, this.useBlockParams = this.useBlockParams || m.useBlockParams;
      var d = m.opcodes, y = void 0, x = void 0, b = void 0, w = void 0;
      for (b = 0, w = d.length; b < w; b++)
        y = d[b], this.source.currentLocation = y.loc, x = x || y.loc, this[y.opcode].apply(this, y.args);
      if (this.source.currentLocation = x, this.pushSource(""), this.stackSlot || this.inlineStack.length || this.compileStack.length)
        throw new a.default("Compile completed with content left on stack");
      this.decorators.isEmpty() ? this.decorators = void 0 : (this.useDecorators = !0, this.decorators.prepend(["var decorators = container.decorators, ", this.lookupPropertyFunctionVarDeclaration(), `;
`]), this.decorators.push("return fn;"), v ? this.decorators = Function.apply(this, ["fn", "props", "container", "depth0", "data", "blockParams", "depths", this.decorators.merge()]) : (this.decorators.prepend(`function(fn, props, container, depth0, data, blockParams, depths) {
`), this.decorators.push(`}
`), this.decorators = this.decorators.merge()));
      var S = this.createFunctionContext(v);
      if (this.isChild)
        return S;
      var T = {
        compiler: this.compilerInfo(),
        main: S
      };
      this.decorators && (T.main_d = this.decorators, T.useDecorators = !0);
      var E = this.context, C = E.programs, A = E.decorators;
      for (b = 0, w = C.length; b < w; b++)
        C[b] && (T[b] = C[b], A[b] && (T[b + "_d"] = A[b], T.useDecorators = !0));
      return this.environment.usePartial && (T.usePartial = !0), this.options.data && (T.useData = !0), this.useDepths && (T.useDepths = !0), this.useBlockParams && (T.useBlockParams = !0), this.options.compat && (T.compat = !0), v ? T.compilerOptions = this.options : (T.compiler = JSON.stringify(T.compiler), this.source.currentLocation = { start: { line: 1, column: 0 } }, T = this.objectLiteral(T), h.srcName ? (T = T.toStringWithSourceMap({ file: h.destName }), T.map = T.map && T.map.toString()) : T = T.toString()), T;
    },
    preamble: function() {
      this.lastContext = 0, this.source = new c.default(this.options.srcName), this.decorators = new c.default(this.options.srcName);
    },
    createFunctionContext: function(m) {
      var h = this, g = "", v = this.stackVars.concat(this.registers.list);
      v.length > 0 && (g += ", " + v.join(", "));
      var d = 0;
      Object.keys(this.aliases).forEach(function(b) {
        var w = h.aliases[b];
        w.children && w.referenceCount > 1 && (g += ", alias" + ++d + "=" + b, w.children[0] = "alias" + d);
      }), this.lookupPropertyFunctionIsUsed && (g += ", " + this.lookupPropertyFunctionVarDeclaration());
      var y = ["container", "depth0", "helpers", "partials", "data"];
      (this.useBlockParams || this.useDepths) && y.push("blockParams"), this.useDepths && y.push("depths");
      var x = this.mergeSource(g);
      return m ? (y.push(x), Function.apply(this, y)) : this.source.wrap(["function(", y.join(","), `) {
  `, x, "}"]);
    },
    mergeSource: function(m) {
      var h = this.environment.isSimple, g = !this.forceBuffer, v = void 0, d = void 0, y = void 0, x = void 0;
      return this.source.each(function(b) {
        b.appendToBuffer ? (y ? b.prepend("  + ") : y = b, x = b) : (y && (d ? y.prepend("buffer += ") : v = !0, x.add(";"), y = x = void 0), d = !0, h || (g = !1));
      }), g ? y ? (y.prepend("return "), x.add(";")) : d || this.source.push('return "";') : (m += ", buffer = " + (v ? "" : this.initializeBuffer()), y ? (y.prepend("return buffer + "), x.add(";")) : this.source.push("return buffer;")), m && this.source.prepend("var " + m.substring(2) + (v ? "" : `;
`)), this.source.merge();
    },
    lookupPropertyFunctionVarDeclaration: function() {
      return `
      lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    }
    `.trim();
    },
    // [blockValue]
    //
    // On stack, before: hash, inverse, program, value
    // On stack, after: return value of blockHelperMissing
    //
    // The purpose of this opcode is to take a block of the form
    // `{{#this.foo}}...{{/this.foo}}`, resolve the value of `foo`, and
    // replace it on the stack with the result of properly
    // invoking blockHelperMissing.
    blockValue: function(m) {
      var h = this.aliasable("container.hooks.blockHelperMissing"), g = [this.contextName(0)];
      this.setupHelperArgs(m, 0, g);
      var v = this.popStack();
      g.splice(1, 0, v), this.push(this.source.functionCall(h, "call", g));
    },
    // [ambiguousBlockValue]
    //
    // On stack, before: hash, inverse, program, value
    // Compiler value, before: lastHelper=value of last found helper, if any
    // On stack, after, if no lastHelper: same as [blockValue]
    // On stack, after, if lastHelper: value
    ambiguousBlockValue: function() {
      var m = this.aliasable("container.hooks.blockHelperMissing"), h = [this.contextName(0)];
      this.setupHelperArgs("", 0, h, !0), this.flushInline();
      var g = this.topStack();
      h.splice(1, 0, g), this.pushSource(["if (!", this.lastHelper, ") { ", g, " = ", this.source.functionCall(m, "call", h), "}"]);
    },
    // [appendContent]
    //
    // On stack, before: ...
    // On stack, after: ...
    //
    // Appends the string value of `content` to the current buffer
    appendContent: function(m) {
      this.pendingContent ? m = this.pendingContent + m : this.pendingLocation = this.source.currentLocation, this.pendingContent = m;
    },
    // [append]
    //
    // On stack, before: value, ...
    // On stack, after: ...
    //
    // Coerces `value` to a String and appends it to the current buffer.
    //
    // If `value` is truthy, or 0, it is coerced into a string and appended
    // Otherwise, the empty string is appended
    append: function() {
      if (this.isInline())
        this.replaceStack(function(h) {
          return [" != null ? ", h, ' : ""'];
        }), this.pushSource(this.appendToBuffer(this.popStack()));
      else {
        var m = this.popStack();
        this.pushSource(["if (", m, " != null) { ", this.appendToBuffer(m, void 0, !0), " }"]), this.environment.isSimple && this.pushSource(["else { ", this.appendToBuffer("''", void 0, !0), " }"]);
      }
    },
    // [appendEscaped]
    //
    // On stack, before: value, ...
    // On stack, after: ...
    //
    // Escape `value` and append it to the buffer
    appendEscaped: function() {
      this.pushSource(this.appendToBuffer([this.aliasable("container.escapeExpression"), "(", this.popStack(), ")"]));
    },
    // [getContext]
    //
    // On stack, before: ...
    // On stack, after: ...
    // Compiler value, after: lastContext=depth
    //
    // Set the value of the `lastContext` compiler value to the depth
    getContext: function(m) {
      this.lastContext = m;
    },
    // [pushContext]
    //
    // On stack, before: ...
    // On stack, after: currentContext, ...
    //
    // Pushes the value of the current context onto the stack.
    pushContext: function() {
      this.pushStackLiteral(this.contextName(this.lastContext));
    },
    // [lookupOnContext]
    //
    // On stack, before: ...
    // On stack, after: currentContext[name], ...
    //
    // Looks up the value of `name` on the current context and pushes
    // it onto the stack.
    lookupOnContext: function(m, h, g, v) {
      var d = 0;
      !v && this.options.compat && !this.lastContext ? this.push(this.depthedLookup(m[d++])) : this.pushContext(), this.resolvePath("context", m, d, h, g);
    },
    // [lookupBlockParam]
    //
    // On stack, before: ...
    // On stack, after: blockParam[name], ...
    //
    // Looks up the value of `parts` on the given block param and pushes
    // it onto the stack.
    lookupBlockParam: function(m, h) {
      this.useBlockParams = !0, this.push(["blockParams[", m[0], "][", m[1], "]"]), this.resolvePath("context", h, 1);
    },
    // [lookupData]
    //
    // On stack, before: ...
    // On stack, after: data, ...
    //
    // Push the data lookup operator
    lookupData: function(m, h, g) {
      m ? this.pushStackLiteral("container.data(data, " + m + ")") : this.pushStackLiteral("data"), this.resolvePath("data", h, 0, !0, g);
    },
    resolvePath: function(m, h, g, v, d) {
      var y = this;
      if (this.options.strict || this.options.assumeObjects) {
        this.push(l(this.options.strict && d, this, h, m));
        return;
      }
      for (var x = h.length; g < x; g++)
        this.replaceStack(function(b) {
          var w = y.nameLookup(b, h[g], m);
          return v ? [" && ", w] : [" != null ? ", w, " : ", b];
        });
    },
    // [resolvePossibleLambda]
    //
    // On stack, before: value, ...
    // On stack, after: resolved value, ...
    //
    // If the `value` is a lambda, replace it on the stack by
    // the return value of the lambda
    resolvePossibleLambda: function() {
      this.push([this.aliasable("container.lambda"), "(", this.popStack(), ", ", this.contextName(0), ")"]);
    },
    // [pushStringParam]
    //
    // On stack, before: ...
    // On stack, after: string, currentContext, ...
    //
    // This opcode is designed for use in string mode, which
    // provides the string value of a parameter along with its
    // depth rather than resolving it immediately.
    pushStringParam: function(m, h) {
      this.pushContext(), this.pushString(h), h !== "SubExpression" && (typeof m == "string" ? this.pushString(m) : this.pushStackLiteral(m));
    },
    emptyHash: function(m) {
      this.trackIds && this.push("{}"), this.stringParams && (this.push("{}"), this.push("{}")), this.pushStackLiteral(m ? "undefined" : "{}");
    },
    pushHash: function() {
      this.hash && this.hashes.push(this.hash), this.hash = { values: {}, types: [], contexts: [], ids: [] };
    },
    popHash: function() {
      var m = this.hash;
      this.hash = this.hashes.pop(), this.trackIds && this.push(this.objectLiteral(m.ids)), this.stringParams && (this.push(this.objectLiteral(m.contexts)), this.push(this.objectLiteral(m.types))), this.push(this.objectLiteral(m.values));
    },
    // [pushString]
    //
    // On stack, before: ...
    // On stack, after: quotedString(string), ...
    //
    // Push a quoted version of `string` onto the stack
    pushString: function(m) {
      this.pushStackLiteral(this.quotedString(m));
    },
    // [pushLiteral]
    //
    // On stack, before: ...
    // On stack, after: value, ...
    //
    // Pushes a value onto the stack. This operation prevents
    // the compiler from creating a temporary variable to hold
    // it.
    pushLiteral: function(m) {
      this.pushStackLiteral(m);
    },
    // [pushProgram]
    //
    // On stack, before: ...
    // On stack, after: program(guid), ...
    //
    // Push a program expression onto the stack. This takes
    // a compile-time guid and converts it into a runtime-accessible
    // expression.
    pushProgram: function(m) {
      m != null ? this.pushStackLiteral(this.programExpression(m)) : this.pushStackLiteral(null);
    },
    // [registerDecorator]
    //
    // On stack, before: hash, program, params..., ...
    // On stack, after: ...
    //
    // Pops off the decorator's parameters, invokes the decorator,
    // and inserts the decorator into the decorators list.
    registerDecorator: function(m, h) {
      var g = this.nameLookup("decorators", h, "decorator"), v = this.setupHelperArgs(h, m);
      this.decorators.push(["fn = ", this.decorators.functionCall(g, "", ["fn", "props", "container", v]), " || fn;"]);
    },
    // [invokeHelper]
    //
    // On stack, before: hash, inverse, program, params..., ...
    // On stack, after: result of helper invocation
    //
    // Pops off the helper's parameters, invokes the helper,
    // and pushes the helper's return value onto the stack.
    //
    // If the helper is not found, `helperMissing` is called.
    invokeHelper: function(m, h, g) {
      var v = this.popStack(), d = this.setupHelper(m, h), y = [];
      g && y.push(d.name), y.push(v), this.options.strict || y.push(this.aliasable("container.hooks.helperMissing"));
      var x = ["(", this.itemsSeparatedBy(y, "||"), ")"], b = this.source.functionCall(x, "call", d.callParams);
      this.push(b);
    },
    itemsSeparatedBy: function(m, h) {
      var g = [];
      g.push(m[0]);
      for (var v = 1; v < m.length; v++)
        g.push(h, m[v]);
      return g;
    },
    // [invokeKnownHelper]
    //
    // On stack, before: hash, inverse, program, params..., ...
    // On stack, after: result of helper invocation
    //
    // This operation is used when the helper is known to exist,
    // so a `helperMissing` fallback is not required.
    invokeKnownHelper: function(m, h) {
      var g = this.setupHelper(m, h);
      this.push(this.source.functionCall(g.name, "call", g.callParams));
    },
    // [invokeAmbiguous]
    //
    // On stack, before: hash, inverse, program, params..., ...
    // On stack, after: result of disambiguation
    //
    // This operation is used when an expression like `{{foo}}`
    // is provided, but we don't know at compile-time whether it
    // is a helper or a path.
    //
    // This operation emits more code than the other options,
    // and can be avoided by passing the `knownHelpers` and
    // `knownHelpersOnly` flags at compile-time.
    invokeAmbiguous: function(m, h) {
      this.useRegister("helper");
      var g = this.popStack();
      this.emptyHash();
      var v = this.setupHelper(0, m, h), d = this.lastHelper = this.nameLookup("helpers", m, "helper"), y = ["(", "(helper = ", d, " || ", g, ")"];
      this.options.strict || (y[0] = "(helper = ", y.push(" != null ? helper : ", this.aliasable("container.hooks.helperMissing"))), this.push(["(", y, v.paramsInit ? ["),(", v.paramsInit] : [], "),", "(typeof helper === ", this.aliasable('"function"'), " ? ", this.source.functionCall("helper", "call", v.callParams), " : helper))"]);
    },
    // [invokePartial]
    //
    // On stack, before: context, ...
    // On stack after: result of partial invocation
    //
    // This operation pops off a context, invokes a partial with that context,
    // and pushes the result of the invocation back.
    invokePartial: function(m, h, g) {
      var v = [], d = this.setupParams(h, 1, v);
      m && (h = this.popStack(), delete d.name), g && (d.indent = JSON.stringify(g)), d.helpers = "helpers", d.partials = "partials", d.decorators = "container.decorators", m ? v.unshift(h) : v.unshift(this.nameLookup("partials", h, "partial")), this.options.compat && (d.depths = "depths"), d = this.objectLiteral(d), v.push(d), this.push(this.source.functionCall("container.invokePartial", "", v));
    },
    // [assignToHash]
    //
    // On stack, before: value, ..., hash, ...
    // On stack, after: ..., hash, ...
    //
    // Pops a value off the stack and assigns it to the current hash
    assignToHash: function(m) {
      var h = this.popStack(), g = void 0, v = void 0, d = void 0;
      this.trackIds && (d = this.popStack()), this.stringParams && (v = this.popStack(), g = this.popStack());
      var y = this.hash;
      g && (y.contexts[m] = g), v && (y.types[m] = v), d && (y.ids[m] = d), y.values[m] = h;
    },
    pushId: function(m, h, g) {
      m === "BlockParam" ? this.pushStackLiteral("blockParams[" + h[0] + "].path[" + h[1] + "]" + (g ? " + " + JSON.stringify("." + g) : "")) : m === "PathExpression" ? this.pushString(h) : m === "SubExpression" ? this.pushStackLiteral("true") : this.pushStackLiteral("null");
    },
    // HELPERS
    compiler: u,
    compileChildren: function(m, h) {
      for (var g = m.children, v = void 0, d = void 0, y = 0, x = g.length; y < x; y++) {
        v = g[y], d = new this.compiler();
        var b = this.matchExistingProgram(v);
        if (b == null) {
          this.context.programs.push("");
          var w = this.context.programs.length;
          v.index = w, v.name = "program" + w, this.context.programs[w] = d.compile(v, h, this.context, !this.precompile), this.context.decorators[w] = d.decorators, this.context.environments[w] = v, this.useDepths = this.useDepths || d.useDepths, this.useBlockParams = this.useBlockParams || d.useBlockParams, v.useDepths = this.useDepths, v.useBlockParams = this.useBlockParams;
        } else
          v.index = b.index, v.name = "program" + b.index, this.useDepths = this.useDepths || b.useDepths, this.useBlockParams = this.useBlockParams || b.useBlockParams;
      }
    },
    matchExistingProgram: function(m) {
      for (var h = 0, g = this.context.environments.length; h < g; h++) {
        var v = this.context.environments[h];
        if (v && v.equals(m))
          return v;
      }
    },
    programExpression: function(m) {
      var h = this.environment.children[m], g = [h.index, "data", h.blockParams];
      return (this.useBlockParams || this.useDepths) && g.push("blockParams"), this.useDepths && g.push("depths"), "container.program(" + g.join(", ") + ")";
    },
    useRegister: function(m) {
      this.registers[m] || (this.registers[m] = !0, this.registers.list.push(m));
    },
    push: function(m) {
      return m instanceof f || (m = this.source.wrap(m)), this.inlineStack.push(m), m;
    },
    pushStackLiteral: function(m) {
      this.push(new f(m));
    },
    pushSource: function(m) {
      this.pendingContent && (this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation)), this.pendingContent = void 0), m && this.source.push(m);
    },
    replaceStack: function(m) {
      var h = ["("], g = void 0, v = void 0, d = void 0;
      if (!this.isInline())
        throw new a.default("replaceStack on non-inline");
      var y = this.popStack(!0);
      if (y instanceof f)
        g = [y.value], h = ["(", g], d = !0;
      else {
        v = !0;
        var x = this.incrStack();
        h = ["((", this.push(x), " = ", y, ")"], g = this.topStack();
      }
      var b = m.call(this, g);
      d || this.popStack(), v && this.stackSlot--, this.push(h.concat(b, ")"));
    },
    incrStack: function() {
      return this.stackSlot++, this.stackSlot > this.stackVars.length && this.stackVars.push("stack" + this.stackSlot), this.topStackName();
    },
    topStackName: function() {
      return "stack" + this.stackSlot;
    },
    flushInline: function() {
      var m = this.inlineStack;
      this.inlineStack = [];
      for (var h = 0, g = m.length; h < g; h++) {
        var v = m[h];
        if (v instanceof f)
          this.compileStack.push(v);
        else {
          var d = this.incrStack();
          this.pushSource([d, " = ", v, ";"]), this.compileStack.push(d);
        }
      }
    },
    isInline: function() {
      return this.inlineStack.length;
    },
    popStack: function(m) {
      var h = this.isInline(), g = (h ? this.inlineStack : this.compileStack).pop();
      if (!m && g instanceof f)
        return g.value;
      if (!h) {
        if (!this.stackSlot)
          throw new a.default("Invalid stack pop");
        this.stackSlot--;
      }
      return g;
    },
    topStack: function() {
      var m = this.isInline() ? this.inlineStack : this.compileStack, h = m[m.length - 1];
      return h instanceof f ? h.value : h;
    },
    contextName: function(m) {
      return this.useDepths && m ? "depths[" + m + "]" : "depth" + m;
    },
    quotedString: function(m) {
      return this.source.quotedString(m);
    },
    objectLiteral: function(m) {
      return this.source.objectLiteral(m);
    },
    aliasable: function(m) {
      var h = this.aliases[m];
      return h ? (h.referenceCount++, h) : (h = this.aliases[m] = this.source.wrap(m), h.aliasable = !0, h.referenceCount = 1, h);
    },
    setupHelper: function(m, h, g) {
      var v = [], d = this.setupHelperArgs(h, m, v, g), y = this.nameLookup("helpers", h, "helper"), x = this.aliasable(this.contextName(0) + " != null ? " + this.contextName(0) + " : (container.nullContext || {})");
      return {
        params: v,
        paramsInit: d,
        name: y,
        callParams: [x].concat(v)
      };
    },
    setupParams: function(m, h, g) {
      var v = {}, d = [], y = [], x = [], b = !g, w = void 0;
      b && (g = []), v.name = this.quotedString(m), v.hash = this.popStack(), this.trackIds && (v.hashIds = this.popStack()), this.stringParams && (v.hashTypes = this.popStack(), v.hashContexts = this.popStack());
      var S = this.popStack(), T = this.popStack();
      (T || S) && (v.fn = T || "container.noop", v.inverse = S || "container.noop");
      for (var E = h; E--; )
        w = this.popStack(), g[E] = w, this.trackIds && (x[E] = this.popStack()), this.stringParams && (y[E] = this.popStack(), d[E] = this.popStack());
      return b && (v.args = this.source.generateArray(g)), this.trackIds && (v.ids = this.source.generateArray(x)), this.stringParams && (v.types = this.source.generateArray(y), v.contexts = this.source.generateArray(d)), this.options.data && (v.data = "data"), this.useBlockParams && (v.blockParams = "blockParams"), v;
    },
    setupHelperArgs: function(m, h, g, v) {
      var d = this.setupParams(m, h, g);
      return d.loc = JSON.stringify(this.source.currentLocation), d = this.objectLiteral(d), v ? (this.useRegister("options"), g.push("options"), ["options=", d]) : g ? (g.push(d), "") : d;
    }
  }, function() {
    for (var p = "break else new var case finally return void catch for switch while continue function this with default if throw delete in try do instanceof typeof abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws const goto private transient debugger implements protected volatile double import public let yield await null true false".split(" "), m = u.RESERVED_WORDS = {}, h = 0, g = p.length; h < g; h++)
      m[p[h]] = !0;
  }(), u.isValidJavaScriptVariableName = function(p) {
    return !u.RESERVED_WORDS[p] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(p);
  };
  function l(p, m, h, g) {
    var v = m.popStack(), d = 0, y = h.length;
    for (p && y--; d < y; d++)
      v = m.nameLookup(v, h[d], g);
    return p ? [m.aliasable("container.strict"), "(", v, ", ", m.quotedString(h[d]), ", ", JSON.stringify(m.source.currentLocation), " )"] : v;
  }
  e.default = u, t.exports = e.default;
})(Km, Km.exports);
var w5 = Km.exports;
(function(t, e) {
  e.__esModule = !0;
  function r(y) {
    return y && y.__esModule ? y : { default: y };
  }
  var n = qM, i = r(n), a = kT, s = r(a), o = cs, c = us, f = w5, u = r(f), l = RT, p = r(l), m = IT, h = r(m), g = i.default.create;
  function v() {
    var y = g();
    return y.compile = function(x, b) {
      return c.compile(x, b, y);
    }, y.precompile = function(x, b) {
      return c.precompile(x, b, y);
    }, y.AST = s.default, y.Compiler = c.Compiler, y.JavaScriptCompiler = u.default, y.Parser = o.parser, y.parse = o.parse, y.parseWithoutProcessing = o.parseWithoutProcessing, y;
  }
  var d = v();
  d.create = v, h.default(d), d.Visitor = p.default, d.default = d, e.default = d, t.exports = e.default;
})(Om, Om.exports);
var FT = Om.exports;
FT.registerHelper("raw", (t) => t.fn());
const x5 = (t, e) => {
  try {
    return {
      error: !1,
      data: {
        contents: FT.compile(t)(e)
      }
    };
  } catch (r) {
    return {
      error: !0,
      message: "Failed to compile",
      data: {
        trace: r
      }
    };
  }
}, _5 = {
  name: "/endpoints",
  type: "invoke",
  fn: (t, e) => {
    e.send({
      error: !1,
      data: {
        endpoints: Eo
      }
    });
  }
}, E5 = {
  get: _5
}, BT = () => ({
  meta: {
    name: "Untitled Project",
    filename: "",
    tags: []
  },
  scorm: {
    name: "",
    description: "",
    authors: "",
    organization: "",
    reportStatus: "Passed/Incomplete",
    identifier: "",
    outputFormat: "2004 3rd Edition",
    optimizeMedia: "recommended"
  },
  modules: [],
  lessons: [],
  glossary: [],
  resources: []
}), S5 = () => {
  var e, r;
  const t = BT();
  return (e = t.modules) == null || e.push({
    id: 0,
    name: "Introduction",
    passingThreshold: 75
  }), (r = t.lessons) == null || r.push({
    moduleId: 0,
    id: 0,
    name: "Introduction"
  }), t;
}, C5 = () => {
  const t = BT();
  return t.modules = [], t.lessons = [], t.modules.push({
    id: 0,
    name: "Introduction",
    passingThreshold: 75
  }), t.lessons.push({
    moduleId: 0,
    id: 0,
    name: "Introduction"
  }), t;
}, T5 = (t) => {
  switch (t) {
    case "beginner":
      return C5();
    case "default":
    default:
      return S5();
  }
}, Sn = "users", UT = [
  {
    column: {
      name: "id",
      type: "uuid"
    }
  },
  {
    column: {
      name: "createdAt",
      type: "datetime"
    }
  },
  {
    column: {
      name: "deletedAt",
      type: "datetime"
    }
  },
  {
    column: {
      name: "name",
      type: "string"
    }
  },
  {
    column: {
      name: "avatar",
      type: "string"
    }
  }
];
var on = { exports: {} };
const O5 = "dotenv", A5 = "16.3.1", $5 = "Loads environment variables from .env file", I5 = "lib/main.js", k5 = "lib/main.d.ts", R5 = {
  ".": {
    types: "./lib/main.d.ts",
    require: "./lib/main.js",
    default: "./lib/main.js"
  },
  "./config": "./config.js",
  "./config.js": "./config.js",
  "./lib/env-options": "./lib/env-options.js",
  "./lib/env-options.js": "./lib/env-options.js",
  "./lib/cli-options": "./lib/cli-options.js",
  "./lib/cli-options.js": "./lib/cli-options.js",
  "./package.json": "./package.json"
}, N5 = {
  "dts-check": "tsc --project tests/types/tsconfig.json",
  lint: "standard",
  "lint-readme": "standard-markdown",
  pretest: "npm run lint && npm run dts-check",
  test: "tap tests/*.js --100 -Rspec",
  prerelease: "npm test",
  release: "standard-version"
}, L5 = {
  type: "git",
  url: "git://github.com/motdotla/dotenv.git"
}, P5 = "https://github.com/motdotla/dotenv?sponsor=1", D5 = [
  "dotenv",
  "env",
  ".env",
  "environment",
  "variables",
  "config",
  "settings"
], M5 = "README.md", q5 = "BSD-2-Clause", j5 = {
  "@definitelytyped/dtslint": "^0.0.133",
  "@types/node": "^18.11.3",
  decache: "^4.6.1",
  sinon: "^14.0.1",
  standard: "^17.0.0",
  "standard-markdown": "^7.1.0",
  "standard-version": "^9.5.0",
  tap: "^16.3.0",
  tar: "^6.1.11",
  typescript: "^4.8.4"
}, F5 = {
  node: ">=12"
}, B5 = {
  fs: !1
}, U5 = {
  name: O5,
  version: A5,
  description: $5,
  main: I5,
  types: k5,
  exports: R5,
  scripts: N5,
  repository: L5,
  funding: P5,
  keywords: D5,
  readmeFilename: M5,
  license: q5,
  devDependencies: j5,
  engines: F5,
  browser: B5
}, zT = se, av = se, z5 = se, H5 = se, W5 = U5, sv = W5.version, G5 = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
function Q5(t) {
  const e = {};
  let r = t.toString();
  r = r.replace(/\r\n?/mg, `
`);
  let n;
  for (; (n = G5.exec(r)) != null; ) {
    const i = n[1];
    let a = n[2] || "";
    a = a.trim();
    const s = a[0];
    a = a.replace(/^(['"`])([\s\S]*)\1$/mg, "$2"), s === '"' && (a = a.replace(/\\n/g, `
`), a = a.replace(/\\r/g, "\r")), e[i] = a;
  }
  return e;
}
function V5(t) {
  const e = WT(t), r = ht.configDotenv({ path: e });
  if (!r.parsed)
    throw new Error(`MISSING_DATA: Cannot parse ${e} for an unknown reason`);
  const n = HT(t).split(","), i = n.length;
  let a;
  for (let s = 0; s < i; s++)
    try {
      const o = n[s].trim(), c = X5(r, o);
      a = ht.decrypt(c.ciphertext, c.key);
      break;
    } catch (o) {
      if (s + 1 >= i)
        throw o;
    }
  return ht.parse(a);
}
function K5(t) {
  console.log(`[dotenv@${sv}][INFO] ${t}`);
}
function J5(t) {
  console.log(`[dotenv@${sv}][WARN] ${t}`);
}
function Xm(t) {
  console.log(`[dotenv@${sv}][DEBUG] ${t}`);
}
function HT(t) {
  return t && t.DOTENV_KEY && t.DOTENV_KEY.length > 0 ? t.DOTENV_KEY : process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0 ? process.env.DOTENV_KEY : "";
}
function X5(t, e) {
  let r;
  try {
    r = new URL(e);
  } catch (o) {
    throw o.code === "ERR_INVALID_URL" ? new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenv.org/vault/.env.vault?environment=development") : o;
  }
  const n = r.password;
  if (!n)
    throw new Error("INVALID_DOTENV_KEY: Missing key part");
  const i = r.searchParams.get("environment");
  if (!i)
    throw new Error("INVALID_DOTENV_KEY: Missing environment part");
  const a = `DOTENV_VAULT_${i.toUpperCase()}`, s = t.parsed[a];
  if (!s)
    throw new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${a} in your .env.vault file.`);
  return { ciphertext: s, key: n };
}
function WT(t) {
  let e = av.resolve(process.cwd(), ".env");
  return t && t.path && t.path.length > 0 && (e = t.path), e.endsWith(".vault") ? e : `${e}.vault`;
}
function Z5(t) {
  return t[0] === "~" ? av.join(z5.homedir(), t.slice(1)) : t;
}
function Y5(t) {
  K5("Loading env from encrypted .env.vault");
  const e = ht._parseVault(t);
  let r = process.env;
  return t && t.processEnv != null && (r = t.processEnv), ht.populate(r, e, t), { parsed: e };
}
function eq(t) {
  let e = av.resolve(process.cwd(), ".env"), r = "utf8";
  const n = !!(t && t.debug);
  t && (t.path != null && (e = Z5(t.path)), t.encoding != null && (r = t.encoding));
  try {
    const i = ht.parse(zT.readFileSync(e, { encoding: r }));
    let a = process.env;
    return t && t.processEnv != null && (a = t.processEnv), ht.populate(a, i, t), { parsed: i };
  } catch (i) {
    return n && Xm(`Failed to load ${e} ${i.message}`), { error: i };
  }
}
function tq(t) {
  const e = WT(t);
  return HT(t).length === 0 ? ht.configDotenv(t) : zT.existsSync(e) ? ht._configVault(t) : (J5(`You set DOTENV_KEY but you are missing a .env.vault file at ${e}. Did you forget to build it?`), ht.configDotenv(t));
}
function rq(t, e) {
  const r = Buffer.from(e.slice(-64), "hex");
  let n = Buffer.from(t, "base64");
  const i = n.slice(0, 12), a = n.slice(-16);
  n = n.slice(12, -16);
  try {
    const s = H5.createDecipheriv("aes-256-gcm", r, i);
    return s.setAuthTag(a), `${s.update(n)}${s.final()}`;
  } catch (s) {
    const o = s instanceof RangeError, c = s.message === "Invalid key length", f = s.message === "Unsupported state or unable to authenticate data";
    if (o || c) {
      const u = "INVALID_DOTENV_KEY: It must be 64 characters long (or more)";
      throw new Error(u);
    } else if (f) {
      const u = "DECRYPTION_FAILED: Please check your DOTENV_KEY";
      throw new Error(u);
    } else
      throw console.error("Error: ", s.code), console.error("Error: ", s.message), s;
  }
}
function nq(t, e, r = {}) {
  const n = !!(r && r.debug), i = !!(r && r.override);
  if (typeof e != "object")
    throw new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
  for (const a of Object.keys(e))
    Object.prototype.hasOwnProperty.call(t, a) ? (i === !0 && (t[a] = e[a]), n && Xm(i === !0 ? `"${a}" is already defined and WAS overwritten` : `"${a}" is already defined and was NOT overwritten`)) : t[a] = e[a];
}
const ht = {
  configDotenv: eq,
  _configVault: Y5,
  _parseVault: V5,
  config: tq,
  decrypt: rq,
  parse: Q5,
  populate: nq
};
on.exports.configDotenv = ht.configDotenv;
on.exports._configVault = ht._configVault;
on.exports._parseVault = ht._parseVault;
var iq = on.exports.config = ht.config;
on.exports.decrypt = ht.decrypt;
on.exports.parse = ht.parse;
on.exports.populate = ht.populate;
on.exports = ht;
var Zm = { exports: {} }, ov = {}, cv = {}, Bc = {};
Object.defineProperty(Bc, "__esModule", { value: !0 });
let aq = class extends Error {
};
Bc.TimeoutError = aq;
var zt = {}, uv = {};
Object.defineProperty(uv, "__esModule", { value: !0 });
class sq {
  constructor(e) {
    this._value = e.value, this._error = e.error;
  }
  value() {
    return this._value;
  }
  reason() {
    return this._error;
  }
  isRejected() {
    return !!this._error;
  }
  isFulfilled() {
    return !!this._value;
  }
}
uv.PromiseInspection = sq;
Object.defineProperty(zt, "__esModule", { value: !0 });
const K0 = uv;
function oq() {
  let t = null, e = null;
  return {
    promise: new Promise((n, i) => {
      t = n, e = i;
    }),
    resolve: t,
    reject: e
  };
}
zt.defer = oq;
function cq() {
  return Date.now();
}
zt.now = cq;
function uq(t, e) {
  return Math.abs(e - t);
}
zt.duration = uq;
function lq(t) {
  return typeof t > "u" ? !0 : GT(t);
}
zt.checkOptionalTime = lq;
function GT(t) {
  return typeof t == "number" && t === Math.round(t) && t > 0;
}
zt.checkRequiredTime = GT;
function pq(t) {
  return new Promise((e) => setTimeout(e, t));
}
zt.delay = pq;
function fq(t) {
  return t.then((e) => new K0.PromiseInspection({ value: e })).catch((e) => new K0.PromiseInspection({ error: e }));
}
zt.reflect = fq;
function hq(t) {
  try {
    const e = t();
    return Promise.resolve(e);
  } catch (e) {
    return Promise.reject(e);
  }
}
zt.tryPromise = hq;
Object.defineProperty(cv, "__esModule", { value: !0 });
const To = Bc, dq = zt;
class mq {
  constructor(e) {
    this.timeoutMillis = e, this.deferred = dq.defer(), this.possibleTimeoutCause = null, this.isRejected = !1, this.promise = gq(this.deferred.promise, e).catch((r) => (r instanceof To.TimeoutError && (this.possibleTimeoutCause ? r = new To.TimeoutError(this.possibleTimeoutCause.message) : r = new To.TimeoutError("operation timed out for an unknown reason")), this.isRejected = !0, Promise.reject(r)));
  }
  abort() {
    this.reject(new Error("aborted"));
  }
  reject(e) {
    this.deferred.reject(e);
  }
  resolve(e) {
    this.deferred.resolve(e);
  }
}
cv.PendingOperation = mq;
function gq(t, e) {
  return new Promise((r, n) => {
    const i = setTimeout(() => n(new To.TimeoutError()), e);
    t.then((a) => {
      clearTimeout(i), r(a);
    }).catch((a) => {
      clearTimeout(i), n(a);
    });
  });
}
var lv = {};
Object.defineProperty(lv, "__esModule", { value: !0 });
const J0 = zt;
class pv {
  constructor(e) {
    this.resource = e, this.resource = e, this.timestamp = J0.now(), this.deferred = J0.defer();
  }
  get promise() {
    return this.deferred.promise;
  }
  resolve() {
    return this.deferred.resolve(void 0), new pv(this.resource);
  }
}
lv.Resource = pv;
Object.defineProperty(ov, "__esModule", { value: !0 });
const Vs = cv, vq = lv, Tt = zt, yq = bt, X0 = se;
let bq = class {
  constructor(e) {
    if (this.destroyed = !1, this.emitter = new yq.EventEmitter(), e = e || {}, !e.create)
      throw new Error("Tarn: opt.create function most be provided");
    if (!e.destroy)
      throw new Error("Tarn: opt.destroy function most be provided");
    if (typeof e.min != "number" || e.min < 0 || e.min !== Math.round(e.min))
      throw new Error("Tarn: opt.min must be an integer >= 0");
    if (typeof e.max != "number" || e.max <= 0 || e.max !== Math.round(e.max))
      throw new Error("Tarn: opt.max must be an integer > 0");
    if (e.min > e.max)
      throw new Error("Tarn: opt.max is smaller than opt.min");
    if (!Tt.checkOptionalTime(e.acquireTimeoutMillis))
      throw new Error("Tarn: invalid opt.acquireTimeoutMillis " + JSON.stringify(e.acquireTimeoutMillis));
    if (!Tt.checkOptionalTime(e.createTimeoutMillis))
      throw new Error("Tarn: invalid opt.createTimeoutMillis " + JSON.stringify(e.createTimeoutMillis));
    if (!Tt.checkOptionalTime(e.destroyTimeoutMillis))
      throw new Error("Tarn: invalid opt.destroyTimeoutMillis " + JSON.stringify(e.destroyTimeoutMillis));
    if (!Tt.checkOptionalTime(e.idleTimeoutMillis))
      throw new Error("Tarn: invalid opt.idleTimeoutMillis " + JSON.stringify(e.idleTimeoutMillis));
    if (!Tt.checkOptionalTime(e.reapIntervalMillis))
      throw new Error("Tarn: invalid opt.reapIntervalMillis " + JSON.stringify(e.reapIntervalMillis));
    if (!Tt.checkOptionalTime(e.createRetryIntervalMillis))
      throw new Error("Tarn: invalid opt.createRetryIntervalMillis " + JSON.stringify(e.createRetryIntervalMillis));
    const r = {
      create: !0,
      validate: !0,
      destroy: !0,
      log: !0,
      min: !0,
      max: !0,
      acquireTimeoutMillis: !0,
      createTimeoutMillis: !0,
      destroyTimeoutMillis: !0,
      idleTimeoutMillis: !0,
      reapIntervalMillis: !0,
      createRetryIntervalMillis: !0,
      propagateCreateError: !0
    };
    for (const n of Object.keys(e))
      if (!r[n])
        throw new Error(`Tarn: unsupported option opt.${n}`);
    this.creator = e.create, this.destroyer = e.destroy, this.validate = typeof e.validate == "function" ? e.validate : () => !0, this.log = e.log || (() => {
    }), this.acquireTimeoutMillis = e.acquireTimeoutMillis || 3e4, this.createTimeoutMillis = e.createTimeoutMillis || 3e4, this.destroyTimeoutMillis = e.destroyTimeoutMillis || 5e3, this.idleTimeoutMillis = e.idleTimeoutMillis || 3e4, this.reapIntervalMillis = e.reapIntervalMillis || 1e3, this.createRetryIntervalMillis = e.createRetryIntervalMillis || 200, this.propagateCreateError = !!e.propagateCreateError, this.min = e.min, this.max = e.max, this.used = [], this.free = [], this.pendingCreates = [], this.pendingAcquires = [], this.pendingDestroys = [], this.pendingValidations = [], this.destroyed = !1, this.interval = null, this.eventId = 1;
  }
  numUsed() {
    return this.used.length;
  }
  numFree() {
    return this.free.length;
  }
  numPendingAcquires() {
    return this.pendingAcquires.length;
  }
  numPendingValidations() {
    return this.pendingValidations.length;
  }
  numPendingCreates() {
    return this.pendingCreates.length;
  }
  acquire() {
    const e = this.eventId++;
    this._executeEventHandlers("acquireRequest", e);
    const r = new Vs.PendingOperation(this.acquireTimeoutMillis);
    return this.pendingAcquires.push(r), r.promise = r.promise.then((n) => (this._executeEventHandlers("acquireSuccess", e, n), n)).catch((n) => (this._executeEventHandlers("acquireFail", e, n), ti(this.pendingAcquires, r), Promise.reject(n))), this._tryAcquireOrCreate(), r;
  }
  release(e) {
    this._executeEventHandlers("release", e);
    for (let r = 0, n = this.used.length; r < n; ++r) {
      const i = this.used[r];
      if (i.resource === e)
        return this.used.splice(r, 1), this.free.push(i.resolve()), this._tryAcquireOrCreate(), !0;
    }
    return !1;
  }
  isEmpty() {
    return [
      this.numFree(),
      this.numUsed(),
      this.numPendingAcquires(),
      this.numPendingValidations(),
      this.numPendingCreates()
    ].reduce((e, r) => e + r) === 0;
  }
  /**
   * Reaping cycle.
   */
  check() {
    const e = Tt.now(), r = [], n = this.min - this.used.length, i = this.free.length - n;
    let a = 0;
    this.free.forEach((s) => {
      Tt.duration(e, s.timestamp) >= this.idleTimeoutMillis && a < i ? (a++, this._destroy(s.resource)) : r.push(s);
    }), this.free = r, this.isEmpty() && this._stopReaping();
  }
  destroy() {
    const e = this.eventId++;
    return this._executeEventHandlers("poolDestroyRequest", e), this._stopReaping(), this.destroyed = !0, Tt.reflect(Promise.all(this.pendingCreates.map((r) => Tt.reflect(r.promise))).then(() => new Promise((r, n) => {
      if (this.numPendingValidations() === 0) {
        r();
        return;
      }
      const i = setInterval(() => {
        this.numPendingValidations() === 0 && (X0.clearInterval(i), r());
      }, 100);
    })).then(() => Promise.all(this.used.map((r) => Tt.reflect(r.promise)))).then(() => Promise.all(this.pendingAcquires.map((r) => (r.abort(), Tt.reflect(r.promise))))).then(() => Promise.all(this.free.map((r) => Tt.reflect(this._destroy(r.resource))))).then(() => Promise.all(this.pendingDestroys.map((r) => r.promise))).then(() => {
      this.free = [], this.pendingAcquires = [];
    })).then((r) => (this._executeEventHandlers("poolDestroySuccess", e), this.emitter.removeAllListeners(), r));
  }
  on(e, r) {
    this.emitter.on(e, r);
  }
  removeListener(e, r) {
    this.emitter.removeListener(e, r);
  }
  removeAllListeners(e) {
    this.emitter.removeAllListeners(e);
  }
  /**
   * The most important method that is called always when resources
   * are created / destroyed / acquired / released. In other words
   * every time when resources are moved from used to free or vice
   * versa.
   *
   * Either assigns free resources to pendingAcquires or creates new
   * resources if there is room for it in the pool.
   */
  _tryAcquireOrCreate() {
    this.destroyed || (this._hasFreeResources() ? this._doAcquire() : this._shouldCreateMoreResources() && this._doCreate());
  }
  _hasFreeResources() {
    return this.free.length > 0;
  }
  _doAcquire() {
    for (; this._canAcquire(); ) {
      const e = this.pendingAcquires.shift(), r = this.free.pop();
      if (r === void 0 || e === void 0) {
        const i = "this.free was empty while trying to acquire resource";
        throw this.log(`Tarn: ${i}`, "warn"), new Error(`Internal error, should never happen. ${i}`);
      }
      this.pendingValidations.push(e), this.used.push(r);
      const n = new Vs.PendingOperation(this.acquireTimeoutMillis);
      e.promise.catch((i) => {
        n.abort();
      }), n.promise.catch((i) => (this.log("Tarn: resource validator threw an exception " + i.stack, "warn"), !1)).then((i) => {
        try {
          i && !e.isRejected ? (this._startReaping(), e.resolve(r.resource)) : (ti(this.used, r), i ? this.free.push(r) : (this._destroy(r.resource), setTimeout(() => {
            this._tryAcquireOrCreate();
          }, 0)), e.isRejected || this.pendingAcquires.unshift(e));
        } finally {
          ti(this.pendingValidations, e);
        }
      }), this._validateResource(r.resource).then((i) => {
        n.resolve(i);
      }).catch((i) => {
        n.reject(i);
      });
    }
  }
  _canAcquire() {
    return this.free.length > 0 && this.pendingAcquires.length > 0;
  }
  _validateResource(e) {
    try {
      return Promise.resolve(this.validate(e));
    } catch (r) {
      return Promise.reject(r);
    }
  }
  _shouldCreateMoreResources() {
    return this.used.length + this.pendingCreates.length < this.max && this.pendingCreates.length < this.pendingAcquires.length;
  }
  _doCreate() {
    const e = this.pendingAcquires.slice();
    this._create().promise.then(() => (this._tryAcquireOrCreate(), null)).catch((n) => {
      this.propagateCreateError && this.pendingAcquires.length !== 0 && this.pendingAcquires[0].reject(n), e.forEach((i) => {
        i.possibleTimeoutCause = n;
      }), Tt.delay(this.createRetryIntervalMillis).then(() => this._tryAcquireOrCreate());
    });
  }
  _create() {
    const e = this.eventId++;
    this._executeEventHandlers("createRequest", e);
    const r = new Vs.PendingOperation(this.createTimeoutMillis);
    return r.promise = r.promise.catch((n) => {
      throw ti(this.pendingCreates, r) && this._executeEventHandlers("createFail", e, n), n;
    }), this.pendingCreates.push(r), wq(this.creator).then((n) => r.isRejected ? (this.destroyer(n), null) : (ti(this.pendingCreates, r), this.free.push(new vq.Resource(n)), r.resolve(n), this._executeEventHandlers("createSuccess", e, n), null)).catch((n) => (r.isRejected || (ti(this.pendingCreates, r) && this._executeEventHandlers("createFail", e, n), r.reject(n)), null)), r;
  }
  _destroy(e) {
    const r = this.eventId++;
    this._executeEventHandlers("destroyRequest", r, e);
    const n = new Vs.PendingOperation(this.destroyTimeoutMillis);
    return Promise.resolve().then(() => this.destroyer(e)).then(() => {
      n.resolve(e);
    }).catch((a) => {
      n.reject(a);
    }), this.pendingDestroys.push(n), n.promise.then((a) => (this._executeEventHandlers("destroySuccess", r, e), a)).catch((a) => this._logDestroyerError(r, e, a)).then((a) => {
      const s = this.pendingDestroys.findIndex((o) => o === n);
      return this.pendingDestroys.splice(s, 1), a;
    });
  }
  _logDestroyerError(e, r, n) {
    this._executeEventHandlers("destroyFail", e, r, n), this.log("Tarn: resource destroyer threw an exception " + n.stack, "warn");
  }
  _startReaping() {
    this.interval || (this._executeEventHandlers("startReaping"), this.interval = setInterval(() => this.check(), this.reapIntervalMillis));
  }
  _stopReaping() {
    this.interval !== null && (this._executeEventHandlers("stopReaping"), X0.clearInterval(this.interval)), this.interval = null;
  }
  _executeEventHandlers(e, ...r) {
    this.emitter.listeners(e).forEach((i) => {
      try {
        i(...r);
      } catch (a) {
        this.log(`Tarn: event handler "${e}" threw an exception ${a.stack}`, "warn");
      }
    });
  }
};
ov.Pool = bq;
function ti(t, e) {
  const r = t.indexOf(e);
  return r === -1 ? !1 : (t.splice(r, 1), !0);
}
function wq(t) {
  return new Promise((e, r) => {
    const n = (i, a) => {
      i ? r(i) : e(a);
    };
    Tt.tryPromise(() => t(n)).then((i) => {
      i && e(i);
    }).catch((i) => {
      r(i);
    });
  });
}
(function(t, e) {
  Object.defineProperty(e, "__esModule", { value: !0 });
  const r = ov;
  e.Pool = r.Pool;
  const n = Bc;
  e.TimeoutError = n.TimeoutError, t.exports = {
    Pool: r.Pool,
    TimeoutError: n.TimeoutError
  };
})(Zm, Zm.exports);
var xq = Zm.exports;
const Oo = /[\0\b\t\n\r\x1a"'\\]/g, QT = {
  "\0": "\\0",
  "\b": "\\b",
  "	": "\\t",
  "\n": "\\n",
  "\r": "\\r",
  "": "\\Z",
  '"': '\\"',
  "'": "\\'",
  "\\": "\\\\"
};
function _q(t) {
  return function e(r, n = {}) {
    return t(r, e, n);
  };
}
function Eq(t = {}) {
  const e = t.escapeDate || JT, r = t.escapeArray || fv, n = t.escapeBuffer || KT, i = t.escapeString || hv, a = t.escapeObject || VT, s = t.wrap || _q;
  function o(c, f, u) {
    if (c == null)
      return "NULL";
    switch (typeof c) {
      case "boolean":
        return c ? "true" : "false";
      case "number":
        return c + "";
      case "object":
        if (c instanceof Date)
          c = e(c, f, u);
        else
          return Array.isArray(c) ? r(c, f, u) : Buffer.isBuffer(c) ? n(c, f, u) : a(c, f, u);
    }
    return i(c, f, u);
  }
  return s ? s(o) : o;
}
function VT(t, e, r) {
  return t && typeof t.toSQL == "function" ? t.toSQL(r) : JSON.stringify(t);
}
function fv(t, e, r) {
  let n = "";
  for (let i = 0; i < t.length; i++) {
    const a = t[i];
    Array.isArray(a) ? n += (i === 0 ? "" : ", ") + "(" + fv(a, e, r) + ")" : n += (i === 0 ? "" : ", ") + e(a, r);
  }
  return n;
}
function KT(t) {
  return "X" + hv(t.toString("hex"));
}
function hv(t, e, r) {
  let n = Oo.lastIndex = 0, i = "", a;
  for (; a = Oo.exec(t); )
    i += t.slice(n, a.index) + QT[a[0]], n = Oo.lastIndex;
  return n === 0 ? "'" + t + "'" : n < t.length ? "'" + i + t.slice(n) + "'" : "'" + i + "'";
}
function JT(t, e, r = {}) {
  const n = r.timeZone || "local", i = new Date(t);
  let a, s, o, c, f, u, l;
  if (n === "local")
    a = i.getFullYear(), s = i.getMonth() + 1, o = i.getDate(), c = i.getHours(), f = i.getMinutes(), u = i.getSeconds(), l = i.getMilliseconds();
  else {
    const p = Sq(n);
    p !== !1 && p !== 0 && i.setTime(i.getTime() + p * 6e4), a = i.getUTCFullYear(), s = i.getUTCMonth() + 1, o = i.getUTCDate(), c = i.getUTCHours(), f = i.getUTCMinutes(), u = i.getUTCSeconds(), l = i.getUTCMilliseconds();
  }
  return vn(a, 4) + "-" + vn(s, 2) + "-" + vn(o, 2) + " " + vn(c, 2) + ":" + vn(f, 2) + ":" + vn(u, 2) + "." + vn(l, 3);
}
function vn(t, e) {
  for (t = t.toString(); t.length < e; )
    t = "0" + t;
  return t;
}
function Sq(t) {
  if (t === "Z")
    return 0;
  const e = t.match(/([+\-\s])(\d\d):?(\d\d)?/);
  return e ? (e[1] == "-" ? -1 : 1) * (parseInt(e[2], 10) + (e[3] ? parseInt(e[3], 10) : 0) / 60) * 60 : !1;
}
var dv = {
  arrayToList: fv,
  bufferToString: KT,
  dateToString: JT,
  escapeString: hv,
  charsRegex: Oo,
  charsMap: QT,
  escapeObject: VT,
  makeEscape: Eq
};
function Cq() {
  this.__data__ = [], this.size = 0;
}
var Tq = Cq;
function Oq(t, e) {
  return t === e || t !== t && e !== e;
}
var Ni = Oq, Aq = Ni;
function $q(t, e) {
  for (var r = t.length; r--; )
    if (Aq(t[r][0], e))
      return r;
  return -1;
}
var Uc = $q, Iq = Uc, kq = Array.prototype, Rq = kq.splice;
function Nq(t) {
  var e = this.__data__, r = Iq(e, t);
  if (r < 0)
    return !1;
  var n = e.length - 1;
  return r == n ? e.pop() : Rq.call(e, r, 1), --this.size, !0;
}
var Lq = Nq, Pq = Uc;
function Dq(t) {
  var e = this.__data__, r = Pq(e, t);
  return r < 0 ? void 0 : e[r][1];
}
var Mq = Dq, qq = Uc;
function jq(t) {
  return qq(this.__data__, t) > -1;
}
var Fq = jq, Bq = Uc;
function Uq(t, e) {
  var r = this.__data__, n = Bq(r, t);
  return n < 0 ? (++this.size, r.push([t, e])) : r[n][1] = e, this;
}
var zq = Uq, Hq = Tq, Wq = Lq, Gq = Mq, Qq = Fq, Vq = zq;
function Li(t) {
  var e = -1, r = t == null ? 0 : t.length;
  for (this.clear(); ++e < r; ) {
    var n = t[e];
    this.set(n[0], n[1]);
  }
}
Li.prototype.clear = Hq;
Li.prototype.delete = Wq;
Li.prototype.get = Gq;
Li.prototype.has = Qq;
Li.prototype.set = Vq;
var zc = Li, Kq = zc;
function Jq() {
  this.__data__ = new Kq(), this.size = 0;
}
var Xq = Jq;
function Zq(t) {
  var e = this.__data__, r = e.delete(t);
  return this.size = e.size, r;
}
var Yq = Zq;
function ej(t) {
  return this.__data__.get(t);
}
var tj = ej;
function rj(t) {
  return this.__data__.has(t);
}
var nj = rj, ij = typeof ve == "object" && ve && ve.Object === Object && ve, XT = ij, aj = XT, sj = typeof self == "object" && self && self.Object === Object && self, oj = aj || sj || Function("return this")(), wr = oj, cj = wr, uj = cj.Symbol, Pn = uj, Z0 = Pn, ZT = Object.prototype, lj = ZT.hasOwnProperty, pj = ZT.toString, ra = Z0 ? Z0.toStringTag : void 0;
function fj(t) {
  var e = lj.call(t, ra), r = t[ra];
  try {
    t[ra] = void 0;
    var n = !0;
  } catch {
  }
  var i = pj.call(t);
  return n && (e ? t[ra] = r : delete t[ra]), i;
}
var hj = fj, dj = Object.prototype, mj = dj.toString;
function gj(t) {
  return mj.call(t);
}
var vj = gj, Y0 = Pn, yj = hj, bj = vj, wj = "[object Null]", xj = "[object Undefined]", ew = Y0 ? Y0.toStringTag : void 0;
function _j(t) {
  return t == null ? t === void 0 ? xj : wj : ew && ew in Object(t) ? yj(t) : bj(t);
}
var Dn = _j;
function Ej(t) {
  var e = typeof t;
  return t != null && (e == "object" || e == "function");
}
var Ht = Ej, Sj = Dn, Cj = Ht, Tj = "[object AsyncFunction]", Oj = "[object Function]", Aj = "[object GeneratorFunction]", $j = "[object Proxy]";
function Ij(t) {
  if (!Cj(t))
    return !1;
  var e = Sj(t);
  return e == Oj || e == Aj || e == Tj || e == $j;
}
var Hc = Ij, kj = wr, Rj = kj["__core-js_shared__"], Nj = Rj, Vl = Nj, tw = function() {
  var t = /[^.]+$/.exec(Vl && Vl.keys && Vl.keys.IE_PROTO || "");
  return t ? "Symbol(src)_1." + t : "";
}();
function Lj(t) {
  return !!tw && tw in t;
}
var Pj = Lj, Dj = Function.prototype, Mj = Dj.toString;
function qj(t) {
  if (t != null) {
    try {
      return Mj.call(t);
    } catch {
    }
    try {
      return t + "";
    } catch {
    }
  }
  return "";
}
var YT = qj, jj = Hc, Fj = Pj, Bj = Ht, Uj = YT, zj = /[\\^$.*+?()[\]{}|]/g, Hj = /^\[object .+?Constructor\]$/, Wj = Function.prototype, Gj = Object.prototype, Qj = Wj.toString, Vj = Gj.hasOwnProperty, Kj = RegExp(
  "^" + Qj.call(Vj).replace(zj, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function Jj(t) {
  if (!Bj(t) || Fj(t))
    return !1;
  var e = jj(t) ? Kj : Hj;
  return e.test(Uj(t));
}
var Xj = Jj;
function Zj(t, e) {
  return t == null ? void 0 : t[e];
}
var Yj = Zj, eF = Xj, tF = Yj;
function rF(t, e) {
  var r = tF(t, e);
  return eF(r) ? r : void 0;
}
var Mn = rF, nF = Mn, iF = wr, aF = nF(iF, "Map"), mv = aF, sF = Mn, oF = sF(Object, "create"), Wc = oF, rw = Wc;
function cF() {
  this.__data__ = rw ? rw(null) : {}, this.size = 0;
}
var uF = cF;
function lF(t) {
  var e = this.has(t) && delete this.__data__[t];
  return this.size -= e ? 1 : 0, e;
}
var pF = lF, fF = Wc, hF = "__lodash_hash_undefined__", dF = Object.prototype, mF = dF.hasOwnProperty;
function gF(t) {
  var e = this.__data__;
  if (fF) {
    var r = e[t];
    return r === hF ? void 0 : r;
  }
  return mF.call(e, t) ? e[t] : void 0;
}
var vF = gF, yF = Wc, bF = Object.prototype, wF = bF.hasOwnProperty;
function xF(t) {
  var e = this.__data__;
  return yF ? e[t] !== void 0 : wF.call(e, t);
}
var _F = xF, EF = Wc, SF = "__lodash_hash_undefined__";
function CF(t, e) {
  var r = this.__data__;
  return this.size += this.has(t) ? 0 : 1, r[t] = EF && e === void 0 ? SF : e, this;
}
var TF = CF, OF = uF, AF = pF, $F = vF, IF = _F, kF = TF;
function Pi(t) {
  var e = -1, r = t == null ? 0 : t.length;
  for (this.clear(); ++e < r; ) {
    var n = t[e];
    this.set(n[0], n[1]);
  }
}
Pi.prototype.clear = OF;
Pi.prototype.delete = AF;
Pi.prototype.get = $F;
Pi.prototype.has = IF;
Pi.prototype.set = kF;
var RF = Pi, nw = RF, NF = zc, LF = mv;
function PF() {
  this.size = 0, this.__data__ = {
    hash: new nw(),
    map: new (LF || NF)(),
    string: new nw()
  };
}
var DF = PF;
function MF(t) {
  var e = typeof t;
  return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t !== "__proto__" : t === null;
}
var qF = MF, jF = qF;
function FF(t, e) {
  var r = t.__data__;
  return jF(e) ? r[typeof e == "string" ? "string" : "hash"] : r.map;
}
var Gc = FF, BF = Gc;
function UF(t) {
  var e = BF(this, t).delete(t);
  return this.size -= e ? 1 : 0, e;
}
var zF = UF, HF = Gc;
function WF(t) {
  return HF(this, t).get(t);
}
var GF = WF, QF = Gc;
function VF(t) {
  return QF(this, t).has(t);
}
var KF = VF, JF = Gc;
function XF(t, e) {
  var r = JF(this, t), n = r.size;
  return r.set(t, e), this.size += r.size == n ? 0 : 1, this;
}
var ZF = XF, YF = DF, eB = zF, tB = GF, rB = KF, nB = ZF;
function Di(t) {
  var e = -1, r = t == null ? 0 : t.length;
  for (this.clear(); ++e < r; ) {
    var n = t[e];
    this.set(n[0], n[1]);
  }
}
Di.prototype.clear = YF;
Di.prototype.delete = eB;
Di.prototype.get = tB;
Di.prototype.has = rB;
Di.prototype.set = nB;
var gv = Di, iB = zc, aB = mv, sB = gv, oB = 200;
function cB(t, e) {
  var r = this.__data__;
  if (r instanceof iB) {
    var n = r.__data__;
    if (!aB || n.length < oB - 1)
      return n.push([t, e]), this.size = ++r.size, this;
    r = this.__data__ = new sB(n);
  }
  return r.set(t, e), this.size = r.size, this;
}
var uB = cB, lB = zc, pB = Xq, fB = Yq, hB = tj, dB = nj, mB = uB;
function Mi(t) {
  var e = this.__data__ = new lB(t);
  this.size = e.size;
}
Mi.prototype.clear = pB;
Mi.prototype.delete = fB;
Mi.prototype.get = hB;
Mi.prototype.has = dB;
Mi.prototype.set = mB;
var Qc = Mi;
function gB(t, e) {
  for (var r = -1, n = t == null ? 0 : t.length; ++r < n && e(t[r], r, t) !== !1; )
    ;
  return t;
}
var vv = gB, vB = Mn, yB = function() {
  try {
    var t = vB(Object, "defineProperty");
    return t({}, "", {}), t;
  } catch {
  }
}(), eO = yB, iw = eO;
function bB(t, e, r) {
  e == "__proto__" && iw ? iw(t, e, {
    configurable: !0,
    enumerable: !0,
    value: r,
    writable: !0
  }) : t[e] = r;
}
var Vc = bB, wB = Vc, xB = Ni, _B = Object.prototype, EB = _B.hasOwnProperty;
function SB(t, e, r) {
  var n = t[e];
  (!(EB.call(t, e) && xB(n, r)) || r === void 0 && !(e in t)) && wB(t, e, r);
}
var Kc = SB, CB = Kc, TB = Vc;
function OB(t, e, r, n) {
  var i = !r;
  r || (r = {});
  for (var a = -1, s = e.length; ++a < s; ) {
    var o = e[a], c = n ? n(r[o], t[o], o, r, t) : void 0;
    c === void 0 && (c = t[o]), i ? TB(r, o, c) : CB(r, o, c);
  }
  return r;
}
var qn = OB;
function AB(t, e) {
  for (var r = -1, n = Array(t); ++r < t; )
    n[r] = e(r);
  return n;
}
var $B = AB;
function IB(t) {
  return t != null && typeof t == "object";
}
var xr = IB, kB = Dn, RB = xr, NB = "[object Arguments]";
function LB(t) {
  return RB(t) && kB(t) == NB;
}
var PB = LB, aw = PB, DB = xr, tO = Object.prototype, MB = tO.hasOwnProperty, qB = tO.propertyIsEnumerable, jB = aw(function() {
  return arguments;
}()) ? aw : function(t) {
  return DB(t) && MB.call(t, "callee") && !qB.call(t, "callee");
}, ps = jB, FB = Array.isArray, at = FB, Wo = { exports: {} };
function BB() {
  return !1;
}
var UB = BB;
Wo.exports;
(function(t, e) {
  var r = wr, n = UB, i = e && !e.nodeType && e, a = i && !0 && t && !t.nodeType && t, s = a && a.exports === i, o = s ? r.Buffer : void 0, c = o ? o.isBuffer : void 0, f = c || n;
  t.exports = f;
})(Wo, Wo.exports);
var qi = Wo.exports, zB = 9007199254740991, HB = /^(?:0|[1-9]\d*)$/;
function WB(t, e) {
  var r = typeof t;
  return e = e ?? zB, !!e && (r == "number" || r != "symbol" && HB.test(t)) && t > -1 && t % 1 == 0 && t < e;
}
var Jc = WB, GB = 9007199254740991;
function QB(t) {
  return typeof t == "number" && t > -1 && t % 1 == 0 && t <= GB;
}
var yv = QB, VB = Dn, KB = yv, JB = xr, XB = "[object Arguments]", ZB = "[object Array]", YB = "[object Boolean]", e9 = "[object Date]", t9 = "[object Error]", r9 = "[object Function]", n9 = "[object Map]", i9 = "[object Number]", a9 = "[object Object]", s9 = "[object RegExp]", o9 = "[object Set]", c9 = "[object String]", u9 = "[object WeakMap]", l9 = "[object ArrayBuffer]", p9 = "[object DataView]", f9 = "[object Float32Array]", h9 = "[object Float64Array]", d9 = "[object Int8Array]", m9 = "[object Int16Array]", g9 = "[object Int32Array]", v9 = "[object Uint8Array]", y9 = "[object Uint8ClampedArray]", b9 = "[object Uint16Array]", w9 = "[object Uint32Array]", Ve = {};
Ve[f9] = Ve[h9] = Ve[d9] = Ve[m9] = Ve[g9] = Ve[v9] = Ve[y9] = Ve[b9] = Ve[w9] = !0;
Ve[XB] = Ve[ZB] = Ve[l9] = Ve[YB] = Ve[p9] = Ve[e9] = Ve[t9] = Ve[r9] = Ve[n9] = Ve[i9] = Ve[a9] = Ve[s9] = Ve[o9] = Ve[c9] = Ve[u9] = !1;
function x9(t) {
  return JB(t) && KB(t.length) && !!Ve[VB(t)];
}
var _9 = x9;
function E9(t) {
  return function(e) {
    return t(e);
  };
}
var bv = E9, Go = { exports: {} };
Go.exports;
(function(t, e) {
  var r = XT, n = e && !e.nodeType && e, i = n && !0 && t && !t.nodeType && t, a = i && i.exports === n, s = a && r.process, o = function() {
    try {
      var c = i && i.require && i.require("util").types;
      return c || s && s.binding && s.binding("util");
    } catch {
    }
  }();
  t.exports = o;
})(Go, Go.exports);
var wv = Go.exports, S9 = _9, C9 = bv, sw = wv, ow = sw && sw.isTypedArray, T9 = ow ? C9(ow) : S9, ji = T9, O9 = $B, A9 = ps, $9 = at, I9 = qi, k9 = Jc, R9 = ji, N9 = Object.prototype, L9 = N9.hasOwnProperty;
function P9(t, e) {
  var r = $9(t), n = !r && A9(t), i = !r && !n && I9(t), a = !r && !n && !i && R9(t), s = r || n || i || a, o = s ? O9(t.length, String) : [], c = o.length;
  for (var f in t)
    (e || L9.call(t, f)) && !(s && // Safari 9 has enumerable `arguments.length` in strict mode.
    (f == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    i && (f == "offset" || f == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    a && (f == "buffer" || f == "byteLength" || f == "byteOffset") || // Skip index properties.
    k9(f, c))) && o.push(f);
  return o;
}
var rO = P9, D9 = Object.prototype;
function M9(t) {
  var e = t && t.constructor, r = typeof e == "function" && e.prototype || D9;
  return t === r;
}
var fs = M9;
function q9(t, e) {
  return function(r) {
    return t(e(r));
  };
}
var nO = q9, j9 = nO, F9 = j9(Object.keys, Object), B9 = F9, U9 = fs, z9 = B9, H9 = Object.prototype, W9 = H9.hasOwnProperty;
function G9(t) {
  if (!U9(t))
    return z9(t);
  var e = [];
  for (var r in Object(t))
    W9.call(t, r) && r != "constructor" && e.push(r);
  return e;
}
var iO = G9, Q9 = Hc, V9 = yv;
function K9(t) {
  return t != null && V9(t.length) && !Q9(t);
}
var jr = K9, J9 = rO, X9 = iO, Z9 = jr;
function Y9(t) {
  return Z9(t) ? J9(t) : X9(t);
}
var jn = Y9, e7 = qn, t7 = jn;
function r7(t, e) {
  return t && e7(e, t7(e), t);
}
var n7 = r7;
function i7(t) {
  var e = [];
  if (t != null)
    for (var r in Object(t))
      e.push(r);
  return e;
}
var a7 = i7, s7 = Ht, o7 = fs, c7 = a7, u7 = Object.prototype, l7 = u7.hasOwnProperty;
function p7(t) {
  if (!s7(t))
    return c7(t);
  var e = o7(t), r = [];
  for (var n in t)
    n == "constructor" && (e || !l7.call(t, n)) || r.push(n);
  return r;
}
var f7 = p7, h7 = rO, d7 = f7, m7 = jr;
function g7(t) {
  return m7(t) ? h7(t, !0) : d7(t);
}
var Fn = g7, v7 = qn, y7 = Fn;
function b7(t, e) {
  return t && v7(e, y7(e), t);
}
var w7 = b7, Qo = { exports: {} };
Qo.exports;
(function(t, e) {
  var r = wr, n = e && !e.nodeType && e, i = n && !0 && t && !t.nodeType && t, a = i && i.exports === n, s = a ? r.Buffer : void 0, o = s ? s.allocUnsafe : void 0;
  function c(f, u) {
    if (u)
      return f.slice();
    var l = f.length, p = o ? o(l) : new f.constructor(l);
    return f.copy(p), p;
  }
  t.exports = c;
})(Qo, Qo.exports);
var aO = Qo.exports;
function x7(t, e) {
  var r = -1, n = t.length;
  for (e || (e = Array(n)); ++r < n; )
    e[r] = t[r];
  return e;
}
var xv = x7;
function _7(t, e) {
  for (var r = -1, n = t == null ? 0 : t.length, i = 0, a = []; ++r < n; ) {
    var s = t[r];
    e(s, r, t) && (a[i++] = s);
  }
  return a;
}
var _v = _7;
function E7() {
  return [];
}
var sO = E7, S7 = _v, C7 = sO, T7 = Object.prototype, O7 = T7.propertyIsEnumerable, cw = Object.getOwnPropertySymbols, A7 = cw ? function(t) {
  return t == null ? [] : (t = Object(t), S7(cw(t), function(e) {
    return O7.call(t, e);
  }));
} : C7, Ev = A7, $7 = qn, I7 = Ev;
function k7(t, e) {
  return $7(t, I7(t), e);
}
var R7 = k7;
function N7(t, e) {
  for (var r = -1, n = e.length, i = t.length; ++r < n; )
    t[i + r] = e[r];
  return t;
}
var Sv = N7, L7 = nO, P7 = L7(Object.getPrototypeOf, Object), Xc = P7, D7 = Sv, M7 = Xc, q7 = Ev, j7 = sO, F7 = Object.getOwnPropertySymbols, B7 = F7 ? function(t) {
  for (var e = []; t; )
    D7(e, q7(t)), t = M7(t);
  return e;
} : j7, oO = B7, U7 = qn, z7 = oO;
function H7(t, e) {
  return U7(t, z7(t), e);
}
var W7 = H7, G7 = Sv, Q7 = at;
function V7(t, e, r) {
  var n = e(t);
  return Q7(t) ? n : G7(n, r(t));
}
var cO = V7, K7 = cO, J7 = Ev, X7 = jn;
function Z7(t) {
  return K7(t, X7, J7);
}
var uO = Z7, Y7 = cO, eU = oO, tU = Fn;
function rU(t) {
  return Y7(t, tU, eU);
}
var lO = rU, nU = Mn, iU = wr, aU = nU(iU, "DataView"), sU = aU, oU = Mn, cU = wr, uU = oU(cU, "Promise"), lU = uU, pU = Mn, fU = wr, hU = pU(fU, "Set"), pO = hU, dU = Mn, mU = wr, gU = dU(mU, "WeakMap"), vU = gU, Ym = sU, eg = mv, tg = lU, rg = pO, ng = vU, fO = Dn, Fi = YT, uw = "[object Map]", yU = "[object Object]", lw = "[object Promise]", pw = "[object Set]", fw = "[object WeakMap]", hw = "[object DataView]", bU = Fi(Ym), wU = Fi(eg), xU = Fi(tg), _U = Fi(rg), EU = Fi(ng), _n = fO;
(Ym && _n(new Ym(new ArrayBuffer(1))) != hw || eg && _n(new eg()) != uw || tg && _n(tg.resolve()) != lw || rg && _n(new rg()) != pw || ng && _n(new ng()) != fw) && (_n = function(t) {
  var e = fO(t), r = e == yU ? t.constructor : void 0, n = r ? Fi(r) : "";
  if (n)
    switch (n) {
      case bU:
        return hw;
      case wU:
        return uw;
      case xU:
        return lw;
      case _U:
        return pw;
      case EU:
        return fw;
    }
  return e;
});
var Bi = _n, SU = Object.prototype, CU = SU.hasOwnProperty;
function TU(t) {
  var e = t.length, r = new t.constructor(e);
  return e && typeof t[0] == "string" && CU.call(t, "index") && (r.index = t.index, r.input = t.input), r;
}
var OU = TU, AU = wr, $U = AU.Uint8Array, hO = $U, dw = hO;
function IU(t) {
  var e = new t.constructor(t.byteLength);
  return new dw(e).set(new dw(t)), e;
}
var Cv = IU, kU = Cv;
function RU(t, e) {
  var r = e ? kU(t.buffer) : t.buffer;
  return new t.constructor(r, t.byteOffset, t.byteLength);
}
var NU = RU, LU = /\w*$/;
function PU(t) {
  var e = new t.constructor(t.source, LU.exec(t));
  return e.lastIndex = t.lastIndex, e;
}
var DU = PU, mw = Pn, gw = mw ? mw.prototype : void 0, vw = gw ? gw.valueOf : void 0;
function MU(t) {
  return vw ? Object(vw.call(t)) : {};
}
var qU = MU, jU = Cv;
function FU(t, e) {
  var r = e ? jU(t.buffer) : t.buffer;
  return new t.constructor(r, t.byteOffset, t.length);
}
var dO = FU, BU = Cv, UU = NU, zU = DU, HU = qU, WU = dO, GU = "[object Boolean]", QU = "[object Date]", VU = "[object Map]", KU = "[object Number]", JU = "[object RegExp]", XU = "[object Set]", ZU = "[object String]", YU = "[object Symbol]", ez = "[object ArrayBuffer]", tz = "[object DataView]", rz = "[object Float32Array]", nz = "[object Float64Array]", iz = "[object Int8Array]", az = "[object Int16Array]", sz = "[object Int32Array]", oz = "[object Uint8Array]", cz = "[object Uint8ClampedArray]", uz = "[object Uint16Array]", lz = "[object Uint32Array]";
function pz(t, e, r) {
  var n = t.constructor;
  switch (e) {
    case ez:
      return BU(t);
    case GU:
    case QU:
      return new n(+t);
    case tz:
      return UU(t, r);
    case rz:
    case nz:
    case iz:
    case az:
    case sz:
    case oz:
    case cz:
    case uz:
    case lz:
      return WU(t, r);
    case VU:
      return new n();
    case KU:
    case ZU:
      return new n(t);
    case JU:
      return zU(t);
    case XU:
      return new n();
    case YU:
      return HU(t);
  }
}
var fz = pz, hz = Ht, yw = Object.create, dz = function() {
  function t() {
  }
  return function(e) {
    if (!hz(e))
      return {};
    if (yw)
      return yw(e);
    t.prototype = e;
    var r = new t();
    return t.prototype = void 0, r;
  };
}(), mO = dz, mz = mO, gz = Xc, vz = fs;
function yz(t) {
  return typeof t.constructor == "function" && !vz(t) ? mz(gz(t)) : {};
}
var gO = yz, bz = Bi, wz = xr, xz = "[object Map]";
function _z(t) {
  return wz(t) && bz(t) == xz;
}
var Ez = _z, Sz = Ez, Cz = bv, bw = wv, ww = bw && bw.isMap, Tz = ww ? Cz(ww) : Sz, Oz = Tz, Az = Bi, $z = xr, Iz = "[object Set]";
function kz(t) {
  return $z(t) && Az(t) == Iz;
}
var Rz = kz, Nz = Rz, Lz = bv, xw = wv, _w = xw && xw.isSet, Pz = _w ? Lz(_w) : Nz, Dz = Pz, Mz = Qc, qz = vv, jz = Kc, Fz = n7, Bz = w7, Uz = aO, zz = xv, Hz = R7, Wz = W7, Gz = uO, Qz = lO, Vz = Bi, Kz = OU, Jz = fz, Xz = gO, Zz = at, Yz = qi, eH = Oz, tH = Ht, rH = Dz, nH = jn, iH = Fn, aH = 1, sH = 2, oH = 4, vO = "[object Arguments]", cH = "[object Array]", uH = "[object Boolean]", lH = "[object Date]", pH = "[object Error]", yO = "[object Function]", fH = "[object GeneratorFunction]", hH = "[object Map]", dH = "[object Number]", bO = "[object Object]", mH = "[object RegExp]", gH = "[object Set]", vH = "[object String]", yH = "[object Symbol]", bH = "[object WeakMap]", wH = "[object ArrayBuffer]", xH = "[object DataView]", _H = "[object Float32Array]", EH = "[object Float64Array]", SH = "[object Int8Array]", CH = "[object Int16Array]", TH = "[object Int32Array]", OH = "[object Uint8Array]", AH = "[object Uint8ClampedArray]", $H = "[object Uint16Array]", IH = "[object Uint32Array]", He = {};
He[vO] = He[cH] = He[wH] = He[xH] = He[uH] = He[lH] = He[_H] = He[EH] = He[SH] = He[CH] = He[TH] = He[hH] = He[dH] = He[bO] = He[mH] = He[gH] = He[vH] = He[yH] = He[OH] = He[AH] = He[$H] = He[IH] = !0;
He[pH] = He[yO] = He[bH] = !1;
function Ao(t, e, r, n, i, a) {
  var s, o = e & aH, c = e & sH, f = e & oH;
  if (r && (s = i ? r(t, n, i, a) : r(t)), s !== void 0)
    return s;
  if (!tH(t))
    return t;
  var u = Zz(t);
  if (u) {
    if (s = Kz(t), !o)
      return zz(t, s);
  } else {
    var l = Vz(t), p = l == yO || l == fH;
    if (Yz(t))
      return Uz(t, o);
    if (l == bO || l == vO || p && !i) {
      if (s = c || p ? {} : Xz(t), !o)
        return c ? Wz(t, Bz(s, t)) : Hz(t, Fz(s, t));
    } else {
      if (!He[l])
        return i ? t : {};
      s = Jz(t, l, o);
    }
  }
  a || (a = new Mz());
  var m = a.get(t);
  if (m)
    return m;
  a.set(t, s), rH(t) ? t.forEach(function(v) {
    s.add(Ao(v, e, r, v, t, a));
  }) : eH(t) && t.forEach(function(v, d) {
    s.set(d, Ao(v, e, r, d, t, a));
  });
  var h = f ? c ? Qz : Gz : c ? iH : nH, g = u ? void 0 : h(t);
  return qz(g || t, function(v, d) {
    g && (d = v, v = t[d]), jz(s, d, Ao(v, e, r, d, t, a));
  }), s;
}
var wO = Ao, kH = wO, RH = 1, NH = 4;
function LH(t) {
  return kH(t, RH | NH);
}
var PH = LH;
function DH(t) {
  return t;
}
var Wt = DH;
function MH(t, e, r) {
  switch (r.length) {
    case 0:
      return t.call(e);
    case 1:
      return t.call(e, r[0]);
    case 2:
      return t.call(e, r[0], r[1]);
    case 3:
      return t.call(e, r[0], r[1], r[2]);
  }
  return t.apply(e, r);
}
var qH = MH, jH = qH, Ew = Math.max;
function FH(t, e, r) {
  return e = Ew(e === void 0 ? t.length - 1 : e, 0), function() {
    for (var n = arguments, i = -1, a = Ew(n.length - e, 0), s = Array(a); ++i < a; )
      s[i] = n[e + i];
    i = -1;
    for (var o = Array(e + 1); ++i < e; )
      o[i] = n[i];
    return o[e] = r(s), jH(t, this, o);
  };
}
var BH = FH;
function UH(t) {
  return function() {
    return t;
  };
}
var xO = UH, zH = xO, Sw = eO, HH = Wt, WH = Sw ? function(t, e) {
  return Sw(t, "toString", {
    configurable: !0,
    enumerable: !1,
    value: zH(e),
    writable: !0
  });
} : HH, GH = WH, QH = 800, VH = 16, KH = Date.now;
function JH(t) {
  var e = 0, r = 0;
  return function() {
    var n = KH(), i = VH - (n - r);
    if (r = n, i > 0) {
      if (++e >= QH)
        return arguments[0];
    } else
      e = 0;
    return t.apply(void 0, arguments);
  };
}
var XH = JH, ZH = GH, YH = XH, eW = YH(ZH), tW = eW, rW = Wt, nW = BH, iW = tW;
function aW(t, e) {
  return iW(nW(t, e, rW), t + "");
}
var Tv = aW, sW = Ni, oW = jr, cW = Jc, uW = Ht;
function lW(t, e, r) {
  if (!uW(r))
    return !1;
  var n = typeof e;
  return (n == "number" ? oW(r) && cW(e, r.length) : n == "string" && e in r) ? sW(r[e], t) : !1;
}
var Zc = lW, pW = Tv, fW = Ni, hW = Zc, dW = Fn, _O = Object.prototype, mW = _O.hasOwnProperty, gW = pW(function(t, e) {
  t = Object(t);
  var r = -1, n = e.length, i = n > 2 ? e[2] : void 0;
  for (i && hW(e[0], e[1], i) && (n = 1); ++r < n; )
    for (var a = e[r], s = dW(a), o = -1, c = s.length; ++o < c; ) {
      var f = s[o], u = t[f];
      (u === void 0 || fW(u, _O[f]) && !mW.call(t, f)) && (t[f] = a[f]);
    }
  return t;
}), EO = gW;
function vW(t, e) {
  for (var r = -1, n = t == null ? 0 : t.length, i = Array(n); ++r < n; )
    i[r] = e(t[r], r, t);
  return i;
}
var Yc = vW, yW = Dn, bW = xr, wW = "[object Symbol]";
function xW(t) {
  return typeof t == "symbol" || bW(t) && yW(t) == wW;
}
var eu = xW, Cw = Pn, _W = Yc, EW = at, SW = eu, CW = 1 / 0, Tw = Cw ? Cw.prototype : void 0, Ow = Tw ? Tw.toString : void 0;
function SO(t) {
  if (typeof t == "string")
    return t;
  if (EW(t))
    return _W(t, SO) + "";
  if (SW(t))
    return Ow ? Ow.call(t) : "";
  var e = t + "";
  return e == "0" && 1 / t == -CW ? "-0" : e;
}
var TW = SO, OW = TW;
function AW(t) {
  return t == null ? "" : OW(t);
}
var CO = AW, $W = CO, IW = 0;
function kW(t) {
  var e = ++IW;
  return $W(t) + e;
}
var TO = kW, cn = {};
let OO = class extends Error {
  constructor(e) {
    super(e), this.name = "KnexTimeoutError";
  }
};
function RW(t, e) {
  return new Promise(function(r, n) {
    const i = setTimeout(function() {
      n(new OO("operation timed out"));
    }, e);
    function a(o) {
      clearTimeout(i), r(o);
    }
    function s(o) {
      clearTimeout(i), n(o);
    }
    t.then(a, s);
  });
}
cn.KnexTimeoutError = OO;
cn.timeout = RW;
function NW(t) {
  t.client.emit("start", t.builder), t.builder.emit("start", t.builder);
  const e = t.builder.toSQL();
  return t.builder._debug && t.client.logger.debug(e), Array.isArray(e) ? t.queryArray(e) : t.query(e);
}
function LW(t, e) {
  try {
    const r = t.builder.toSQL();
    if (Array.isArray(r) && e.hasHandler)
      throw new Error(
        "The stream may only be used with a single query statement."
      );
    return t.client.stream(
      t.connection,
      r,
      e.stream,
      e.options
    );
  } catch (r) {
    throw e.stream.emit("error", r), r;
  }
}
var PW = {
  ensureConnectionCallback: NW,
  ensureConnectionStreamCallback: LW
};
const { KnexTimeoutError: Aw } = cn, { timeout: DW } = cn, {
  ensureConnectionCallback: MW,
  ensureConnectionStreamCallback: qW
} = PW;
let Kl, jW = class AO {
  constructor(e, r) {
    this.client = e, this.builder = r, this.queries = [], this.connection = void 0;
  }
  // "Run" the target, calling "toSQL" on the builder, returning
  // an object or array of queries to run, each of which are run on
  // a single connection.
  async run() {
    const e = this;
    try {
      const r = await this.ensureConnection(MW);
      return e.builder.emit("end"), r;
    } catch (r) {
      throw e.builder._events && e.builder._events.error && e.builder.emit("error", r), r;
    }
  }
  // Stream the result set, by passing through to the dialect's streaming
  // capabilities. If the options are
  stream(e, r) {
    const n = typeof e == "function" && arguments.length === 1, i = n ? {} : e, a = n ? e : r, s = typeof a == "function";
    Kl = Kl || se.Transform;
    const o = this.builder.queryContext(), c = new Kl({
      objectMode: !0,
      transform: (u, l, p) => {
        p(null, this.client.postProcessResponse(u, o));
      }
    });
    c.on("close", () => {
      this.client.releaseConnection(this.connection);
    });
    const f = this.ensureConnection(
      qW,
      {
        options: i,
        hasHandler: s,
        stream: c
      }
    ).catch((u) => {
      this.connection || c.emit("error", u);
    });
    return s ? (a(c), f) : c;
  }
  // Allow you to pipe the stream to a writable stream.
  pipe(e, r) {
    return this.stream(r).pipe(e);
  }
  // "Runs" a query, returning a promise. All queries specified by the builder are guaranteed
  // to run in sequence, and on the same connection, especially helpful when schema building
  // and dealing with foreign key constraints, etc.
  async query(e) {
    const { __knexUid: r, __knexTxId: n } = this.connection;
    this.builder.emit("query", Object.assign({ __knexUid: r, __knexTxId: n }, e));
    const i = this, a = this.builder.queryContext();
    e !== null && typeof e == "object" && (e.queryContext = a);
    let s = this.client.query(this.connection, e);
    return e.timeout && (s = DW(s, e.timeout)), s.then((o) => this.client.processResponse(o, i)).then((o) => {
      const c = this.client.postProcessResponse(
        o,
        a
      );
      return this.builder.emit(
        "query-response",
        c,
        Object.assign({ __knexUid: r, __knexTxId: n }, e),
        this.builder
      ), this.client.emit(
        "query-response",
        c,
        Object.assign({ __knexUid: r, __knexTxId: n }, e),
        this.builder
      ), c;
    }).catch((o) => {
      if (!(o instanceof Aw))
        return Promise.reject(o);
      const { timeout: c, sql: f, bindings: u } = e;
      let l;
      return e.cancelOnTimeout ? l = this.client.cancelQuery(this.connection) : (this.connection.__knex__disposed = o, l = Promise.resolve()), l.catch((p) => {
        throw this.connection.__knex__disposed = o, Object.assign(p, {
          message: `After query timeout of ${c}ms exceeded, cancelling of query failed.`,
          sql: f,
          bindings: u,
          timeout: c
        });
      }).then(() => {
        throw Object.assign(o, {
          message: `Defined query timeout of ${c}ms exceeded when running query.`,
          sql: f,
          bindings: u,
          timeout: c
        });
      });
    }).catch((o) => {
      throw this.builder.emit(
        "query-error",
        o,
        Object.assign({ __knexUid: r, __knexTxId: n, queryContext: a }, e)
      ), o;
    });
  }
  // In the case of the "schema builder" we call `queryArray`, which runs each
  // of the queries in sequence.
  async queryArray(e) {
    if (e.length === 1) {
      const n = e[0];
      if (!n.statementsProducer)
        return this.query(n);
      const i = await n.statementsProducer(
        void 0,
        this.connection
      ), a = i.sql.map((f) => ({
        sql: f,
        bindings: n.bindings
      })), s = i.pre.map((f) => ({
        sql: f,
        bindings: n.bindings
      })), o = i.post.map((f) => ({
        sql: f,
        bindings: n.bindings
      }));
      let c = [];
      await this.queryArray(s);
      try {
        await this.client.transaction(
          async (f) => {
            const u = new AO(f.client, this.builder);
            if (u.connection = this.connection, c = await u.queryArray(a), i.check && (await f.raw(i.check)).length > 0)
              throw new Error("FOREIGN KEY constraint failed");
          },
          { connection: this.connection }
        );
      } finally {
        await this.queryArray(o);
      }
      return c;
    }
    const r = [];
    for (const n of e)
      r.push(await this.queryArray([n]));
    return r;
  }
  // Check whether there's a transaction flag, and that it has a connection.
  async ensureConnection(e, r) {
    if (this.builder._connection && (this.connection = this.builder._connection), this.connection)
      return e(this, r);
    let n;
    try {
      n = await this.client.acquireConnection();
    } catch (i) {
      if (!(i instanceof Aw))
        return Promise.reject(i);
      throw this.builder && (i.sql = this.builder.sql, i.bindings = this.builder.bindings), i;
    }
    try {
      return this.connection = n, await e(this, r);
    } finally {
      await this.client.releaseConnection(n);
    }
  }
};
var FW = jW, ig = { exports: {} }, Jl, $w;
function BW() {
  if ($w)
    return Jl;
  $w = 1;
  var t = 1e3, e = t * 60, r = e * 60, n = r * 24, i = n * 7, a = n * 365.25;
  Jl = function(u, l) {
    l = l || {};
    var p = typeof u;
    if (p === "string" && u.length > 0)
      return s(u);
    if (p === "number" && isFinite(u))
      return l.long ? c(u) : o(u);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(u)
    );
  };
  function s(u) {
    if (u = String(u), !(u.length > 100)) {
      var l = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        u
      );
      if (l) {
        var p = parseFloat(l[1]), m = (l[2] || "ms").toLowerCase();
        switch (m) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return p * a;
          case "weeks":
          case "week":
          case "w":
            return p * i;
          case "days":
          case "day":
          case "d":
            return p * n;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return p * r;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return p * e;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return p * t;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return p;
          default:
            return;
        }
      }
    }
  }
  function o(u) {
    var l = Math.abs(u);
    return l >= n ? Math.round(u / n) + "d" : l >= r ? Math.round(u / r) + "h" : l >= e ? Math.round(u / e) + "m" : l >= t ? Math.round(u / t) + "s" : u + "ms";
  }
  function c(u) {
    var l = Math.abs(u);
    return l >= n ? f(u, l, n, "day") : l >= r ? f(u, l, r, "hour") : l >= e ? f(u, l, e, "minute") : l >= t ? f(u, l, t, "second") : u + " ms";
  }
  function f(u, l, p, m) {
    var h = l >= p * 1.5;
    return Math.round(u / p) + " " + m + (h ? "s" : "");
  }
  return Jl;
}
function UW(t) {
  r.debug = r, r.default = r, r.coerce = c, r.disable = a, r.enable = i, r.enabled = s, r.humanize = BW(), r.destroy = f, Object.keys(t).forEach((u) => {
    r[u] = t[u];
  }), r.names = [], r.skips = [], r.formatters = {};
  function e(u) {
    let l = 0;
    for (let p = 0; p < u.length; p++)
      l = (l << 5) - l + u.charCodeAt(p), l |= 0;
    return r.colors[Math.abs(l) % r.colors.length];
  }
  r.selectColor = e;
  function r(u) {
    let l, p = null, m, h;
    function g(...v) {
      if (!g.enabled)
        return;
      const d = g, y = Number(/* @__PURE__ */ new Date()), x = y - (l || y);
      d.diff = x, d.prev = l, d.curr = y, l = y, v[0] = r.coerce(v[0]), typeof v[0] != "string" && v.unshift("%O");
      let b = 0;
      v[0] = v[0].replace(/%([a-zA-Z%])/g, (S, T) => {
        if (S === "%%")
          return "%";
        b++;
        const E = r.formatters[T];
        if (typeof E == "function") {
          const C = v[b];
          S = E.call(d, C), v.splice(b, 1), b--;
        }
        return S;
      }), r.formatArgs.call(d, v), (d.log || r.log).apply(d, v);
    }
    return g.namespace = u, g.useColors = r.useColors(), g.color = r.selectColor(u), g.extend = n, g.destroy = r.destroy, Object.defineProperty(g, "enabled", {
      enumerable: !0,
      configurable: !1,
      get: () => p !== null ? p : (m !== r.namespaces && (m = r.namespaces, h = r.enabled(u)), h),
      set: (v) => {
        p = v;
      }
    }), typeof r.init == "function" && r.init(g), g;
  }
  function n(u, l) {
    const p = r(this.namespace + (typeof l > "u" ? ":" : l) + u);
    return p.log = this.log, p;
  }
  function i(u) {
    r.save(u), r.namespaces = u, r.names = [], r.skips = [];
    let l;
    const p = (typeof u == "string" ? u : "").split(/[\s,]+/), m = p.length;
    for (l = 0; l < m; l++)
      p[l] && (u = p[l].replace(/\*/g, ".*?"), u[0] === "-" ? r.skips.push(new RegExp("^" + u.slice(1) + "$")) : r.names.push(new RegExp("^" + u + "$")));
  }
  function a() {
    const u = [
      ...r.names.map(o),
      ...r.skips.map(o).map((l) => "-" + l)
    ].join(",");
    return r.enable(""), u;
  }
  function s(u) {
    if (u[u.length - 1] === "*")
      return !0;
    let l, p;
    for (l = 0, p = r.skips.length; l < p; l++)
      if (r.skips[l].test(u))
        return !1;
    for (l = 0, p = r.names.length; l < p; l++)
      if (r.names[l].test(u))
        return !0;
    return !1;
  }
  function o(u) {
    return u.toString().substring(2, u.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function c(u) {
    return u instanceof Error ? u.stack || u.message : u;
  }
  function f() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  return r.enable(r.load()), r;
}
var zW = UW;
(function(t, e) {
  e.formatArgs = n, e.save = i, e.load = a, e.useColors = r, e.storage = s(), e.destroy = (() => {
    let c = !1;
    return () => {
      c || (c = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), e.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function r() {
    return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? !0 : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function n(c) {
    if (c[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + c[0] + (this.useColors ? "%c " : " ") + "+" + t.exports.humanize(this.diff), !this.useColors)
      return;
    const f = "color: " + this.color;
    c.splice(1, 0, f, "color: inherit");
    let u = 0, l = 0;
    c[0].replace(/%[a-zA-Z%]/g, (p) => {
      p !== "%%" && (u++, p === "%c" && (l = u));
    }), c.splice(l, 0, f);
  }
  e.log = console.debug || console.log || (() => {
  });
  function i(c) {
    try {
      c ? e.storage.setItem("debug", c) : e.storage.removeItem("debug");
    } catch {
    }
  }
  function a() {
    let c;
    try {
      c = e.storage.getItem("debug");
    } catch {
    }
    return !c && typeof process < "u" && "env" in process && (c = process.env.DEBUG), c;
  }
  function s() {
    try {
      return localStorage;
    } catch {
    }
  }
  t.exports = zW(e);
  const { formatters: o } = t.exports;
  o.j = function(c) {
    try {
      return JSON.stringify(c);
    } catch (f) {
      return "[UnexpectedJSONParseError]: " + f.message;
    }
  };
})(ig, ig.exports);
var ar = ig.exports, tu = function() {
};
let HW = class {
  constructor(e) {
    this.client = e;
  }
  now(e) {
    return typeof e == "number" ? this.client.raw(`CURRENT_TIMESTAMP(${e})`) : this.client.raw("CURRENT_TIMESTAMP");
  }
  uuidToBin(e, r = !0) {
    const n = Buffer.from(e.replace(/-/g, ""), "hex");
    return r ? Buffer.concat([
      n.slice(6, 8),
      n.slice(4, 6),
      n.slice(0, 4),
      n.slice(8, 16)
    ]) : Buffer.concat([
      n.slice(0, 4),
      n.slice(4, 6),
      n.slice(6, 8),
      n.slice(8, 16)
    ]);
  }
  binToUuid(e, r = !0) {
    const n = Buffer.from(e, "hex");
    return r ? [
      n.toString("hex", 4, 8),
      n.toString("hex", 2, 4),
      n.toString("hex", 0, 2),
      n.toString("hex", 8, 10),
      n.toString("hex", 10, 16)
    ].join("-") : [
      n.toString("hex", 0, 4),
      n.toString("hex", 4, 6),
      n.toString("hex", 6, 8),
      n.toString("hex", 8, 10),
      n.toString("hex", 10, 16)
    ].join("-");
  }
};
var WW = HW, $O = [
  "with",
  "withRecursive",
  "withMaterialized",
  "withNotMaterialized",
  "select",
  "as",
  "columns",
  "column",
  "from",
  "fromJS",
  "fromRaw",
  "into",
  "withSchema",
  "table",
  "distinct",
  "join",
  "joinRaw",
  "innerJoin",
  "leftJoin",
  "leftOuterJoin",
  "rightJoin",
  "rightOuterJoin",
  "outerJoin",
  "fullOuterJoin",
  "crossJoin",
  "where",
  "andWhere",
  "orWhere",
  "whereNot",
  "orWhereNot",
  "whereLike",
  "andWhereLike",
  "orWhereLike",
  "whereILike",
  "andWhereILike",
  "orWhereILike",
  "whereRaw",
  "whereWrapped",
  "havingWrapped",
  "orWhereRaw",
  "whereExists",
  "orWhereExists",
  "whereNotExists",
  "orWhereNotExists",
  "whereIn",
  "orWhereIn",
  "whereNotIn",
  "orWhereNotIn",
  "whereNull",
  "orWhereNull",
  "whereNotNull",
  "orWhereNotNull",
  "whereBetween",
  "whereNotBetween",
  "andWhereBetween",
  "andWhereNotBetween",
  "orWhereBetween",
  "orWhereNotBetween",
  "groupBy",
  "groupByRaw",
  "orderBy",
  "orderByRaw",
  "union",
  "unionAll",
  "intersect",
  "having",
  "havingRaw",
  "orHaving",
  "orHavingRaw",
  "offset",
  "limit",
  "count",
  "countDistinct",
  "min",
  "max",
  "sum",
  "sumDistinct",
  "avg",
  "avgDistinct",
  "increment",
  "decrement",
  "first",
  "debug",
  "pluck",
  "clearSelect",
  "clearWhere",
  "clearGroup",
  "clearOrder",
  "clearHaving",
  "insert",
  "update",
  "returning",
  "del",
  "delete",
  "truncate",
  "transacting",
  "connection",
  // JSON methods
  // Json manipulation functions
  "jsonExtract",
  "jsonSet",
  "jsonInsert",
  "jsonRemove",
  // Wheres Json
  "whereJsonObject",
  "orWhereJsonObject",
  "andWhereJsonObject",
  "whereNotJsonObject",
  "orWhereNotJsonObject",
  "andWhereNotJsonObject",
  "whereJsonPath",
  "orWhereJsonPath",
  "andWhereJsonPath",
  "whereJsonSupersetOf",
  "orWhereJsonSupersetOf",
  "andWhereJsonSupersetOf",
  "whereJsonNotSupersetOf",
  "orWhereJsonNotSupersetOf",
  "andWhereJsonNotSupersetOf",
  "whereJsonSubsetOf",
  "orWhereJsonSubsetOf",
  "andWhereJsonSubsetOf",
  "whereJsonNotSubsetOf",
  "orWhereJsonNotSubsetOf",
  "andWhereJsonNotSubsetOf"
], GW = Vc, QW = Ni;
function VW(t, e, r) {
  (r !== void 0 && !QW(t[e], r) || r === void 0 && !(e in t)) && GW(t, e, r);
}
var IO = VW;
function KW(t) {
  return function(e, r, n) {
    for (var i = -1, a = Object(e), s = n(e), o = s.length; o--; ) {
      var c = s[t ? o : ++i];
      if (r(a[c], c, a) === !1)
        break;
    }
    return e;
  };
}
var JW = KW, XW = JW, ZW = XW(), kO = ZW, YW = jr, eG = xr;
function tG(t) {
  return eG(t) && YW(t);
}
var rG = tG, nG = Dn, iG = Xc, aG = xr, sG = "[object Object]", oG = Function.prototype, cG = Object.prototype, RO = oG.toString, uG = cG.hasOwnProperty, lG = RO.call(Object);
function pG(t) {
  if (!aG(t) || nG(t) != sG)
    return !1;
  var e = iG(t);
  if (e === null)
    return !0;
  var r = uG.call(e, "constructor") && e.constructor;
  return typeof r == "function" && r instanceof r && RO.call(r) == lG;
}
var un = pG;
function fG(t, e) {
  if (!(e === "constructor" && typeof t[e] == "function") && e != "__proto__")
    return t[e];
}
var NO = fG, hG = qn, dG = Fn;
function mG(t) {
  return hG(t, dG(t));
}
var gG = mG, Iw = IO, vG = aO, yG = dO, bG = xv, wG = gO, kw = ps, Rw = at, xG = rG, _G = qi, EG = Hc, SG = Ht, CG = un, TG = ji, Nw = NO, OG = gG;
function AG(t, e, r, n, i, a, s) {
  var o = Nw(t, r), c = Nw(e, r), f = s.get(c);
  if (f) {
    Iw(t, r, f);
    return;
  }
  var u = a ? a(o, c, r + "", t, e, s) : void 0, l = u === void 0;
  if (l) {
    var p = Rw(c), m = !p && _G(c), h = !p && !m && TG(c);
    u = c, p || m || h ? Rw(o) ? u = o : xG(o) ? u = bG(o) : m ? (l = !1, u = vG(c, !0)) : h ? (l = !1, u = yG(c, !0)) : u = [] : CG(c) || kw(c) ? (u = o, kw(o) ? u = OG(o) : (!SG(o) || EG(o)) && (u = wG(c))) : l = !1;
  }
  l && (s.set(c, u), i(u, c, n, a, s), s.delete(c)), Iw(t, r, u);
}
var $G = AG, IG = Qc, kG = IO, RG = kO, NG = $G, LG = Ht, PG = Fn, DG = NO;
function LO(t, e, r, n, i) {
  t !== e && RG(e, function(a, s) {
    if (i || (i = new IG()), LG(a))
      NG(t, e, s, r, LO, n, i);
    else {
      var o = n ? n(DG(t, s), a, s + "", t, e, i) : void 0;
      o === void 0 && (o = a), kG(t, s, o);
    }
  }, PG);
}
var MG = LO, qG = Tv, jG = Zc;
function FG(t) {
  return qG(function(e, r) {
    var n = -1, i = r.length, a = i > 1 ? r[i - 1] : void 0, s = i > 2 ? r[2] : void 0;
    for (a = t.length > 3 && typeof a == "function" ? (i--, a) : void 0, s && jG(r[0], r[1], s) && (a = i < 3 ? void 0 : a, i = 1), e = Object(e); ++n < i; ) {
      var o = r[n];
      o && t(e, o, n, a);
    }
    return e;
  });
}
var Ov = FG, BG = MG, UG = Ov, zG = UG(function(t, e, r) {
  BG(t, e, r);
}), HG = zG;
function WG(t, e, r) {
  var n = -1, i = t.length;
  e < 0 && (e = -e > i ? 0 : i + e), r = r > i ? i : r, r < 0 && (r += i), i = e > r ? 0 : r - e >>> 0, e >>>= 0;
  for (var a = Array(i); ++n < i; )
    a[n] = t[n + e];
  return a;
}
var PO = WG, GG = /\s/;
function QG(t) {
  for (var e = t.length; e-- && GG.test(t.charAt(e)); )
    ;
  return e;
}
var VG = QG, KG = VG, JG = /^\s+/;
function XG(t) {
  return t && t.slice(0, KG(t) + 1).replace(JG, "");
}
var ZG = XG, YG = ZG, Lw = Ht, eQ = eu, Pw = 0 / 0, tQ = /^[-+]0x[0-9a-f]+$/i, rQ = /^0b[01]+$/i, nQ = /^0o[0-7]+$/i, iQ = parseInt;
function aQ(t) {
  if (typeof t == "number")
    return t;
  if (eQ(t))
    return Pw;
  if (Lw(t)) {
    var e = typeof t.valueOf == "function" ? t.valueOf() : t;
    t = Lw(e) ? e + "" : e;
  }
  if (typeof t != "string")
    return t === 0 ? t : +t;
  t = YG(t);
  var r = rQ.test(t);
  return r || nQ.test(t) ? iQ(t.slice(2), r ? 2 : 8) : tQ.test(t) ? Pw : +t;
}
var sQ = aQ, oQ = sQ, Dw = 1 / 0, cQ = 17976931348623157e292;
function uQ(t) {
  if (!t)
    return t === 0 ? t : 0;
  if (t = oQ(t), t === Dw || t === -Dw) {
    var e = t < 0 ? -1 : 1;
    return e * cQ;
  }
  return t === t ? t : 0;
}
var lQ = uQ, pQ = lQ;
function fQ(t) {
  var e = pQ(t), r = e % 1;
  return e === e ? r ? e - r : e : 0;
}
var DO = fQ, hQ = PO, dQ = Zc, mQ = DO, gQ = Math.ceil, vQ = Math.max;
function yQ(t, e, r) {
  (r ? dQ(t, e, r) : e === void 0) ? e = 1 : e = vQ(mQ(e), 0);
  var n = t == null ? 0 : t.length;
  if (!n || e < 1)
    return [];
  for (var i = 0, a = 0, s = Array(gQ(n / e)); i < n; )
    s[a++] = hQ(t, i, i += e);
  return s;
}
var bQ = yQ, Mw = Pn, wQ = ps, xQ = at, qw = Mw ? Mw.isConcatSpreadable : void 0;
function _Q(t) {
  return xQ(t) || wQ(t) || !!(qw && t && t[qw]);
}
var EQ = _Q, SQ = Sv, CQ = EQ;
function MO(t, e, r, n, i) {
  var a = -1, s = t.length;
  for (r || (r = CQ), i || (i = []); ++a < s; ) {
    var o = t[a];
    e > 0 && r(o) ? e > 1 ? MO(o, e - 1, r, n, i) : SQ(i, o) : n || (i[i.length] = o);
  }
  return i;
}
var TQ = MO, OQ = TQ;
function AQ(t) {
  var e = t == null ? 0 : t.length;
  return e ? OQ(t, 1) : [];
}
var qO = AQ, $Q = (t) => new Promise((e) => setTimeout(e, t));
function IQ(t) {
  return typeof t == "string";
}
function kQ(t) {
  return typeof t == "number";
}
function RQ(t) {
  return typeof t == "boolean";
}
function NQ(t) {
  return typeof t > "u";
}
function LQ(t) {
  return typeof t == "object" && t !== null;
}
function PQ(t) {
  return typeof t == "function";
}
var Je = {
  isString: IQ,
  isNumber: kQ,
  isBoolean: RQ,
  isUndefined: NQ,
  isObject: LQ,
  isFunction: PQ
};
const DQ = bQ, MQ = qO, qQ = $Q, { isNumber: jQ } = Je;
function FQ(t, e, r, n = 1e3) {
  let i, a = null;
  if (!jQ(n) || n < 1)
    throw new TypeError(`Invalid chunkSize: ${n}`);
  if (!Array.isArray(r))
    throw new TypeError(`Invalid batch: Expected array, got ${typeof r}`);
  const s = DQ(r, n), o = (c) => a ? c(a) : t.transaction(c);
  return Object.assign(
    Promise.resolve().then(async () => (await qQ(1), o(async (c) => {
      const f = [];
      for (const u of s)
        f.push(await c(e).insert(u, i));
      return MQ(f);
    }))),
    {
      returning(c) {
        return i = c, this;
      },
      transacting(c) {
        return a = c, this;
      }
    }
  );
}
var BQ = FQ;
const { EventEmitter: UQ } = bt, { Migrator: zQ } = tu, HQ = tu, WQ = WW, jw = $O, GQ = HG, QQ = BQ, { isObject: VQ } = Je, jO = {
  client: {
    get() {
      return this.context.client;
    },
    set(t) {
      this.context.client = t;
    },
    configurable: !0
  },
  userParams: {
    get() {
      return this.context.userParams;
    },
    set(t) {
      this.context.userParams = t;
    },
    configurable: !0
  },
  schema: {
    get() {
      return this.client.schemaBuilder();
    },
    configurable: !0
  },
  migrate: {
    get() {
      return new zQ(this);
    },
    configurable: !0
  },
  seed: {
    get() {
      return new HQ();
    },
    configurable: !0
  },
  fn: {
    get() {
      return new WQ(this.client);
    },
    configurable: !0
  }
}, KQ = [
  "raw",
  "batchInsert",
  "transaction",
  "transactionProvider",
  "initialize",
  "destroy",
  "ref",
  "withUserParams",
  "queryBuilder",
  "disableProcessing",
  "enableProcessing"
];
for (const t of KQ)
  jO[t] = {
    value: function(...e) {
      return this.context[t](...e);
    },
    configurable: !0
  };
function JQ(t) {
  function e(r, n) {
    return BO(e.context, r, n);
  }
  return FO(e, t), e;
}
function XQ(t) {
  const e = t.context || {};
  Object.assign(e, {
    queryBuilder() {
      return this.client.queryBuilder();
    },
    raw() {
      return this.client.raw.apply(this.client, arguments);
    },
    batchInsert(r, n, i = 1e3) {
      return QQ(this, r, n, i);
    },
    // Creates a new transaction.
    // If container is provided, returns a promise for when the transaction is resolved.
    // If container is not provided, returns a promise with a transaction that is resolved
    // when transaction is ready to be used.
    transaction(r, n) {
      !n && VQ(r) && (n = r, r = null);
      const i = Object.assign({}, n);
      return i.userParams = this.userParams || {}, i.doNotRejectOnRollback === void 0 && (i.doNotRejectOnRollback = !0), this._transaction(r, i);
    },
    // Internal method that actually establishes the Transaction.  It makes no assumptions
    // about the `config` or `outerTx`, and expects the caller to handle these details.
    _transaction(r, n, i = null) {
      return r ? this.client.transaction(r, n, i) : new Promise((a, s) => {
        this.client.transaction(a, n, i).catch(s);
      });
    },
    transactionProvider(r) {
      let n;
      return () => (n || (n = this.transaction(void 0, r)), n);
    },
    // Typically never needed, initializes the pool for a knex client.
    initialize(r) {
      return this.client.initializePool(r);
    },
    // Convenience method for tearing down the pool.
    destroy(r) {
      return this.client.destroy(r);
    },
    ref(r) {
      return this.client.ref(r);
    },
    // Do not document this as public API until naming and API is improved for general consumption
    // This method exists to disable processing of internal queries in migrations
    disableProcessing() {
      this.userParams.isProcessingDisabled || (this.userParams.wrapIdentifier = this.client.config.wrapIdentifier, this.userParams.postProcessResponse = this.client.config.postProcessResponse, this.client.config.wrapIdentifier = null, this.client.config.postProcessResponse = null, this.userParams.isProcessingDisabled = !0);
    },
    // Do not document this as public API until naming and API is improved for general consumption
    // This method exists to enable execution of non-internal queries with consistent identifier naming in migrations
    enableProcessing() {
      this.userParams.isProcessingDisabled && (this.client.config.wrapIdentifier = this.userParams.wrapIdentifier, this.client.config.postProcessResponse = this.userParams.postProcessResponse, this.userParams.isProcessingDisabled = !1);
    },
    withUserParams(r) {
      const n = ZQ(t);
      return this.client && (n.client = Object.create(this.client.constructor.prototype), GQ(n.client, this.client), n.client.config = Object.assign({}, this.client.config)), FO(n, n.client), Ks("query", t, n), Ks("query-error", t, n), Ks("query-response", t, n), Ks("start", t, n), n.userParams = r, n;
    }
  }), t.context || (t.context = e);
}
function Ks(t, e, r) {
  e.listeners(t).forEach((i) => {
    r.on(t, i);
  });
}
function FO(t, e) {
  for (let n = 0; n < jw.length; n++) {
    const i = jw[n];
    t[i] = function() {
      const a = this.queryBuilder();
      return a[i].apply(a, arguments);
    };
  }
  Object.defineProperties(t, jO), XQ(t), t.client = e, t.userParams = {};
  const r = new UQ();
  for (const n in r)
    t[n] = r[n];
  t._internalListeners && t._internalListeners.forEach(({ eventName: n, listener: i }) => {
    t.client.removeListener(n, i);
  }), t._internalListeners = [], Js(t, "start", (n) => {
    t.emit("start", n);
  }), Js(t, "query", (n) => {
    t.emit("query", n);
  }), Js(t, "query-error", (n, i) => {
    t.emit("query-error", n, i);
  }), Js(t, "query-response", (n, i, a) => {
    t.emit("query-response", n, i, a);
  });
}
function Js(t, e, r) {
  t.client.on(e, r), t._internalListeners.push({
    eventName: e,
    listener: r
  });
}
function BO(t, e, r) {
  const n = t.queryBuilder();
  return e || t.client.logger.warn(
    "calling knex without a tableName is deprecated. Use knex.queryBuilder() instead."
  ), e ? n.table(e, r) : n;
}
function ZQ(t) {
  const e = Object.create(
    Object.getPrototypeOf(t),
    Object.getOwnPropertyDescriptors(t)
  ), r = {}, i = ((a, s) => BO(r, a, s)).bind(e);
  return Object.assign(i, t), i.context = r, i;
}
var UO = JQ;
const YQ = tu, eV = (t) => Object.assign(t, {
  finally(e) {
    return this.then().finally(e);
  }
});
var zO = Promise.prototype.finally ? eV : YQ;
const { EventEmitter: tV } = bt, rV = ar, nV = TO, { callbackify: iV } = nt, aV = UO, { timeout: Fw, KnexTimeoutError: Bw } = cn, sV = zO, fa = rV("knex:tx");
function oV() {
  return {
    userParams: {},
    doNotRejectOnRollback: !0
  };
}
const Uw = [
  // Doesn't really work in postgres, it treats it as read committed
  "read uncommitted",
  "read committed",
  "snapshot",
  // snapshot and repeatable read are basically the same, most "repeatable
  // read" implementations are actually "snapshot" also known as Multi Version
  // Concurrency Control (MVCC). Mssql's repeatable read doesn't stop
  // repeated reads for inserts as it uses a pessimistic locking system so
  // you should probably use 'snapshot' to stop read skew.
  "repeatable read",
  // mysql pretends to have serializable, but it is not
  "serializable"
];
let HO = class extends tV {
  constructor(e, r, n = oV(), i = null) {
    super(), this.userParams = n.userParams, this.doNotRejectOnRollback = n.doNotRejectOnRollback;
    const a = this.txid = nV("trx");
    this.client = e, this.logger = e.logger, this.outerTx = i, this.trxClient = void 0, this._completed = !1, this._debug = e.config && e.config.debug, n.isolationLevel && this.setIsolationLevel(n.isolationLevel), fa(
      "%s: Starting %s transaction",
      a,
      i ? "nested" : "top level"
    ), this._lastChild = Promise.resolve();
    const o = (i ? i._lastChild : Promise.resolve()).then(
      () => this._evaluateContainer(n, r)
    );
    this._promise = o.then((c) => c), i && (i._lastChild = o.catch(() => {
    }));
  }
  isCompleted() {
    return this._completed || this.outerTx && this.outerTx.isCompleted() || !1;
  }
  begin(e) {
    return (this.isolationLevel ? this.query(
      e,
      `SET TRANSACTION ISOLATION LEVEL ${this.isolationLevel};`
    ) : Promise.resolve()).then(() => this.query(e, "BEGIN;"));
  }
  savepoint(e) {
    return this.query(e, `SAVEPOINT ${this.txid};`);
  }
  commit(e, r) {
    return this.query(e, "COMMIT;", 1, r);
  }
  release(e, r) {
    return this.query(e, `RELEASE SAVEPOINT ${this.txid};`, 1, r);
  }
  setIsolationLevel(e) {
    if (!Uw.includes(e))
      throw new Error(
        `Invalid isolationLevel, supported isolation levels are: ${JSON.stringify(
          Uw
        )}`
      );
    return this.isolationLevel = e, this;
  }
  rollback(e, r) {
    return Fw(this.query(e, "ROLLBACK", 2, r), 5e3).catch(
      (n) => {
        if (!(n instanceof Bw))
          return Promise.reject(n);
        this._rejecter(r);
      }
    );
  }
  rollbackTo(e, r) {
    return Fw(
      this.query(e, `ROLLBACK TO SAVEPOINT ${this.txid}`, 2, r),
      5e3
    ).catch((n) => {
      if (!(n instanceof Bw))
        return Promise.reject(n);
      this._rejecter(r);
    });
  }
  query(e, r, n, i) {
    const a = this.trxClient.query(e, r).catch((s) => {
      n = 2, i = s, this._completed = !0, fa("%s error running transaction query", this.txid);
    }).then((s) => {
      if (n === 1 && this._resolver(i), n === 2) {
        if (i === void 0) {
          if (this.doNotRejectOnRollback && /^ROLLBACK\b/i.test(r)) {
            this._resolver();
            return;
          }
          i = new Error(`Transaction rejected with non-error: ${i}`);
        }
        this._rejecter(i);
      }
      return s;
    });
    return (n === 1 || n === 2) && (this._completed = !0), a;
  }
  debug(e) {
    return this._debug = arguments.length ? e : !0, this;
  }
  async _evaluateContainer(e, r) {
    return this.acquireConnection(e, (n) => {
      const i = this.trxClient = uV(
        this,
        this.client,
        n
      ), a = this.client.transacting ? this.savepoint(n) : this.begin(n), s = new Promise((o, c) => {
        this._resolver = o, this._rejecter = c;
      });
      return a.then(() => cV(this, n, i)).then((o) => {
        o.executionPromise = s;
        let c;
        try {
          c = r(o);
        } catch (f) {
          c = Promise.reject(f);
        }
        return c && c.then && typeof c.then == "function" && c.then((f) => o.commit(f)).catch((f) => o.rollback(f)), null;
      }).catch((o) => this._rejecter(o)), s;
    });
  }
  // Acquire a connection and create a disposer - either using the one passed
  // via config or getting one off the client. The disposer will be called once
  // the original promise is marked completed.
  async acquireConnection(e, r) {
    const n = e && e.connection, i = n || await this.client.acquireConnection();
    try {
      return i.__knexTxId = this.txid, await r(i);
    } finally {
      n ? fa("%s: not releasing external connection", this.txid) : (fa("%s: releasing connection", this.txid), this.client.releaseConnection(i));
    }
  }
  then(e, r) {
    return this._promise.then(e, r);
  }
  catch(...e) {
    return this._promise.catch(...e);
  }
  asCallback(e) {
    return iV(() => this._promise)(e), this._promise;
  }
};
sV(HO.prototype);
function cV(t, e, r) {
  const n = aV(r);
  return n.context.withUserParams = () => {
    throw new Error(
      "Cannot set user params on a transaction - it can only inherit params from main knex instance"
    );
  }, n.isTransaction = !0, n.userParams = t.userParams || {}, n.context.transaction = function(i, a) {
    return a ? a.doNotRejectOnRollback === void 0 && (a.doNotRejectOnRollback = !0) : a = { doNotRejectOnRollback: !0 }, this._transaction(i, a, t);
  }, n.savepoint = function(i, a) {
    return n.transaction(i, a);
  }, t.client.transacting ? (n.commit = (i) => t.release(e, i), n.rollback = (i) => t.rollbackTo(e, i)) : (n.commit = (i) => t.commit(e, i), n.rollback = (i) => t.rollback(e, i)), n.isCompleted = () => t.isCompleted(), n;
}
function uV(t, e, r) {
  const n = Object.create(e.constructor.prototype);
  n.version = e.version, n.config = e.config, n.driver = e.driver, n.connectionSettings = e.connectionSettings, n.transacting = !0, n.valueForUndefined = e.valueForUndefined, n.logger = e.logger, n.on("start", function(s) {
    t.emit("start", s), e.emit("start", s);
  }), n.on("query", function(s) {
    t.emit("query", s), e.emit("query", s);
  }), n.on("query-error", function(s, o) {
    t.emit("query-error", s, o), e.emit("query-error", s, o);
  }), n.on("query-response", function(s, o, c) {
    t.emit("query-response", s, o, c), e.emit("query-response", s, o, c);
  });
  const i = n.query;
  n.query = function(s, o) {
    const c = t.isCompleted();
    return new Promise(function(f, u) {
      try {
        if (s !== r)
          throw new Error("Invalid connection for transaction query.");
        c && zw(t, o), f(i.call(n, s, o));
      } catch (l) {
        u(l);
      }
    });
  };
  const a = n.stream;
  return n.stream = function(s, o, c, f) {
    const u = t.isCompleted();
    return new Promise(function(l, p) {
      try {
        if (s !== r)
          throw new Error("Invalid connection for transaction query.");
        u && zw(t, o), l(a.call(n, s, o, c, f));
      } catch (m) {
        p(m);
      }
    });
  }, n.acquireConnection = function() {
    return Promise.resolve(r);
  }, n.releaseConnection = function() {
    return Promise.resolve();
  }, n;
}
function zw(t, e) {
  const r = typeof e == "string" ? e : e && e.sql;
  throw fa("%s: Transaction completed: %s", t.txid, r), new Error(
    "Transaction query already complete, run with DEBUG=knex:tx for more info"
  );
}
var ln = HO;
const lV = ar("knex:query"), pV = ar("knex:bindings"), fV = (t, e) => lV(t.replace(/%/g, "%%"), e), { isString: hV } = Je;
function WO(t, e, r, n) {
  e = e == null ? [] : [].concat(e);
  let i = 0;
  return t.replace(/\\?\?/g, (a) => {
    if (a === "\\?")
      return "?";
    if (i === e.length)
      return a;
    const s = e[i++];
    return n._escapeBinding(s, { timeZone: r });
  });
}
function dV(t, e, r) {
  const n = hV(e) ? { sql: e } : e;
  n.bindings = r.prepBindings(n.bindings), n.sql = r.positionBindings(n.sql);
  const { __knexUid: i, __knexTxId: a } = t;
  return r.emit("query", Object.assign({ __knexUid: i, __knexTxId: a }, n)), fV(n.sql, a), pV(n.bindings, a), n;
}
function mV(t, e, r) {
  return r._query(t, e).catch((n) => {
    throw r.config && r.config.compileSqlOnError === !1 ? n.message = e.sql + " - " + n.message : n.message = WO(e.sql, e.bindings, void 0, r) + " - " + n.message, r.emit(
      "query-error",
      n,
      Object.assign(
        { __knexUid: t.__knexUid, __knexTxId: t.__knexUid },
        e
      )
    ), n;
  });
}
var GO = {
  enrichQueryObject: dV,
  executeQuery: mV,
  formatQuery: WO
}, gV = Kc, vV = qn, yV = Ov, bV = jr, wV = fs, xV = jn, _V = Object.prototype, EV = _V.hasOwnProperty, SV = yV(function(t, e) {
  if (wV(e) || bV(e)) {
    vV(e, xV(e), t);
    return;
  }
  for (var r in e)
    EV.call(e, r) && gV(t, r, e[r]);
}), Bn = SV, CV = wO, TV = 4;
function OV(t) {
  return CV(t, TV);
}
var Av = OV, AV = kO, $V = jn;
function IV(t, e) {
  return t && AV(t, e, $V);
}
var QO = IV, kV = jr;
function RV(t, e) {
  return function(r, n) {
    if (r == null)
      return r;
    if (!kV(r))
      return t(r, n);
    for (var i = r.length, a = e ? i : -1, s = Object(r); (e ? a-- : ++a < i) && n(s[a], a, s) !== !1; )
      ;
    return r;
  };
}
var NV = RV, LV = QO, PV = NV, DV = PV(LV), Ui = DV, MV = Wt;
function qV(t) {
  return typeof t == "function" ? t : MV;
}
var jV = qV, FV = vv, BV = Ui, UV = jV, zV = at;
function HV(t, e) {
  var r = zV(t) ? FV : BV;
  return r(t, UV(e));
}
var WV = HV, hs = WV, GV = iO, QV = Bi, VV = ps, KV = at, JV = jr, XV = qi, ZV = fs, YV = ji, eK = "[object Map]", tK = "[object Set]", rK = Object.prototype, nK = rK.hasOwnProperty;
function iK(t) {
  if (t == null)
    return !0;
  if (JV(t) && (KV(t) || typeof t == "string" || typeof t.splice == "function" || XV(t) || YV(t) || VV(t)))
    return !t.length;
  var e = QV(t);
  if (e == eK || e == tK)
    return !t.size;
  if (ZV(t))
    return !GV(t).length;
  for (var r in t)
    if (nK.call(t, r))
      return !1;
  return !0;
}
var sr = iK;
function aK(t) {
  var e = t == null ? 0 : t.length;
  return e ? t[e - 1] : void 0;
}
var sK = aK, oK = Ui;
function cK(t, e) {
  var r = [];
  return oK(t, function(n, i, a) {
    e(n, i, a) && r.push(n);
  }), r;
}
var VO = cK, Xl, Hw;
function uK() {
  if (Hw)
    return Xl;
  Hw = 1;
  var t = "__lodash_hash_undefined__";
  function e(r) {
    return this.__data__.set(r, t), this;
  }
  return Xl = e, Xl;
}
var Zl, Ww;
function lK() {
  if (Ww)
    return Zl;
  Ww = 1;
  function t(e) {
    return this.__data__.has(e);
  }
  return Zl = t, Zl;
}
var Yl, Gw;
function KO() {
  if (Gw)
    return Yl;
  Gw = 1;
  var t = gv, e = uK(), r = lK();
  function n(i) {
    var a = -1, s = i == null ? 0 : i.length;
    for (this.__data__ = new t(); ++a < s; )
      this.add(i[a]);
  }
  return n.prototype.add = n.prototype.push = e, n.prototype.has = r, Yl = n, Yl;
}
var ep, Qw;
function JO() {
  if (Qw)
    return ep;
  Qw = 1;
  function t(e, r) {
    for (var n = -1, i = e == null ? 0 : e.length; ++n < i; )
      if (r(e[n], n, e))
        return !0;
    return !1;
  }
  return ep = t, ep;
}
function pK(t, e) {
  return t.has(e);
}
var XO = pK, fK = KO(), hK = JO(), dK = XO, mK = 1, gK = 2;
function vK(t, e, r, n, i, a) {
  var s = r & mK, o = t.length, c = e.length;
  if (o != c && !(s && c > o))
    return !1;
  var f = a.get(t), u = a.get(e);
  if (f && u)
    return f == e && u == t;
  var l = -1, p = !0, m = r & gK ? new fK() : void 0;
  for (a.set(t, e), a.set(e, t); ++l < o; ) {
    var h = t[l], g = e[l];
    if (n)
      var v = s ? n(g, h, l, e, t, a) : n(h, g, l, t, e, a);
    if (v !== void 0) {
      if (v)
        continue;
      p = !1;
      break;
    }
    if (m) {
      if (!hK(e, function(d, y) {
        if (!dK(m, y) && (h === d || i(h, d, r, n, a)))
          return m.push(y);
      })) {
        p = !1;
        break;
      }
    } else if (!(h === g || i(h, g, r, n, a))) {
      p = !1;
      break;
    }
  }
  return a.delete(t), a.delete(e), p;
}
var ZO = vK;
function yK(t) {
  var e = -1, r = Array(t.size);
  return t.forEach(function(n, i) {
    r[++e] = [i, n];
  }), r;
}
var YO = yK;
function bK(t) {
  var e = -1, r = Array(t.size);
  return t.forEach(function(n) {
    r[++e] = n;
  }), r;
}
var ru = bK, Vw = Pn, Kw = hO, wK = Ni, xK = ZO, _K = YO, EK = ru, SK = 1, CK = 2, TK = "[object Boolean]", OK = "[object Date]", AK = "[object Error]", $K = "[object Map]", IK = "[object Number]", kK = "[object RegExp]", RK = "[object Set]", NK = "[object String]", LK = "[object Symbol]", PK = "[object ArrayBuffer]", DK = "[object DataView]", Jw = Vw ? Vw.prototype : void 0, tp = Jw ? Jw.valueOf : void 0;
function MK(t, e, r, n, i, a, s) {
  switch (r) {
    case DK:
      if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset)
        return !1;
      t = t.buffer, e = e.buffer;
    case PK:
      return !(t.byteLength != e.byteLength || !a(new Kw(t), new Kw(e)));
    case TK:
    case OK:
    case IK:
      return wK(+t, +e);
    case AK:
      return t.name == e.name && t.message == e.message;
    case kK:
    case NK:
      return t == e + "";
    case $K:
      var o = _K;
    case RK:
      var c = n & SK;
      if (o || (o = EK), t.size != e.size && !c)
        return !1;
      var f = s.get(t);
      if (f)
        return f == e;
      n |= CK, s.set(t, e);
      var u = xK(o(t), o(e), n, i, a, s);
      return s.delete(t), u;
    case LK:
      if (tp)
        return tp.call(t) == tp.call(e);
  }
  return !1;
}
var qK = MK, Xw = uO, jK = 1, FK = Object.prototype, BK = FK.hasOwnProperty;
function UK(t, e, r, n, i, a) {
  var s = r & jK, o = Xw(t), c = o.length, f = Xw(e), u = f.length;
  if (c != u && !s)
    return !1;
  for (var l = c; l--; ) {
    var p = o[l];
    if (!(s ? p in e : BK.call(e, p)))
      return !1;
  }
  var m = a.get(t), h = a.get(e);
  if (m && h)
    return m == e && h == t;
  var g = !0;
  a.set(t, e), a.set(e, t);
  for (var v = s; ++l < c; ) {
    p = o[l];
    var d = t[p], y = e[p];
    if (n)
      var x = s ? n(y, d, p, e, t, a) : n(d, y, p, t, e, a);
    if (!(x === void 0 ? d === y || i(d, y, r, n, a) : x)) {
      g = !1;
      break;
    }
    v || (v = p == "constructor");
  }
  if (g && !v) {
    var b = t.constructor, w = e.constructor;
    b != w && "constructor" in t && "constructor" in e && !(typeof b == "function" && b instanceof b && typeof w == "function" && w instanceof w) && (g = !1);
  }
  return a.delete(t), a.delete(e), g;
}
var zK = UK, rp = Qc, HK = ZO, WK = qK, GK = zK, Zw = Bi, Yw = at, e1 = qi, QK = ji, VK = 1, t1 = "[object Arguments]", r1 = "[object Array]", Xs = "[object Object]", KK = Object.prototype, n1 = KK.hasOwnProperty;
function JK(t, e, r, n, i, a) {
  var s = Yw(t), o = Yw(e), c = s ? r1 : Zw(t), f = o ? r1 : Zw(e);
  c = c == t1 ? Xs : c, f = f == t1 ? Xs : f;
  var u = c == Xs, l = f == Xs, p = c == f;
  if (p && e1(t)) {
    if (!e1(e))
      return !1;
    s = !0, u = !1;
  }
  if (p && !u)
    return a || (a = new rp()), s || QK(t) ? HK(t, e, r, n, i, a) : WK(t, e, c, r, n, i, a);
  if (!(r & VK)) {
    var m = u && n1.call(t, "__wrapped__"), h = l && n1.call(e, "__wrapped__");
    if (m || h) {
      var g = m ? t.value() : t, v = h ? e.value() : e;
      return a || (a = new rp()), i(g, v, r, n, a);
    }
  }
  return p ? (a || (a = new rp()), GK(t, e, r, n, i, a)) : !1;
}
var XK = JK, ZK = XK, i1 = xr;
function eA(t, e, r, n, i) {
  return t === e ? !0 : t == null || e == null || !i1(t) && !i1(e) ? t !== t && e !== e : ZK(t, e, r, n, eA, i);
}
var tA = eA, YK = Qc, eJ = tA, tJ = 1, rJ = 2;
function nJ(t, e, r, n) {
  var i = r.length, a = i, s = !n;
  if (t == null)
    return !a;
  for (t = Object(t); i--; ) {
    var o = r[i];
    if (s && o[2] ? o[1] !== t[o[0]] : !(o[0] in t))
      return !1;
  }
  for (; ++i < a; ) {
    o = r[i];
    var c = o[0], f = t[c], u = o[1];
    if (s && o[2]) {
      if (f === void 0 && !(c in t))
        return !1;
    } else {
      var l = new YK();
      if (n)
        var p = n(f, u, c, t, e, l);
      if (!(p === void 0 ? eJ(u, f, tJ | rJ, n, l) : p))
        return !1;
    }
  }
  return !0;
}
var iJ = nJ, aJ = Ht;
function sJ(t) {
  return t === t && !aJ(t);
}
var rA = sJ, oJ = rA, cJ = jn;
function uJ(t) {
  for (var e = cJ(t), r = e.length; r--; ) {
    var n = e[r], i = t[n];
    e[r] = [n, i, oJ(i)];
  }
  return e;
}
var lJ = uJ;
function pJ(t, e) {
  return function(r) {
    return r == null ? !1 : r[t] === e && (e !== void 0 || t in Object(r));
  };
}
var nA = pJ, fJ = iJ, hJ = lJ, dJ = nA;
function mJ(t) {
  var e = hJ(t);
  return e.length == 1 && e[0][2] ? dJ(e[0][0], e[0][1]) : function(r) {
    return r === t || fJ(r, t, e);
  };
}
var gJ = mJ, vJ = at, yJ = eu, bJ = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, wJ = /^\w*$/;
function xJ(t, e) {
  if (vJ(t))
    return !1;
  var r = typeof t;
  return r == "number" || r == "symbol" || r == "boolean" || t == null || yJ(t) ? !0 : wJ.test(t) || !bJ.test(t) || e != null && t in Object(e);
}
var $v = xJ, iA = gv, _J = "Expected a function";
function Iv(t, e) {
  if (typeof t != "function" || e != null && typeof e != "function")
    throw new TypeError(_J);
  var r = function() {
    var n = arguments, i = e ? e.apply(this, n) : n[0], a = r.cache;
    if (a.has(i))
      return a.get(i);
    var s = t.apply(this, n);
    return r.cache = a.set(i, s) || a, s;
  };
  return r.cache = new (Iv.Cache || iA)(), r;
}
Iv.Cache = iA;
var EJ = Iv, SJ = EJ, CJ = 500;
function TJ(t) {
  var e = SJ(t, function(n) {
    return r.size === CJ && r.clear(), n;
  }), r = e.cache;
  return e;
}
var OJ = TJ, AJ = OJ, $J = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, IJ = /\\(\\)?/g, kJ = AJ(function(t) {
  var e = [];
  return t.charCodeAt(0) === 46 && e.push(""), t.replace($J, function(r, n, i, a) {
    e.push(i ? a.replace(IJ, "$1") : n || r);
  }), e;
}), RJ = kJ, NJ = at, LJ = $v, PJ = RJ, DJ = CO;
function MJ(t, e) {
  return NJ(t) ? t : LJ(t, e) ? [t] : PJ(DJ(t));
}
var nu = MJ, qJ = eu, jJ = 1 / 0;
function FJ(t) {
  if (typeof t == "string" || qJ(t))
    return t;
  var e = t + "";
  return e == "0" && 1 / t == -jJ ? "-0" : e;
}
var ds = FJ, BJ = nu, UJ = ds;
function zJ(t, e) {
  e = BJ(e, t);
  for (var r = 0, n = e.length; t != null && r < n; )
    t = t[UJ(e[r++])];
  return r && r == n ? t : void 0;
}
var kv = zJ, HJ = kv;
function WJ(t, e, r) {
  var n = t == null ? void 0 : HJ(t, e);
  return n === void 0 ? r : n;
}
var GJ = WJ;
function QJ(t, e) {
  return t != null && e in Object(t);
}
var VJ = QJ, KJ = nu, JJ = ps, XJ = at, ZJ = Jc, YJ = yv, eX = ds;
function tX(t, e, r) {
  e = KJ(e, t);
  for (var n = -1, i = e.length, a = !1; ++n < i; ) {
    var s = eX(e[n]);
    if (!(a = t != null && r(t, s)))
      break;
    t = t[s];
  }
  return a || ++n != i ? a : (i = t == null ? 0 : t.length, !!i && YJ(i) && ZJ(s, i) && (XJ(t) || JJ(t)));
}
var aA = tX, rX = VJ, nX = aA;
function iX(t, e) {
  return t != null && nX(t, e, rX);
}
var aX = iX, sX = tA, oX = GJ, cX = aX, uX = $v, lX = rA, pX = nA, fX = ds, hX = 1, dX = 2;
function mX(t, e) {
  return uX(t) && lX(e) ? pX(fX(t), e) : function(r) {
    var n = oX(r, t);
    return n === void 0 && n === e ? cX(r, t) : sX(e, n, hX | dX);
  };
}
var gX = mX;
function vX(t) {
  return function(e) {
    return e == null ? void 0 : e[t];
  };
}
var yX = vX, bX = kv;
function wX(t) {
  return function(e) {
    return bX(e, t);
  };
}
var xX = wX, _X = yX, EX = xX, SX = $v, CX = ds;
function TX(t) {
  return SX(t) ? _X(CX(t)) : EX(t);
}
var OX = TX, AX = gJ, $X = gX, IX = Wt, kX = at, RX = OX;
function NX(t) {
  return typeof t == "function" ? t : t == null ? IX : typeof t == "object" ? kX(t) ? $X(t[0], t[1]) : AX(t) : RX(t);
}
var Fr = NX, LX = "Expected a function";
function PX(t) {
  if (typeof t != "function")
    throw new TypeError(LX);
  return function() {
    var e = arguments;
    switch (e.length) {
      case 0:
        return !t.call(this);
      case 1:
        return !t.call(this, e[0]);
      case 2:
        return !t.call(this, e[0], e[1]);
      case 3:
        return !t.call(this, e[0], e[1], e[2]);
    }
    return !t.apply(this, e);
  };
}
var sA = PX, DX = _v, MX = VO, qX = Fr, jX = at, FX = sA;
function BX(t, e) {
  var r = jX(t) ? DX : MX;
  return r(t, FX(qX(e)));
}
var UX = BX, zX = PO;
function HX(t) {
  var e = t == null ? 0 : t.length;
  return e ? zX(t, 1, e) : [];
}
var iu = HX, WX = Dn, GX = at, QX = xr, VX = "[object String]";
function KX(t) {
  return typeof t == "string" || !GX(t) && QX(t) && WX(t) == VX;
}
var JX = KX;
function XX(t) {
  for (var e, r = []; !(e = t.next()).done; )
    r.push(e.value);
  return r;
}
var ZX = XX;
function YX(t) {
  return t.split("");
}
var eZ = YX, tZ = "\\ud800-\\udfff", rZ = "\\u0300-\\u036f", nZ = "\\ufe20-\\ufe2f", iZ = "\\u20d0-\\u20ff", aZ = rZ + nZ + iZ, sZ = "\\ufe0e\\ufe0f", oZ = "\\u200d", cZ = RegExp("[" + oZ + tZ + aZ + sZ + "]");
function uZ(t) {
  return cZ.test(t);
}
var lZ = uZ, oA = "\\ud800-\\udfff", pZ = "\\u0300-\\u036f", fZ = "\\ufe20-\\ufe2f", hZ = "\\u20d0-\\u20ff", dZ = pZ + fZ + hZ, mZ = "\\ufe0e\\ufe0f", gZ = "[" + oA + "]", ag = "[" + dZ + "]", sg = "\\ud83c[\\udffb-\\udfff]", vZ = "(?:" + ag + "|" + sg + ")", cA = "[^" + oA + "]", uA = "(?:\\ud83c[\\udde6-\\uddff]){2}", lA = "[\\ud800-\\udbff][\\udc00-\\udfff]", yZ = "\\u200d", pA = vZ + "?", fA = "[" + mZ + "]?", bZ = "(?:" + yZ + "(?:" + [cA, uA, lA].join("|") + ")" + fA + pA + ")*", wZ = fA + pA + bZ, xZ = "(?:" + [cA + ag + "?", ag, uA, lA, gZ].join("|") + ")", _Z = RegExp(sg + "(?=" + sg + ")|" + xZ + wZ, "g");
function EZ(t) {
  return t.match(_Z) || [];
}
var SZ = EZ, CZ = eZ, TZ = lZ, OZ = SZ;
function AZ(t) {
  return TZ(t) ? OZ(t) : CZ(t);
}
var $Z = AZ, IZ = Yc;
function kZ(t, e) {
  return IZ(e, function(r) {
    return t[r];
  });
}
var RZ = kZ, NZ = RZ, LZ = jn;
function PZ(t) {
  return t == null ? [] : NZ(t, LZ(t));
}
var hA = PZ, a1 = Pn, DZ = xv, MZ = Bi, qZ = jr, jZ = JX, FZ = ZX, BZ = YO, UZ = ru, zZ = $Z, HZ = hA, WZ = "[object Map]", GZ = "[object Set]", np = a1 ? a1.iterator : void 0;
function QZ(t) {
  if (!t)
    return [];
  if (qZ(t))
    return jZ(t) ? zZ(t) : DZ(t);
  if (np && t[np])
    return FZ(t[np]());
  var e = MZ(t), r = e == WZ ? BZ : e == GZ ? UZ : HZ;
  return r(t);
}
var ms = QZ;
const dA = Object.freeze({
  pg: "postgres",
  postgresql: "postgres",
  sqlite: "sqlite3"
}), VZ = Object.freeze(
  [
    "mssql",
    "mysql",
    "mysql2",
    "oracledb",
    "postgres",
    "pgnative",
    "redshift",
    "sqlite3",
    "cockroachdb",
    "better-sqlite3"
  ].concat(Object.keys(dA))
), KZ = Object.freeze({
  MsSQL: "mssql",
  MySQL: "mysql",
  MySQL2: "mysql2",
  Oracle: "oracledb",
  PostgreSQL: "pg",
  PgNative: "pgnative",
  Redshift: "pg-redshift",
  SQLite: "sqlite3",
  CockroachDB: "cockroachdb",
  BetterSQLite3: "better-sqlite3"
}), JZ = Object.freeze([
  "maxWaitingClients",
  "testOnBorrow",
  "fifo",
  "priorityRange",
  "autostart",
  "evictionRunIntervalMillis",
  "numTestsPerRun",
  "softIdleTimeoutMillis",
  "Promise"
]), XZ = /,[\s](?![^(]*\))/g;
var Rv = {
  CLIENT_ALIASES: dA,
  SUPPORTED_CLIENTS: VZ,
  POOL_CONFIG_OPTIONS: JZ,
  COMMA_NO_PAREN_REGEX: XZ,
  DRIVER_NAMES: KZ
};
const mA = un, ZZ = ji, { CLIENT_ALIASES: YZ } = Rv, { isFunction: eY } = Je;
function tY(...t) {
  return Array.isArray(t[0]) ? t[0] : t;
}
function ja(t) {
  let e = !1;
  if (ZZ(t))
    return !1;
  if (t && eY(t.toSQL))
    return e;
  if (Array.isArray(t))
    for (let r = 0; r < t.length && !e; r++)
      e = ja(t[r]);
  else
    mA(t) ? Object.keys(t).forEach((r) => {
      e || (e = ja(t[r]));
    }) : e = t === void 0;
  return e;
}
function rY(t) {
  const e = [];
  return Array.isArray(t) ? t.forEach((r, n) => {
    ja(r) && e.push(n);
  }) : mA(t) ? Object.keys(t).forEach((r) => {
    ja(t[r]) && e.push(r);
  }) : e.push(0), e;
}
function nY(t) {
  t.prototype.queryContext = function(e) {
    return e === void 0 ? this._queryContext : (this._queryContext = e, this);
  };
}
function iY(t) {
  return YZ[t] || t;
}
function aY(t, e) {
  if (t == null)
    return e;
  const r = parseInt(t, 10);
  return isNaN(r) ? e : r;
}
var wt = {
  addQueryContext: nY,
  containsUndefined: ja,
  getUndefinedIndices: rY,
  normalizeArr: tY,
  resolveClientNameWithAliases: iY,
  toNumber: aY
};
const s1 = se;
function o1(t, e, r, n, i) {
  if (typeof r == "function")
    return {
      type: "onWrapped",
      value: r,
      bool: e
    };
  switch (arguments.length) {
    case 3:
      return { type: "onRaw", value: r, bool: e };
    case 4:
      return {
        type: t,
        column: r,
        operator: "=",
        value: n,
        bool: e
      };
    default:
      return {
        type: t,
        column: r,
        operator: n,
        value: i,
        bool: e
      };
  }
}
let rt = class {
  constructor(e, r, n) {
    this.schema = n, this.table = e, this.joinType = r, this.and = this, this.clauses = [];
  }
  get or() {
    return this._bool("or");
  }
  // Adds an "on" clause to the current join object.
  on(e) {
    if (typeof e == "object" && typeof e.toSQL != "function") {
      const n = Object.keys(e);
      let i = -1;
      const a = this._bool() === "or" ? "orOn" : "on";
      for (; ++i < n.length; )
        this[a](n[i], e[n[i]]);
      return this;
    }
    const r = o1("onBasic", this._bool(), ...arguments);
    return r && this.clauses.push(r), this;
  }
  // Adds an "or on" clause to the current join object.
  orOn(e, r, n) {
    return this._bool("or").on.apply(this, arguments);
  }
  onJsonPathEquals(e, r, n, i) {
    return this.clauses.push({
      type: "onJsonPathEquals",
      columnFirst: e,
      jsonPathFirst: r,
      columnSecond: n,
      jsonPathSecond: i,
      bool: this._bool(),
      not: this._not()
    }), this;
  }
  orOnJsonPathEquals(e, r, n, i) {
    return this._bool("or").onJsonPathEquals.apply(this, arguments);
  }
  // Adds a "using" clause to the current join.
  using(e) {
    return this.clauses.push({ type: "onUsing", column: e, bool: this._bool() });
  }
  onVal(e) {
    if (typeof e == "object" && typeof e.toSQL != "function") {
      const n = Object.keys(e);
      let i = -1;
      const a = this._bool() === "or" ? "orOnVal" : "onVal";
      for (; ++i < n.length; )
        this[a](n[i], e[n[i]]);
      return this;
    }
    const r = o1("onVal", this._bool(), ...arguments);
    return r && this.clauses.push(r), this;
  }
  andOnVal() {
    return this.onVal(...arguments);
  }
  orOnVal() {
    return this._bool("or").onVal(...arguments);
  }
  onBetween(e, r) {
    return s1(
      Array.isArray(r),
      "The second argument to onBetween must be an array."
    ), s1(
      r.length === 2,
      "You must specify 2 values for the onBetween clause"
    ), this.clauses.push({
      type: "onBetween",
      column: e,
      value: r,
      bool: this._bool(),
      not: this._not()
    }), this;
  }
  onNotBetween(e, r) {
    return this._not(!0).onBetween(e, r);
  }
  orOnBetween(e, r) {
    return this._bool("or").onBetween(e, r);
  }
  orOnNotBetween(e, r) {
    return this._bool("or")._not(!0).onBetween(e, r);
  }
  onIn(e, r) {
    return Array.isArray(r) && r.length === 0 ? this.on(1, "=", 0) : (this.clauses.push({
      type: "onIn",
      column: e,
      value: r,
      not: this._not(),
      bool: this._bool()
    }), this);
  }
  onNotIn(e, r) {
    return this._not(!0).onIn(e, r);
  }
  orOnIn(e, r) {
    return this._bool("or").onIn(e, r);
  }
  orOnNotIn(e, r) {
    return this._bool("or")._not(!0).onIn(e, r);
  }
  onNull(e) {
    return this.clauses.push({
      type: "onNull",
      column: e,
      not: this._not(),
      bool: this._bool()
    }), this;
  }
  orOnNull(e) {
    return this._bool("or").onNull(e);
  }
  onNotNull(e) {
    return this._not(!0).onNull(e);
  }
  orOnNotNull(e) {
    return this._not(!0)._bool("or").onNull(e);
  }
  onExists(e) {
    return this.clauses.push({
      type: "onExists",
      value: e,
      not: this._not(),
      bool: this._bool()
    }), this;
  }
  orOnExists(e) {
    return this._bool("or").onExists(e);
  }
  onNotExists(e) {
    return this._not(!0).onExists(e);
  }
  orOnNotExists(e) {
    return this._not(!0)._bool("or").onExists(e);
  }
  // Explicitly set the type of join, useful within a function when creating a grouped join.
  type(e) {
    return this.joinType = e, this;
  }
  _bool(e) {
    if (arguments.length === 1)
      return this._boolFlag = e, this;
    const r = this._boolFlag || "and";
    return this._boolFlag = "and", r;
  }
  _not(e) {
    if (arguments.length === 1)
      return this._notFlag = e, this;
    const r = this._notFlag;
    return this._notFlag = !1, r;
  }
};
Object.assign(rt.prototype, {
  grouping: "join"
});
rt.prototype.andOn = rt.prototype.on;
rt.prototype.andOnIn = rt.prototype.onIn;
rt.prototype.andOnNotIn = rt.prototype.onNotIn;
rt.prototype.andOnNull = rt.prototype.onNull;
rt.prototype.andOnNotNull = rt.prototype.onNotNull;
rt.prototype.andOnExists = rt.prototype.onExists;
rt.prototype.andOnNotExists = rt.prototype.onNotExists;
rt.prototype.andOnBetween = rt.prototype.onBetween;
rt.prototype.andOnNotBetween = rt.prototype.onNotBetween;
rt.prototype.andOnJsonPathEquals = rt.prototype.onJsonPathEquals;
var gA = rt;
const c1 = se;
let sY = class {
  constructor(e, r, n, i, a) {
    this.schema = r, this.type = "analytic", this.method = e, this.order = i || [], this.partitions = a || [], this.alias = n, this.and = this, this.grouping = "columns";
  }
  partitionBy(e, r) {
    return c1(
      Array.isArray(e) || typeof e == "string",
      `The argument to an analytic partitionBy function must be either a string
            or an array of string.`
    ), Array.isArray(e) ? this.partitions = this.partitions.concat(e) : this.partitions.push({ column: e, order: r }), this;
  }
  orderBy(e, r) {
    return c1(
      Array.isArray(e) || typeof e == "string",
      `The argument to an analytic orderBy function must be either a string
            or an array of string.`
    ), Array.isArray(e) ? this.order = this.order.concat(e) : this.order.push({ column: e, order: r }), this;
  }
};
var oY = sY, Nv = function(e, r) {
  e.client.config.asyncStackTraces && (e._asyncStack = {
    error: new Error(),
    lines: r
  });
}, cY = {
  lockMode: {
    forShare: "forShare",
    forUpdate: "forUpdate",
    forNoKeyUpdate: "forNoKeyUpdate",
    forKeyShare: "forKeyShare"
  },
  waitMode: {
    skipLocked: "skipLocked",
    noWait: "noWait"
  }
};
const uY = Av, lY = sr, { callbackify: pY } = nt, fY = zO, { formatQuery: hY } = GO;
function dY(t) {
  t.prototype.toQuery = function(e) {
    let r = this.toSQL(this._method, e);
    return Array.isArray(r) || (r = [r]), r.length ? r.map((n) => hY(n.sql, n.bindings, e, this.client)).reduce((n, i) => n.concat(n.endsWith(";") ? `
` : `;
`, i)) : "";
  }, t.prototype.then = function() {
    let e = this.client.runner(this).run();
    return this.client.config.asyncStackTraces && (e = e.catch((r) => {
      r.originalStack = r.stack;
      const n = r.stack.split(`
`)[0], { error: i, lines: a } = this._asyncStack, o = i.stack.split(`
`).slice(a);
      throw o.unshift(n), r.stack = o.join(`
`), r;
    })), e.then.apply(e, arguments);
  }, t.prototype.options = function(e) {
    return this._options = this._options || [], this._options.push(uY(e) || {}), this;
  }, t.prototype.connection = function(e) {
    return this._connection = e, this.client.processPassedConnection(e), this;
  }, t.prototype.debug = function(e) {
    return this._debug = arguments.length ? e : !0, this;
  }, t.prototype.transacting = function(e) {
    if (e && e.client && (e.client.transacting ? this.client = e.client : e.client.logger.warn(
      `Invalid transaction value: ${e.client}`
    )), lY(e))
      throw this.client.logger.error(
        "Invalid value on transacting call, potential bug"
      ), Error(
        "Invalid transacting value (null, undefined or empty object)"
      );
    return this;
  }, t.prototype.stream = function(e) {
    return this.client.runner(this).stream(e);
  }, t.prototype.pipe = function(e, r) {
    return this.client.runner(this).pipe(e, r);
  }, t.prototype.asCallback = function(e) {
    const r = this.then();
    return pY(() => r)(e), r;
  }, t.prototype.catch = function(e) {
    return this.then().catch(e);
  }, Object.defineProperty(t.prototype, Symbol.toStringTag, {
    get: () => "object"
  }), fY(t.prototype);
}
var Lv = {
  augmentWithBuilderInterface: dY
};
const ri = se, { EventEmitter: mY } = bt, gY = Bn, Zs = Av, vY = hs, ni = sr, u1 = un, yY = sK, bY = UX, wY = iu, l1 = ms, { addQueryContext: xY, normalizeArr: na } = wt, ip = gA, _Y = oY, EY = Nv, {
  isBoolean: ia,
  isNumber: SY,
  isObject: Or,
  isString: ap,
  isFunction: CY
} = Je, { lockMode: Jr, waitMode: Ys } = cY, {
  augmentWithBuilderInterface: TY
} = Lv, OY = /* @__PURE__ */ new Set(["pluck", "first", "select"]), AY = /* @__PURE__ */ new Set([
  "with",
  "select",
  "columns",
  "hintComments",
  "where",
  "union",
  "join",
  "group",
  "order",
  "having",
  "limit",
  "offset",
  "counter",
  "counters"
]), $Y = /* @__PURE__ */ new Set([
  Jr.forShare,
  Jr.forUpdate,
  Jr.forNoKeyUpdate,
  Jr.forKeyShare
]);
class xe extends mY {
  constructor(e) {
    super(), this.client = e, this.and = this, this._single = {}, this._statements = [], this._method = "select", e.config && (EY(this, 5), this._debug = e.config.debug), this._joinFlag = "inner", this._boolFlag = "and", this._notFlag = !1, this._asColumnFlag = !1;
  }
  toString() {
    return this.toQuery();
  }
  // Convert the current query "toSQL"
  toSQL(e, r) {
    return this.client.queryCompiler(this).toSQL(e || this._method, r);
  }
  // Create a shallow clone of the current query builder.
  clone() {
    const e = new this.constructor(this.client);
    return e._method = this._method, e._single = Zs(this._single), e._statements = Zs(this._statements), e._debug = this._debug, this._options !== void 0 && (e._options = Zs(this._options)), this._queryContext !== void 0 && (e._queryContext = Zs(this._queryContext)), this._connection !== void 0 && (e._connection = this._connection), e;
  }
  timeout(e, { cancel: r } = {}) {
    return SY(e) && e > 0 && (this._timeout = e, r && (this.client.assertCanCancelQuery(), this._cancelOnTimeout = !0)), this;
  }
  // With
  // ------
  isValidStatementArg(e) {
    return typeof e == "function" || e instanceof xe || e && e.isRawInstance;
  }
  _validateWithArgs(e, r, n, i) {
    const [a, s] = typeof n > "u" ? [r, void 0] : [n, r];
    if (typeof e != "string")
      throw new Error(`${i}() first argument must be a string`);
    if (this.isValidStatementArg(a) && typeof s > "u")
      return;
    if (!(Array.isArray(s) && s.length > 0 && s.every((c) => typeof c == "string")))
      throw new Error(
        `${i}() second argument must be a statement or non-empty column name list.`
      );
    if (!this.isValidStatementArg(a))
      throw new Error(
        `${i}() third argument must be a function / QueryBuilder or a raw when its second argument is a column name list`
      );
  }
  with(e, r, n) {
    return this._validateWithArgs(
      e,
      r,
      n,
      "with"
    ), this.withWrapped(e, r, n);
  }
  withMaterialized(e, r, n) {
    throw new Error("With materialized is not supported by this dialect");
  }
  withNotMaterialized(e, r, n) {
    throw new Error("With materialized is not supported by this dialect");
  }
  // Helper for compiling any advanced `with` queries.
  withWrapped(e, r, n, i) {
    const [a, s] = typeof n > "u" ? [r, void 0] : [n, r], o = {
      grouping: "with",
      type: "withWrapped",
      alias: e,
      columnList: s,
      value: a
    };
    return i !== void 0 && (o.materialized = i), this._statements.push(o), this;
  }
  // With Recursive
  // ------
  withRecursive(e, r, n) {
    return this._validateWithArgs(
      e,
      r,
      n,
      "withRecursive"
    ), this.withRecursiveWrapped(
      e,
      r,
      n
    );
  }
  // Helper for compiling any advanced `withRecursive` queries.
  withRecursiveWrapped(e, r, n) {
    return this.withWrapped(e, r, n), this._statements[this._statements.length - 1].recursive = !0, this;
  }
  // Select
  // ------
  // Adds a column or columns to the list of "columns"
  // being selected on the query.
  columns(e) {
    return !e && e !== 0 ? this : (this._statements.push({
      grouping: "columns",
      value: na(...arguments)
    }), this);
  }
  // Allow for a sub-select to be explicitly aliased as a column,
  // without needing to compile the query in a where.
  as(e) {
    return this._single.as = e, this;
  }
  // Adds a single hint or an array of hits to the list of "hintComments" on the query.
  hintComment(e) {
    if (e = Array.isArray(e) ? e : [e], e.some((r) => !ap(r)))
      throw new Error("Hint comment must be a string");
    if (e.some((r) => r.includes("/*") || r.includes("*/")))
      throw new Error('Hint comment cannot include "/*" or "*/"');
    if (e.some((r) => r.includes("?")))
      throw new Error('Hint comment cannot include "?"');
    return this._statements.push({
      grouping: "hintComments",
      value: e
    }), this;
  }
  // Prepends the `schemaName` on `tableName` defined by `.table` and `.join`.
  withSchema(e) {
    return this._single.schema = e, this;
  }
  // Sets the `tableName` on the query.
  // Alias to "from" for select and "into" for insert statements
  // e.g. builder.insert({a: value}).into('tableName')
  // `options`: options object containing keys:
  //   - `only`: whether the query should use SQL's ONLY to not return
  //           inheriting table data. Defaults to false.
  table(e, r = {}) {
    return this._single.table = e, this._single.only = r.only === !0, this;
  }
  // Adds a `distinct` clause to the query.
  distinct(...e) {
    return this._statements.push({
      grouping: "columns",
      value: na(...e),
      distinct: !0
    }), this;
  }
  distinctOn(...e) {
    if (ni(e))
      throw new Error("distinctOn requires at least on argument");
    return this._statements.push({
      grouping: "columns",
      value: na(...e),
      distinctOn: !0
    }), this;
  }
  // Adds a join clause to the query, allowing for advanced joins
  // with an anonymous function as the second argument.
  join(e, r, ...n) {
    let i;
    const a = e instanceof xe || typeof e == "function" ? void 0 : this._single.schema, s = this._joinType();
    return typeof r == "function" ? (i = new ip(e, s, a), r.call(i, i)) : s === "raw" ? i = new ip(this.client.raw(e, r), "raw") : (i = new ip(e, s, a), r && i.on(r, ...n)), this._statements.push(i), this;
  }
  using(e) {
    throw new Error(
      "'using' function is only available in PostgreSQL dialect with Delete statements."
    );
  }
  // JOIN blocks:
  innerJoin(...e) {
    return this._joinType("inner").join(...e);
  }
  leftJoin(...e) {
    return this._joinType("left").join(...e);
  }
  leftOuterJoin(...e) {
    return this._joinType("left outer").join(...e);
  }
  rightJoin(...e) {
    return this._joinType("right").join(...e);
  }
  rightOuterJoin(...e) {
    return this._joinType("right outer").join(...e);
  }
  outerJoin(...e) {
    return this._joinType("outer").join(...e);
  }
  fullOuterJoin(...e) {
    return this._joinType("full outer").join(...e);
  }
  crossJoin(...e) {
    return this._joinType("cross").join(...e);
  }
  joinRaw(...e) {
    return this._joinType("raw").join(...e);
  }
  // Where modifiers:
  get or() {
    return this._bool("or");
  }
  get not() {
    return this._not(!0);
  }
  // The where function can be used in several ways:
  // The most basic is `where(key, value)`, which expands to
  // where key = value.
  where(e, r, n) {
    const i = arguments.length;
    if (e === !1 || e === !0)
      return this.where(1, "=", e ? 1 : 0);
    if (typeof e == "function")
      return this.whereWrapped(e);
    if (Or(e) && !e.isRawInstance)
      return this._objectWhere(e);
    if (e && e.isRawInstance && i === 1)
      return this.whereRaw(e);
    if (i === 2 && (n = r, r = "=", n === null))
      return this.whereNull(e);
    const a = `${r}`.toLowerCase().trim();
    if (i === 3) {
      if (a === "in" || a === "not in")
        return this._not(a === "not in").whereIn(e, n);
      if (a === "between" || a === "not between")
        return this._not(a === "not between").whereBetween(
          e,
          n
        );
    }
    return n === null && (a === "is" || a === "is not") ? this._not(a === "is not").whereNull(e) : (this._statements.push({
      grouping: "where",
      type: "whereBasic",
      column: e,
      operator: r,
      value: n,
      not: this._not(),
      bool: this._bool(),
      asColumn: this._asColumnFlag
    }), this);
  }
  whereColumn(...e) {
    return this._asColumnFlag = !0, this.where(...e), this._asColumnFlag = !1, this;
  }
  // Adds an `or where` clause to the query.
  orWhere(e, ...r) {
    this._bool("or");
    const n = e;
    return Or(n) && !n.isRawInstance ? this.whereWrapped(function() {
      for (const i in n)
        this.andWhere(i, n[i]);
    }) : this.where(e, ...r);
  }
  orWhereColumn(e, ...r) {
    this._bool("or");
    const n = e;
    return Or(n) && !n.isRawInstance ? this.whereWrapped(function() {
      for (const i in n)
        this.andWhereColumn(i, "=", n[i]);
    }) : this.whereColumn(e, ...r);
  }
  // Adds an `not where` clause to the query.
  whereNot(e, ...r) {
    return r.length >= 2 && (r[0] === "in" || r[0] === "between") && this.client.logger.warn(
      'whereNot is not suitable for "in" and "between" type subqueries. You should use "not in" and "not between" instead.'
    ), this._not(!0).where(e, ...r);
  }
  whereNotColumn(...e) {
    return this._not(!0).whereColumn(...e);
  }
  // Adds an `or not where` clause to the query.
  orWhereNot(...e) {
    return this._bool("or").whereNot(...e);
  }
  orWhereNotColumn(...e) {
    return this._bool("or").whereNotColumn(...e);
  }
  // Processes an object literal provided in a "where" clause.
  _objectWhere(e) {
    const r = this._bool(), n = this._not() ? "Not" : "";
    for (const i in e)
      this[r + "Where" + n](i, e[i]);
    return this;
  }
  // Adds a raw `where` clause to the query.
  whereRaw(e, r) {
    const n = e.isRawInstance ? e : this.client.raw(e, r);
    return this._statements.push({
      grouping: "where",
      type: "whereRaw",
      value: n,
      not: this._not(),
      bool: this._bool()
    }), this;
  }
  orWhereRaw(e, r) {
    return this._bool("or").whereRaw(e, r);
  }
  // Helper for compiling any advanced `where` queries.
  whereWrapped(e) {
    return this._statements.push({
      grouping: "where",
      type: "whereWrapped",
      value: e,
      not: this._not(),
      bool: this._bool()
    }), this;
  }
  // Adds a `where exists` clause to the query.
  whereExists(e) {
    return this._statements.push({
      grouping: "where",
      type: "whereExists",
      value: e,
      not: this._not(),
      bool: this._bool()
    }), this;
  }
  // Adds an `or where exists` clause to the query.
  orWhereExists(e) {
    return this._bool("or").whereExists(e);
  }
  // Adds a `where not exists` clause to the query.
  whereNotExists(e) {
    return this._not(!0).whereExists(e);
  }
  // Adds a `or where not exists` clause to the query.
  orWhereNotExists(e) {
    return this._bool("or").whereNotExists(e);
  }
  // Adds a `where in` clause to the query.
  whereIn(e, r) {
    return Array.isArray(r) && ni(r) ? this.where(this._not()) : (this._statements.push({
      grouping: "where",
      type: "whereIn",
      column: e,
      value: r,
      not: this._not(),
      bool: this._bool()
    }), this);
  }
  // Adds a `or where in` clause to the query.
  orWhereIn(e, r) {
    return this._bool("or").whereIn(e, r);
  }
  // Adds a `where not in` clause to the query.
  whereNotIn(e, r) {
    return this._not(!0).whereIn(e, r);
  }
  // Adds a `or where not in` clause to the query.
  orWhereNotIn(e, r) {
    return this._bool("or")._not(!0).whereIn(e, r);
  }
  // Adds a `where null` clause to the query.
  whereNull(e) {
    return this._statements.push({
      grouping: "where",
      type: "whereNull",
      column: e,
      not: this._not(),
      bool: this._bool()
    }), this;
  }
  // Adds a `or where null` clause to the query.
  orWhereNull(e) {
    return this._bool("or").whereNull(e);
  }
  // Adds a `where not null` clause to the query.
  whereNotNull(e) {
    return this._not(!0).whereNull(e);
  }
  // Adds a `or where not null` clause to the query.
  orWhereNotNull(e) {
    return this._bool("or").whereNotNull(e);
  }
  // Adds a `where between` clause to the query.
  whereBetween(e, r) {
    return ri(
      Array.isArray(r),
      "The second argument to whereBetween must be an array."
    ), ri(
      r.length === 2,
      "You must specify 2 values for the whereBetween clause"
    ), this._statements.push({
      grouping: "where",
      type: "whereBetween",
      column: e,
      value: r,
      not: this._not(),
      bool: this._bool()
    }), this;
  }
  // Adds a `where not between` clause to the query.
  whereNotBetween(e, r) {
    return this._not(!0).whereBetween(e, r);
  }
  // Adds a `or where between` clause to the query.
  orWhereBetween(e, r) {
    return this._bool("or").whereBetween(e, r);
  }
  // Adds a `or where not between` clause to the query.
  orWhereNotBetween(e, r) {
    return this._bool("or").whereNotBetween(e, r);
  }
  _whereLike(e, r, n) {
    return this._statements.push({
      grouping: "where",
      type: e,
      column: r,
      value: n,
      not: this._not(),
      bool: this._bool(),
      asColumn: this._asColumnFlag
    }), this;
  }
  // Adds a `where like` clause to the query.
  whereLike(e, r) {
    return this._whereLike("whereLike", e, r);
  }
  // Adds a `or where like` clause to the query.
  orWhereLike(e, r) {
    return this._bool("or")._whereLike("whereLike", e, r);
  }
  // Adds a `where ilike` clause to the query.
  whereILike(e, r) {
    return this._whereLike("whereILike", e, r);
  }
  // Adds a `or where ilike` clause to the query.
  orWhereILike(e, r) {
    return this._bool("or")._whereLike("whereILike", e, r);
  }
  // Adds a `group by` clause to the query.
  groupBy(e) {
    return e && e.isRawInstance ? this.groupByRaw.apply(this, arguments) : (this._statements.push({
      grouping: "group",
      type: "groupByBasic",
      value: na(...arguments)
    }), this);
  }
  // Adds a raw `group by` clause to the query.
  groupByRaw(e, r) {
    const n = e.isRawInstance ? e : this.client.raw(e, r);
    return this._statements.push({
      grouping: "group",
      type: "groupByRaw",
      value: n
    }), this;
  }
  // Adds a `order by` clause to the query.
  orderBy(e, r, n = "") {
    return Array.isArray(e) ? this._orderByArray(e) : (this._statements.push({
      grouping: "order",
      type: "orderByBasic",
      value: e,
      direction: r,
      nulls: n
    }), this);
  }
  // Adds a `order by` with multiple columns to the query.
  _orderByArray(e) {
    for (let r = 0; r < e.length; r++) {
      const n = e[r];
      Or(n) ? this._statements.push({
        grouping: "order",
        type: "orderByBasic",
        value: n.column,
        direction: n.order,
        nulls: n.nulls
      }) : ap(n) && this._statements.push({
        grouping: "order",
        type: "orderByBasic",
        value: n
      });
    }
    return this;
  }
  // Add a raw `order by` clause to the query.
  orderByRaw(e, r) {
    const n = e.isRawInstance ? e : this.client.raw(e, r);
    return this._statements.push({
      grouping: "order",
      type: "orderByRaw",
      value: n
    }), this;
  }
  _union(e, r) {
    let n = r[0], i = r[1];
    if (r.length === 1 || r.length === 2 && ia(i)) {
      Array.isArray(n) || (n = [n]);
      for (let a = 0, s = n.length; a < s; a++)
        this._statements.push({
          grouping: "union",
          clause: e,
          value: n[a],
          wrap: i || !1
        });
    } else
      n = l1(r).slice(0, r.length - 1), i = r[r.length - 1], ia(i) || (n.push(i), i = !1), this._union(e, [n, i]);
    return this;
  }
  // Add a union statement to the query.
  union(...e) {
    return this._union("union", e);
  }
  // Adds a union all statement to the query.
  unionAll(...e) {
    return this._union("union all", e);
  }
  // Adds an intersect statement to the query
  intersect(e, r) {
    if (arguments.length === 1 || arguments.length === 2 && ia(r)) {
      Array.isArray(e) || (e = [e]);
      for (let n = 0, i = e.length; n < i; n++)
        this._statements.push({
          grouping: "union",
          clause: "intersect",
          value: e[n],
          wrap: r || !1
        });
    } else
      e = l1(arguments).slice(0, arguments.length - 1), r = arguments[arguments.length - 1], ia(r) || (e.push(r), r = !1), this.intersect(e, r);
    return this;
  }
  // Adds a `having` clause to the query.
  having(e, r, n) {
    return e.isRawInstance && arguments.length === 1 ? this.havingRaw(e) : typeof e == "function" ? this.havingWrapped(e) : (this._statements.push({
      grouping: "having",
      type: "havingBasic",
      column: e,
      operator: r,
      value: n,
      bool: this._bool(),
      not: this._not()
    }), this);
  }
  orHaving(e, ...r) {
    this._bool("or");
    const n = e;
    return Or(n) && !n.isRawInstance ? this.havingWrapped(function() {
      for (const i in n)
        this.andHaving(i, n[i]);
    }) : this.having(e, ...r);
  }
  // Helper for compiling any advanced `having` queries.
  havingWrapped(e) {
    return this._statements.push({
      grouping: "having",
      type: "havingWrapped",
      value: e,
      bool: this._bool(),
      not: this._not()
    }), this;
  }
  havingNull(e) {
    return this._statements.push({
      grouping: "having",
      type: "havingNull",
      column: e,
      not: this._not(),
      bool: this._bool()
    }), this;
  }
  orHavingNull(e) {
    return this._bool("or").havingNull(e);
  }
  havingNotNull(e) {
    return this._not(!0).havingNull(e);
  }
  orHavingNotNull(e) {
    return this._not(!0)._bool("or").havingNull(e);
  }
  havingExists(e) {
    return this._statements.push({
      grouping: "having",
      type: "havingExists",
      value: e,
      not: this._not(),
      bool: this._bool()
    }), this;
  }
  orHavingExists(e) {
    return this._bool("or").havingExists(e);
  }
  havingNotExists(e) {
    return this._not(!0).havingExists(e);
  }
  orHavingNotExists(e) {
    return this._not(!0)._bool("or").havingExists(e);
  }
  havingBetween(e, r) {
    return ri(
      Array.isArray(r),
      "The second argument to havingBetween must be an array."
    ), ri(
      r.length === 2,
      "You must specify 2 values for the havingBetween clause"
    ), this._statements.push({
      grouping: "having",
      type: "havingBetween",
      column: e,
      value: r,
      not: this._not(),
      bool: this._bool()
    }), this;
  }
  orHavingBetween(e, r) {
    return this._bool("or").havingBetween(e, r);
  }
  havingNotBetween(e, r) {
    return this._not(!0).havingBetween(e, r);
  }
  orHavingNotBetween(e, r) {
    return this._not(!0)._bool("or").havingBetween(e, r);
  }
  havingIn(e, r) {
    return Array.isArray(r) && ni(r) ? this.where(this._not()) : (this._statements.push({
      grouping: "having",
      type: "havingIn",
      column: e,
      value: r,
      not: this._not(),
      bool: this._bool()
    }), this);
  }
  // Adds a `or where in` clause to the query.
  orHavingIn(e, r) {
    return this._bool("or").havingIn(e, r);
  }
  // Adds a `where not in` clause to the query.
  havingNotIn(e, r) {
    return this._not(!0).havingIn(e, r);
  }
  // Adds a `or where not in` clause to the query.
  orHavingNotIn(e, r) {
    return this._bool("or")._not(!0).havingIn(e, r);
  }
  // Adds a raw `having` clause to the query.
  havingRaw(e, r) {
    const n = e.isRawInstance ? e : this.client.raw(e, r);
    return this._statements.push({
      grouping: "having",
      type: "havingRaw",
      value: n,
      bool: this._bool(),
      not: this._not()
    }), this;
  }
  orHavingRaw(e, r) {
    return this._bool("or").havingRaw(e, r);
  }
  // set the skip binding parameter (= insert the raw value in the query) for an attribute.
  _setSkipBinding(e, r) {
    let n = r;
    Or(r) && (n = r.skipBinding), this._single.skipBinding = this._single.skipBinding || {}, this._single.skipBinding[e] = n;
  }
  // Only allow a single "offset" to be set for the current query.
  offset(e, r) {
    if (e == null || e.isRawInstance || e instanceof xe)
      this._single.offset = e;
    else {
      const n = parseInt(e, 10);
      if (isNaN(n))
        this.client.logger.warn("A valid integer must be provided to offset");
      else {
        if (n < 0)
          throw new Error("A non-negative integer must be provided to offset.");
        this._single.offset = n;
      }
    }
    return this._setSkipBinding("offset", r), this;
  }
  // Only allow a single "limit" to be set for the current query.
  limit(e, r) {
    const n = parseInt(e, 10);
    return isNaN(n) ? this.client.logger.warn("A valid integer must be provided to limit") : (this._single.limit = n, this._setSkipBinding("limit", r)), this;
  }
  // Retrieve the "count" result of the query.
  count(e, r) {
    return this._aggregate("count", e || "*", r);
  }
  // Retrieve the minimum value of a given column.
  min(e, r) {
    return this._aggregate("min", e, r);
  }
  // Retrieve the maximum value of a given column.
  max(e, r) {
    return this._aggregate("max", e, r);
  }
  // Retrieve the sum of the values of a given column.
  sum(e, r) {
    return this._aggregate("sum", e, r);
  }
  // Retrieve the average of the values of a given column.
  avg(e, r) {
    return this._aggregate("avg", e, r);
  }
  // Retrieve the "count" of the distinct results of the query.
  countDistinct(...e) {
    let r;
    return e.length > 1 && u1(yY(e)) && ([r] = e.splice(e.length - 1, 1)), e.length ? e.length === 1 && (e = e[0]) : e = "*", this._aggregate("count", e, { ...r, distinct: !0 });
  }
  // Retrieve the sum of the distinct values of a given column.
  sumDistinct(e, r) {
    return this._aggregate("sum", e, { ...r, distinct: !0 });
  }
  // Retrieve the vg of the distinct results of the query.
  avgDistinct(e, r) {
    return this._aggregate("avg", e, { ...r, distinct: !0 });
  }
  // Increments a column's value by the specified amount.
  increment(e, r = 1) {
    if (Or(e)) {
      for (const n in e)
        this._counter(n, e[n]);
      return this;
    }
    return this._counter(e, r);
  }
  // Decrements a column's value by the specified amount.
  decrement(e, r = 1) {
    if (Or(e)) {
      for (const n in e)
        this._counter(n, -e[n]);
      return this;
    }
    return this._counter(e, -r);
  }
  // Clears increments/decrements
  clearCounters() {
    return this._single.counter = {}, this;
  }
  // Sets the values for a `select` query, informing that only the first
  // row should be returned (limit 1).
  first(...e) {
    if (this._method && this._method !== "select")
      throw new Error(`Cannot chain .first() on "${this._method}" query`);
    return this.select(na(...e)), this._method = "first", this.limit(1), this;
  }
  // Use existing connection to execute the query
  // Same value that client.acquireConnection() for an according client returns should be passed
  connection(e) {
    return this._connection = e, this.client.processPassedConnection(e), this;
  }
  // Pluck a column from a query.
  pluck(e) {
    if (this._method && this._method !== "select")
      throw new Error(`Cannot chain .pluck() on "${this._method}" query`);
    return this._method = "pluck", this._single.pluck = e, this._statements.push({
      grouping: "columns",
      type: "pluck",
      value: e
    }), this;
  }
  // Deprecated. Remove everything from select clause
  clearSelect() {
    return this._clearGrouping("columns"), this;
  }
  // Deprecated. Remove everything from where clause
  clearWhere() {
    return this._clearGrouping("where"), this;
  }
  // Deprecated. Remove everything from group clause
  clearGroup() {
    return this._clearGrouping("group"), this;
  }
  // Deprecated. Remove everything from order clause
  clearOrder() {
    return this._clearGrouping("order"), this;
  }
  // Deprecated. Remove everything from having clause
  clearHaving() {
    return this._clearGrouping("having"), this;
  }
  // Remove everything from statement clause
  clear(e) {
    if (!AY.has(e))
      throw new Error(`Knex Error: unknown statement '${e}'`);
    return e.startsWith("counter") ? this.clearCounters() : (e === "select" && (e = "columns"), this._clearGrouping(e), this);
  }
  // Insert & Update
  // ------
  // Sets the values for an `insert` query.
  insert(e, r, n) {
    return this._method = "insert", ni(r) || this.returning(r, n), this._single.insert = e, this;
  }
  // Sets the values for an `update`, allowing for both
  // `.update(key, value, [returning])` and `.update(obj, [returning])` syntaxes.
  update(e, r, n) {
    let i;
    const a = this._single.update || {};
    if (this._method = "update", ap(e))
      u1(r) ? a[e] = JSON.stringify(r) : a[e] = r, arguments.length > 2 && (i = arguments[2]);
    else {
      const s = Object.keys(e);
      this._single.update && this.client.logger.warn("Update called multiple times with objects.");
      let o = -1;
      for (; ++o < s.length; )
        a[s[o]] = e[s[o]];
      i = arguments[1];
    }
    return ni(i) || this.returning(i, n), this._single.update = a, this;
  }
  // Sets the returning value for the query.
  returning(e, r) {
    return this._single.returning = e, this._single.options = r, this;
  }
  onConflict(e) {
    return typeof e == "string" && (e = [e]), new IY(this, e || !0);
  }
  // Delete
  // ------
  // Executes a delete statement on the query;
  delete(e, r) {
    return this._method = "del", ni(e) || this.returning(e, r), this;
  }
  // Truncates a table, ends the query chain.
  truncate(e) {
    return this._method = "truncate", e && (this._single.table = e), this;
  }
  // Retrieves columns for the table specified by `knex(tableName)`
  columnInfo(e) {
    return this._method = "columnInfo", this._single.columnInfo = e, this;
  }
  // Set a lock for update constraint.
  forUpdate(...e) {
    return this._single.lock = Jr.forUpdate, e.length === 1 && Array.isArray(e[0]) ? this._single.lockTables = e[0] : this._single.lockTables = e, this;
  }
  // Set a lock for share constraint.
  forShare(...e) {
    return this._single.lock = Jr.forShare, this._single.lockTables = e, this;
  }
  // Set a lock for no key update constraint.
  forNoKeyUpdate(...e) {
    return this._single.lock = Jr.forNoKeyUpdate, this._single.lockTables = e, this;
  }
  // Set a lock for key share constraint.
  forKeyShare(...e) {
    return this._single.lock = Jr.forKeyShare, this._single.lockTables = e, this;
  }
  // Skips locked rows when using a lock constraint.
  skipLocked() {
    if (!this._isSelectQuery())
      throw new Error(`Cannot chain .skipLocked() on "${this._method}" query!`);
    if (!this._hasLockMode())
      throw new Error(
        ".skipLocked() can only be used after a call to .forShare() or .forUpdate()!"
      );
    if (this._single.waitMode === Ys.noWait)
      throw new Error(".skipLocked() cannot be used together with .noWait()!");
    return this._single.waitMode = Ys.skipLocked, this;
  }
  // Causes error when acessing a locked row instead of waiting for it to be released.
  noWait() {
    if (!this._isSelectQuery())
      throw new Error(`Cannot chain .noWait() on "${this._method}" query!`);
    if (!this._hasLockMode())
      throw new Error(
        ".noWait() can only be used after a call to .forShare() or .forUpdate()!"
      );
    if (this._single.waitMode === Ys.skipLocked)
      throw new Error(".noWait() cannot be used together with .skipLocked()!");
    return this._single.waitMode = Ys.noWait, this;
  }
  // Takes a JS object of methods to call and calls them
  fromJS(e) {
    return vY(e, (r, n) => {
      typeof this[n] != "function" && this.client.logger.warn(`Knex Error: unknown key ${n}`), Array.isArray(r) ? this[n].apply(this, r) : this[n](r);
    }), this;
  }
  fromRaw(e, r) {
    const n = e.isRawInstance ? e : this.client.raw(e, r);
    return this.from(n);
  }
  // Passes query to provided callback function, useful for e.g. composing
  // domain-specific helpers
  modify(e) {
    return e.apply(this, [this].concat(wY(arguments))), this;
  }
  upsert(e, r, n) {
    throw new Error(
      `Upsert is not yet supported for dialect ${this.client.dialect}`
    );
  }
  // JSON support functions
  _json(e, r) {
    return this._statements.push({
      grouping: "columns",
      type: "json",
      method: e,
      params: r
    }), this;
  }
  jsonExtract() {
    const e = arguments[0];
    let r, n, i = !0;
    return arguments.length >= 2 && (r = arguments[1]), arguments.length >= 3 && (n = arguments[2]), arguments.length === 4 && (i = arguments[3]), arguments.length === 2 && Array.isArray(arguments[0]) && ia(arguments[1]) && (i = arguments[1]), this._json("jsonExtract", {
      column: e,
      path: r,
      alias: n,
      singleValue: i
      // boolean used only in MSSQL to use function for extract value instead of object/array.
    });
  }
  jsonSet(e, r, n, i) {
    return this._json("jsonSet", {
      column: e,
      path: r,
      value: n,
      alias: i
    });
  }
  jsonInsert(e, r, n, i) {
    return this._json("jsonInsert", {
      column: e,
      path: r,
      value: n,
      alias: i
    });
  }
  jsonRemove(e, r, n) {
    return this._json("jsonRemove", {
      column: e,
      path: r,
      alias: n
    });
  }
  // Wheres for JSON
  _isJsonObject(e) {
    return Or(e) && !(e instanceof xe);
  }
  _whereJsonWrappedValue(e, r, n) {
    const i = {
      grouping: "where",
      type: e,
      column: r,
      value: n,
      not: this._not(),
      bool: this._bool(),
      asColumn: this._asColumnFlag
    };
    arguments[3] && (i.operator = arguments[3]), arguments[4] && (i.jsonPath = arguments[4]), this._statements.push(i);
  }
  whereJsonObject(e, r) {
    return this._whereJsonWrappedValue("whereJsonObject", e, r), this;
  }
  orWhereJsonObject(e, r) {
    return this._bool("or").whereJsonObject(e, r);
  }
  whereNotJsonObject(e, r) {
    return this._not(!0).whereJsonObject(e, r);
  }
  orWhereNotJsonObject(e, r) {
    return this._bool("or").whereNotJsonObject(e, r);
  }
  whereJsonPath(e, r, n, i) {
    return this._whereJsonWrappedValue("whereJsonPath", e, i, n, r), this;
  }
  orWhereJsonPath(e, r, n, i) {
    return this._bool("or").whereJsonPath(e, r, n, i);
  }
  // Json superset wheres
  whereJsonSupersetOf(e, r) {
    return this._whereJsonWrappedValue("whereJsonSupersetOf", e, r), this;
  }
  whereJsonNotSupersetOf(e, r) {
    return this._not(!0).whereJsonSupersetOf(e, r);
  }
  orWhereJsonSupersetOf(e, r) {
    return this._bool("or").whereJsonSupersetOf(e, r);
  }
  orWhereJsonNotSupersetOf(e, r) {
    return this._bool("or").whereJsonNotSupersetOf(e, r);
  }
  // Json subset wheres
  whereJsonSubsetOf(e, r) {
    return this._whereJsonWrappedValue("whereJsonSubsetOf", e, r), this;
  }
  whereJsonNotSubsetOf(e, r) {
    return this._not(!0).whereJsonSubsetOf(e, r);
  }
  orWhereJsonSubsetOf(e, r) {
    return this._bool("or").whereJsonSubsetOf(e, r);
  }
  orWhereJsonNotSubsetOf(e, r) {
    return this._bool("or").whereJsonNotSubsetOf(e, r);
  }
  whereJsonHasNone(e, r) {
    return this._not(!0).whereJsonHasAll(e, r), this;
  }
  // end of wheres for JSON
  _analytic(e, r, n) {
    let i;
    const { schema: a } = this._single, s = this._analyticMethod();
    if (e = typeof e == "string" ? e : null, ri(
      typeof r == "function" || r.isRawInstance || Array.isArray(r) || typeof r == "string" || typeof r == "object",
      `The second argument to an analytic function must be either a function, a raw,
       an array of string or object, an object or a single string.`
    ), n && ri(
      Array.isArray(n) || typeof n == "string" || typeof n == "object",
      "The third argument to an analytic function must be either a string, an array of string or object or an object."
    ), CY(r))
      i = new _Y(s, a, e), r.call(i, i);
    else if (r.isRawInstance)
      i = {
        grouping: "columns",
        type: "analytic",
        method: s,
        raw: r,
        alias: e
      };
    else {
      const o = Array.isArray(r) ? r : [r];
      let c = n || [];
      c = Array.isArray(c) ? c : [c], i = {
        grouping: "columns",
        type: "analytic",
        method: s,
        order: o,
        alias: e,
        partitions: c
      };
    }
    return this._statements.push(i), this;
  }
  rank(...e) {
    return this._analyticMethod("rank")._analytic(...e);
  }
  denseRank(...e) {
    return this._analyticMethod("dense_rank")._analytic(...e);
  }
  rowNumber(...e) {
    return this._analyticMethod("row_number")._analytic(...e);
  }
  // ----------------------------------------------------------------------
  // Helper for the incrementing/decrementing queries.
  _counter(e, r) {
    return r = parseFloat(r), this._method = "update", this._single.counter = this._single.counter || {}, this._single.counter[e] = r, this;
  }
  // Helper to get or set the "boolFlag" value.
  _bool(e) {
    if (arguments.length === 1)
      return this._boolFlag = e, this;
    const r = this._boolFlag;
    return this._boolFlag = "and", r;
  }
  // Helper to get or set the "notFlag" value.
  _not(e) {
    if (arguments.length === 1)
      return this._notFlag = e, this;
    const r = this._notFlag;
    return this._notFlag = !1, r;
  }
  // Helper to get or set the "joinFlag" value.
  _joinType(e) {
    if (arguments.length === 1)
      return this._joinFlag = e, this;
    const r = this._joinFlag || "inner";
    return this._joinFlag = "inner", r;
  }
  _analyticMethod(e) {
    return arguments.length === 1 ? (this._analyticFlag = e, this) : this._analyticFlag || "row_number";
  }
  // Helper for compiling any aggregate queries.
  _aggregate(e, r, n = {}) {
    return this._statements.push({
      grouping: "columns",
      type: r.isRawInstance ? "aggregateRaw" : "aggregate",
      method: e,
      value: r,
      aggregateDistinct: n.distinct || !1,
      alias: n.as
    }), this;
  }
  // Helper function for clearing or reseting a grouping type from the builder
  _clearGrouping(e) {
    e in this._single ? this._single[e] = void 0 : this._statements = bY(this._statements, { grouping: e });
  }
  // Helper function that checks if the builder will emit a select query
  _isSelectQuery() {
    return OY.has(this._method);
  }
  // Helper function that checks if the query has a lock mode set
  _hasLockMode() {
    return $Y.has(this._single.lock);
  }
}
xe.prototype.select = xe.prototype.columns;
xe.prototype.column = xe.prototype.columns;
xe.prototype.andWhereNot = xe.prototype.whereNot;
xe.prototype.andWhereNotColumn = xe.prototype.whereNotColumn;
xe.prototype.andWhere = xe.prototype.where;
xe.prototype.andWhereColumn = xe.prototype.whereColumn;
xe.prototype.andWhereRaw = xe.prototype.whereRaw;
xe.prototype.andWhereBetween = xe.prototype.whereBetween;
xe.prototype.andWhereNotBetween = xe.prototype.whereNotBetween;
xe.prototype.andWhereJsonObject = xe.prototype.whereJsonObject;
xe.prototype.andWhereNotJsonObject = xe.prototype.whereJsonObject;
xe.prototype.andWhereJsonPath = xe.prototype.whereJsonPath;
xe.prototype.andWhereLike = xe.prototype.whereLike;
xe.prototype.andWhereILike = xe.prototype.whereILike;
xe.prototype.andHaving = xe.prototype.having;
xe.prototype.andHavingIn = xe.prototype.havingIn;
xe.prototype.andHavingNotIn = xe.prototype.havingNotIn;
xe.prototype.andHavingNull = xe.prototype.havingNull;
xe.prototype.andHavingNotNull = xe.prototype.havingNotNull;
xe.prototype.andHavingExists = xe.prototype.havingExists;
xe.prototype.andHavingNotExists = xe.prototype.havingNotExists;
xe.prototype.andHavingBetween = xe.prototype.havingBetween;
xe.prototype.andHavingNotBetween = xe.prototype.havingNotBetween;
xe.prototype.from = xe.prototype.table;
xe.prototype.into = xe.prototype.table;
xe.prototype.del = xe.prototype.delete;
TY(xe);
xY(xe);
xe.extend = (t, e) => {
  if (Object.prototype.hasOwnProperty.call(xe.prototype, t))
    throw new Error(
      `Can't extend QueryBuilder with existing method ('${t}').`
    );
  gY(xe.prototype, { [t]: e });
};
class IY {
  constructor(e, r) {
    this.builder = e, this._columns = r;
  }
  // Sets insert query to ignore conflicts
  ignore() {
    return this.builder._single.onConflict = this._columns, this.builder._single.ignore = !0, this.builder;
  }
  // Sets insert query to update on conflict
  merge(e) {
    return this.builder._single.onConflict = this._columns, this.builder._single.merge = { updates: e }, this.builder;
  }
  // Prevent
  then() {
    throw new Error(
      "Incomplete onConflict clause. .onConflict() must be directly followed by either .merge() or .ignore()"
    );
  }
}
var pn = xe;
function kY(t, e, r, n) {
  var i = -1, a = t == null ? 0 : t.length;
  for (n && a && (r = t[++i]); ++i < a; )
    r = e(r, t[i], i, t);
  return r;
}
var RY = kY;
function NY(t, e, r, n, i) {
  return i(t, function(a, s, o) {
    r = n ? (n = !1, a) : e(r, a, s, o);
  }), r;
}
var LY = NY, PY = RY, DY = Ui, MY = Fr, qY = LY, jY = at;
function FY(t, e, r) {
  var n = jY(t) ? PY : qY, i = arguments.length < 3;
  return n(t, MY(e), r, i, DY);
}
var gs = FY, BY = vv, UY = mO, zY = QO, HY = Fr, WY = Xc, GY = at, QY = qi, VY = Hc, KY = Ht, JY = ji;
function XY(t, e, r) {
  var n = GY(t), i = n || QY(t) || JY(t);
  if (e = HY(e), r == null) {
    var a = t && t.constructor;
    i ? r = n ? new a() : [] : KY(t) ? r = VY(a) ? UY(WY(t)) : {} : r = {};
  }
  return (i ? BY : zY)(t, function(s, o, c) {
    return e(r, s, o, c);
  }), r;
}
var ZY = XY;
const { isObject: YY } = Je;
function eee(t, e, r, n) {
  const i = r.queryBuilder();
  return t.call(i, i), r.queryCompiler(i, n.bindings).toSQL(e || i._method || "select");
}
function tee(t, e, r) {
  const n = e.queryContext();
  return r.wrapIdentifier((t || "").trim(), n);
}
function ree(t, e, r) {
  return t === void 0 ? "" : t === null ? "null" : t && t.isRawInstance ? t.toQuery() : e === "bool" ? (t === "false" && (t = 0), `'${t ? 1 : 0}'`) : (e === "json" || e === "jsonb") && YY(t) ? `'${JSON.stringify(t)}'` : r._escapeBinding(t.toString());
}
var Un = {
  compileCallback: eee,
  wrapAsIdentifier: tee,
  formatDefault: ree
};
const nee = ZY, vA = pn, { compileCallback: Pv, wrapAsIdentifier: Vo } = Un, iee = ["asc", "desc"], aee = nee(
  [
    "=",
    "<",
    ">",
    "<=",
    ">=",
    "<>",
    "!=",
    "like",
    "not like",
    "between",
    "not between",
    "ilike",
    "not ilike",
    "exists",
    "not exist",
    "rlike",
    "not rlike",
    "regexp",
    "not regexp",
    "match",
    "&",
    "|",
    "^",
    "<<",
    ">>",
    "~",
    "~=",
    "~*",
    "!~",
    "!~*",
    "#",
    "&&",
    "@>",
    "<@",
    "||",
    "&<",
    "&>",
    "-|-",
    "@@",
    "!!",
    ["?", "\\?"],
    ["?|", "\\?|"],
    ["?&", "\\?&"]
  ],
  (t, e) => {
    Array.isArray(e) ? t[e[0]] = e[1] : t[e] = e;
  },
  {}
);
function see(t, e, r, n) {
  const i = Array.isArray(t) ? t : [t];
  let a = "", s = -1;
  for (; ++s < i.length; )
    s > 0 && (a += ", "), a += Ko(i[s], void 0, e, r, n);
  return a;
}
function Ko(t, e, r, n, i) {
  const a = vs(t, e, r, n, i);
  if (a)
    return a;
  switch (typeof t) {
    case "function":
      return ys(
        Pv(t, void 0, n, i),
        !0,
        r,
        n
      );
    case "object":
      return cee(t, r, n, i);
    case "number":
      return t;
    default:
      return Fa(t + "", r, n);
  }
}
function vs(t, e, r, n, i) {
  let a;
  if (t instanceof vA)
    return a = n.queryCompiler(t).toSQL(), a.bindings && i.bindings.push(...a.bindings), ys(a, e, r, n);
  if (t && t.isRawInstance)
    return t.client = n, r._queryContext && (t.queryContext = () => r._queryContext), a = t.toSQL(), a.bindings && i.bindings.push(...a.bindings), a.sql;
  e && i.bindings.push(t);
}
function oee(t, e, r, n) {
  const i = vs(t, void 0, e, r, n);
  if (i)
    return i;
  const a = aee[(t || "").toLowerCase()];
  if (!a)
    throw new TypeError(`The operator "${t}" is not permitted`);
  return a;
}
function Fa(t, e, r) {
  const n = t.toLowerCase().indexOf(" as ");
  if (n !== -1) {
    const o = t.slice(0, n), c = t.slice(n + 4);
    return r.alias(
      Fa(o, e, r),
      Vo(c, e, r)
    );
  }
  const i = [];
  let a = -1;
  const s = t.split(".");
  for (; ++a < s.length; )
    t = s[a], a === 0 && s.length > 1 ? i.push(Fa((t || "").trim(), e, r)) : i.push(Vo(t, e, r));
  return i.join(".");
}
function cee(t, e, r, n) {
  const i = [];
  for (const a in t) {
    const s = t[a];
    if (typeof s == "function") {
      const o = Pv(
        s,
        void 0,
        r,
        n
      );
      o.as = a, i.push(ys(o, !0, e, r));
    } else
      s instanceof vA ? i.push(
        r.alias(
          `(${Ko(s, void 0, e, r, n)})`,
          Vo(a, e, r)
        )
      ) : i.push(
        r.alias(
          Ko(s, void 0, e, r, n),
          Vo(a, e, r)
        )
      );
  }
  return i.join(", ");
}
function ys(t, e, r, n) {
  let i = t.sql || "";
  return i && (t.method === "select" || t.method === "first") && (e || t.as) && (i = `(${i})`, t.as) ? n.alias(i, Fa(t.as, r, n)) : i;
}
function uee(t, e, r, n, i) {
  return typeof t == "function" ? ys(
    Pv(t, e, n, i),
    void 0,
    r,
    n
  ) : vs(t, void 0, r, n, i) || "";
}
function lee(t, e, r, n) {
  const i = vs(t, void 0, e, r, n);
  return i || (iee.indexOf((t || "").toLowerCase()) !== -1 ? t : "asc");
}
var xt = {
  columnize: see,
  direction: lee,
  operator: oee,
  outputQuery: ys,
  rawOrFn: uee,
  unwrapRaw: vs,
  wrap: Ko,
  wrapString: Fa
};
const { columnize: yA } = xt;
function pee(t, e) {
  const r = {
    bindings: []
  }, n = t, i = t.bindings.length, a = t.bindings;
  let s = 0;
  const o = t.sql.replace(/\\?\?\??/g, function(c) {
    if (c === "\\?")
      return c;
    const f = a[s++];
    return c === "??" ? yA(f, n, e, r) : e.parameter(f, n, r);
  });
  if (i !== s)
    throw new Error(`Expected ${i} bindings, saw ${s}`);
  return {
    method: "raw",
    sql: o,
    bindings: r.bindings
  };
}
function fee(t, e) {
  const r = {
    bindings: []
  }, n = t, i = t.bindings, a = /\\?(:(\w+):(?=::)|:(\w+):(?!:)|:(\w+))/g;
  return {
    method: "raw",
    sql: t.sql.replace(a, function(o, c, f, u, l) {
      if (o !== c)
        return c;
      const p = f || u || l, m = o.trim(), h = m[m.length - 1] === ":", g = i[p];
      return g === void 0 ? (Object.prototype.hasOwnProperty.call(i, p) && r.bindings.push(g), o) : h ? o.replace(
        c,
        yA(g, n, e, r)
      ) : o.replace(c, e.parameter(g, n, r));
    }),
    bindings: r.bindings
  };
}
var hee = {
  replaceKeyBindings: fee,
  replaceRawArrBindings: pee
};
const dee = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW", mee = "0123456789";
function gee(t = 21) {
  let e = "", r = t;
  for (; r--; )
    e += dee[Math.random() * 64 | 0];
  return e;
}
function vee(t = 21) {
  let e = "", r = t;
  for (; r--; )
    e += mee[Math.random() * 10 | 0];
  return e;
}
var Dv = { nanoid: gee, nanonum: vee };
const { EventEmitter: yee } = bt, bee = ar, wee = Bn, xee = un, _ee = gs, {
  replaceRawArrBindings: Eee,
  replaceKeyBindings: See
} = hee, og = wt, Cee = Nv, { nanoid: Tee } = Dv, { isNumber: Oee, isObject: Aee } = Je, {
  augmentWithBuilderInterface: $ee
} = Lv, Iee = bee("knex:bindings");
let au = class extends yee {
  constructor(e) {
    super(), this.client = e, this.sql = "", this.bindings = [], this._wrappedBefore = void 0, this._wrappedAfter = void 0, e && e.config && (this._debug = e.config.debug, Cee(this, 4));
  }
  set(e, r) {
    return this.sql = e, this.bindings = Aee(r) && !r.toSQL || r === void 0 ? r : [r], this;
  }
  timeout(e, { cancel: r } = {}) {
    return Oee(e) && e > 0 && (this._timeout = e, r && (this.client.assertCanCancelQuery(), this._cancelOnTimeout = !0)), this;
  }
  // Wraps the current sql with `before` and `after`.
  wrap(e, r) {
    return this._wrappedBefore = e, this._wrappedAfter = r, this;
  }
  // Calls `toString` on the Knex object.
  toString() {
    return this.toQuery();
  }
  // Returns the raw sql for the query.
  toSQL(e, r) {
    let n;
    if (Array.isArray(this.bindings) ? n = Eee(this, this.client) : this.bindings && xee(this.bindings) ? n = See(this, this.client) : n = {
      method: "raw",
      sql: this.sql,
      bindings: this.bindings === void 0 ? [] : [this.bindings]
    }, this._wrappedBefore && (n.sql = this._wrappedBefore + n.sql), this._wrappedAfter && (n.sql = n.sql + this._wrappedAfter), n.options = _ee(this._options, wee, {}), this._timeout && (n.timeout = this._timeout, this._cancelOnTimeout && (n.cancelOnTimeout = this._cancelOnTimeout)), n.bindings = n.bindings || [], og.containsUndefined(n.bindings)) {
      const i = og.getUndefinedIndices(
        this.bindings
      );
      throw Iee(n.bindings), new Error(
        `Undefined binding(s) detected for keys [${i}] when compiling RAW query: ${n.sql}`
      );
    }
    return n.__knexQueryUid = Tee(), Object.defineProperties(n, {
      toNative: {
        value: () => ({
          sql: this.client.positionBindings(n.sql),
          bindings: this.client.prepBindings(n.bindings)
        }),
        enumerable: !1
      }
    }), n;
  }
};
au.prototype.isRawInstance = !0;
$ee(au);
og.addQueryContext(au);
var zi = au;
function kee(t) {
  for (var e = -1, r = t == null ? 0 : t.length, n = 0, i = []; ++e < r; ) {
    var a = t[e];
    a && (i[n++] = a);
  }
  return i;
}
var Mv = kee;
function Ree(t, e, r, n) {
  for (var i = -1, a = t == null ? 0 : t.length; ++i < a; ) {
    var s = t[i];
    e(n, s, r(s), t);
  }
  return n;
}
var Nee = Ree, Lee = Ui;
function Pee(t, e, r, n) {
  return Lee(t, function(i, a, s) {
    e(n, i, r(i), s);
  }), n;
}
var Dee = Pee, Mee = Nee, qee = Dee, jee = Fr, Fee = at;
function Bee(t, e) {
  return function(r, n) {
    var i = Fee(r) ? Mee : qee, a = e ? e() : {};
    return i(r, t, jee(n), a);
  };
}
var Uee = Bee, zee = Vc, Hee = Uee, Wee = Object.prototype, Gee = Wee.hasOwnProperty, Qee = Hee(function(t, e, r) {
  Gee.call(t, r) ? t[r].push(e) : zee(t, r, [e]);
}), su = Qee, Vee = Object.prototype, Kee = Vee.hasOwnProperty;
function Jee(t, e) {
  return t != null && Kee.call(t, e);
}
var Xee = Jee, Zee = Xee, Yee = aA;
function ete(t, e) {
  return t != null && Yee(t, e, Zee);
}
var ou = ete, tte = Ui, rte = jr;
function nte(t, e) {
  var r = -1, n = rte(t) ? Array(t.length) : [];
  return tte(t, function(i, a, s) {
    n[++r] = e(i, a, s);
  }), n;
}
var ite = nte, ate = Yc, ste = Fr, ote = ite, cte = at;
function ute(t, e) {
  var r = cte(t) ? ate : ote;
  return r(t, ste(e));
}
var zn = ute, lte = Kc, pte = nu, fte = Jc, p1 = Ht, hte = ds;
function dte(t, e, r, n) {
  if (!p1(t))
    return t;
  e = pte(e, t);
  for (var i = -1, a = e.length, s = a - 1, o = t; o != null && ++i < a; ) {
    var c = hte(e[i]), f = r;
    if (c === "__proto__" || c === "constructor" || c === "prototype")
      return t;
    if (i != s) {
      var u = o[c];
      f = n ? n(u, c, o) : void 0, f === void 0 && (f = p1(u) ? u : fte(e[i + 1]) ? [] : {});
    }
    lte(o, c, f), o = o[c];
  }
  return t;
}
var mte = dte, gte = kv, vte = mte, yte = nu;
function bte(t, e, r) {
  for (var n = -1, i = e.length, a = {}; ++n < i; ) {
    var s = e[n], o = gte(t, s);
    r(o, s) && vte(a, yte(s, t), o);
  }
  return a;
}
var wte = bte, xte = Yc, _te = Fr, Ete = wte, Ste = lO;
function Cte(t, e) {
  if (t == null)
    return {};
  var r = xte(Ste(t), function(n) {
    return [n];
  });
  return e = _te(e), Ete(t, r, function(n, i) {
    return e(n, i[0]);
  });
}
var Tte = Cte, Ote = Fr, Ate = sA, $te = Tte;
function Ite(t, e) {
  return $te(t, Ate(Ote(e)));
}
var kte = Ite;
const Rte = wt, ii = zi, eo = pn, Nte = gA, Lte = ar, f1 = Bn, aa = Mv, Pte = su, Dte = ou, h1 = sr, d1 = zn, Mte = kte, qte = gs, { nanoid: jte } = Dv, { isString: sp, isUndefined: Fte } = Je, {
  columnize: Ar,
  direction: m1,
  operator: sa,
  wrap: it,
  unwrapRaw: ai,
  rawOrFn: Wr
} = xt, Bte = Lte("knex:bindings"), Ute = [
  "columns",
  "join",
  "where",
  "union",
  "group",
  "having",
  "order",
  "limit",
  "offset",
  "lock",
  "waitMode"
];
let zte = class {
  constructor(e, r, n) {
    this.client = e, this.method = r._method || "select", this.options = r._options, this.single = r._single, this.timeout = r._timeout || !1, this.cancelOnTimeout = r._cancelOnTimeout || !1, this.grouped = Pte(r._statements, "grouping"), this.formatter = e.formatter(r), this._emptyInsertValue = "default values", this.first = this.select, this.bindings = n || [], this.formatter.bindings = this.bindings, this.bindingsHolder = this, this.builder = this.formatter.builder;
  }
  // Collapse the builder into a single object
  toSQL(e, r) {
    this._undefinedInWhereClause = !1, this.undefinedBindingsInfo = [], e = e || this.method;
    const n = this[e]() || "", i = {
      method: e,
      options: qte(this.options, f1, {}),
      timeout: this.timeout,
      cancelOnTimeout: this.cancelOnTimeout,
      bindings: this.bindingsHolder.bindings || [],
      __knexQueryUid: jte()
    };
    if (Object.defineProperties(i, {
      toNative: {
        value: () => ({
          sql: this.client.positionBindings(i.sql),
          bindings: this.client.prepBindings(i.bindings)
        }),
        enumerable: !1
      }
    }), sp(n) ? i.sql = n : f1(i, n), (e === "select" || e === "first") && this.single.as && (i.as = this.single.as), this._undefinedInWhereClause)
      throw Bte(i.bindings), new Error(
        `Undefined binding(s) detected when compiling ${e.toUpperCase()}. Undefined column(s): [${this.undefinedBindingsInfo.join(
          ", "
        )}] query: ${i.sql}`
      );
    return i;
  }
  // Compiles the `select` statement, or nested sub-selects by calling each of
  // the component compilers, trimming out the empties, and returning a
  // generated query string.
  select() {
    let e = this.with(), r = "";
    const n = [], i = [];
    Ute.forEach((s) => {
      const o = this[s](this);
      switch (s) {
        case "union":
          r = o;
          break;
        case "columns":
        case "join":
        case "where":
          n.push(o);
          break;
        default:
          i.push(o);
          break;
      }
    });
    const a = this.grouped.union && this.grouped.union.map((s) => s.wrap).some((s) => s);
    if (this.onlyUnions()) {
      const s = aa(n.concat(i)).join(
        " "
      );
      e += r + (s ? " " + s : "");
    } else {
      const s = (a ? "(" : "") + aa(n).join(" ") + (a ? ")" : ""), o = aa(i).join(" ");
      e += s + (r ? " " + r : "") + (o && " " + o);
    }
    return e;
  }
  pluck() {
    let e = this.single.pluck;
    return e.indexOf(".") !== -1 && (e = e.split(".").slice(-1)[0]), {
      sql: this.select(),
      pluck: e
    };
  }
  // Compiles an "insert" query, allowing for multiple
  // inserts using a single query statement.
  insert() {
    const e = this.single.insert || [], r = this.with() + `insert into ${this.tableName} `, n = this._insertBody(e);
    return n === "" ? "" : r + n;
  }
  _onConflictClause(e) {
    return e instanceof ii ? this.formatter.wrap(e) : `(${this.formatter.columnize(e)})`;
  }
  _buildInsertValues(e) {
    let r = "", n = -1;
    for (; ++n < e.values.length; )
      n !== 0 && (r += "), ("), r += this.client.parameterize(
        e.values[n],
        this.client.valueForUndefined,
        this.builder,
        this.bindingsHolder
      );
    return r;
  }
  _insertBody(e) {
    let r = "";
    if (Array.isArray(e)) {
      if (e.length === 0)
        return "";
    } else if (typeof e == "object" && h1(e))
      return r + this._emptyInsertValue;
    const n = this._prepInsert(e);
    return typeof n == "string" ? r += n : n.columns.length ? (r += `(${Ar(
      n.columns,
      this.builder,
      this.client,
      this.bindingsHolder
    )}`, r += ") values (" + this._buildInsertValues(n) + ")") : e.length === 1 && e[0] ? r += this._emptyInsertValue : r = "", r;
  }
  // Compiles the "update" query.
  update() {
    const e = this.with(), { tableName: r } = this, n = this._prepUpdate(this.single.update), i = this.where();
    return e + `update ${this.single.only ? "only " : ""}${r} set ` + n.join(", ") + (i ? ` ${i}` : "");
  }
  _hintComments() {
    let e = this.grouped.hintComments || [];
    return e = e.map((r) => aa(r.value).join(" ")), e = aa(e).join(" "), e ? `/*+ ${e} */ ` : "";
  }
  // Compiles the columns in the query, specifying if an item was distinct.
  columns() {
    let e = "";
    if (this.onlyUnions())
      return "";
    const r = this._hintComments(), n = this.grouped.columns || [];
    let i = -1, a = [];
    if (n)
      for (; ++i < n.length; ) {
        const o = n[i];
        if (o.distinct && (e = "distinct "), o.distinctOn) {
          e = this.distinctOn(o.value);
          continue;
        }
        o.type === "aggregate" ? a.push(...this.aggregate(o)) : o.type === "aggregateRaw" ? a.push(this.aggregateRaw(o)) : o.type === "analytic" ? a.push(this.analytic(o)) : o.type === "json" ? a.push(this.json(o)) : o.value && o.value.length > 0 && a.push(
          Ar(
            o.value,
            this.builder,
            this.client,
            this.bindingsHolder
          )
        );
      }
    return a.length === 0 && (a = ["*"]), `${this.onlyJson() ? "" : "select "}${r}${e}` + a.join(", ") + (this.tableName ? ` from ${this.single.only ? "only " : ""}${this.tableName}` : "");
  }
  _aggregate(e, { aliasSeparator: r = " as ", distinctParentheses: n } = {}) {
    const i = e.value, a = e.method, s = e.aggregateDistinct ? "distinct " : "", o = (h) => it(
      h,
      void 0,
      this.builder,
      this.client,
      this.bindingsHolder
    ), c = (h, g) => g ? h + r + o(g) : h, f = (h, g) => {
      let v = h.map(o).join(", ");
      if (s) {
        const y = n ? "(" : " ", x = n ? ")" : "";
        v = s.trim() + y + v + x;
      }
      const d = `${a}(${v})`;
      return c(d, g);
    }, u = (h, g) => {
      const v = `${a}(${s + o(h)})`;
      return c(v, g);
    };
    if (Array.isArray(i))
      return [f(i)];
    if (typeof i == "object") {
      if (e.alias)
        throw new Error("When using an object explicit alias can not be used");
      return Object.entries(i).map(([h, g]) => Array.isArray(g) ? f(g, h) : u(g, h));
    }
    const l = i.toLowerCase().indexOf(" as ");
    let p = i, { alias: m } = e;
    if (l !== -1) {
      if (p = i.slice(0, l), m)
        throw new Error(`Found multiple aliases for same column: ${p}`);
      m = i.slice(l + 4);
    }
    return [u(p, m)];
  }
  aggregate(e) {
    return this._aggregate(e);
  }
  aggregateRaw(e) {
    const r = e.aggregateDistinct ? "distinct " : "";
    return `${e.method}(${r + ai(
      e.value,
      void 0,
      this.builder,
      this.client,
      this.bindingsHolder
    )})`;
  }
  _joinTable(e) {
    return e.schema && !(e.table instanceof ii) ? `${e.schema}.${e.table}` : e.table;
  }
  // Compiles all each of the `join` clauses on the query,
  // including any nested join queries.
  join() {
    let e = "", r = -1;
    const n = this.grouped.join;
    if (!n)
      return "";
    for (; ++r < n.length; ) {
      const i = n[r], a = this._joinTable(i);
      if (r > 0 && (e += " "), i.joinType === "raw")
        e += ai(
          i.table,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        );
      else {
        e += i.joinType + " join " + it(
          a,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        );
        let s = -1;
        for (; ++s < i.clauses.length; ) {
          const o = i.clauses[s];
          s > 0 ? e += ` ${o.bool} ` : e += ` ${o.type === "onUsing" ? "using" : "on"} `;
          const c = this[o.type](o);
          c && (e += c);
        }
      }
    }
    return e;
  }
  onBetween(e) {
    return it(
      e.column,
      void 0,
      this.builder,
      this.client,
      this.bindingsHolder
    ) + " " + this._not(e, "between") + " " + e.value.map(
      (r) => this.client.parameter(r, this.builder, this.bindingsHolder)
    ).join(" and ");
  }
  onNull(e) {
    return it(
      e.column,
      void 0,
      this.builder,
      this.client,
      this.bindingsHolder
    ) + " is " + this._not(e, "null");
  }
  onExists(e) {
    return this._not(e, "exists") + " (" + Wr(
      e.value,
      void 0,
      this.builder,
      this.client,
      this.bindingsHolder
    ) + ")";
  }
  onIn(e) {
    if (Array.isArray(e.column))
      return this.multiOnIn(e);
    let r;
    return e.value instanceof ii ? r = this.client.parameter(
      e.value,
      this.builder,
      this.formatter
    ) : r = this.client.parameterize(
      e.value,
      void 0,
      this.builder,
      this.bindingsHolder
    ), it(
      e.column,
      void 0,
      this.builder,
      this.client,
      this.bindingsHolder
    ) + " " + this._not(e, "in ") + this.wrap(r);
  }
  multiOnIn(e) {
    let r = -1, n = `(${Ar(
      e.column,
      this.builder,
      this.client,
      this.bindingsHolder
    )}) `;
    for (n += this._not(e, "in ") + "(("; ++r < e.value.length; )
      r !== 0 && (n += "),("), n += this.client.parameterize(
        e.value[r],
        void 0,
        this.builder,
        this.bindingsHolder
      );
    return n + "))";
  }
  // Compiles all `where` statements on the query.
  where() {
    const e = this.grouped.where;
    if (!e)
      return;
    const r = [];
    let n = -1;
    for (; ++n < e.length; ) {
      const i = e[n];
      Object.prototype.hasOwnProperty.call(i, "value") && Rte.containsUndefined(i.value) && (this.undefinedBindingsInfo.push(i.column), this._undefinedInWhereClause = !0);
      const a = this[i.type](i);
      a && (r.length === 0 ? r[0] = "where" : r.push(i.bool), r.push(a));
    }
    return r.length > 1 ? r.join(" ") : "";
  }
  group() {
    return this._groupsOrders("group");
  }
  order() {
    return this._groupsOrders("order");
  }
  // Compiles the `having` statements.
  having() {
    const e = this.grouped.having;
    if (!e)
      return "";
    const r = ["having"];
    for (let n = 0, i = e.length; n < i; n++) {
      const a = e[n], s = this[a.type](a);
      s && (r.length === 0 && (r[0] = "where"), (r.length > 1 || r.length === 1 && r[0] !== "having") && r.push(a.bool), r.push(s));
    }
    return r.length > 1 ? r.join(" ") : "";
  }
  havingRaw(e) {
    return this._not(e, "") + ai(
      e.value,
      void 0,
      this.builder,
      this.client,
      this.bindingsHolder
    );
  }
  havingWrapped(e) {
    const r = Wr(
      e.value,
      "where",
      this.builder,
      this.client,
      this.bindingsHolder
    );
    return r && this._not(e, "") + "(" + r.slice(6) + ")" || "";
  }
  havingBasic(e) {
    return this._not(e, "") + it(
      e.column,
      void 0,
      this.builder,
      this.client,
      this.bindingsHolder
    ) + " " + sa(
      e.operator,
      this.builder,
      this.client,
      this.bindingsHolder
    ) + " " + this.client.parameter(e.value, this.builder, this.bindingsHolder);
  }
  havingNull(e) {
    return it(
      e.column,
      void 0,
      this.builder,
      this.client,
      this.bindingsHolder
    ) + " is " + this._not(e, "null");
  }
  havingExists(e) {
    return this._not(e, "exists") + " (" + Wr(
      e.value,
      void 0,
      this.builder,
      this.client,
      this.bindingsHolder
    ) + ")";
  }
  havingBetween(e) {
    return it(
      e.column,
      void 0,
      this.builder,
      this.client,
      this.bindingsHolder
    ) + " " + this._not(e, "between") + " " + e.value.map(
      (r) => this.client.parameter(r, this.builder, this.bindingsHolder)
    ).join(" and ");
  }
  havingIn(e) {
    return Array.isArray(e.column) ? this.multiHavingIn(e) : it(
      e.column,
      void 0,
      this.builder,
      this.client,
      this.bindingsHolder
    ) + " " + this._not(e, "in ") + this.wrap(
      this.client.parameterize(
        e.value,
        void 0,
        this.builder,
        this.bindingsHolder
      )
    );
  }
  multiHavingIn(e) {
    return this.multiOnIn(e);
  }
  // Compile the "union" queries attached to the main query.
  union() {
    const e = this.onlyUnions(), r = this.grouped.union;
    if (!r)
      return "";
    let n = "";
    for (let i = 0, a = r.length; i < a; i++) {
      const s = r[i];
      i > 0 && (n += " "), (i > 0 || !e) && (n += s.clause + " ");
      const o = Wr(
        s.value,
        void 0,
        this.builder,
        this.client,
        this.bindingsHolder
      );
      if (o) {
        const c = s.wrap;
        c && (n += "("), n += o, c && (n += ")");
      }
    }
    return n;
  }
  // If we haven't specified any columns or a `tableName`, we're assuming this
  // is only being used for unions.
  onlyUnions() {
    return (!this.grouped.columns || !!this.grouped.columns[0].value) && this.grouped.union && !this.tableName;
  }
  _getValueOrParameterFromAttribute(e, r) {
    return this.single.skipBinding[e] === !0 ? r ?? this.single[e] : this.client.parameter(
      this.single[e],
      this.builder,
      this.bindingsHolder
    );
  }
  onlyJson() {
    return !this.tableName && this.grouped.columns && this.grouped.columns.length === 1 && this.grouped.columns[0].type === "json";
  }
  limit() {
    return !this.single.limit && this.single.limit !== 0 ? "" : `limit ${this._getValueOrParameterFromAttribute("limit")}`;
  }
  offset() {
    return this.single.offset ? `offset ${this._getValueOrParameterFromAttribute("offset")}` : "";
  }
  // Compiles a `delete` query.
  del() {
    const { tableName: e } = this, r = this.with(), n = this.where(), i = this.join(), a = i ? e + " " : "";
    return r + `delete ${a}from ${this.single.only ? "only " : ""}${e}` + (i ? ` ${i}` : "") + (n ? ` ${n}` : "");
  }
  // Compiles a `truncate` query.
  truncate() {
    return `truncate ${this.tableName}`;
  }
  // Compiles the "locks".
  lock() {
    if (this.single.lock)
      return this[this.single.lock]();
  }
  // Compiles the wait mode on the locks.
  waitMode() {
    if (this.single.waitMode)
      return this[this.single.waitMode]();
  }
  // Fail on unsupported databases
  skipLocked() {
    throw new Error(
      ".skipLocked() is currently only supported on MySQL 8.0+ and PostgreSQL 9.5+"
    );
  }
  // Fail on unsupported databases
  noWait() {
    throw new Error(
      ".noWait() is currently only supported on MySQL 8.0+, MariaDB 10.3.0+ and PostgreSQL 9.5+"
    );
  }
  distinctOn(e) {
    throw new Error(".distinctOn() is currently only supported on PostgreSQL");
  }
  // On Clause
  // ------
  onWrapped(e) {
    const r = this, n = new Nte();
    e.value.call(n, n);
    let i = "";
    for (let a = 0; a < n.clauses.length; a++) {
      const s = n.clauses[a];
      a > 0 && (i += ` ${s.bool} `);
      const o = r[s.type](s);
      o && (i += o);
    }
    return i.length ? `(${i})` : "";
  }
  onBasic(e) {
    const r = e.value instanceof eo;
    return it(
      e.column,
      void 0,
      this.builder,
      this.client,
      this.bindingsHolder
    ) + " " + sa(
      e.operator,
      this.builder,
      this.client,
      this.bindingsHolder
    ) + " " + (r ? "(" : "") + it(
      e.value,
      void 0,
      this.builder,
      this.client,
      this.bindingsHolder
    ) + (r ? ")" : "");
  }
  onVal(e) {
    return it(
      e.column,
      void 0,
      this.builder,
      this.client,
      this.bindingsHolder
    ) + " " + sa(
      e.operator,
      this.builder,
      this.client,
      this.bindingsHolder
    ) + " " + this.client.parameter(e.value, this.builder, this.bindingsHolder);
  }
  onRaw(e) {
    return ai(
      e.value,
      void 0,
      this.builder,
      this.client,
      this.bindingsHolder
    );
  }
  onUsing(e) {
    return "(" + Ar(
      e.column,
      this.builder,
      this.client,
      this.bindingsHolder
    ) + ")";
  }
  // Where Clause
  // ------
  _valueClause(e) {
    return e.asColumn ? it(
      e.value,
      void 0,
      this.builder,
      this.client,
      this.bindingsHolder
    ) : this.client.parameter(
      e.value,
      this.builder,
      this.bindingsHolder
    );
  }
  _columnClause(e) {
    let r;
    return Array.isArray(e.column) ? r = `(${Ar(
      e.column,
      this.builder,
      this.client,
      this.bindingsHolder
    )})` : r = it(
      e.column,
      void 0,
      this.builder,
      this.client,
      this.bindingsHolder
    ), r;
  }
  whereIn(e) {
    const r = this.client.values(
      e.value,
      this.builder,
      this.bindingsHolder
    );
    return `${this._columnClause(e)} ${this._not(
      e,
      "in "
    )}${r}`;
  }
  whereLike(e) {
    return `${this._columnClause(e)} ${this._not(
      e,
      "like "
    )}${this._valueClause(e)}`;
  }
  whereILike(e) {
    return `${this._columnClause(e)} ${this._not(
      e,
      "ilike "
    )}${this._valueClause(e)}`;
  }
  whereNull(e) {
    return it(
      e.column,
      void 0,
      this.builder,
      this.client,
      this.bindingsHolder
    ) + " is " + this._not(e, "null");
  }
  // Compiles a basic "where" clause.
  whereBasic(e) {
    return this._not(e, "") + it(
      e.column,
      void 0,
      this.builder,
      this.client,
      this.bindingsHolder
    ) + " " + sa(
      e.operator,
      this.builder,
      this.client,
      this.bindingsHolder
    ) + " " + this._valueClause(e);
  }
  whereExists(e) {
    return this._not(e, "exists") + " (" + Wr(
      e.value,
      void 0,
      this.builder,
      this.client,
      this.bindingsHolder
    ) + ")";
  }
  whereWrapped(e) {
    const r = Wr(
      e.value,
      "where",
      this.builder,
      this.client,
      this.bindingsHolder
    );
    return r && this._not(e, "") + "(" + r.slice(6) + ")" || "";
  }
  whereBetween(e) {
    return it(
      e.column,
      void 0,
      this.builder,
      this.client,
      this.bindingsHolder
    ) + " " + this._not(e, "between") + " " + e.value.map(
      (r) => this.client.parameter(r, this.builder, this.bindingsHolder)
    ).join(" and ");
  }
  // Compiles a "whereRaw" query.
  whereRaw(e) {
    return this._not(e, "") + ai(
      e.value,
      void 0,
      this.builder,
      this.client,
      this.bindingsHolder
    );
  }
  _jsonWrapValue(e) {
    if (!this.builder._isJsonObject(e))
      try {
        return JSON.stringify(JSON.parse(e.replace(/\n|\t/g, "")));
      } catch {
        return e;
      }
    return JSON.stringify(e);
  }
  _jsonValueClause(e) {
    return e.value = this._jsonWrapValue(e.value), this._valueClause(e);
  }
  whereJsonObject(e) {
    return `${this._columnClause(e)} ${e.not ? "!=" : "="} ${this._jsonValueClause(e)}`;
  }
  wrap(e) {
    return e.charAt(0) !== "(" ? `(${e})` : e;
  }
  json(e) {
    return this[e.method](e.params);
  }
  analytic(e) {
    let r = "";
    const n = this;
    return r += e.method + "() over (", e.raw ? r += e.raw : (e.partitions.length && (r += "partition by ", r += d1(e.partitions, function(i) {
      return sp(i) ? n.formatter.columnize(i) : n.formatter.columnize(i.column) + (i.order ? " " + i.order : "");
    }).join(", ") + " "), r += "order by ", r += d1(e.order, function(i) {
      return sp(i) ? n.formatter.columnize(i) : n.formatter.columnize(i.column) + (i.order ? " " + i.order : "");
    }).join(", ")), r += ")", e.alias && (r += " as " + e.alias), r;
  }
  // Compiles all `with` statements on the query.
  with() {
    if (!this.grouped.with || !this.grouped.with.length)
      return "";
    const e = this.grouped.with;
    if (!e)
      return;
    const r = [];
    let n = -1, i = !1;
    for (; ++n < e.length; ) {
      const a = e[n];
      a.recursive && (i = !0);
      const s = this[a.type](a);
      r.push(s);
    }
    return `with ${i ? "recursive " : ""}${r.join(", ")} `;
  }
  withWrapped(e) {
    const r = Wr(
      e.value,
      void 0,
      this.builder,
      this.client,
      this.bindingsHolder
    ), n = e.columnList ? "(" + Ar(
      e.columnList,
      this.builder,
      this.client,
      this.bindingsHolder
    ) + ")" : "", i = e.materialized === void 0 ? "" : e.materialized ? "materialized " : "not materialized ";
    return r && Ar(
      e.alias,
      this.builder,
      this.client,
      this.bindingsHolder
    ) + n + " as " + i + "(" + r + ")" || "";
  }
  // Determines whether to add a "not" prefix to the where clause.
  _not(e, r) {
    return e.not ? `not ${r}` : r;
  }
  _prepInsert(e) {
    const r = Wr(
      e,
      void 0,
      this.builder,
      this.client,
      this.bindingsHolder
    );
    if (r)
      return r;
    let n = [];
    const i = [];
    Array.isArray(e) || (e = e ? [e] : []);
    let a = -1;
    for (; ++a < e.length && e[a] != null; ) {
      a === 0 && (n = Object.keys(e[a]).sort());
      const s = new Array(n.length), o = Object.keys(e[a]);
      let c = -1;
      for (; ++c < o.length; ) {
        const f = o[c];
        let u = n.indexOf(f);
        if (u === -1) {
          n = n.concat(f).sort(), u = n.indexOf(f);
          let l = -1;
          for (; ++l < i.length; )
            i[l].splice(u, 0, void 0);
          s.splice(u, 0, void 0);
        }
        s[u] = e[a][f];
      }
      i.push(s);
    }
    return {
      columns: n,
      values: i
    };
  }
  // "Preps" the update.
  _prepUpdate(e = {}) {
    const { counter: r = {} } = this.single;
    for (const s of Object.keys(r)) {
      if (Dte(e, s)) {
        this.client.logger.warn(
          "increment/decrement called for a column that has already been specified in main .update() call. Ignoring increment/decrement and using value from .update() call."
        );
        continue;
      }
      let o = r[s];
      const c = o < 0 ? "-" : "+";
      c === "-" && (o = -o), e[s] = this.client.raw(`?? ${c} ?`, [s, o]);
    }
    e = Mte(e, Fte);
    const n = [], i = Object.keys(e);
    let a = -1;
    for (; ++a < i.length; )
      n.push(
        it(
          i[a],
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + " = " + this.client.parameter(
          e[i[a]],
          this.builder,
          this.bindingsHolder
        )
      );
    if (h1(n))
      throw new Error(
        [
          "Empty .update() call detected!",
          "Update data does not contain any values to update.",
          "This will result in a faulty query.",
          this.single.table ? `Table: ${this.single.table}.` : "",
          this.single.update ? `Columns: ${Object.keys(this.single.update)}.` : ""
        ].join(" ")
      );
    return n;
  }
  _formatGroupsItemValue(e, r) {
    const { formatter: n } = this;
    let i = "";
    r === "last" ? i = " is null" : r === "first" && (i = " is not null");
    let a;
    return e instanceof ii ? a = ai(
      e,
      void 0,
      this.builder,
      this.client,
      this.bindingsHolder
    ) : e instanceof eo || r ? a = "(" + n.columnize(e) + i + ")" : a = n.columnize(e), a;
  }
  _basicGroupOrder(e, r) {
    const n = this._formatGroupsItemValue(e.value, e.nulls), i = r === "order" && e.type !== "orderByRaw" ? ` ${m1(
      e.direction,
      this.builder,
      this.client,
      this.bindingsHolder
    )}` : "";
    return n + i;
  }
  _groupOrder(e, r) {
    return this._basicGroupOrder(e, r);
  }
  _groupOrderNulls(e, r) {
    const n = this._formatGroupsItemValue(e.value), i = r === "order" && e.type !== "orderByRaw" ? ` ${m1(
      e.direction,
      this.builder,
      this.client,
      this.bindingsHolder
    )}` : "";
    return e.nulls && !(e.value instanceof ii) ? `${n}${i || ""} nulls ${e.nulls}` : n + i;
  }
  // Compiles the `order by` statements.
  _groupsOrders(e) {
    const r = this.grouped[e];
    if (!r)
      return "";
    const n = r.map((i) => this._groupOrder(i, e));
    return n.length ? e + " by " + n.join(", ") : "";
  }
  // Get the table name, wrapping it if necessary.
  // Implemented as a property to prevent ordering issues as described in #704.
  get tableName() {
    if (!this._tableName) {
      let e = this.single.table;
      const r = this.single.schema;
      if (e && r) {
        const n = e instanceof eo, i = e instanceof ii;
        !n && !i && !(typeof e == "function") && (e = `${r}.${e}`);
      }
      this._tableName = e ? (
        // Wrap subQuery with parenthesis, #3485
        it(
          e,
          e instanceof eo,
          this.builder,
          this.client,
          this.bindingsHolder
        )
      ) : "";
    }
    return this._tableName;
  }
  _jsonPathWrap(e) {
    return this.client.parameter(
      e.path || e[1],
      this.builder,
      this.bindingsHolder
    );
  }
  // Json common functions
  _jsonExtract(e, r) {
    let n;
    return Array.isArray(r.column) ? n = r.column : n = [r], Array.isArray(e) || (e = [e]), n.map((i) => {
      let a = `${Ar(
        i.column || i[0],
        this.builder,
        this.client,
        this.bindingsHolder
      )}, ${this._jsonPathWrap(i)}`;
      e.forEach((o) => {
        a = o + "(" + a + ")";
      });
      const s = i.alias || i[2];
      return s ? this.client.alias(a, this.formatter.wrap(s)) : a;
    }).join(", ");
  }
  _jsonSet(e, r) {
    const n = `${e}(${Ar(
      r.column,
      this.builder,
      this.client,
      this.bindingsHolder
    )}, ${this.client.parameter(
      r.path,
      this.builder,
      this.bindingsHolder
    )}, ${this.client.parameter(
      r.value,
      this.builder,
      this.bindingsHolder
    )})`;
    return r.alias ? this.client.alias(n, this.formatter.wrap(r.alias)) : n;
  }
  _whereJsonPath(e, r) {
    return `${e}(${this._columnClause(
      r
    )}, ${this._jsonPathWrap({ path: r.jsonPath })}) ${sa(
      r.operator,
      this.builder,
      this.client,
      this.bindingsHolder
    )} ${this._jsonValueClause(r)}`;
  }
  _onJsonPathEquals(e, r) {
    return e + "(" + it(
      r.columnFirst,
      void 0,
      this.builder,
      this.client,
      this.bindingsHolder
    ) + ", " + this.client.parameter(
      r.jsonPathFirst,
      this.builder,
      this.bindingsHolder
    ) + ") = " + e + "(" + it(
      r.columnSecond,
      void 0,
      this.builder,
      this.client,
      this.bindingsHolder
    ) + ", " + this.client.parameter(
      r.jsonPathSecond,
      this.builder,
      this.bindingsHolder
    ) + ")";
  }
};
var Hn = zte;
const { EventEmitter: Hte } = bt, Wte = ms, Gte = Bn, { addQueryContext: Qte } = wt, Vte = Nv, {
  augmentWithBuilderInterface: Kte
} = Lv;
let Cn = class extends Hte {
  constructor(e) {
    super(), this.client = e, this._sequence = [], e.config && (this._debug = e.config.debug, Vte(this, 4));
  }
  withSchema(e) {
    return this._schema = e, this;
  }
  toString() {
    return this.toQuery();
  }
  toSQL() {
    return this.client.schemaCompiler(this).toSQL();
  }
  async generateDdlCommands() {
    return await this.client.schemaCompiler(this).generateDdlCommands();
  }
};
[
  "createTable",
  "createTableIfNotExists",
  "createTableLike",
  "createView",
  "createViewOrReplace",
  "createMaterializedView",
  "refreshMaterializedView",
  "dropView",
  "dropViewIfExists",
  "dropMaterializedView",
  "dropMaterializedViewIfExists",
  "createSchema",
  "createSchemaIfNotExists",
  "dropSchema",
  "dropSchemaIfExists",
  "createExtension",
  "createExtensionIfNotExists",
  "dropExtension",
  "dropExtensionIfExists",
  "table",
  "alterTable",
  "view",
  "alterView",
  "hasTable",
  "hasColumn",
  "dropTable",
  "renameTable",
  "renameView",
  "dropTableIfExists",
  "raw"
].forEach(function(t) {
  Cn.prototype[t] = function() {
    return t === "createTableIfNotExists" && this.client.logger.warn(
      [
        "Use async .hasTable to check if table exists and then use plain .createTable. Since ",
        '.createTableIfNotExists actually just generates plain "CREATE TABLE IF NOT EXIST..." ',
        "query it will not work correctly if there are any alter table queries generated for ",
        "columns afterwards. To not break old migrations this function is left untouched for now",
        ", but it should not be used when writing new code and it is removed from documentation."
      ].join("")
    ), t === "table" && (t = "alterTable"), t === "view" && (t = "alterView"), this._sequence.push({
      method: t,
      args: Wte(arguments)
    }), this;
  };
});
Cn.extend = (t, e) => {
  if (Object.prototype.hasOwnProperty.call(Cn.prototype, t))
    throw new Error(
      `Can't extend SchemaBuilder with existing method ('${t}').`
    );
  Gte(Cn.prototype, { [t]: e });
};
Kte(Cn);
Qte(Cn);
var bA = Cn;
const Jte = iu, { isString: wA } = Je;
function Xte(t) {
  t && (wA(t) && (t = { sql: t }), t.bindings || (t.bindings = this.bindingsHolder.bindings), this.sequence.push(t), this.formatter = this.client.formatter(this._commonBuilder), this.bindings = [], this.formatter.bindings = this.bindings);
}
function Zte(t) {
  const e = new this.constructor(
    this.client,
    this.tableCompiler,
    this.columnBuilder
  );
  t.call(e, Jte(arguments)), this.sequence.additional = (this.sequence.additional || []).concat(
    e.sequence
  );
}
function Yte(t) {
  t && (wA(t) && (t = { sql: t }), t.bindings || (t.bindings = this.bindingsHolder.bindings), this.sequence.unshift(t), this.formatter = this.client.formatter(this._commonBuilder), this.bindings = [], this.formatter.bindings = this.bindings);
}
var cu = {
  pushAdditional: Zte,
  pushQuery: Xte,
  unshiftQuery: Yte
};
const {
  pushQuery: ere,
  pushAdditional: tre,
  unshiftQuery: rre
} = cu;
let Ct = class {
  constructor(e, r) {
    this.builder = r, this._commonBuilder = this.builder, this.client = e, this.schema = r._schema, this.bindings = [], this.bindingsHolder = this, this.formatter = e.formatter(r), this.formatter.bindings = this.bindings, this.sequence = [];
  }
  createSchema() {
    to("createSchema");
  }
  createSchemaIfNotExists() {
    to("createSchemaIfNotExists");
  }
  dropSchema() {
    to("dropSchema");
  }
  dropSchemaIfExists() {
    to("dropSchemaIfExists");
  }
  dropTable(e) {
    this.pushQuery(
      this.dropTablePrefix + this.formatter.wrap(op(this.schema, e))
    );
  }
  dropTableIfExists(e) {
    this.pushQuery(
      this.dropTablePrefix + "if exists " + this.formatter.wrap(op(this.schema, e))
    );
  }
  dropView(e) {
    this._dropView(e, !1, !1);
  }
  dropViewIfExists(e) {
    this._dropView(e, !0, !1);
  }
  dropMaterializedView(e) {
    throw new Error("materialized views are not supported by this dialect.");
  }
  dropMaterializedViewIfExists(e) {
    throw new Error("materialized views are not supported by this dialect.");
  }
  renameView(e, r) {
    throw new Error(
      "rename view is not supported by this dialect (instead drop then create another view)."
    );
  }
  refreshMaterializedView() {
    throw new Error("materialized views are not supported by this dialect.");
  }
  _dropView(e, r, n) {
    this.pushQuery(
      (n ? this.dropMaterializedViewPrefix : this.dropViewPrefix) + (r ? "if exists " : "") + this.formatter.wrap(op(this.schema, e))
    );
  }
  raw(e, r) {
    this.sequence.push(this.client.raw(e, r).toSQL());
  }
  toSQL() {
    const e = this.builder._sequence;
    for (let r = 0, n = e.length; r < n; r++) {
      const i = e[r];
      this[i.method].apply(this, i.args);
    }
    return this.sequence;
  }
  async generateDdlCommands() {
    const e = this.toSQL();
    return {
      pre: [],
      sql: Array.isArray(e) ? e : [e],
      check: null,
      post: []
    };
  }
};
Ct.prototype.dropTablePrefix = "drop table ";
Ct.prototype.dropViewPrefix = "drop view ";
Ct.prototype.dropMaterializedViewPrefix = "drop materialized view ";
Ct.prototype.alterViewPrefix = "alter view ";
Ct.prototype.alterTable = uu("alter");
Ct.prototype.createTable = uu("create");
Ct.prototype.createTableIfNotExists = uu("createIfNot");
Ct.prototype.createTableLike = uu("createLike");
Ct.prototype.createView = lu("create");
Ct.prototype.createViewOrReplace = lu("createOrReplace");
Ct.prototype.createMaterializedView = lu(
  "createMaterializedView"
);
Ct.prototype.alterView = lu("alter");
Ct.prototype.pushQuery = ere;
Ct.prototype.pushAdditional = tre;
Ct.prototype.unshiftQuery = rre;
function cg(t) {
  const e = this.builder.queryContext();
  e !== void 0 && t.queryContext() === void 0 && t.queryContext(e), t.setSchema(this.schema);
  const r = t.toSQL();
  for (let n = 0, i = r.length; n < i; n++)
    this.sequence.push(r[n]);
}
function uu(t) {
  return t === "createLike" ? function(e, r, n) {
    const i = this.client.tableBuilder(
      t,
      e,
      r,
      n
    );
    cg.call(this, i);
  } : function(e, r) {
    const n = this.client.tableBuilder(t, e, null, r);
    cg.call(this, n);
  };
}
function lu(t) {
  return function(e, r) {
    const n = this.client.viewBuilder(t, e, r);
    cg.call(this, n);
  };
}
function op(t, e) {
  return t ? `${t}.${e}` : e;
}
function to(t) {
  throw new Error(
    `${t} is not supported for this dialect (only PostgreSQL supports it currently).`
  );
}
var Hi = Ct, nre = qn, ire = Ov, are = Fn, sre = ire(function(t, e) {
  nre(e, are(e), t);
}), ore = sre, pu = ore;
const cre = hs, g1 = pu, ure = Bn, fu = ms, lre = wt, { isString: pre, isFunction: fre, isObject: hre } = Je;
let rn = class {
  constructor(e, r, n, i, a) {
    if (this.client = e, this._fn = a, this._method = r, this._schemaName = void 0, this._tableName = n, this._tableNameLike = i, this._statements = [], this._single = {}, !i && !fre(this._fn))
      throw new TypeError(
        "A callback function must be supplied to calls against `.createTable` and `.table`"
      );
  }
  setSchema(e) {
    this._schemaName = e;
  }
  // Convert the current tableBuilder object "toSQL"
  // giving us additional methods if we're altering
  // rather than creating the table.
  toSQL() {
    return this._method === "alter" && g1(this, ug), this._fn && this._fn.call(this, this), this.client.tableCompiler(this).toSQL();
  }
  // The "timestamps" call is really just sets the `created_at` and `updated_at` columns.
  timestamps(e, r, n) {
    hre(e) && ({ useTimestamps: e, defaultToNow: r, useCamelCase: n } = e);
    const i = e === !0 ? "timestamp" : "datetime", a = this[i](n ? "createdAt" : "created_at"), s = this[i](n ? "updatedAt" : "updated_at");
    if (r === !0) {
      const o = this.client.raw("CURRENT_TIMESTAMP");
      a.notNullable().defaultTo(o), s.notNullable().defaultTo(o);
    }
  }
  // Set the comment value for a table, they're only allowed to be called
  // once per table.
  comment(e) {
    if (typeof e != "string")
      throw new TypeError("Table comment must be string");
    this._single.comment = e;
  }
  // Set a foreign key on the table, calling
  // `table.foreign('column_name').references('column').on('table').onDelete()...
  // Also called from the ColumnBuilder context when chaining.
  foreign(e, r) {
    const n = { column: e, keyName: r };
    this._statements.push({
      grouping: "alterTable",
      method: "foreign",
      args: [n]
    });
    let i = {
      references(a) {
        let s;
        return pre(a) && (s = a.split(".")), !s || s.length === 1 ? (n.references = s ? s[0] : a, {
          on(o) {
            if (typeof o != "string")
              throw new TypeError(
                `Expected tableName to be a string, got: ${typeof o}`
              );
            return n.inTable = o, i;
          },
          inTable() {
            return this.on.apply(this, arguments);
          }
        }) : (n.inTable = s[0], n.references = s[1], i);
      },
      withKeyName(a) {
        return n.keyName = a, i;
      },
      onUpdate(a) {
        return n.onUpdate = a, i;
      },
      onDelete(a) {
        return n.onDelete = a, i;
      },
      deferrable: (a) => {
        if ([
          "mysql",
          "mssql",
          "redshift",
          "mysql2",
          "oracledb"
        ].indexOf(this.client.dialect) !== -1)
          throw new Error(`${this.client.dialect} does not support deferrable`);
        return n.deferrable = a, i;
      },
      _columnBuilder(a) {
        return g1(a, i), i = a, a;
      }
    };
    return i;
  }
  check(e, r, n) {
    return this._statements.push({
      grouping: "checks",
      args: [e, r, n]
    }), this;
  }
};
[
  // Each of the index methods can be called individually, with the
  // column name to be used, e.g. table.unique('column').
  "index",
  "primary",
  "unique",
  // Key specific
  "dropPrimary",
  "dropUnique",
  "dropIndex",
  "dropForeign"
].forEach((t) => {
  rn.prototype[t] = function() {
    return this._statements.push({
      grouping: "alterTable",
      method: t,
      args: fu(arguments)
    }), this;
  };
});
const dre = {
  mysql: ["engine", "charset", "collate"],
  postgresql: ["inherits"]
};
cre(dre, function(t, e) {
  t.forEach(function(r) {
    rn.prototype[r] = function(n) {
      if (this.client.dialect !== e)
        throw new Error(
          `Knex only supports ${r} statement with ${e}.`
        );
      if (this._method === "alter")
        throw new Error(
          `Knex does not support altering the ${r} outside of create table, please use knex.raw statement.`
        );
      this._single[r] = n;
    };
  });
});
lre.addQueryContext(rn);
const mre = [
  // Numeric
  "tinyint",
  "smallint",
  "mediumint",
  "int",
  "bigint",
  "decimal",
  "float",
  "double",
  "real",
  "bit",
  "boolean",
  "serial",
  // Date / Time
  "date",
  "datetime",
  "timestamp",
  "time",
  "year",
  // Geometry
  "geometry",
  "geography",
  "point",
  // String
  "char",
  "varchar",
  "tinytext",
  "tinyText",
  "text",
  "mediumtext",
  "mediumText",
  "longtext",
  "longText",
  "binary",
  "varbinary",
  "tinyblob",
  "tinyBlob",
  "mediumblob",
  "mediumBlob",
  "blob",
  "longblob",
  "longBlob",
  "enum",
  "set",
  // Increments, Aliases, and Additional
  "bool",
  "dateTime",
  "increments",
  "bigincrements",
  "bigIncrements",
  "integer",
  "biginteger",
  "bigInteger",
  "string",
  "json",
  "jsonb",
  "uuid",
  "enu",
  "specificType"
];
mre.forEach((t) => {
  rn.prototype[t] = function() {
    const e = fu(arguments), r = this.client.columnBuilder(this, t, e);
    return this._statements.push({
      grouping: "columns",
      builder: r
    }), r;
  };
});
const ug = {
  // Renames the current column `from` the current
  // TODO: this.column(from).rename(to)
  renameColumn(t, e) {
    return this._statements.push({
      grouping: "alterTable",
      method: "renameColumn",
      args: [t, e]
    }), this;
  },
  dropTimestamps() {
    return this.dropColumns(
      arguments[0] === !0 ? ["createdAt", "updatedAt"] : ["created_at", "updated_at"]
    );
  },
  setNullable(t) {
    return this._statements.push({
      grouping: "alterTable",
      method: "setNullable",
      args: [t]
    }), this;
  },
  check(t, e, r) {
    this._statements.push({
      grouping: "alterTable",
      method: "check",
      args: [t, e, r]
    });
  },
  dropChecks() {
    this._statements.push({
      grouping: "alterTable",
      method: "dropChecks",
      args: fu(arguments)
    });
  },
  dropNullable(t) {
    return this._statements.push({
      grouping: "alterTable",
      method: "dropNullable",
      args: [t]
    }), this;
  }
  // TODO: changeType
};
ug.dropColumn = ug.dropColumns = function() {
  return this._statements.push({
    grouping: "alterTable",
    method: "dropColumn",
    args: fu(arguments)
  }), this;
};
rn.extend = (t, e) => {
  if (Object.prototype.hasOwnProperty.call(rn.prototype, t))
    throw new Error(
      `Can't extend TableBuilder with existing method ('${t}').`
    );
  ure(rn.prototype, { [t]: e });
};
var xA = rn;
function gre(t, e, r, n) {
  for (var i = t.length, a = r + (n ? 1 : -1); n ? a-- : ++a < i; )
    if (e(t[a], a, t))
      return a;
  return -1;
}
var vre = gre;
function yre(t) {
  return t !== t;
}
var bre = yre;
function wre(t, e, r) {
  for (var n = r - 1, i = t.length; ++n < i; )
    if (t[n] === e)
      return n;
  return -1;
}
var xre = wre, _re = vre, Ere = bre, Sre = xre;
function Cre(t, e, r) {
  return e === e ? Sre(t, e, r) : _re(t, Ere, r);
}
var _A = Cre, Tre = _A, Ore = DO, Are = Math.max;
function $re(t, e, r) {
  var n = t == null ? 0 : t.length;
  if (!n)
    return -1;
  var i = r == null ? 0 : Ore(r);
  return i < 0 && (i = Are(n + i, 0)), Tre(t, e, i);
}
var Ire = $re;
const {
  pushAdditional: kre,
  pushQuery: Rre,
  unshiftQuery: Nre
} = cu, Lre = wt, Pre = su, Dre = Ire, v1 = sr, Mre = iu, { normalizeArr: qre } = wt;
let _r = class {
  constructor(e, r) {
    this.client = e, this.tableBuilder = r, this._commonBuilder = this.tableBuilder, this.method = r._method, this.schemaNameRaw = r._schemaName, this.tableNameRaw = r._tableName, this.tableNameLikeRaw = r._tableNameLike, this.single = r._single, this.grouped = Pre(r._statements, "grouping"), this.formatter = e.formatter(r), this.bindings = [], this.formatter.bindings = this.bindings, this.bindingsHolder = this, this.sequence = [], this._formatting = e.config && e.config.formatting, this.checksCount = 0;
  }
  // Convert the tableCompiler toSQL
  toSQL() {
    return this[this.method](), this.sequence;
  }
  // Column Compilation
  // -------
  // If this is a table "creation", we need to first run through all
  // of the columns to build them into a single string,
  // and then run through anything else and push it to the query sequence.
  create(e, r) {
    const i = this.getColumns().map((s) => s.toSQL()), a = this.getColumnTypes(i);
    this.createAlterTableMethods && this.alterTableForCreate(a), this.createQuery(a, e, r), this.columnQueries(i), delete this.single.comment, this.alterTable();
  }
  // Only create the table if it doesn't exist.
  createIfNot() {
    this.create(!0);
  }
  createLike() {
    this.create(!1, !0);
  }
  createLikeIfNot() {
    this.create(!0, !0);
  }
  // If we're altering the table, we need to one-by-one
  // go through and handle each of the queries associated
  // with altering the table's schema.
  alter() {
    const r = this.getColumns().map((o) => o.toSQL()), n = this.getColumns("alter"), i = n.map((o) => o.toSQL()), a = this.getColumnTypes(r), s = this.getColumnTypes(i);
    this.addColumns(a), this.alterColumns(s, n), this.columnQueries(r), this.columnQueries(i), this.alterTable();
  }
  foreign(e) {
    if (e.inTable && e.references) {
      const r = e.keyName ? this.formatter.wrap(e.keyName) : this._indexCommand("foreign", this.tableNameRaw, e.column), n = this.formatter.columnize(e.column), i = this.formatter.columnize(e.references), a = this.formatter.wrap(e.inTable), s = e.onUpdate ? (this.lowerCase ? " on update " : " ON UPDATE ") + e.onUpdate : "", o = e.onDelete ? (this.lowerCase ? " on delete " : " ON DELETE ") + e.onDelete : "", c = e.deferrable ? this.lowerCase ? ` deferrable initially ${e.deferrable.toLowerCase()} ` : ` DEFERRABLE INITIALLY ${e.deferrable.toUpperCase()} ` : "";
      this.lowerCase ? this.pushQuery(
        (this.forCreate ? "" : `alter table ${this.tableName()} add `) + "constraint " + r + " foreign key (" + n + ") references " + a + " (" + i + ")" + s + o + c
      ) : this.pushQuery(
        (this.forCreate ? "" : `ALTER TABLE ${this.tableName()} ADD `) + "CONSTRAINT " + r + " FOREIGN KEY (" + n + ") REFERENCES " + a + " (" + i + ")" + s + o + c
      );
    }
  }
  // Get all of the column sql & bindings individually for building the table queries.
  getColumnTypes(e) {
    return e.reduce(
      function(r, n) {
        const i = n[0];
        return r.sql.push(i.sql), r.bindings.concat(i.bindings), r;
      },
      { sql: [], bindings: [] }
    );
  }
  // Adds all of the additional queries from the "column"
  columnQueries(e) {
    const r = e.reduce(function(n, i) {
      const a = Mre(i);
      return v1(a) ? n : n.concat(a);
    }, []);
    for (const n of r)
      this.pushQuery(n);
  }
  // All of the columns to "add" for the query
  addColumns(e, r) {
    if (r = r || this.addColumnsPrefix, e.sql.length > 0) {
      const n = e.sql.map((i) => r + i);
      this.pushQuery({
        sql: (this.lowerCase ? "alter table " : "ALTER TABLE ") + this.tableName() + " " + n.join(", "),
        bindings: e.bindings
      });
    }
  }
  alterColumns(e, r) {
    e.sql.length > 0 && this.addColumns(e, this.alterColumnsPrefix, r);
  }
  // Compile the columns as needed for the current create or alter table
  getColumns(e) {
    const r = this.grouped.columns || [];
    e = e || "add";
    const n = this.tableBuilder.queryContext();
    return r.filter((i) => i.builder._method === e).map((i) => (n !== void 0 && i.builder.queryContext() === void 0 && i.builder.queryContext(n), this.client.columnCompiler(this, i.builder)));
  }
  tableName() {
    const e = this.schemaNameRaw ? `${this.schemaNameRaw}.${this.tableNameRaw}` : this.tableNameRaw;
    return this.formatter.wrap(e);
  }
  tableNameLike() {
    const e = this.schemaNameRaw ? `${this.schemaNameRaw}.${this.tableNameLikeRaw}` : this.tableNameLikeRaw;
    return this.formatter.wrap(e);
  }
  // Generate all of the alter column statements necessary for the query.
  alterTable() {
    const e = this.grouped.alterTable || [];
    for (let r = 0, n = e.length; r < n; r++) {
      const i = e[r];
      this[i.method] ? this[i.method].apply(this, i.args) : this.client.logger.error(`Debug: ${i.method} does not exist`);
    }
    for (const r in this.single)
      typeof this[r] == "function" && this[r](this.single[r]);
  }
  alterTableForCreate(e) {
    this.forCreate = !0;
    const r = this.sequence, n = this.grouped.alterTable || [];
    this.grouped.alterTable = [];
    for (let i = 0, a = n.length; i < a; i++) {
      const s = n[i];
      if (Dre(this.createAlterTableMethods, s.method) < 0) {
        this.grouped.alterTable.push(s);
        continue;
      }
      this[s.method] ? (this.sequence = [], this[s.method].apply(this, s.args), e.sql.push(this.sequence[0].sql)) : this.client.logger.error(`Debug: ${s.method} does not exist`);
    }
    this.sequence = r, this.forCreate = !1;
  }
  // Drop the index on the current table.
  dropIndex(e) {
    this.pushQuery(`drop index${e}`);
  }
  dropUnique() {
    throw new Error("Method implemented in the dialect driver");
  }
  dropForeign() {
    throw new Error("Method implemented in the dialect driver");
  }
  dropColumn() {
    const e = Lre.normalizeArr.apply(null, arguments), r = (Array.isArray(e) ? e : [e]).map(
      (n) => this.dropColumnPrefix + this.formatter.wrap(n)
    );
    this.pushQuery(
      (this.lowerCase ? "alter table " : "ALTER TABLE ") + this.tableName() + " " + r.join(", ")
    );
  }
  //Default implementation of setNullable. Overwrite on dialect-specific tablecompiler when needed
  //(See postgres/mssql for reference)
  _setNullableState(e, r) {
    const n = this.tableName(), i = this.formatter.columnize(e), a = this.alterColumnsPrefix;
    return this.pushQuery({
      sql: "SELECT 1",
      output: () => this.client.queryBuilder().from(this.tableNameRaw).columnInfo(e).then((s) => {
        if (v1(s))
          throw new Error(
            `.setNullable: Column ${i} does not exist in table ${n}.`
          );
        const o = r ? "null" : "not null", c = s.type + (s.maxLength ? `(${s.maxLength})` : ""), f = s.defaultValue !== null && s.defaultValue !== void 0 ? `default '${s.defaultValue}'` : "", u = `alter table ${n} ${a} ${i} ${c} ${o} ${f}`;
        return this.client.raw(u);
      })
    });
  }
  setNullable(e) {
    return this._setNullableState(e, !0);
  }
  dropNullable(e) {
    return this._setNullableState(e, !1);
  }
  dropChecks(e) {
    if (e === void 0)
      return "";
    e = qre(e);
    const n = `alter table ${this.tableName()} ${e.map((i) => `drop constraint ${i}`).join(", ")}`;
    this.pushQuery(n);
  }
  check(e, r, n) {
    const i = this.tableName();
    let a = n;
    a || (this.checksCount++, a = i + "_" + this.checksCount);
    const s = `alter table ${i} add constraint ${a} check(${e})`;
    this.pushQuery(s);
  }
  _addChecks() {
    return this.grouped.checks ? ", " + this.grouped.checks.map((e) => `${e.args[2] ? "constraint " + e.args[2] + " " : ""}check (${this.client.raw(e.args[0], e.args[1])})`).join(", ") : "";
  }
  // If no name was specified for this index, we will create one using a basic
  // convention of the table name, followed by the columns, followed by an
  // index type, such as primary or index, which makes the index unique.
  _indexCommand(e, r, n) {
    Array.isArray(n) || (n = n ? [n] : []);
    const a = (r.replace(/\.|-/g, "_") + "_" + n.join("_") + "_" + e).toLowerCase();
    return this.formatter.wrap(a);
  }
  _getPrimaryKeys() {
    return (this.grouped.alterTable || []).filter((e) => e.method === "primary").flatMap((e) => e.args).flat();
  }
  _canBeAddPrimaryKey(e) {
    return e.primaryKey && this._getPrimaryKeys().length === 0;
  }
  _getIncrementsColumnNames() {
    return this.grouped.columns.filter((e) => e.builder._type === "increments").map((e) => e.builder._args[0]);
  }
};
_r.prototype.pushQuery = Rre;
_r.prototype.pushAdditional = kre;
_r.prototype.unshiftQuery = Nre;
_r.prototype.lowerCase = !0;
_r.prototype.createAlterTableMethods = null;
_r.prototype.addColumnsPrefix = "add column ";
_r.prototype.alterColumnsPrefix = "alter column ";
_r.prototype.modifyColumnPrefix = "modify column ";
_r.prototype.dropColumnPrefix = "drop column ";
var Wi = _r;
const jre = pu, Fre = Bn, EA = ms, { addQueryContext: Bre } = wt;
let Dr = class {
  constructor(e, r, n, i) {
    this.client = e, this._method = "add", this._single = {}, this._modifiers = {}, this._statements = [], this._type = Hre[n] || n, this._args = i, this._tableBuilder = r, r._method === "alter" && jre(this, hu);
  }
  // Specify that the current column "references" a column,
  // which may be tableName.column or just "column"
  references(e) {
    return this._tableBuilder.foreign.call(this._tableBuilder, this._args[0], void 0, this)._columnBuilder(this).references(e);
  }
};
const Ure = [
  "default",
  "defaultsTo",
  "defaultTo",
  "unsigned",
  "nullable",
  "first",
  "after",
  "comment",
  "collate",
  "check",
  "checkPositive",
  "checkNegative",
  "checkIn",
  "checkNotIn",
  "checkBetween",
  "checkLength",
  "checkRegex"
], zre = {
  default: "defaultTo",
  defaultsTo: "defaultTo"
};
Ure.forEach(function(t) {
  const e = zre[t] || t;
  Dr.prototype[t] = function() {
    return this._modifiers[e] = EA(arguments), this;
  };
});
Bre(Dr);
Dr.prototype.notNull = Dr.prototype.notNullable = function() {
  return this.nullable(!1);
};
["index", "primary", "unique"].forEach(function(t) {
  Dr.prototype[t] = function() {
    return this._type.toLowerCase().indexOf("increments") === -1 && this._tableBuilder[t].apply(
      this._tableBuilder,
      [this._args[0]].concat(EA(arguments))
    ), this;
  };
});
Dr.extend = (t, e) => {
  if (Object.prototype.hasOwnProperty.call(Dr.prototype, t))
    throw new Error(
      `Can't extend ColumnBuilder with existing method ('${t}').`
    );
  Fre(Dr.prototype, { [t]: e });
};
const hu = {};
hu.drop = function() {
  return this._single.drop = !0, this;
};
hu.alterType = function(t) {
  return this._statements.push({
    grouping: "alterType",
    value: t
  }), this;
};
hu.alter = function({
  alterNullable: t = !0,
  alterType: e = !0
} = {}) {
  return this._method = "alter", this.alterNullable = t, this.alterType = e, this;
};
const Hre = {
  float: "floating",
  enum: "enu",
  boolean: "bool",
  string: "varchar",
  bigint: "bigInteger"
};
var du = Dr;
function Wre(t) {
  return t && t.length ? t[0] : void 0;
}
var Gre = Wre, Qre = Gre;
const qv = cu, Vre = su, Kre = Qre, Jre = ou, Xre = iu, { toNumber: si } = wt, { formatDefault: Zre } = Un, { operator: cp } = xt;
let Ke = class {
  constructor(e, r, n) {
    this.client = e, this.tableCompiler = r, this.columnBuilder = n, this._commonBuilder = this.columnBuilder, this.args = n._args, this.type = n._type.toLowerCase(), this.grouped = Vre(n._statements, "grouping"), this.modified = n._modifiers, this.isIncrements = this.type.indexOf("increments") !== -1, this.formatter = e.formatter(n), this.bindings = [], this.formatter.bindings = this.bindings, this.bindingsHolder = this, this.sequence = [], this.modifiers = [], this.checksCount = 0;
  }
  _addCheckModifiers() {
    this.modifiers.push(
      "check",
      "checkPositive",
      "checkNegative",
      "checkIn",
      "checkNotIn",
      "checkBetween",
      "checkLength",
      "checkRegex"
    );
  }
  defaults(e) {
    if (Object.prototype.hasOwnProperty.call(this._defaultMap, e))
      return this._defaultMap[e].bind(this)();
    throw new Error(
      `There is no default for the specified identifier ${e}`
    );
  }
  // To convert to sql, we first go through and build the
  // column as it would be in the insert statement
  toSQL() {
    return this.pushQuery(this.compileColumn()), this.sequence.additional && (this.sequence = this.sequence.concat(this.sequence.additional)), this.sequence;
  }
  // Compiles a column.
  compileColumn() {
    return this.formatter.wrap(this.getColumnName()) + " " + this.getColumnType() + this.getModifiers();
  }
  // Assumes the autoincrementing key is named `id` if not otherwise specified.
  getColumnName() {
    return Kre(this.args) || this.defaults("columnName");
  }
  getColumnType() {
    if (!this._columnType) {
      const e = this[this.type];
      this._columnType = typeof e == "function" ? e.apply(this, Xre(this.args)) : e;
    }
    return this._columnType;
  }
  getModifiers() {
    const e = [];
    for (let r = 0, n = this.modifiers.length; r < n; r++) {
      const i = this.modifiers[r];
      if ((!this.isIncrements || this.isIncrements && i === "comment") && Jre(this.modified, i)) {
        const a = this[i].apply(this, this.modified[i]);
        a && e.push(a);
      }
    }
    return e.length > 0 ? ` ${e.join(" ")}` : "";
  }
  // Types
  // ------
  varchar(e) {
    return `varchar(${si(e, 255)})`;
  }
  floating(e, r) {
    return `float(${si(e, 8)}, ${si(r, 2)})`;
  }
  decimal(e, r) {
    if (e === null)
      throw new Error(
        "Specifying no precision on decimal columns is not supported for that SQL dialect."
      );
    return `decimal(${si(e, 8)}, ${si(r, 2)})`;
  }
  // Used to support custom types
  specifictype(e) {
    return e;
  }
  // Modifiers
  // -------
  nullable(e) {
    return e === !1 ? "not null" : "null";
  }
  notNullable() {
    return this.nullable(!1);
  }
  defaultTo(e) {
    return `default ${Zre(e, this.type, this.client)}`;
  }
  increments(e = { primaryKey: !0 }) {
    return "integer not null" + (this.tableCompiler._canBeAddPrimaryKey(e) ? " primary key" : "") + " autoincrement";
  }
  bigincrements(e = { primaryKey: !0 }) {
    return this.increments(e);
  }
  _pushAlterCheckQuery(e, r) {
    let n = r;
    n || (this.checksCount++, n = this.tableCompiler.tableNameRaw + "_" + this.getColumnName() + "_" + this.checksCount), this.pushAdditional(function() {
      this.pushQuery(
        `alter table ${this.tableCompiler.tableName()} add constraint ${n} check(${e})`
      );
    });
  }
  _checkConstraintName(e) {
    return e ? `constraint ${e} ` : "";
  }
  _check(e, r) {
    return this.columnBuilder._method === "alter" ? (this._pushAlterCheckQuery(e, r), "") : `${this._checkConstraintName(
      r
    )}check (${e})`;
  }
  checkPositive(e) {
    return this._check(
      `${this.formatter.wrap(this.getColumnName())} ${cp(
        ">",
        this.columnBuilder,
        this.bindingsHolder
      )} 0`,
      e
    );
  }
  checkNegative(e) {
    return this._check(
      `${this.formatter.wrap(this.getColumnName())} ${cp(
        "<",
        this.columnBuilder,
        this.bindingsHolder
      )} 0`,
      e
    );
  }
  _checkIn(e, r, n) {
    return this._check(
      `${this.formatter.wrap(this.getColumnName())} ${n ? "not " : ""}in (${e.map((i) => this.client._escapeBinding(i)).join(",")})`,
      r
    );
  }
  checkIn(e, r) {
    return this._checkIn(e, r);
  }
  checkNotIn(e, r) {
    return this._checkIn(e, r, !0);
  }
  checkBetween(e, r) {
    e.length === 2 && !Array.isArray(e[0]) && !Array.isArray(e[1]) && (e = [e]);
    const n = e.map((i) => `${this.formatter.wrap(
      this.getColumnName()
    )} between ${this.client._escapeBinding(
      i[0]
    )} and ${this.client._escapeBinding(i[1])}`).join(" or ");
    return this._check(n, r);
  }
  checkLength(e, r, n) {
    return this._check(
      `length(${this.formatter.wrap(this.getColumnName())}) ${cp(
        e,
        this.columnBuilder,
        this.bindingsHolder
      )} ${si(r)}`,
      n
    );
  }
};
Ke.prototype.binary = "blob";
Ke.prototype.bool = "boolean";
Ke.prototype.date = "date";
Ke.prototype.datetime = "datetime";
Ke.prototype.time = "time";
Ke.prototype.timestamp = "timestamp";
Ke.prototype.geometry = "geometry";
Ke.prototype.geography = "geography";
Ke.prototype.point = "point";
Ke.prototype.enu = "varchar";
Ke.prototype.bit = Ke.prototype.json = "text";
Ke.prototype.uuid = ({
  useBinaryUuid: t = !1,
  primaryKey: e = !1
} = {}) => t ? "binary(16)" : "char(36)";
Ke.prototype.integer = Ke.prototype.smallint = Ke.prototype.mediumint = "integer";
Ke.prototype.biginteger = "bigint";
Ke.prototype.text = "text";
Ke.prototype.tinyint = "tinyint";
Ke.prototype.pushQuery = qv.pushQuery;
Ke.prototype.pushAdditional = qv.pushAdditional;
Ke.prototype.unshiftQuery = qv.unshiftQuery;
Ke.prototype._defaultMap = {
  columnName: function() {
    if (!this.isIncrements)
      throw new Error(
        `You did not specify a column name for the ${this.type} column.`
      );
    return "id";
  }
};
var Wn = Ke;
const Yre = zi;
let ene = class extends Yre {
  constructor(e, r) {
    super(e), this.ref = r, this._schema = null, this._alias = null;
  }
  withSchema(e) {
    return this._schema = e, this;
  }
  as(e) {
    return this._alias = e, this;
  }
  toSQL() {
    const e = this._schema ? `${this._schema}.${this.ref}` : this.ref, r = this.client.formatter(this), n = r.columnize(e), i = this._alias ? `${n} as ${r.wrap(this._alias)}` : n;
    return this.set(i, []), super.toSQL(...arguments);
  }
};
var tne = ene;
const {
  columnize: rne,
  wrap: nne
} = xt;
let ine = class {
  constructor(e, r) {
    this.client = e, this.builder = r, this.bindings = [];
  }
  // Accepts a string or array of columns to wrap as appropriate.
  columnize(e) {
    return rne(e, this.builder, this.client, this);
  }
  // Puts the appropriate wrapper around a value depending on the database
  // engine, unless it's a knex.raw value, in which case it's left alone.
  wrap(e, r) {
    return nne(e, r, this.builder, this.client, this);
  }
};
var mu = ine, Te = {};
Object.defineProperty(Te, "__esModule", { value: !0 });
var ane = se;
function sne(t) {
  if (t && t.__esModule)
    return t;
  var e = /* @__PURE__ */ Object.create(null);
  return t && Object.keys(t).forEach(function(r) {
    if (r !== "default") {
      var n = Object.getOwnPropertyDescriptor(t, r);
      Object.defineProperty(e, r, n.get ? n : {
        enumerable: !0,
        get: function() {
          return t[r];
        }
      });
    }
  }), e.default = t, Object.freeze(e);
}
var up = /* @__PURE__ */ sne(ane);
const {
  env: Xr = {},
  argv: SA = [],
  platform: one = ""
} = typeof process > "u" ? {} : process, cne = "NO_COLOR" in Xr || SA.includes("--no-color"), une = "FORCE_COLOR" in Xr || SA.includes("--color"), lne = one === "win32", CA = Xr.TERM === "dumb", pne = up && up.isatty && up.isatty(1) && Xr.TERM && !CA, fne = "CI" in Xr && ("GITHUB_ACTIONS" in Xr || "GITLAB_CI" in Xr || "CIRCLECI" in Xr), TA = !cne && (une || lne && !CA || pne || fne), OA = (t, e, r, n, i = e.substring(0, t) + n, a = e.substring(t + r.length), s = a.indexOf(r)) => i + (s < 0 ? a : OA(s, a, r, n)), hne = (t, e, r, n, i) => t < 0 ? r + e + n : r + OA(t, e, n, i) + n, dne = (t, e, r = t, n = t.length + 1) => (i) => i || !(i === "" || i === void 0) ? hne(
  ("" + i).indexOf(e, n),
  i,
  t,
  e,
  r
) : "", Ae = (t, e, r) => dne(`\x1B[${t}m`, `\x1B[${e}m`, r), y1 = {
  reset: Ae(0, 0),
  bold: Ae(1, 22, "\x1B[22m\x1B[1m"),
  dim: Ae(2, 22, "\x1B[22m\x1B[2m"),
  italic: Ae(3, 23),
  underline: Ae(4, 24),
  inverse: Ae(7, 27),
  hidden: Ae(8, 28),
  strikethrough: Ae(9, 29),
  black: Ae(30, 39),
  red: Ae(31, 39),
  green: Ae(32, 39),
  yellow: Ae(33, 39),
  blue: Ae(34, 39),
  magenta: Ae(35, 39),
  cyan: Ae(36, 39),
  white: Ae(37, 39),
  gray: Ae(90, 39),
  bgBlack: Ae(40, 49),
  bgRed: Ae(41, 49),
  bgGreen: Ae(42, 49),
  bgYellow: Ae(43, 49),
  bgBlue: Ae(44, 49),
  bgMagenta: Ae(45, 49),
  bgCyan: Ae(46, 49),
  bgWhite: Ae(47, 49),
  blackBright: Ae(90, 39),
  redBright: Ae(91, 39),
  greenBright: Ae(92, 39),
  yellowBright: Ae(93, 39),
  blueBright: Ae(94, 39),
  magentaBright: Ae(95, 39),
  cyanBright: Ae(96, 39),
  whiteBright: Ae(97, 39),
  bgBlackBright: Ae(100, 49),
  bgRedBright: Ae(101, 49),
  bgGreenBright: Ae(102, 49),
  bgYellowBright: Ae(103, 49),
  bgBlueBright: Ae(104, 49),
  bgMagentaBright: Ae(105, 49),
  bgCyanBright: Ae(106, 49),
  bgWhiteBright: Ae(107, 49)
}, AA = ({ useColor: t = TA } = {}) => t ? y1 : Object.keys(y1).reduce(
  (e, r) => ({ ...e, [r]: String }),
  {}
), {
  reset: mne,
  bold: gne,
  dim: vne,
  italic: yne,
  underline: bne,
  inverse: wne,
  hidden: xne,
  strikethrough: _ne,
  black: Ene,
  red: Sne,
  green: Cne,
  yellow: Tne,
  blue: One,
  magenta: Ane,
  cyan: $ne,
  white: Ine,
  gray: kne,
  bgBlack: Rne,
  bgRed: Nne,
  bgGreen: Lne,
  bgYellow: Pne,
  bgBlue: Dne,
  bgMagenta: Mne,
  bgCyan: qne,
  bgWhite: jne,
  blackBright: Fne,
  redBright: Bne,
  greenBright: Une,
  yellowBright: zne,
  blueBright: Hne,
  magentaBright: Wne,
  cyanBright: Gne,
  whiteBright: Qne,
  bgBlackBright: Vne,
  bgRedBright: Kne,
  bgGreenBright: Jne,
  bgYellowBright: Xne,
  bgBlueBright: Zne,
  bgMagentaBright: Yne,
  bgCyanBright: eie,
  bgWhiteBright: tie
} = AA();
Te.bgBlack = Rne;
Te.bgBlackBright = Vne;
Te.bgBlue = Dne;
Te.bgBlueBright = Zne;
Te.bgCyan = qne;
Te.bgCyanBright = eie;
Te.bgGreen = Lne;
Te.bgGreenBright = Jne;
Te.bgMagenta = Mne;
Te.bgMagentaBright = Yne;
Te.bgRed = Nne;
Te.bgRedBright = Kne;
Te.bgWhite = jne;
Te.bgWhiteBright = tie;
Te.bgYellow = Pne;
Te.bgYellowBright = Xne;
Te.black = Ene;
Te.blackBright = Fne;
Te.blue = One;
Te.blueBright = Hne;
Te.bold = gne;
Te.createColors = AA;
Te.cyan = $ne;
Te.cyanBright = Gne;
Te.dim = vne;
Te.gray = kne;
Te.green = Cne;
Te.greenBright = Une;
Te.hidden = xne;
Te.inverse = wne;
Te.isColorSupported = TA;
Te.italic = yne;
Te.magenta = Ane;
Te.magentaBright = Wne;
Te.red = Sne;
Te.redBright = Bne;
Te.reset = mne;
Te.strikethrough = _ne;
Te.underline = bne;
Te.white = Ine;
Te.whiteBright = Qne;
Te.yellow = Tne;
Te.yellowBright = zne;
const lp = Te, { inspect: rie } = nt, { isString: nie, isFunction: b1 } = Je;
let iie = class {
  constructor(e = {}) {
    const {
      log: {
        debug: r,
        warn: n,
        error: i,
        deprecate: a,
        inspectionDepth: s,
        enableColors: o
      } = {}
    } = e;
    this._inspectionDepth = s || 5, this._enableColors = aie(o), this._debug = r, this._warn = n, this._error = i, this._deprecate = a;
  }
  _log(e, r, n) {
    if (r != null && !b1(r))
      throw new TypeError("Extensions to knex logger must be functions!");
    if (b1(r)) {
      r(e);
      return;
    }
    nie(e) || (e = rie(e, {
      depth: this._inspectionDepth,
      colors: this._enableColors
    })), console.log(n ? n(e) : e);
  }
  debug(e) {
    this._log(e, this._debug);
  }
  warn(e) {
    this._log(e, this._warn, lp.yellow);
  }
  error(e) {
    this._log(e, this._error, lp.red);
  }
  deprecate(e, r) {
    const n = `${e} is deprecated, please use ${r}`;
    this._log(n, this._deprecate, lp.yellow);
  }
};
function aie(t) {
  return t ?? (process && process.stdout ? process.stdout.isTTY : !1);
}
var sie = iie;
const oie = wt, cie = pu, uie = Bn;
let ya = class {
  constructor(e, r, n, i) {
    this.client = e, this._method = r, this._schemaName = void 0, this._columns = void 0, this._fn = i, this._viewName = n, this._statements = [], this._single = {};
  }
  setSchema(e) {
    this._schemaName = e;
  }
  columns(e) {
    this._columns = e;
  }
  as(e) {
    this._selectQuery = e;
  }
  checkOption() {
    throw new Error(
      "check option definition is not supported by this dialect."
    );
  }
  localCheckOption() {
    throw new Error(
      "check option definition is not supported by this dialect."
    );
  }
  cascadedCheckOption() {
    throw new Error(
      "check option definition is not supported by this dialect."
    );
  }
  toSQL() {
    return this._method === "alter" && cie(this, lie), this._fn.call(this, this), this.client.viewCompiler(this).toSQL();
  }
};
const lie = {
  column(t) {
    const e = this;
    return {
      rename: function(r) {
        return e._statements.push({
          grouping: "alterView",
          method: "renameColumn",
          args: [t, r]
        }), this;
      },
      defaultTo: function(r) {
        return e._statements.push({
          grouping: "alterView",
          method: "defaultTo",
          args: [t, r]
        }), this;
      }
    };
  }
};
oie.addQueryContext(ya);
ya.extend = (t, e) => {
  if (Object.prototype.hasOwnProperty.call(ya.prototype, t))
    throw new Error(
      `Can't extend ViewBuilder with existing method ('${t}').`
    );
  uie(ya.prototype, { [t]: e });
};
var bs = ya;
const { pushQuery: pie } = cu, fie = su, { columnize: hie } = xt;
let $A = class {
  constructor(e, r) {
    this.client = e, this.viewBuilder = r, this._commonBuilder = this.viewBuilder, this.method = r._method, this.schemaNameRaw = r._schemaName, this.viewNameRaw = r._viewName, this.single = r._single, this.selectQuery = r._selectQuery, this.columns = r._columns, this.grouped = fie(r._statements, "grouping"), this.formatter = e.formatter(r), this.bindings = [], this.formatter.bindings = this.bindings, this.bindingsHolder = this, this.sequence = [];
  }
  // Convert the tableCompiler toSQL
  toSQL() {
    return this[this.method](), this.sequence;
  }
  // Column Compilation
  // -------
  create() {
    this.createQuery(this.columns, this.selectQuery);
  }
  createOrReplace() {
    throw new Error("replace views is not supported by this dialect.");
  }
  createMaterializedView() {
    throw new Error("materialized views are not supported by this dialect.");
  }
  createQuery(e, r, n, i) {
    const a = "create " + (n ? "materialized " : "") + (i ? "or replace " : "") + "view ", s = e ? " (" + hie(
      e,
      this.viewBuilder,
      this.client,
      this.bindingsHolder
    ) + ")" : "";
    let o = a + this.viewName() + s;
    switch (o += " as ", o += r.toString(), this.single.checkOption) {
      case "default_option":
        o += " with check option";
        break;
      case "local":
        o += " with local check option";
        break;
      case "cascaded":
        o += " with cascaded check option";
        break;
    }
    this.pushQuery({
      sql: o
    });
  }
  renameView(e, r) {
    throw new Error(
      "rename view is not supported by this dialect (instead drop, then create another view)."
    );
  }
  refreshMaterializedView() {
    throw new Error("materialized views are not supported by this dialect.");
  }
  alter() {
    this.alterView();
  }
  alterView() {
    const e = this.grouped.alterView || [];
    for (let r = 0, n = e.length; r < n; r++) {
      const i = e[r];
      this[i.method] ? this[i.method].apply(this, i.args) : this.client.logger.error(`Debug: ${i.method} does not exist`);
    }
    for (const r in this.single)
      typeof this[r] == "function" && this[r](this.single[r]);
  }
  renameColumn(e, r) {
    throw new Error("rename column of views is not supported by this dialect.");
  }
  defaultTo(e, r) {
    throw new Error(
      "change default values of views is not supported by this dialect."
    );
  }
  viewName() {
    const e = this.schemaNameRaw ? `${this.schemaNameRaw}.${this.viewNameRaw}` : this.viewNameRaw;
    return this.formatter.wrap(e);
  }
};
$A.prototype.pushQuery = pie;
var Gi = $A;
const { Pool: die, TimeoutError: mie } = xq, { EventEmitter: gie } = bt, { promisify: vie } = nt, { makeEscape: yie } = dv, bie = PH, wie = EO, xie = TO, _ie = FW, Eie = ln, {
  executeQuery: Sie,
  enrichQueryObject: w1
} = GO, Cie = pn, Tie = Hn, Oie = bA, Aie = Hi, $ie = xA, Iie = Wi, kie = du, Rie = Wn, { KnexTimeoutError: Nie } = cn, { outputQuery: Lie, unwrapRaw: Pie } = xt, { compileCallback: Die } = Un, Mie = zi, qie = tne, jie = mu, Fie = sie, { POOL_CONFIG_OPTIONS: Bie } = Rv, Uie = bs, zie = Gi, Hie = un, pp = ar("knex:client");
let IA = class extends gie {
  constructor(e = {}) {
    if (super(), this.config = e, this.logger = new Fie(e), this.dialect && !this.config.client && this.logger.warn(
      "Using 'this.dialect' to identify the client is deprecated and support for it will be removed in the future. Please use configuration option 'client' instead."
    ), !(this.config.client || this.dialect))
      throw new Error(
        "knex: Required configuration option 'client' is missing."
      );
    e.version && (this.version = e.version), e.connection && e.connection instanceof Function ? (this.connectionConfigProvider = e.connection, this.connectionConfigExpirationChecker = () => !0) : (this.connectionSettings = bie(e.connection || {}), this.connectionConfigExpirationChecker = null), this.driverName && e.connection && (this.initializeDriver(), (!e.pool || e.pool && e.pool.max !== 0) && this.initializePool(e)), this.valueForUndefined = this.raw("DEFAULT"), e.useNullAsDefault && (this.valueForUndefined = null);
  }
  formatter(e) {
    return new jie(this, e);
  }
  queryBuilder() {
    return new Cie(this);
  }
  queryCompiler(e, r) {
    return new Tie(this, e, r);
  }
  schemaBuilder() {
    return new Oie(this);
  }
  schemaCompiler(e) {
    return new Aie(this, e);
  }
  tableBuilder(e, r, n, i) {
    return new $ie(this, e, r, n, i);
  }
  viewBuilder(e, r, n) {
    return new Uie(this, e, r, n);
  }
  tableCompiler(e) {
    return new Iie(this, e);
  }
  viewCompiler(e) {
    return new zie(this, e);
  }
  columnBuilder(e, r, n) {
    return new kie(this, e, r, n);
  }
  columnCompiler(e, r) {
    return new Rie(this, e, r);
  }
  runner(e) {
    return new _ie(this, e);
  }
  transaction(e, r, n) {
    return new Eie(this, e, r, n);
  }
  raw() {
    return new Mie(this).set(...arguments);
  }
  ref() {
    return new qie(this, ...arguments);
  }
  query(e, r) {
    const n = w1(e, r, this);
    return Sie(e, n, this);
  }
  stream(e, r, n, i) {
    const a = w1(e, r, this);
    return this._stream(e, a, n, i);
  }
  prepBindings(e) {
    return e;
  }
  positionBindings(e) {
    return e;
  }
  postProcessResponse(e, r) {
    return this.config.postProcessResponse ? this.config.postProcessResponse(e, r) : e;
  }
  wrapIdentifier(e, r) {
    return this.customWrapIdentifier(
      e,
      this.wrapIdentifierImpl,
      r
    );
  }
  customWrapIdentifier(e, r, n) {
    return this.config.wrapIdentifier ? this.config.wrapIdentifier(e, r, n) : r(e);
  }
  wrapIdentifierImpl(e) {
    return e !== "*" ? `"${e.replace(/"/g, '""')}"` : "*";
  }
  initializeDriver() {
    try {
      this.driver = this._driver();
    } catch (e) {
      const r = `Knex: run
$ npm install ${this.driverName} --save`;
      throw this.logger.error(`${r}
${e.message}
${e.stack}`), new Error(`${r}
${e.message}`);
    }
  }
  poolDefaults() {
    return { min: 2, max: 10, propagateCreateError: !0 };
  }
  getPoolSettings(e) {
    e = wie({}, e, this.poolDefaults()), Bie.forEach((a) => {
      a in e && this.logger.warn(
        [
          `Pool config option "${a}" is no longer supported.`,
          "See https://github.com/Vincit/tarn.js for possible pool config options."
        ].join(" ")
      );
    });
    const r = 6e4, n = [
      this.config.acquireConnectionTimeout,
      e.acquireTimeoutMillis
    ].filter((a) => a !== void 0);
    n.length || n.push(r), e.acquireTimeoutMillis = Math.min(...n);
    const i = async () => {
      if (!this.connectionConfigProvider || !this.connectionConfigExpirationChecker || !this.connectionConfigExpirationChecker())
        return;
      const a = await this.connectionConfigProvider();
      a.expirationChecker ? (this.connectionConfigExpirationChecker = a.expirationChecker, delete a.expirationChecker) : this.connectionConfigExpirationChecker = null, this.connectionSettings = a;
    };
    return Object.assign(e, {
      create: async () => {
        await i();
        const a = await this.acquireRawConnection();
        return a.__knexUid = xie("__knexUid"), e.afterCreate && await vie(e.afterCreate)(a), a;
      },
      destroy: (a) => {
        if (a !== void 0)
          return this.destroyRawConnection(a);
      },
      validate: (a) => a.__knex__disposed ? (this.logger.warn(`Connection Error: ${a.__knex__disposed}`), !1) : this.validateConnection(a)
    });
  }
  initializePool(e = this.config) {
    if (this.pool) {
      this.logger.warn("The pool has already been initialized");
      return;
    }
    const r = {
      ...this.getPoolSettings(e.pool)
    };
    r.afterCreate && delete r.afterCreate, this.pool = new die(r);
  }
  validateConnection(e) {
    return !0;
  }
  // Acquire a connection from the pool.
  async acquireConnection() {
    if (!this.pool)
      throw new Error("Unable to acquire a connection");
    try {
      const e = await this.pool.acquire().promise;
      return pp("acquired connection from pool: %s", e.__knexUid), e;
    } catch (e) {
      let r = e;
      throw e instanceof mie && (r = new Nie(
        "Knex: Timeout acquiring a connection. The pool is probably full. Are you missing a .transacting(trx) call?"
      )), r;
    }
  }
  // Releases a connection back to the connection pool,
  // returning a promise resolved when the connection is released.
  releaseConnection(e) {
    return pp("releasing connection to pool: %s", e.__knexUid), this.pool.release(e) || pp("pool refused connection: %s", e.__knexUid), Promise.resolve();
  }
  // Destroy the current connection pool for the client.
  async destroy(e) {
    try {
      this.pool && this.pool.destroy && await this.pool.destroy(), this.pool = void 0, typeof e == "function" && e();
    } catch (r) {
      if (typeof e == "function")
        return e(r);
      throw r;
    }
  }
  // Return the database being used by this client.
  database() {
    return this.connectionSettings.database;
  }
  toString() {
    return "[object KnexClient]";
  }
  assertCanCancelQuery() {
    if (!this.canCancelQuery)
      throw new Error("Query cancelling not supported for this dialect");
  }
  cancelQuery() {
    throw new Error("Query cancelling not supported for this dialect");
  }
  // Formatter part
  alias(e, r) {
    return e + " as " + r;
  }
  // Checks whether a value is a function... if it is, we compile it
  // otherwise we check whether it's a raw
  parameter(e, r, n) {
    return typeof e == "function" ? Lie(
      Die(e, void 0, this, n),
      !0,
      r,
      this
    ) : Pie(e, !0, r, this, n) || "?";
  }
  // Turns a list of values into a list of ?'s, joining them with commas unless
  // a "joining" value is specified (e.g. ' and ')
  parameterize(e, r, n, i) {
    if (typeof e == "function")
      return this.parameter(e, n, i);
    e = Array.isArray(e) ? e : [e];
    let a = "", s = -1;
    for (; ++s < e.length; ) {
      s > 0 && (a += ", ");
      let o = e[s];
      Hie(o) && (o = JSON.stringify(o)), a += this.parameter(
        o === void 0 ? r : o,
        n,
        i
      );
    }
    return a;
  }
  // Formats `values` into a parenthesized list of parameters for a `VALUES`
  // clause.
  //
  // [1, 2]                  -> '(?, ?)'
  // [[1, 2], [3, 4]]        -> '((?, ?), (?, ?))'
  // knex('table')           -> '(select * from "table")'
  // knex.raw('select ?', 1) -> '(select ?)'
  //
  values(e, r, n) {
    return Array.isArray(e) ? Array.isArray(e[0]) ? `(${e.map(
      (i) => `(${this.parameterize(
        i,
        void 0,
        r,
        n
      )})`
    ).join(", ")})` : `(${this.parameterize(
      e,
      void 0,
      r,
      n
    )})` : e && e.isRawInstance ? `(${this.parameter(e, r, n)})` : this.parameter(e, r, n);
  }
  processPassedConnection(e) {
  }
  toPathForJson(e) {
    return e;
  }
};
Object.assign(IA.prototype, {
  _escapeBinding: yie({
    escapeString(t) {
      return `'${t.replace(/'/g, "''")}'`;
    }
  }),
  canCancelQuery: !1
});
var Gn = IA, Wie = se, fp = se;
function lg(t) {
  if (t.charAt(0) === "/") {
    var r = t.split(" ");
    return { host: r[0], database: r[1] };
  }
  var e = Wie.parse(
    / |%[^a-f0-9]|%[a-f0-9][^a-f0-9]/i.test(t) ? encodeURI(t).replace(/\%25(\d\d)/g, "%$1") : t,
    !0
  ), r = e.query;
  for (var n in r)
    Array.isArray(r[n]) && (r[n] = r[n][r[n].length - 1]);
  var i = (e.auth || ":").split(":");
  if (r.user = i[0], r.password = i.splice(1).join(":"), r.port = e.port, e.protocol == "socket:")
    return r.host = decodeURI(e.pathname), r.database = e.query.db, r.client_encoding = e.query.encoding, r;
  r.host || (r.host = e.hostname);
  var a = e.pathname;
  if (!r.host && a && /^%2f/i.test(a)) {
    var s = a.split("/");
    r.host = decodeURIComponent(s[0]), a = s.splice(1).join("/");
  }
  switch (a && a.charAt(0) === "/" && (a = a.slice(1) || null), r.database = a && decodeURI(a), (r.ssl === "true" || r.ssl === "1") && (r.ssl = !0), r.ssl === "0" && (r.ssl = !1), (r.sslcert || r.sslkey || r.sslrootcert || r.sslmode) && (r.ssl = {}), r.sslcert && (r.ssl.cert = fp.readFileSync(r.sslcert).toString()), r.sslkey && (r.ssl.key = fp.readFileSync(r.sslkey).toString()), r.sslrootcert && (r.ssl.ca = fp.readFileSync(r.sslrootcert).toString()), r.sslmode) {
    case "disable": {
      r.ssl = !1;
      break;
    }
    case "prefer":
    case "require":
    case "verify-ca":
    case "verify-full":
      break;
    case "no-verify": {
      r.ssl.rejectUnauthorized = !1;
      break;
    }
  }
  return r;
}
var Gie = lg;
lg.parse = lg;
const { parse: Qie } = Gie, Vie = Qie, Kie = process && process.platform && process.platform === "win32";
function Jie(t) {
  try {
    return new URL(t);
  } catch {
    return null;
  }
}
var Xie = function(e) {
  const r = Jie(e), n = Kie && r && r.protocol.length === 2;
  if (!r || n)
    return {
      client: "sqlite3",
      connection: {
        filename: e
      }
    };
  let { protocol: i } = r;
  i.slice(-1) === ":" && (i = i.slice(0, -1));
  const a = ["postgresql", "postgres"].includes(i);
  return {
    client: i,
    connection: a ? Vie(e) : Zie(r)
  };
};
function Zie(t) {
  const e = {};
  let r = t.pathname;
  if (r[0] === "/" && (r = r.slice(1)), e.database = r, t.hostname && (t.protocol.indexOf("mssql") === 0 ? e.server = t.hostname : e.host = t.hostname), t.port && (e.port = t.port), (t.username || t.password) && (e.user = decodeURIComponent(t.username)), t.password && (e.password = decodeURIComponent(t.password)), t.searchParams)
    for (const [n, i] of t.searchParams.entries())
      if (["mysql:", "mariadb:", "mssql:"].includes(
        t.protocol
      ))
        try {
          e[n] = JSON.parse(i);
        } catch {
          e[n] = i;
        }
      else
        e[n] = i;
  return e;
}
var gu = {}, hp, x1;
function Yie() {
  if (x1)
    return hp;
  x1 = 1;
  const t = ln;
  class e extends t {
    begin(n) {
      return this.isolationLevel && this.client.logger.warn(
        "sqlite3 only supports serializable transactions, ignoring the isolation level param"
      ), this.query(n, "BEGIN;");
    }
  }
  return hp = e, hp;
}
var dp, _1;
function eae() {
  if (_1)
    return dp;
  _1 = 1;
  const t = xO, e = hs, r = Wt, n = sr, i = gs, a = Hn, s = tu, { isString: o } = Je, {
    wrapString: c,
    columnize: f
  } = xt, u = t("");
  class l extends a {
    constructor(m, h, g) {
      super(m, h, g), this.forShare = u, this.forKeyShare = u, this.forUpdate = u, this.forNoKeyUpdate = u;
    }
    // SQLite requires us to build the multi-row insert as a listing of select with
    // unions joining them together. So we'll build out this list of columns and
    // then join them all together with select unions to complete the queries.
    insert() {
      const m = this.single.insert || [];
      let h = this.with() + `insert into ${this.tableName} `;
      if (Array.isArray(m)) {
        if (m.length === 0)
          return "";
        if (m.length === 1 && m[0] && n(m[0]))
          return {
            sql: h + this._emptyInsertValue
          };
      } else if (typeof m == "object" && n(m))
        return {
          sql: h + this._emptyInsertValue
        };
      const g = this._prepInsert(m);
      if (o(g))
        return {
          sql: h + g
        };
      if (g.columns.length === 0)
        return {
          sql: ""
        };
      if (h += `(${this.formatter.columnize(g.columns)})`, this.client.valueForUndefined !== null && g.values.forEach((S) => {
        e(S, (T) => {
          if (T === void 0)
            throw new TypeError(
              "`sqlite` does not support inserting default values. Specify values explicitly or use the `useNullAsDefault` config flag. (see docs https://knexjs.org/guide/query-builder.html#insert)."
            );
        });
      }), g.values.length === 1) {
        const S = this.client.parameterize(
          g.values[0],
          this.client.valueForUndefined,
          this.builder,
          this.bindingsHolder
        );
        h += ` values (${S})`;
        const { onConflict: T, ignore: E, merge: C } = this.single;
        if (T && E)
          h += this._ignore(T);
        else if (T && C) {
          h += this._merge(C.updates, T, m);
          const R = this.where();
          R && (h += ` ${R}`);
        }
        const { returning: A } = this.single;
        return A && (h += this._returning(A)), {
          sql: h,
          returning: A
        };
      }
      const v = [];
      let d = -1;
      for (; ++d < g.values.length; ) {
        let S = -1;
        const T = v[d] = [];
        let E = g.values[d];
        for (E = E === void 0 ? this.client.valueForUndefined : E; ++S < g.columns.length; )
          T.push(
            this.client.alias(
              this.client.parameter(
                E[S],
                this.builder,
                this.bindingsHolder
              ),
              this.formatter.wrap(g.columns[S])
            )
          );
        v[d] = T.join(", ");
      }
      h += " select " + v.join(" union all select ");
      const { onConflict: y, ignore: x, merge: b } = this.single;
      y && x ? h += " where true" + this._ignore(y) : y && b && (h += " where true" + this._merge(b.updates, y, m));
      const { returning: w } = this.single;
      return w && (h += this._returning(w)), {
        sql: h,
        returning: w
      };
    }
    // Compiles an `update` query, allowing for a return value.
    update() {
      const m = this.with(), h = this._prepUpdate(this.single.update), g = this.where(), { returning: v } = this.single;
      return {
        sql: m + `update ${this.single.only ? "only " : ""}${this.tableName} set ${h.join(", ")}` + (g ? ` ${g}` : "") + this._returning(v),
        returning: v
      };
    }
    _ignore(m) {
      return m === !0 ? " on conflict do nothing" : ` on conflict ${this._onConflictClause(m)} do nothing`;
    }
    _merge(m, h, g) {
      let v = ` on conflict ${this._onConflictClause(h)} do update set `;
      if (m && Array.isArray(m))
        return v += m.map(
          (d) => c(
            d.split(".").pop(),
            this.formatter.builder,
            this.client,
            this.formatter
          )
        ).map((d) => `${d} = excluded.${d}`).join(", "), v;
      if (m && typeof m == "object") {
        const d = this._prepUpdate(m);
        return typeof d == "string" ? v += d : v += d.join(","), v;
      } else {
        const d = this._prepInsert(g);
        if (typeof d == "string")
          throw new Error(
            "If using merge with a raw insert query, then updates must be provided"
          );
        return v += d.columns.map(
          (y) => c(y.split(".").pop(), this.builder, this.client)
        ).map((y) => `${y} = excluded.${y}`).join(", "), v;
      }
    }
    _returning(m) {
      return m ? ` returning ${this.formatter.columnize(m)}` : "";
    }
    // Compile a truncate table statement into SQL.
    truncate() {
      const { table: m } = this.single;
      return {
        sql: `delete from ${this.tableName}`,
        output() {
          return this.query({
            sql: `delete from sqlite_sequence where name = '${m}'`
          }).catch(s);
        }
      };
    }
    // Compiles a `columnInfo` query
    columnInfo() {
      const m = this.single.columnInfo;
      return {
        sql: `PRAGMA table_info(\`${this.client.customWrapIdentifier(this.single.table, r)}\`)`,
        output(g) {
          const v = /.*\((\d+)\)/, d = i(
            g,
            function(y, x) {
              let { type: b } = x, w = b.match(v);
              return w && (w = w[1]), b = w ? b.split("(")[0] : b, y[x.name] = {
                type: b.toLowerCase(),
                maxLength: w,
                nullable: !x.notnull,
                defaultValue: x.dflt_value
              }, y;
            },
            {}
          );
          return m && d[m] || d;
        }
      };
    }
    limit() {
      const m = !this.single.limit && this.single.limit !== 0;
      return m && !this.single.offset ? "" : (this.single.limit = m ? -1 : this.single.limit, `limit ${this._getValueOrParameterFromAttribute("limit")}`);
    }
    // Json functions
    jsonExtract(m) {
      return this._jsonExtract("json_extract", m);
    }
    jsonSet(m) {
      return this._jsonSet("json_set", m);
    }
    jsonInsert(m) {
      return this._jsonSet("json_insert", m);
    }
    jsonRemove(m) {
      const h = `json_remove(${f(
        m.column,
        this.builder,
        this.client,
        this.bindingsHolder
      )},${this.client.parameter(
        m.path,
        this.builder,
        this.bindingsHolder
      )})`;
      return m.alias ? this.client.alias(h, this.formatter.wrap(m.alias)) : h;
    }
    whereJsonPath(m) {
      return this._whereJsonPath("json_extract", m);
    }
    whereJsonSupersetOf(m) {
      throw new Error(
        "Json superset where clause not actually supported by SQLite"
      );
    }
    whereJsonSubsetOf(m) {
      throw new Error(
        "Json subset where clause not actually supported by SQLite"
      );
    }
    onJsonPathEquals(m) {
      return this._onJsonPathEquals("json_extract", m);
    }
  }
  return dp = l, dp;
}
var mp, E1;
function tae() {
  if (E1)
    return mp;
  E1 = 1;
  var t = Ui;
  function e(r, n) {
    var i;
    return t(r, function(a, s, o) {
      return i = n(a, s, o), !i;
    }), !!i;
  }
  return mp = e, mp;
}
var gp, S1;
function rae() {
  if (S1)
    return gp;
  S1 = 1;
  var t = JO(), e = Fr, r = tae(), n = at, i = Zc;
  function a(s, o, c) {
    var f = n(s) ? t : r;
    return c && i(s, o, c) && (o = void 0), f(s, e(o));
  }
  return gp = a, gp;
}
var vp, C1;
function nae() {
  if (C1)
    return vp;
  C1 = 1;
  const t = Hi, e = rae();
  class r extends t {
    constructor(i, a) {
      super(i, a);
    }
    // Compile the query to determine if a table exists.
    hasTable(i) {
      const a = `select * from sqlite_master where type = 'table' and name = ${this.client.parameter(
        this.formatter.wrap(i).replace(/`/g, ""),
        this.builder,
        this.bindingsHolder
      )}`;
      this.pushQuery({ sql: a, output: (s) => s.length > 0 });
    }
    // Compile the query to determine if a column exists.
    hasColumn(i, a) {
      this.pushQuery({
        sql: `PRAGMA table_info(${this.formatter.wrap(i)})`,
        output(s) {
          return e(s, (o) => this.client.wrapIdentifier(o.name.toLowerCase()) === this.client.wrapIdentifier(a.toLowerCase()));
        }
      });
    }
    // Compile a rename table command.
    renameTable(i, a) {
      this.pushQuery(
        `alter table ${this.formatter.wrap(i)} rename to ${this.formatter.wrap(
          a
        )}`
      );
    }
    async generateDdlCommands() {
      const i = this.builder._sequence;
      for (let s = 0, o = i.length; s < o; s++) {
        const c = i[s];
        this[c.method].apply(this, c.args);
      }
      const a = this.sequence;
      if (a.length === 1 && a[0].statementsProducer)
        return a[0].statementsProducer();
      {
        const s = [];
        for (const o of a) {
          const c = o.sql;
          Array.isArray(c) ? s.push(...c) : s.push(c);
        }
        return { pre: [], sql: s, check: null, post: [] };
      }
    }
  }
  return vp = r, vp;
}
var yp, T1;
function iae() {
  if (T1)
    return yp;
  T1 = 1;
  const t = Wn;
  class e extends t {
    constructor() {
      super(...arguments), this.modifiers = ["nullable", "defaultTo"], this._addCheckModifiers();
    }
    // Types
    // -------
    enu(n) {
      return `text check (${this.formatter.wrap(
        this.args[0]
      )} in ('${n.join("', '")}'))`;
    }
    _pushAlterCheckQuery(n, i) {
      throw new Error(
        "Alter table with to add constraints is not permitted in SQLite"
      );
    }
    checkRegex(n, i) {
      return this._check(
        `${this.formatter.wrap(
          this.getColumnName()
        )} REGEXP ${this.client._escapeBinding(n)}`,
        i
      );
    }
  }
  return e.prototype.json = "json", e.prototype.jsonb = "json", e.prototype.double = e.prototype.decimal = e.prototype.floating = "float", e.prototype.timestamp = "datetime", e.prototype.increments = e.prototype.bigincrements = "integer not null primary key autoincrement", yp = e, yp;
}
var bp, O1;
function aae() {
  if (O1)
    return bp;
  O1 = 1;
  var t = _v, e = VO, r = Fr, n = at;
  function i(a, s) {
    var o = n(a) ? t : e;
    return o(a, r(s));
  }
  return bp = i, bp;
}
var wp, A1;
function sae() {
  if (A1)
    return wp;
  A1 = 1;
  const t = aae(), e = hA, r = Wt, { isObject: n } = Je, i = Wi, { formatDefault: a } = Un;
  class s extends i {
    constructor() {
      super(...arguments);
    }
    // Create a new table.
    createQuery(c, f, u) {
      let p = (f ? "create table if not exists " : "create table ") + this.tableName();
      u && this.tableNameLike() ? p += " as select * from " + this.tableNameLike() + " where 0=1" : (p += " (" + c.sql.join(", "), p += this.foreignKeys() || "", p += this.primaryKeys() || "", p += this._addChecks(), p += ")"), this.pushQuery(p), u && this.addColumns(c, this.addColumnsPrefix);
    }
    addColumns(c, f, u) {
      if (f === this.alterColumnsPrefix) {
        const l = this, p = u.map((m) => {
          const h = this.client.customWrapIdentifier(
            m.getColumnName(),
            r,
            m.columnBuilder.queryContext()
          ), g = m.getColumnType(), v = m.modified.defaultTo ? a(m.modified.defaultTo[0], m.type, this.client) : null, d = m.modified.nullable && m.modified.nullable[0] === !1;
          return { name: h, type: g, defaultTo: v, notNull: d };
        });
        this.pushQuery({
          sql: `PRAGMA table_info(${this.tableName()})`,
          statementsProducer(m, h) {
            return l.client.ddl(l, m, h).alterColumn(p);
          }
        });
      } else
        for (let l = 0, p = c.sql.length; l < p; l++)
          this.pushQuery({
            sql: `alter table ${this.tableName()} add column ${c.sql[l]}`,
            bindings: c.bindings[l]
          });
    }
    // Compile a drop unique key command.
    dropUnique(c, f) {
      f = f ? this.formatter.wrap(f) : this._indexCommand("unique", this.tableNameRaw, c), this.pushQuery(`drop index ${f}`);
    }
    // Compile a drop foreign key command.
    dropForeign(c, f) {
      const u = this;
      c = Array.isArray(c) ? c : [c], c = c.map(
        (l) => this.client.customWrapIdentifier(l, r)
      ), f = this.client.customWrapIdentifier(f, r), this.pushQuery({
        sql: `PRAGMA table_info(${this.tableName()})`,
        output(l) {
          return u.client.ddl(u, l, this.connection).dropForeign(c, f);
        }
      });
    }
    // Compile a drop primary key command.
    dropPrimary(c) {
      const f = this;
      c = this.client.customWrapIdentifier(c, r), this.pushQuery({
        sql: `PRAGMA table_info(${this.tableName()})`,
        output(u) {
          return f.client.ddl(f, u, this.connection).dropPrimary(c);
        }
      });
    }
    dropIndex(c, f) {
      f = f ? this.formatter.wrap(f) : this._indexCommand("index", this.tableNameRaw, c), this.pushQuery(`drop index ${f}`);
    }
    // Compile a unique key command.
    unique(c, f) {
      let u, l;
      n(f) && ({ indexName: f, deferrable: u, predicate: l } = f), u && u !== "not deferrable" && this.client.logger.warn(
        `sqlite3: unique index \`${f}\` will not be deferrable ${u} because sqlite3 does not support deferred constraints.`
      ), f = f ? this.formatter.wrap(f) : this._indexCommand("unique", this.tableNameRaw, c), c = this.formatter.columnize(c);
      const p = l ? " " + this.client.queryCompiler(l).where() : "";
      this.pushQuery(
        `create unique index ${f} on ${this.tableName()} (${c})${p}`
      );
    }
    // Compile a plain index key command.
    index(c, f, u) {
      f = f ? this.formatter.wrap(f) : this._indexCommand("index", this.tableNameRaw, c), c = this.formatter.columnize(c);
      let l;
      n(u) && ({ predicate: l } = u);
      const p = l ? " " + this.client.queryCompiler(l).where() : "";
      this.pushQuery(
        `create index ${f} on ${this.tableName()} (${c})${p}`
      );
    }
    /**
     * Add a primary key to an existing table.
     *
     * @NOTE The `createQuery` method above handles table creation. Don't do anything regarding table
     *       creation in this method
     *
     * @param {string | string[]} columns - Column name(s) to assign as primary keys
     * @param {string} [constraintName] - Custom name for the PK constraint
     */
    primary(c, f) {
      const u = this;
      c = Array.isArray(c) ? c : [c], c = c.map(
        (p) => this.client.customWrapIdentifier(p, r)
      );
      let l;
      n(f) && ({ constraintName: f, deferrable: l } = f), l && l !== "not deferrable" && this.client.logger.warn(
        `sqlite3: primary key constraint \`${f}\` will not be deferrable ${l} because sqlite3 does not support deferred constraints.`
      ), f = this.client.customWrapIdentifier(f, r), this.method !== "create" && this.method !== "createIfNot" && this.pushQuery({
        sql: `PRAGMA table_info(${this.tableName()})`,
        output(p) {
          return u.client.ddl(u, p, this.connection).primary(c, f);
        }
      });
    }
    /**
     * Add a foreign key constraint to an existing table
     *
     * @NOTE The `createQuery` method above handles foreign key constraints on table creation. Don't do
     *       anything regarding table creation in this method
     *
     * @param {object} foreignInfo - Information about the current column foreign setup
     * @param {string | string[]} [foreignInfo.column] - Column in the current constraint
     * @param {string | undefined} foreignInfo.keyName - Name of the foreign key constraint
     * @param {string | string[]} foreignInfo.references - What column it references in the other table
     * @param {string} foreignInfo.inTable - What table is referenced in this constraint
     * @param {string} [foreignInfo.onUpdate] - What to do on updates
     * @param {string} [foreignInfo.onDelete] - What to do on deletions
     */
    foreign(c) {
      const f = this;
      this.method !== "create" && this.method !== "createIfNot" && (c.column = Array.isArray(c.column) ? c.column : [c.column], c.column = c.column.map(
        (u) => this.client.customWrapIdentifier(u, r)
      ), c.inTable = this.client.customWrapIdentifier(
        c.inTable,
        r
      ), c.references = Array.isArray(c.references) ? c.references : [c.references], c.references = c.references.map(
        (u) => this.client.customWrapIdentifier(u, r)
      ), this.pushQuery({
        sql: `PRAGMA table_info(${this.tableName()})`,
        statementsProducer(u, l) {
          return f.client.ddl(f, u, l).foreign(c);
        }
      }));
    }
    primaryKeys() {
      const c = t(this.grouped.alterTable || [], { method: "primary" });
      if (c.length > 0 && c[0].args.length > 0) {
        const f = c[0].args[0];
        let u = c[0].args[1] || "";
        u && (u = " constraint " + this.formatter.wrap(u));
        const l = this.grouped.columns.filter((p) => p.builder._type === "increments").length > 0;
        return `,${u} ${l ? "unique" : "primary key"} (${this.formatter.columnize(f)})`;
      }
    }
    foreignKeys() {
      let c = "";
      const f = t(this.grouped.alterTable || [], {
        method: "foreign"
      });
      for (let u = 0, l = f.length; u < l; u++) {
        const p = f[u].args[0], m = this.formatter.columnize(p.column), h = this.formatter.columnize(p.references), g = this.formatter.wrap(p.inTable);
        let v = p.keyName || "";
        v && (v = " constraint " + this.formatter.wrap(v)), c += `,${v} foreign key(${m}) references ${g}(${h})`, p.onDelete && (c += ` on delete ${p.onDelete}`), p.onUpdate && (c += ` on update ${p.onUpdate}`);
      }
      return c;
    }
    createTableBlock() {
      return this.getColumns().concat().join(",");
    }
    renameColumn(c, f) {
      this.pushQuery({
        sql: `alter table ${this.tableName()} rename ${this.formatter.wrap(
          c
        )} to ${this.formatter.wrap(f)}`
      });
    }
    _setNullableState(c, f) {
      const u = this;
      this.pushQuery({
        sql: `PRAGMA table_info(${this.tableName()})`,
        statementsProducer(l, p) {
          return u.client.ddl(u, l, p).setNullable(c, f);
        }
      });
    }
    dropColumn() {
      const c = this, u = e(arguments).map(
        (l) => this.client.customWrapIdentifier(l, r)
      );
      this.pushQuery({
        sql: `PRAGMA table_info(${this.tableName()})`,
        output(l) {
          return c.client.ddl(c, l, this.connection).dropColumn(u);
        }
      });
    }
  }
  return wp = s, wp;
}
var xp, $1;
function oae() {
  if ($1)
    return xp;
  $1 = 1;
  const t = Gi, {
    columnize: e
  } = xt;
  class r extends t {
    constructor(i, a) {
      super(i, a);
    }
    createOrReplace() {
      const i = this.columns, a = this.selectQuery.toString(), s = this.viewName(), o = i ? " (" + e(
        i,
        this.viewBuilder,
        this.client,
        this.bindingsHolder
      ) + ")" : "", c = `drop view if exists ${s}`, f = `create view ${s}${o} as ${a}`;
      this.pushQuery({
        sql: c
      }), this.pushQuery({
        sql: f
      });
    }
  }
  return xp = r, xp;
}
var _p, I1;
function cae() {
  if (I1)
    return _p;
  I1 = 1;
  function t(o, c, f) {
    return `INSERT INTO "${c}" SELECT ${f === void 0 ? "*" : f.map((u) => `"${u}"`).join(", ")} FROM "${o}";`;
  }
  function e(o) {
    return `DROP TABLE "${o}"`;
  }
  function r(o, c) {
    return `ALTER TABLE "${o}" RENAME TO "${c}"`;
  }
  function n(o) {
    return `SELECT type, sql FROM sqlite_master WHERE (type='table' OR (type='index' AND sql IS NOT NULL)) AND tbl_name='${o}'`;
  }
  function i() {
    return "PRAGMA foreign_keys";
  }
  function a(o) {
    return `PRAGMA foreign_keys = ${o ? "ON" : "OFF"}`;
  }
  function s() {
    return "PRAGMA foreign_key_check";
  }
  return _p = {
    copyData: t,
    dropOriginal: e,
    renameTable: r,
    getTableSql: n,
    isForeignCheckEnabled: i,
    setForeignCheck: a,
    executeForeignCheck: s
  }, _p;
}
var Ep, k1;
function uae() {
  if (k1)
    return Ep;
  k1 = 1;
  function t(e, r) {
    const n = new RegExp(
      Object.entries(r).map(([s, o]) => `(?<${s}>${o.source})`).join("|"),
      "yi"
    );
    let i = 0;
    const a = [];
    for (; i < e.length; ) {
      n.lastIndex = i;
      const s = e.match(n);
      if (s !== null) {
        const [o, c] = Object.entries(s.groups).find(
          ([f, u]) => u !== void 0
        );
        i += c.length, o.startsWith("_") || a.push({ type: o, text: c });
      } else
        throw new Error(
          `No matching tokenizer rule found at: [${e.substring(i)}]`
        );
    }
    return a;
  }
  return Ep = {
    tokenize: t
  }, Ep;
}
var Sp, R1;
function lae() {
  if (R1)
    return Sp;
  R1 = 1;
  function t(f, u = (l) => l) {
    return function({ index: l = 0, input: p }) {
      let m = l;
      const h = [];
      for (const g of f) {
        const v = g({ index: m, input: p });
        if (v.success)
          m = v.index, h.push(v.ast);
        else
          return v;
      }
      return { success: !0, ast: u(h), index: m, input: p };
    };
  }
  function e(f, u = (l) => l) {
    return function({ index: l = 0, input: p }) {
      for (const m of f) {
        const h = m({ index: l, input: p });
        if (h.success)
          return {
            success: !0,
            ast: u(h.ast),
            index: h.index,
            input: p
          };
      }
      return { success: !1, ast: null, index: l, input: p };
    };
  }
  function r(f, u = (l) => l) {
    return function({ index: l = 0, input: p }) {
      let m = {}, h = l;
      const g = [];
      do
        m = f({ index: h, input: p }), m.success && (h = m.index, g.push(m.ast));
      while (m.success);
      return g.length > 0 ? { success: !0, ast: u(g), index: h, input: p } : { success: !1, ast: null, index: h, input: p };
    };
  }
  function n(f, u = (l) => l) {
    return function({ index: l = 0, input: p }) {
      const m = f({ index: l, input: p });
      return m.success ? {
        success: !0,
        ast: u(m.ast),
        index: m.index,
        input: p
      } : { success: !0, ast: u(null), index: l, input: p };
    };
  }
  function i(f, u = (l) => l) {
    return function({ index: l = 0, input: p }) {
      const m = f.do({ index: l, input: p });
      return m.success && f.next({ index: m.index, input: p }).success ? {
        success: !0,
        ast: u(m.ast),
        index: m.index,
        input: p
      } : { success: !1, ast: null, index: l, input: p };
    };
  }
  function a(f, u = (l) => l) {
    return function({ index: l = 0, input: p }) {
      const m = f.do({ index: l, input: p });
      return m.success && !f.not({ index: l, input: p }).success ? {
        success: !0,
        ast: u(m.ast),
        index: m.index,
        input: p
      } : { success: !1, ast: null, index: l, input: p };
    };
  }
  function s(f, u = (l) => l.text) {
    return function({ index: l = 0, input: p }) {
      const m = p[l];
      return m !== void 0 && (f.type === void 0 || f.type === m.type) && (f.text === void 0 || f.text.toUpperCase() === m.text.toUpperCase()) ? {
        success: !0,
        ast: u(m),
        index: l + 1,
        input: p
      } : { success: !1, ast: null, index: l, input: p };
    };
  }
  return Sp = { s: t, a: e, m: r, o: n, l: i, n: a, t: s, e: function({ index: f = 0, input: u }) {
    return { success: !0, ast: null, index: f, input: u };
  }, f: function({ index: f = 0, input: u }) {
    return { success: f === u.length, ast: null, index: f, input: u };
  } }, Sp;
}
var Cp, N1;
function pae() {
  if (N1)
    return Cp;
  N1 = 1;
  const { tokenize: t } = uae(), { s: e, a: r, m: n, o: i, l: a, n: s, t: o, e: c, f } = lae(), u = {
    keyword: /(?:ABORT|ACTION|ADD|AFTER|ALL|ALTER|ALWAYS|ANALYZE|AND|AS|ASC|ATTACH|AUTOINCREMENT|BEFORE|BEGIN|BETWEEN|BY|CASCADE|CASE|CAST|CHECK|COLLATE|COLUMN|COMMIT|CONFLICT|CONSTRAINT|CREATE|CROSS|CURRENT|CURRENT_DATE|CURRENT_TIME|CURRENT_TIMESTAMP|DATABASE|DEFAULT|DEFERRED|DEFERRABLE|DELETE|DESC|DETACH|DISTINCT|DO|DROP|END|EACH|ELSE|ESCAPE|EXCEPT|EXCLUSIVE|EXCLUDE|EXISTS|EXPLAIN|FAIL|FILTER|FIRST|FOLLOWING|FOR|FOREIGN|FROM|FULL|GENERATED|GLOB|GROUP|GROUPS|HAVING|IF|IGNORE|IMMEDIATE|IN|INDEX|INDEXED|INITIALLY|INNER|INSERT|INSTEAD|INTERSECT|INTO|IS|ISNULL|JOIN|KEY|LAST|LEFT|LIKE|LIMIT|MATCH|MATERIALIZED|NATURAL|NO|NOT|NOTHING|NOTNULL|NULL|NULLS|OF|OFFSET|ON|OR|ORDER|OTHERS|OUTER|OVER|PARTITION|PLAN|PRAGMA|PRECEDING|PRIMARY|QUERY|RAISE|RANGE|RECURSIVE|REFERENCES|REGEXP|REINDEX|RELEASE|RENAME|REPLACE|RESTRICT|RETURNING|RIGHT|ROLLBACK|ROW|ROWS|SAVEPOINT|SELECT|SET|TABLE|TEMP|TEMPORARY|THEN|TIES|TO|TRANSACTION|TRIGGER|UNBOUNDED|UNION|UNIQUE|UPDATE|USING|VACUUM|VALUES|VIEW|VIRTUAL|WHEN|WHERE|WINDOW|WITH|WITHOUT)(?=\s+|-|\(|\)|;|\+|\*|\/|%|==|=|<=|<>|<<|<|>=|>>|>|!=|,|&|~|\|\||\||\.)/,
    id: /"[^"]*(?:""[^"]*)*"|`[^`]*(?:``[^`]*)*`|\[[^[\]]*\]|[a-z_][a-z0-9_$]*/,
    string: /'[^']*(?:''[^']*)*'/,
    blob: /x'(?:[0-9a-f][0-9a-f])+'/,
    numeric: /(?:\d+(?:\.\d*)?|\.\d+)(?:e(?:\+|-)?\d+)?|0x[0-9a-f]+/,
    variable: /\?\d*|[@$:][a-z0-9_$]+/,
    operator: /-|\(|\)|;|\+|\*|\/|%|==|=|<=|<>|<<|<|>=|>>|>|!=|,|&|~|\|\||\||\./,
    _ws: /\s+/
  };
  function l(le) {
    const W = m({ input: t(le, u) });
    if (!W.success)
      throw new Error(
        `Parsing CREATE TABLE failed at [${W.input.slice(W.index).map((Se) => Se.text).join(" ")}] of "${le}"`
      );
    return W.ast;
  }
  function p(le) {
    const W = G({ input: t(le, u) });
    if (!W.success)
      throw new Error(
        `Parsing CREATE INDEX failed at [${W.input.slice(W.index).map((Se) => Se.text).join(" ")}] of "${le}"`
      );
    return W.ast;
  }
  function m(le) {
    return e(
      [
        o({ text: "CREATE" }, (W) => null),
        h,
        o({ text: "TABLE" }, (W) => null),
        M,
        Z,
        re,
        o({ text: "(" }, (W) => null),
        v,
        V,
        o({ text: ")" }, (W) => null),
        g,
        f
      ],
      (W) => Object.assign({}, ...W.filter((Se) => Se !== null))
    )(le);
  }
  function h(le) {
    return r([o({ text: "TEMP" }), o({ text: "TEMPORARY" }), c], (W) => ({
      temporary: W !== null
    }))(le);
  }
  function g(le) {
    return i(e([o({ text: "WITHOUT" }), o({ text: "ROWID" })]), (W) => ({
      rowid: W !== null
    }))(le);
  }
  function v(le) {
    return r([
      e([d, o({ text: "," }), v], (W) => ({
        columns: [W[0]].concat(W[2].columns)
      })),
      e([d], (W) => ({ columns: [W[0]] }))
    ])(le);
  }
  function d(le) {
    return e(
      [e([ye], (W) => ({ name: W[0] })), y, x],
      (W) => Object.assign({}, ...W)
    )(le);
  }
  function y(le) {
    return i(
      e(
        [
          n(o({ type: "id" })),
          r([
            e(
              [
                o({ text: "(" }),
                Ce,
                o({ text: "," }),
                Ce,
                o({ text: ")" })
              ],
              (W) => `(${W[1]}, ${W[3]})`
            ),
            e(
              [o({ text: "(" }), Ce, o({ text: ")" })],
              (W) => `(${W[1]})`
            ),
            c
          ])
        ],
        (W) => `${W[0].join(" ")}${W[1] || ""}`
      ),
      (W) => ({ type: W })
    )(le);
  }
  function x(le) {
    return i(n(b), (W) => ({
      constraints: Object.assign(
        {
          primary: null,
          notnull: null,
          null: null,
          unique: null,
          check: null,
          default: null,
          collate: null,
          references: null,
          as: null
        },
        ...W || []
      )
    }))(le);
  }
  function b(le) {
    return r([
      w,
      T,
      E,
      C,
      A,
      R,
      D,
      F,
      K
    ])(le);
  }
  function w(le) {
    return e(
      [
        z,
        o({ text: "PRIMARY" }, (W) => null),
        o({ text: "KEY" }, (W) => null),
        pe,
        P,
        S
      ],
      (W) => ({ primary: Object.assign({}, ...W.filter((Se) => Se !== null)) })
    )(le);
  }
  function S(le) {
    return i(o({ text: "AUTOINCREMENT" }), (W) => ({
      autoincrement: W !== null
    }))(le);
  }
  function T(le) {
    return e(
      [
        z,
        o({ text: "NOT" }, (W) => null),
        o({ text: "NULL" }, (W) => null),
        P
      ],
      (W) => ({ notnull: Object.assign({}, ...W.filter((Se) => Se !== null)) })
    )(le);
  }
  function E(le) {
    return e(
      [z, o({ text: "NULL" }, (W) => null), P],
      (W) => ({ null: Object.assign({}, ...W.filter((Se) => Se !== null)) })
    )(le);
  }
  function C(le) {
    return e(
      [z, o({ text: "UNIQUE" }, (W) => null), P],
      (W) => ({ unique: Object.assign({}, ...W.filter((Se) => Se !== null)) })
    )(le);
  }
  function A(le) {
    return e(
      [
        z,
        o({ text: "CHECK" }, (W) => null),
        o({ text: "(" }, (W) => null),
        e([be], (W) => ({ expression: W[0] })),
        o({ text: ")" }, (W) => null)
      ],
      (W) => ({ check: Object.assign({}, ...W.filter((Se) => Se !== null)) })
    )(le);
  }
  function R(le) {
    return e(
      [
        z,
        o({ text: "DEFAULT" }, (W) => null),
        r([
          e([o({ text: "(" }), be, o({ text: ")" })], (W) => ({
            value: W[1],
            expression: !0
          })),
          e([$e], (W) => ({ value: W[0], expression: !1 })),
          e([Ce], (W) => ({ value: W[0], expression: !1 }))
        ])
      ],
      (W) => ({ default: Object.assign({}, ...W.filter((Se) => Se !== null)) })
    )(le);
  }
  function D(le) {
    return e(
      [
        z,
        o({ text: "COLLATE" }, (W) => null),
        o({ type: "id" }, (W) => ({ collation: W.text }))
      ],
      (W) => ({ collate: Object.assign({}, ...W.filter((Se) => Se !== null)) })
    )(le);
  }
  function F(le) {
    return e(
      [z, e([Y], (W) => W[0].references)],
      (W) => ({
        references: Object.assign({}, ...W.filter((Se) => Se !== null))
      })
    )(le);
  }
  function K(le) {
    return e(
      [
        z,
        i(e([o({ text: "GENERATED" }), o({ text: "ALWAYS" })]), (W) => ({
          generated: W !== null
        })),
        o({ text: "AS" }, (W) => null),
        o({ text: "(" }, (W) => null),
        e([be], (W) => ({ expression: W[0] })),
        o({ text: ")" }, (W) => null),
        r([o({ text: "STORED" }), o({ text: "VIRTUAL" }), c], (W) => ({
          mode: W ? W.toUpperCase() : null
        }))
      ],
      (W) => ({ as: Object.assign({}, ...W.filter((Se) => Se !== null)) })
    )(le);
  }
  function V(le) {
    return i(n(e([o({ text: "," }), ne], (W) => W[1])), (W) => ({
      constraints: W || []
    }))(le);
  }
  function ne(le) {
    return r([
      $,
      L,
      H,
      Q
    ])(le);
  }
  function $(le) {
    return e(
      [
        z,
        o({ text: "PRIMARY" }, (W) => null),
        o({ text: "KEY" }, (W) => null),
        o({ text: "(" }, (W) => null),
        k,
        o({ text: ")" }, (W) => null),
        P
      ],
      (W) => Object.assign({ type: "PRIMARY KEY" }, ...W.filter((Se) => Se !== null))
    )(le);
  }
  function L(le) {
    return e(
      [
        z,
        o({ text: "UNIQUE" }, (W) => null),
        o({ text: "(" }, (W) => null),
        k,
        o({ text: ")" }, (W) => null),
        P
      ],
      (W) => Object.assign({ type: "UNIQUE" }, ...W.filter((Se) => Se !== null))
    )(le);
  }
  function P(le) {
    return i(
      e(
        [
          o({ text: "ON" }),
          o({ text: "CONFLICT" }),
          r([
            o({ text: "ROLLBACK" }),
            o({ text: "ABORT" }),
            o({ text: "FAIL" }),
            o({ text: "IGNORE" }),
            o({ text: "REPLACE" })
          ])
        ],
        (W) => W[2]
      ),
      (W) => ({ conflict: W ? W.toUpperCase() : null })
    )(le);
  }
  function H(le) {
    return e(
      [
        z,
        o({ text: "CHECK" }, (W) => null),
        o({ text: "(" }, (W) => null),
        e([be], (W) => ({ expression: W[0] })),
        o({ text: ")" }, (W) => null)
      ],
      (W) => Object.assign({ type: "CHECK" }, ...W.filter((Se) => Se !== null))
    )(le);
  }
  function Q(le) {
    return e(
      [
        z,
        o({ text: "FOREIGN" }, (W) => null),
        o({ text: "KEY" }, (W) => null),
        o({ text: "(" }, (W) => null),
        ue,
        o({ text: ")" }, (W) => null),
        Y
      ],
      (W) => Object.assign({ type: "FOREIGN KEY" }, ...W.filter((Se) => Se !== null))
    )(le);
  }
  function Y(le) {
    return e(
      [
        o({ text: "REFERENCES" }, (W) => null),
        re,
        ce,
        i(
          n(r([me, J, O])),
          (W) => Object.assign({ delete: null, update: null, match: null }, ...W || [])
        ),
        I
      ],
      (W) => ({ references: Object.assign({}, ...W.filter((Se) => Se !== null)) })
    )(le);
  }
  function ce(le) {
    return i(
      e([o({ text: "(" }), ue, o({ text: ")" })], (W) => W[1]),
      (W) => ({ columns: W ? W.columns : [] })
    )(le);
  }
  function ue(le) {
    return e(
      [
        i(
          n(e([ye, o({ text: "," })], (W) => W[0])),
          (W) => W !== null ? W : []
        ),
        ye
      ],
      (W) => ({ columns: W[0].concat([W[1]]) })
    )(le);
  }
  function me(le) {
    return e([o({ text: "ON" }), o({ text: "DELETE" }), Ee], (W) => ({
      delete: W[2]
    }))(le);
  }
  function J(le) {
    return e([o({ text: "ON" }), o({ text: "UPDATE" }), Ee], (W) => ({
      update: W[2]
    }))(le);
  }
  function O(le) {
    return e(
      [o({ text: "MATCH" }), r([o({ type: "keyword" }), o({ type: "id" })])],
      (W) => ({ match: W[1] })
    )(le);
  }
  function I(le) {
    return i(
      e([
        i(o({ text: "NOT" })),
        o({ text: "DEFERRABLE" }),
        i(
          e(
            [
              o({ text: "INITIALLY" }),
              r([o({ text: "DEFERRED" }), o({ text: "IMMEDIATE" })])
            ],
            (W) => W[1].toUpperCase()
          )
        )
      ]),
      (W) => ({ deferrable: W ? { not: W[0] !== null, initially: W[2] } : null })
    )(le);
  }
  function z(le) {
    return i(
      e([o({ text: "CONSTRAINT" }), ye], (W) => W[1]),
      (W) => ({ name: W })
    )(le);
  }
  function G(le) {
    return e(
      [
        o({ text: "CREATE" }, (W) => null),
        q,
        o({ text: "INDEX" }, (W) => null),
        M,
        Z,
        B,
        o({ text: "ON" }, (W) => null),
        re,
        o({ text: "(" }, (W) => null),
        k,
        o({ text: ")" }, (W) => null),
        j,
        f
      ],
      (W) => Object.assign({}, ...W.filter((Se) => Se !== null))
    )(le);
  }
  function q(le) {
    return i(o({ text: "UNIQUE" }), (W) => ({ unique: W !== null }))(le);
  }
  function M(le) {
    return i(
      e([o({ text: "IF" }), o({ text: "NOT" }), o({ text: "EXISTS" })]),
      (W) => ({ exists: W !== null })
    )(le);
  }
  function Z(le) {
    return i(
      e([ye, o({ text: "." })], (W) => W[0]),
      (W) => ({ schema: W })
    )(le);
  }
  function B(le) {
    return e([ye], (W) => ({ index: W[0] }))(le);
  }
  function re(le) {
    return e([ye], (W) => ({ table: W[0] }))(le);
  }
  function j(le) {
    return i(
      e([o({ text: "WHERE" }), be], (W) => W[1]),
      (W) => ({ where: W })
    )(le);
  }
  function k(le) {
    return r([
      e([N, o({ text: "," }), k], (W) => ({
        columns: [W[0]].concat(W[2].columns)
      })),
      e([U, o({ text: "," }), k], (W) => ({
        columns: [W[0]].concat(W[2].columns)
      })),
      a({ do: N, next: o({ text: ")" }) }, (W) => ({
        columns: [W]
      })),
      a({ do: U, next: o({ text: ")" }) }, (W) => ({
        columns: [W]
      }))
    ])(le);
  }
  function N(le) {
    return e(
      [
        e([ye], (W) => ({ name: W[0], expression: !1 })),
        ee,
        pe
      ],
      (W) => Object.assign({}, ...W.filter((Se) => Se !== null))
    )(le);
  }
  function U(le) {
    return e(
      [
        e([he], (W) => ({ name: W[0], expression: !0 })),
        ee,
        pe
      ],
      (W) => Object.assign({}, ...W.filter((Se) => Se !== null))
    )(le);
  }
  function ee(le) {
    return i(
      e([o({ text: "COLLATE" }), o({ type: "id" })], (W) => W[1]),
      (W) => ({ collation: W })
    )(le);
  }
  function pe(le) {
    return r([o({ text: "ASC" }), o({ text: "DESC" }), c], (W) => ({
      order: W ? W.toUpperCase() : null
    }))(le);
  }
  function he(le) {
    return n(
      r([
        s({
          do: o({ type: "keyword" }),
          not: r([
            o({ text: "COLLATE" }),
            o({ text: "ASC" }),
            o({ text: "DESC" })
          ])
        }),
        o({ type: "id" }),
        o({ type: "string" }),
        o({ type: "blob" }),
        o({ type: "numeric" }),
        o({ type: "variable" }),
        s({
          do: o({ type: "operator" }),
          not: r([o({ text: "(" }), o({ text: ")" }), o({ text: "," })])
        }),
        e([o({ text: "(" }), i(be), o({ text: ")" })], (W) => W[1] || [])
      ])
    )(le);
  }
  function be(le) {
    return n(
      r([
        o({ type: "keyword" }),
        o({ type: "id" }),
        o({ type: "string" }),
        o({ type: "blob" }),
        o({ type: "numeric" }),
        o({ type: "variable" }),
        s({
          do: o({ type: "operator" }),
          not: r([o({ text: "(" }), o({ text: ")" })])
        }),
        e([o({ text: "(" }), i(be), o({ text: ")" })], (W) => W[1] || [])
      ])
    )(le);
  }
  function ye(le) {
    return r(
      [o({ type: "id" }), o({ type: "string" })],
      (W) => /^["`['][^]*["`\]']$/.test(W) ? W.substring(1, W.length - 1) : W
    )(le);
  }
  function Ee(le) {
    return r(
      [
        e([o({ text: "SET" }), o({ text: "NULL" })], (W) => `${W[0]} ${W[1]}`),
        e([o({ text: "SET" }), o({ text: "DEFAULT" })], (W) => `${W[0]} ${W[1]}`),
        o({ text: "CASCADE" }),
        o({ text: "RESTRICT" }),
        e([o({ text: "NO" }), o({ text: "ACTION" })], (W) => `${W[0]} ${W[1]}`)
      ],
      (W) => W.toUpperCase()
    )(le);
  }
  function $e(le) {
    return r([
      o({ type: "numeric" }),
      o({ type: "string" }),
      o({ type: "id" }),
      o({ type: "blob" }),
      o({ text: "NULL" }),
      o({ text: "TRUE" }),
      o({ text: "FALSE" }),
      o({ text: "CURRENT_TIME" }),
      o({ text: "CURRENT_DATE" }),
      o({ text: "CURRENT_TIMESTAMP" })
    ])(le);
  }
  function Ce(le) {
    return e(
      [r([o({ text: "+" }), o({ text: "-" }), c]), o({ type: "numeric" })],
      (W) => `${W[0] || ""}${W[1]}`
    )(le);
  }
  return Cp = {
    parseCreateTable: l,
    parseCreateIndex: p
  }, Cp;
}
var Tp, L1;
function fae() {
  if (L1)
    return Tp;
  L1 = 1;
  function t(B, re = (j) => j) {
    return r(B, re);
  }
  function e(B, re = (j) => j) {
    return P(B, re);
  }
  function r(B, re) {
    return `CREATE${n(B)} TABLE${Q(B)} ${Y(
      B,
      re
    )}${ue(B, re)} (${a(
      B,
      re
    )}${x(B, re)})${i(B)}`;
  }
  function n(B, re) {
    return B.temporary ? " TEMP" : "";
  }
  function i(B, re) {
    return B.rowid ? " WITHOUT ROWID" : "";
  }
  function a(B, re) {
    return B.columns.map((j) => s(j, re)).join(", ");
  }
  function s(B, re) {
    return `${Z(B.name, re)}${o(
      B
    )}${c(B.constraints, re)}`;
  }
  function o(B, re) {
    return B.type !== null ? ` ${B.type}` : "";
  }
  function c(B, re) {
    return `${f(B, re)}${l(
      B,
      re
    )}${p(B, re)}${m(
      B,
      re
    )}${h(B, re)}${g(
      B,
      re
    )}${v(B, re)}${d(
      B,
      re
    )}${y(B, re)}`;
  }
  function f(B, re) {
    return B.primary !== null ? ` ${L(B.primary, re)}PRIMARY KEY${G(
      B.primary
    )}${T(B.primary)}${u(B.primary)}` : "";
  }
  function u(B, re) {
    return B.autoincrement ? " AUTOINCREMENT" : "";
  }
  function l(B, re) {
    return B.notnull !== null ? ` ${L(B.notnull, re)}NOT NULL${T(
      B.notnull
    )}` : "";
  }
  function p(B, re) {
    return B.null !== null ? ` ${L(B.null, re)}NULL${T(B.null)}` : "";
  }
  function m(B, re) {
    return B.unique !== null ? ` ${L(B.unique, re)}UNIQUE${T(
      B.unique
    )}` : "";
  }
  function h(B, re) {
    return B.check !== null ? ` ${L(B.check, re)}CHECK (${M(
      B.check.expression
    )})` : "";
  }
  function g(B, re) {
    return B.default !== null ? ` ${L(B.default, re)}DEFAULT ${B.default.expression ? `(${M(B.default.value)})` : B.default.value}` : "";
  }
  function v(B, re) {
    return B.collate !== null ? ` ${L(B.collate, re)}COLLATE ${B.collate.collation}` : "";
  }
  function d(B, re) {
    return B.references !== null ? ` ${L(B.references, re)}${A(
      B.references,
      re
    )}` : "";
  }
  function y(B, re) {
    return B.as !== null ? ` ${L(B.as, re)}${B.as.generated ? "GENERATED ALWAYS " : ""}AS (${M(B.as.expression)})${B.as.mode !== null ? ` ${B.as.mode}` : ""}` : "";
  }
  function x(B, re) {
    return B.constraints.reduce(
      (j, k) => `${j}, ${b(k, re)}`,
      ""
    );
  }
  function b(B, re) {
    switch (B.type) {
      case "PRIMARY KEY":
        return w(B, re);
      case "UNIQUE":
        return S(B, re);
      case "CHECK":
        return E(B, re);
      case "FOREIGN KEY":
        return C(B, re);
    }
  }
  function w(B, re) {
    return `${L(B, re)}PRIMARY KEY (${J(
      B,
      re
    )})${T(B)}`;
  }
  function S(B, re) {
    return `${L(B, re)}UNIQUE (${J(
      B,
      re
    )})${T(B)}`;
  }
  function T(B, re) {
    return B.conflict !== null ? ` ON CONFLICT ${B.conflict}` : "";
  }
  function E(B, re) {
    return `${L(B, re)}CHECK (${M(
      B.expression
    )})`;
  }
  function C(B, re) {
    return `${L(B, re)}FOREIGN KEY (${D(
      B,
      re
    )}) ${A(B.references, re)}`;
  }
  function A(B, re) {
    return `REFERENCES ${ue(B, re)}${R(
      B,
      re
    )}${F(B)}${$(B.deferrable)}`;
  }
  function R(B, re) {
    return B.columns.length > 0 ? ` (${D(B, re)})` : "";
  }
  function D(B, re) {
    return B.columns.map((j) => Z(j, re)).join(", ");
  }
  function F(B, re) {
    return `${K(B)}${V(
      B
    )}${ne(B)}`;
  }
  function K(B, re) {
    return B.delete !== null ? ` ON DELETE ${B.delete}` : "";
  }
  function V(B, re) {
    return B.update !== null ? ` ON UPDATE ${B.update}` : "";
  }
  function ne(B, re) {
    return B.match !== null ? ` MATCH ${B.match}` : "";
  }
  function $(B, re) {
    return B !== null ? ` ${B.not ? "NOT " : ""}DEFERRABLE${B.initially !== null ? ` INITIALLY ${B.initially}` : ""}` : "";
  }
  function L(B, re) {
    return B.name !== null ? `CONSTRAINT ${Z(B.name, re)} ` : "";
  }
  function P(B, re) {
    return `CREATE${H(B)} INDEX${Q(B)} ${Y(
      B,
      re
    )}${ce(B, re)} on ${ue(B, re)} (${J(
      B,
      re
    )})${me(B)}`;
  }
  function H(B, re) {
    return B.unique ? " UNIQUE" : "";
  }
  function Q(B, re) {
    return B.exists ? " IF NOT EXISTS" : "";
  }
  function Y(B, re) {
    return B.schema !== null ? `${Z(B.schema, re)}.` : "";
  }
  function ce(B, re) {
    return Z(B.index, re);
  }
  function ue(B, re) {
    return Z(B.table, re);
  }
  function me(B, re) {
    return B.where !== null ? ` where ${M(B.where)}` : "";
  }
  function J(B, re) {
    return B.columns.map(
      (j) => j.expression ? I(j) : O(j, re)
    ).join(", ");
  }
  function O(B, re) {
    return `${Z(B.name, re)}${z(B)}${G(
      B
    )}`;
  }
  function I(B, re) {
    return `${q(B.name)}${z(B)}${G(
      B
    )}`;
  }
  function z(B, re) {
    return B.collation !== null ? ` COLLATE ${B.collation}` : "";
  }
  function G(B, re) {
    return B.order !== null ? ` ${B.order}` : "";
  }
  function q(B, re) {
    return M(B);
  }
  function M(B, re) {
    return B.reduce(
      (j, k) => Array.isArray(k) ? `${j}(${M(k)})` : j ? `${j} ${k}` : k,
      ""
    );
  }
  function Z(B, re) {
    return re(B);
  }
  return Tp = {
    compileCreateTable: t,
    compileCreateIndex: e
  }, Tp;
}
var Op, P1;
function hae() {
  if (P1)
    return Op;
  P1 = 1;
  function t(r, n) {
    return r.toLowerCase() === n.toLowerCase();
  }
  function e(r, n) {
    return r.some((i) => t(i, n));
  }
  return Op = {
    isEqualId: t,
    includesId: e
  }, Op;
}
var Ap, D1;
function dae() {
  if (D1)
    return Ap;
  D1 = 1;
  const t = Wt, { nanonum: e } = Dv, {
    copyData: r,
    dropOriginal: n,
    renameTable: i,
    getTableSql: a,
    isForeignCheckEnabled: s,
    setForeignCheck: o,
    executeForeignCheck: c
  } = cae(), { parseCreateTable: f, parseCreateIndex: u } = pae(), {
    compileCreateTable: l,
    compileCreateIndex: p
  } = fae(), { isEqualId: m, includesId: h } = hae();
  class g {
    constructor(d, y, x, b) {
      this.client = d, this.tableCompiler = y, this.pragma = x, this.tableNameRaw = this.tableCompiler.tableNameRaw, this.alteredName = `_knex_temp_alter${e(3)}`, this.connection = b, this.formatter = (w) => this.client.customWrapIdentifier(w, t), this.wrap = (w) => this.client.wrapIdentifierImpl(w);
    }
    tableName() {
      return this.formatter(this.tableNameRaw);
    }
    getTableSql() {
      const d = this.tableName();
      return this.client.transaction(
        async (y) => {
          y.disableProcessing();
          const x = await y.raw(a(d));
          return y.enableProcessing(), {
            createTable: x.filter((b) => b.type === "table")[0].sql,
            createIndices: x.filter((b) => b.type === "index").map((b) => b.sql)
          };
        },
        { connection: this.connection }
      );
    }
    async isForeignCheckEnabled() {
      return (await this.client.raw(s()).connection(this.connection))[0].foreign_keys === 1;
    }
    async setForeignCheck(d) {
      await this.client.raw(o(d)).connection(this.connection);
    }
    renameTable(d) {
      return d.raw(i(this.alteredName, this.tableName()));
    }
    dropOriginal(d) {
      return d.raw(n(this.tableName()));
    }
    copyData(d, y) {
      return d.raw(r(this.tableName(), this.alteredName, y));
    }
    async alterColumn(d) {
      const { createTable: y, createIndices: x } = await this.getTableSql(), b = f(y);
      b.table = this.alteredName, b.columns = b.columns.map((S) => {
        const T = d.find((E) => m(E.name, S.name));
        return T && (S.type = T.type, S.constraints.default = T.defaultTo !== null ? {
          name: null,
          value: T.defaultTo,
          expression: !1
        } : null, S.constraints.notnull = T.notNull ? { name: null, conflict: null } : null, S.constraints.null = T.notNull ? null : S.constraints.null), S;
      });
      const w = l(b, this.wrap);
      return this.generateAlterCommands(w, x);
    }
    async dropColumn(d) {
      const { createTable: y, createIndices: x } = await this.getTableSql(), b = f(y);
      if (b.table = this.alteredName, b.columns = b.columns.filter(
        (E) => E.expression || !h(d, E.name)
      ), b.columns.length === 0)
        throw new Error("Unable to drop last column from table");
      b.constraints = b.constraints.filter((E) => E.type === "PRIMARY KEY" || E.type === "UNIQUE" ? E.columns.every(
        (C) => C.expression || !h(d, C.name)
      ) : E.type === "FOREIGN KEY" ? E.columns.every(
        (C) => !h(d, C)
      ) && (E.references.table !== b.table || E.references.columns.every(
        (C) => !h(d, C)
      )) : !0);
      const w = b.columns.map((E) => E.name), S = l(b, this.wrap), T = [];
      for (const E of x) {
        const C = u(E);
        C.columns = C.columns.filter(
          (A) => A.expression || !h(d, A.name)
        ), C.columns.length > 0 && T.push(p(C, this.wrap));
      }
      return this.alter(S, T, w);
    }
    async dropForeign(d, y) {
      const { createTable: x, createIndices: b } = await this.getTableSql(), w = f(x);
      w.table = this.alteredName, y || (w.columns = w.columns.map((T) => ({
        ...T,
        references: h(d, T.name) ? null : T.references
      }))), w.constraints = w.constraints.filter((T) => T.type === "FOREIGN KEY" ? y ? !T.name || !m(T.name, y) : T.columns.every(
        (E) => !h(d, E)
      ) : !0);
      const S = l(w, this.wrap);
      return this.alter(S, b);
    }
    async dropPrimary(d) {
      const { createTable: y, createIndices: x } = await this.getTableSql(), b = f(y);
      b.table = this.alteredName, b.columns = b.columns.map((S) => ({
        ...S,
        primary: null
      })), b.constraints = b.constraints.filter((S) => S.type === "PRIMARY KEY" ? d ? !S.name || !m(S.name, d) : !1 : !0);
      const w = l(b, this.wrap);
      return this.alter(w, x);
    }
    async primary(d, y) {
      const { createTable: x, createIndices: b } = await this.getTableSql(), w = f(x);
      w.table = this.alteredName, w.columns = w.columns.map((T) => ({
        ...T,
        primary: null
      })), w.constraints = w.constraints.filter(
        (T) => T.type !== "PRIMARY KEY"
      ), w.constraints.push({
        type: "PRIMARY KEY",
        name: y || null,
        columns: d.map((T) => ({
          name: T,
          expression: !1,
          collation: null,
          order: null
        })),
        conflict: null
      });
      const S = l(w, this.wrap);
      return this.alter(S, b);
    }
    async foreign(d) {
      const { createTable: y, createIndices: x } = await this.getTableSql(), b = f(y);
      b.table = this.alteredName, b.constraints.push({
        type: "FOREIGN KEY",
        name: d.keyName || null,
        columns: d.column,
        references: {
          table: d.inTable,
          columns: d.references,
          delete: d.onDelete || null,
          update: d.onUpdate || null,
          match: null,
          deferrable: null
        }
      });
      const w = l(b, this.wrap);
      return this.generateAlterCommands(w, x);
    }
    async setNullable(d, y) {
      const { createTable: x, createIndices: b } = await this.getTableSql(), w = f(x);
      w.table = this.alteredName;
      const S = w.columns.find(
        (E) => m(d, E.name)
      );
      if (!S)
        throw new Error(
          `.setNullable: Column ${d} does not exist in table ${this.tableName()}.`
        );
      S.constraints.notnull = y ? null : { name: null, conflict: null }, S.constraints.null = y ? S.constraints.null : null;
      const T = l(w, this.wrap);
      return this.generateAlterCommands(T, b);
    }
    async alter(d, y, x) {
      const b = await this.isForeignCheckEnabled();
      b && await this.setForeignCheck(!1);
      try {
        await this.client.transaction(
          async (w) => {
            await w.raw(d), await this.copyData(w, x), await this.dropOriginal(w), await this.renameTable(w);
            for (const S of y)
              await w.raw(S);
            if (b && (await w.raw(c())).length > 0)
              throw new Error("FOREIGN KEY constraint failed");
          },
          { connection: this.connection }
        );
      } finally {
        b && await this.setForeignCheck(!0);
      }
    }
    async generateAlterCommands(d, y, x) {
      const b = [], w = [], S = [];
      let T = null;
      b.push(d), b.push(r(this.tableName(), this.alteredName, x)), b.push(n(this.tableName())), b.push(i(this.alteredName, this.tableName()));
      for (const C of y)
        b.push(C);
      return await this.isForeignCheckEnabled() && (w.push(o(!1)), S.push(o(!0)), T = c()), { pre: w, sql: b, check: T, post: S };
    }
  }
  return Ap = g, Ap;
}
var $p, M1;
function mae() {
  if (M1)
    return $p;
  M1 = 1;
  const t = pn;
  return $p = class extends t {
    withMaterialized(r, n, i) {
      return this._validateWithArgs(
        r,
        n,
        i,
        "with"
      ), this.withWrapped(
        r,
        n,
        i,
        !0
      );
    }
    withNotMaterialized(r, n, i) {
      return this._validateWithArgs(
        r,
        n,
        i,
        "with"
      ), this.withWrapped(
        r,
        n,
        i,
        !1
      );
    }
  }, $p;
}
var Ip, q1;
function kA() {
  if (q1)
    return Ip;
  q1 = 1;
  const t = EO, e = zn, { promisify: r } = nt, n = Gn, i = zi, a = Yie(), s = eae(), o = nae(), c = iae(), f = sae(), u = oae(), l = dae(), p = mu, m = mae();
  class h extends n {
    constructor(v) {
      super(v), v.connection && v.connection.filename === void 0 && this.logger.warn(
        "Could not find `connection.filename` in config. Please specify the database path and name to avoid errors. (see docs https://knexjs.org/guide/#configuration-options)"
      ), v.useNullAsDefault === void 0 && this.logger.warn(
        "sqlite does not support inserting default values. Set the `useNullAsDefault` flag to hide this warning. (see docs https://knexjs.org/guide/query-builder.html#insert)."
      );
    }
    _driver() {
      return se;
    }
    schemaCompiler() {
      return new o(this, ...arguments);
    }
    transaction() {
      return new a(this, ...arguments);
    }
    queryCompiler(v, d) {
      return new s(this, v, d);
    }
    queryBuilder() {
      return new m(this);
    }
    viewCompiler(v, d) {
      return new u(this, v, d);
    }
    columnCompiler() {
      return new c(this, ...arguments);
    }
    tableCompiler() {
      return new f(this, ...arguments);
    }
    ddl(v, d, y) {
      return new l(this, v, d, y);
    }
    wrapIdentifierImpl(v) {
      return v !== "*" ? `\`${v.replace(/`/g, "``")}\`` : "*";
    }
    // Get a raw connection from the database, returning a promise with the connection object.
    acquireRawConnection() {
      return new Promise((v, d) => {
        let y = this.driver.OPEN_READWRITE | this.driver.OPEN_CREATE;
        if (this.connectionSettings.flags) {
          if (!Array.isArray(this.connectionSettings.flags))
            throw new Error("flags must be an array of strings");
          this.connectionSettings.flags.forEach((b) => {
            if (!b.startsWith("OPEN_") || !this.driver[b])
              throw new Error(`flag ${b} not supported by node-sqlite3`);
            y = y | this.driver[b];
          });
        }
        const x = new this.driver.Database(
          this.connectionSettings.filename,
          y,
          (b) => {
            if (b)
              return d(b);
            v(x);
          }
        );
      });
    }
    // Used to explicitly close a connection, called internally by the pool when
    // a connection times out or the pool is shutdown.
    async destroyRawConnection(v) {
      return r((y) => v.close(y))();
    }
    // Runs the query on the specified connection, providing the bindings and any
    // other necessary prep work.
    _query(v, d) {
      if (!d.sql)
        throw new Error("The query is empty");
      const { method: y } = d;
      let x;
      switch (y) {
        case "insert":
        case "update":
          x = d.returning ? "all" : "run";
          break;
        case "counter":
        case "del":
          x = "run";
          break;
        default:
          x = "all";
      }
      return new Promise(function(b, w) {
        if (!v || !v[x])
          return w(
            new Error(`Error calling ${x} on connection.`)
          );
        v[x](d.sql, d.bindings, function(S, T) {
          return S ? w(S) : (d.response = T, d.context = this, b(d));
        });
      });
    }
    _stream(v, d, y) {
      if (!d.sql)
        throw new Error("The query is empty");
      const x = this;
      return new Promise(function(b, w) {
        return y.on("error", w), y.on("end", b), x._query(v, d).then((S) => S.response).then((S) => S.forEach((T) => y.write(T))).catch(function(S) {
          y.emit("error", S);
        }).then(function() {
          y.end();
        });
      });
    }
    // Ensures the response is returned in the same format as other clients.
    processResponse(v, d) {
      const y = v.context, { response: x, returning: b } = v;
      if (v.output)
        return v.output.call(d, x);
      switch (v.method) {
        case "select":
          return x;
        case "first":
          return x[0];
        case "pluck":
          return e(x, v.pluck);
        case "insert":
          return b && x ? x : [y.lastID];
        case "update":
          return b && x ? x : y.changes;
        case "del":
        case "counter":
          return y.changes;
        default:
          return x;
      }
    }
    poolDefaults() {
      return t({ min: 1, max: 1 }, super.poolDefaults());
    }
    formatter(v) {
      return new p(this, v);
    }
    values(v, d, y) {
      return Array.isArray(v) ? Array.isArray(v[0]) ? `( values ${v.map(
        (x) => `(${this.parameterize(x, void 0, d, y)})`
      ).join(", ")})` : `(${this.parameterize(v, void 0, d, y)})` : v instanceof i ? `(${this.parameter(v, d, y)})` : this.parameter(v, d, y);
    }
  }
  return Object.assign(h.prototype, {
    dialect: "sqlite3",
    driverName: "sqlite3"
  }), Ip = h, Ip;
}
var kp, j1;
function gae() {
  if (j1)
    return kp;
  j1 = 1;
  const t = kA();
  class e extends t {
    _driver() {
      return se;
    }
    // Get a raw connection from the database, returning a promise with the connection object.
    async acquireRawConnection() {
      return new this.driver(this.connectionSettings.filename);
    }
    // Used to explicitly close a connection, called internally by the pool when
    // a connection times out or the pool is shutdown.
    async destroyRawConnection(n) {
      return n.close();
    }
    // Runs the query on the specified connection, providing the bindings and any
    // other necessary prep work.
    async _query(n, i) {
      if (!i.sql)
        throw new Error("The query is empty");
      if (!n)
        throw new Error("No connection provided");
      const a = n.prepare(i.sql), s = this._formatBindings(i.bindings);
      if (a.reader) {
        const c = await a.all(s);
        return i.response = c, i;
      }
      const o = await a.run(s);
      return i.response = o, i.context = {
        lastID: o.lastInsertRowid,
        changes: o.changes
      }, i;
    }
    _formatBindings(n) {
      return n ? n.map((i) => i instanceof Date ? i.valueOf() : typeof i == "boolean" ? Number(i) : i) : [];
    }
  }
  return Object.assign(e.prototype, {
    // The "dialect", for reference .
    driverName: "better-sqlite3"
  }), kp = e, kp;
}
var Rp, F1;
function RA() {
  if (F1)
    return Rp;
  F1 = 1;
  const t = ln;
  class e extends t {
    begin(n) {
      return this.isolationLevel ? this.query(n, `BEGIN ISOLATION LEVEL ${this.isolationLevel};`) : this.query(n, "BEGIN;");
    }
  }
  return Rp = e, Rp;
}
var Np, B1;
function jv() {
  if (B1)
    return Np;
  B1 = 1;
  const t = Wt, e = gs, r = Hn, {
    wrapString: n,
    columnize: i,
    operator: a,
    wrap: s
  } = xt;
  class o extends r {
    constructor(f, u, l) {
      super(f, u, l), this._defaultInsertValue = "default";
    }
    // Compiles a truncate query.
    truncate() {
      return `truncate ${this.tableName} restart identity`;
    }
    // is used if the an array with multiple empty values supplied
    // Compiles an `insert` query, allowing for multiple
    // inserts using a single query statement.
    insert() {
      let f = super.insert();
      if (f === "")
        return f;
      const { returning: u, onConflict: l, ignore: p, merge: m, insert: h } = this.single;
      if (l && p && (f += this._ignore(l)), l && m) {
        f += this._merge(m.updates, l, h);
        const g = this.where();
        g && (f += ` ${g}`);
      }
      return u && (f += this._returning(u)), {
        sql: f,
        returning: u
      };
    }
    // Compiles an `update` query, allowing for a return value.
    update() {
      const f = this.with(), u = this._prepUpdate(this.single.update), l = this.where(), { returning: p } = this.single;
      return {
        sql: f + `update ${this.single.only ? "only " : ""}${this.tableName} set ${u.join(", ")}` + (l ? ` ${l}` : "") + this._returning(p),
        returning: p
      };
    }
    using() {
      const f = this.single.using;
      if (!f)
        return;
      let u = "using ";
      return Array.isArray(f) ? u += f.map((l) => this.formatter.wrap(l)).join(",") : u += this.formatter.wrap(f), u;
    }
    // Compiles an `delete` query, allowing for a return value.
    del() {
      const { tableName: f } = this, u = this.with();
      let l = this.where() || "", p = this.using() || "";
      const m = this.grouped.join, h = [];
      if (Array.isArray(m)) {
        for (const d of m) {
          h.push(
            s(
              this._joinTable(d),
              void 0,
              this.builder,
              this.client,
              this.bindingsHolder
            )
          );
          const y = [];
          for (const x of d.clauses)
            y.push(
              this.whereBasic({
                column: x.column,
                operator: "=",
                value: x.value,
                asColumn: !0
              })
            );
          y.length > 0 && (l += (l ? " and " : "where ") + y.join(" and "));
        }
        h.length > 0 && (p += (p ? "," : "using ") + h.join(","));
      }
      const g = u + `delete from ${this.single.only ? "only " : ""}${f}` + (p ? ` ${p}` : "") + (l ? ` ${l}` : ""), { returning: v } = this.single;
      return {
        sql: g + this._returning(v),
        returning: v
      };
    }
    aggregate(f) {
      return this._aggregate(f, { distinctParentheses: !0 });
    }
    _returning(f) {
      return f ? ` returning ${this.formatter.columnize(f)}` : "";
    }
    _ignore(f) {
      return f === !0 ? " on conflict do nothing" : ` on conflict ${this._onConflictClause(f)} do nothing`;
    }
    _merge(f, u, l) {
      let p = ` on conflict ${this._onConflictClause(u)} do update set `;
      if (f && Array.isArray(f))
        return p += f.map(
          (m) => n(
            m.split(".").pop(),
            this.formatter.builder,
            this.client,
            this.formatter
          )
        ).map((m) => `${m} = excluded.${m}`).join(", "), p;
      if (f && typeof f == "object") {
        const m = this._prepUpdate(f);
        return typeof m == "string" ? p += m : p += m.join(","), p;
      } else {
        const m = this._prepInsert(l);
        if (typeof m == "string")
          throw new Error(
            "If using merge with a raw insert query, then updates must be provided"
          );
        return p += m.columns.map(
          (h) => n(h.split(".").pop(), this.builder, this.client)
        ).map((h) => `${h} = excluded.${h}`).join(", "), p;
      }
    }
    // Join array of table names and apply default schema.
    _tableNames(f) {
      const u = this.single.schema, l = [];
      for (let p = 0; p < f.length; p++) {
        let m = f[p];
        m && (u && (m = `${u}.${m}`), l.push(this.formatter.wrap(m)));
      }
      return l.join(", ");
    }
    _lockingClause(f) {
      const u = this.single.lockTables || [];
      return f + (u.length ? " of " + this._tableNames(u) : "");
    }
    _groupOrder(f, u) {
      return super._groupOrderNulls(f, u);
    }
    forUpdate() {
      return this._lockingClause("for update");
    }
    forShare() {
      return this._lockingClause("for share");
    }
    forNoKeyUpdate() {
      return this._lockingClause("for no key update");
    }
    forKeyShare() {
      return this._lockingClause("for key share");
    }
    skipLocked() {
      return "skip locked";
    }
    noWait() {
      return "nowait";
    }
    // Compiles a columnInfo query
    columnInfo() {
      const f = this.single.columnInfo;
      let u = this.single.schema;
      const l = this.client.customWrapIdentifier(this.single.table, t);
      u && (u = this.client.customWrapIdentifier(u, t));
      const p = "select * from information_schema.columns where table_name = ? and table_catalog = current_database()", m = [l];
      return this._buildColumnInfoQuery(u, p, m, f);
    }
    _buildColumnInfoQuery(f, u, l, p) {
      return f ? (u += " and table_schema = ?", l.push(f)) : u += " and table_schema = current_schema()", {
        sql: u,
        bindings: l,
        output(m) {
          const h = e(
            m.rows,
            function(g, v) {
              return g[v.column_name] = {
                type: v.data_type,
                maxLength: v.character_maximum_length,
                nullable: v.is_nullable === "YES",
                defaultValue: v.column_default
              }, g;
            },
            {}
          );
          return p && h[p] || h;
        }
      };
    }
    distinctOn(f) {
      return "distinct on (" + this.formatter.columnize(f) + ") ";
    }
    // Json functions
    jsonExtract(f) {
      return this._jsonExtract("jsonb_path_query", f);
    }
    jsonSet(f) {
      return this._jsonSet(
        "jsonb_set",
        Object.assign({}, f, {
          path: this.client.toPathForJson(f.path)
        })
      );
    }
    jsonInsert(f) {
      return this._jsonSet(
        "jsonb_insert",
        Object.assign({}, f, {
          path: this.client.toPathForJson(f.path)
        })
      );
    }
    jsonRemove(f) {
      const u = `${i(
        f.column,
        this.builder,
        this.client,
        this.bindingsHolder
      )} #- ${this.client.parameter(
        this.client.toPathForJson(f.path),
        this.builder,
        this.bindingsHolder
      )}`;
      return f.alias ? this.client.alias(u, this.formatter.wrap(f.alias)) : u;
    }
    whereJsonPath(f) {
      let u = "";
      return !isNaN(f.value) && parseInt(f.value) ? u = "::int" : !isNaN(f.value) && parseFloat(f.value) ? u = "::float" : u = " #>> '{}'", `jsonb_path_query_first(${this._columnClause(
        f
      )}, ${this.client.parameter(
        f.jsonPath,
        this.builder,
        this.bindingsHolder
      )})${u} ${a(
        f.operator,
        this.builder,
        this.client,
        this.bindingsHolder
      )} ${this._jsonValueClause(f)}`;
    }
    whereJsonSupersetOf(f) {
      return this._not(
        f,
        `${s(
          f.column,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        )} @> ${this._jsonValueClause(f)}`
      );
    }
    whereJsonSubsetOf(f) {
      return this._not(
        f,
        `${i(
          f.column,
          this.builder,
          this.client,
          this.bindingsHolder
        )} <@ ${this._jsonValueClause(f)}`
      );
    }
    onJsonPathEquals(f) {
      return this._onJsonPathEquals("jsonb_path_query_first", f);
    }
  }
  return Np = o, Np;
}
var Lp, U1;
function vae() {
  if (U1)
    return Lp;
  U1 = 1;
  const t = pn;
  return Lp = class extends t {
    using(r) {
      return this._single.using = r, this;
    }
    withMaterialized(r, n, i) {
      return this._validateWithArgs(
        r,
        n,
        i,
        "with"
      ), this.withWrapped(
        r,
        n,
        i,
        !0
      );
    }
    withNotMaterialized(r, n, i) {
      return this._validateWithArgs(
        r,
        n,
        i,
        "with"
      ), this.withWrapped(
        r,
        n,
        i,
        !1
      );
    }
  }, Lp;
}
var Pp, z1;
function Fv() {
  if (z1)
    return Pp;
  z1 = 1;
  const t = Wn, { isObject: e } = Je, { toNumber: r } = wt, n = new RegExp("(?<!')'(?!')", "g");
  class i extends t {
    constructor(o, c, f) {
      super(o, c, f), this.modifiers = ["nullable", "defaultTo", "comment"], this._addCheckModifiers();
    }
    // Types
    // ------
    bit(o) {
      return o.length !== !1 ? `bit(${o.length})` : "bit";
    }
    // Create the column definition for an enum type.
    // Using method "2" here: http://stackoverflow.com/a/10984951/525714
    enu(o, c) {
      c = c || {};
      const f = c.useNative && c.existingType ? void 0 : o.join("', '");
      if (c.useNative) {
        let u = "";
        const l = c.schemaName || this.tableCompiler.schemaNameRaw;
        return l && (u += `"${l}".`), u += `"${c.enumName}"`, c.existingType || this.tableCompiler.unshiftQuery(
          `create type ${u} as enum ('${f}')`
        ), u;
      }
      return `text check (${this.formatter.wrap(this.args[0])} in ('${f}'))`;
    }
    decimal(o, c) {
      return o === null ? "decimal" : `decimal(${r(o, 8)}, ${r(c, 2)})`;
    }
    json(o) {
      return o && this.client.logger.deprecate("json(true)", "jsonb()"), a(this.client, o);
    }
    jsonb() {
      return a(this.client, !0);
    }
    checkRegex(o, c) {
      return this._check(
        `${this.formatter.wrap(
          this.getColumnName()
        )} ~ ${this.client._escapeBinding(o)}`,
        c
      );
    }
    datetime(o = !1, c) {
      let f;
      return e(o) ? { useTz: f, precision: c } = o : f = !o, f = typeof f == "boolean" ? f : !0, c = c != null ? "(" + c + ")" : "", `${f ? "timestamptz" : "timestamp"}${c}`;
    }
    timestamp(o = !1, c) {
      return this.datetime(o, c);
    }
    // Modifiers:
    // ------
    comment(o) {
      const c = this.args[0] || this.defaults("columnName"), f = o ? `'${o.replace(n, "''")}'` : "NULL";
      this.pushAdditional(function() {
        this.pushQuery(
          `comment on column ${this.tableCompiler.tableName()}.` + this.formatter.wrap(c) + ` is ${f}`
        );
      }, o);
    }
    increments(o = { primaryKey: !0 }) {
      return "serial" + (this.tableCompiler._canBeAddPrimaryKey(o) ? " primary key" : "");
    }
    bigincrements(o = { primaryKey: !0 }) {
      return "bigserial" + (this.tableCompiler._canBeAddPrimaryKey(o) ? " primary key" : "");
    }
    uuid(o = { primaryKey: !1 }) {
      return "uuid" + (this.tableCompiler._canBeAddPrimaryKey(o) ? " primary key" : "");
    }
  }
  i.prototype.bigint = "bigint", i.prototype.binary = "bytea", i.prototype.bool = "boolean", i.prototype.double = "double precision", i.prototype.floating = "real", i.prototype.smallint = "smallint", i.prototype.tinyint = "smallint";
  function a(s, o) {
    return !s.version || s.config.client === "cockroachdb" || s.config.jsonbSupport === !0 || parseFloat(s.version) >= 9.2 ? o ? "jsonb" : "json" : "text";
  }
  return Pp = i, Pp;
}
var Dp, H1;
function Bv() {
  if (H1)
    return Dp;
  H1 = 1;
  const t = ou, e = Wi, { isObject: r, isString: n } = Je;
  class i extends e {
    constructor(s, o) {
      super(s, o);
    }
    // Compile a rename column command.
    renameColumn(s, o) {
      return this.pushQuery({
        sql: `alter table ${this.tableName()} rename ${this.formatter.wrap(
          s
        )} to ${this.formatter.wrap(o)}`
      });
    }
    _setNullableState(s, o) {
      const c = o ? "drop not null" : "set not null", f = `alter table ${this.tableName()} alter column ${this.formatter.wrap(
        s
      )} ${c}`;
      return this.pushQuery({
        sql: f
      });
    }
    compileAdd(s) {
      const o = this.formatter.wrap(s), c = this.prefixArray("add column", this.getColumns(s));
      return this.pushQuery({
        sql: `alter table ${o} ${c.join(", ")}`
      });
    }
    // Adds the "create" query to the query sequence.
    createQuery(s, o, c) {
      const f = o ? "create table if not exists " : "create table ", u = ` (${s.sql.join(", ")}${this.primaryKeys() || ""}${this._addChecks()})`;
      let l = f + this.tableName() + (c && this.tableNameLike() ? " (like " + this.tableNameLike() + " including all" + (s.sql.length ? ", " + s.sql.join(", ") : "") + ")" : u);
      this.single.inherits && (l += ` inherits (${this.formatter.wrap(this.single.inherits)})`), this.pushQuery({
        sql: l,
        bindings: s.bindings
      }), t(this.single, "comment") && this.comment(this.single.comment);
    }
    primaryKeys() {
      const s = (this.grouped.alterTable || []).filter(
        (o) => o.method === "primary"
      );
      if (s.length > 0 && s[0].args.length > 0) {
        const o = s[0].args[0];
        let c = s[0].args[1] || "", f;
        return r(c) && ({ constraintName: c, deferrable: f } = c), f = f ? ` deferrable initially ${f}` : "", c = c ? this.formatter.wrap(c) : this.formatter.wrap(`${this.tableNameRaw}_pkey`), `, constraint ${c} primary key (${this.formatter.columnize(
          o
        )})${f}`;
      }
    }
    addColumns(s, o, c) {
      if (o === this.alterColumnsPrefix)
        for (const f of c)
          this._addColumn(f);
      else
        super.addColumns(s, o);
    }
    _addColumn(s) {
      const o = this.tableName(), c = s.getColumnType(), f = this.client.wrapIdentifier(
        s.getColumnName(),
        s.columnBuilder.queryContext()
      ), u = s.type === "enu";
      this.pushQuery({
        sql: `alter table ${o} alter column ${f} drop default`,
        bindings: []
      });
      const l = s.columnBuilder.alterNullable;
      l && this.pushQuery({
        sql: `alter table ${o} alter column ${f} drop not null`,
        bindings: []
      }), s.columnBuilder.alterType && this.pushQuery({
        sql: `alter table ${o} alter column ${f} type ${c} using (${f}${u ? "::text::" : "::"}${c})`,
        bindings: []
      });
      const m = s.modified.defaultTo;
      if (m) {
        const h = s.defaultTo.apply(s, m);
        this.pushQuery({
          sql: `alter table ${o} alter column ${f} set ${h}`,
          bindings: []
        });
      }
      if (l) {
        const h = s.modified.nullable;
        h && h[0] === !1 && this.pushQuery({
          sql: `alter table ${o} alter column ${f} set not null`,
          bindings: []
        });
      }
    }
    // Compiles the comment on the table.
    comment(s) {
      this.pushQuery(
        `comment on table ${this.tableName()} is '${this.single.comment}'`
      );
    }
    // Indexes:
    // -------
    primary(s, o) {
      let c;
      r(o) && ({ constraintName: o, deferrable: c } = o), c = c ? ` deferrable initially ${c}` : "", o = o ? this.formatter.wrap(o) : this.formatter.wrap(`${this.tableNameRaw}_pkey`), this.method !== "create" && this.method !== "createIfNot" && this.pushQuery(
        `alter table ${this.tableName()} add constraint ${o} primary key (${this.formatter.columnize(
          s
        )})${c}`
      );
    }
    unique(s, o) {
      let c, f = !0, u;
      if (r(o) && ({ indexName: o, deferrable: c, useConstraint: f, predicate: u } = o, f === void 0 && (f = !!c || !u)), !f && c && c !== "not deferrable")
        throw new Error("postgres cannot create deferrable index");
      if (f && u)
        throw new Error("postgres cannot create constraint with predicate");
      if (c = c ? ` deferrable initially ${c}` : "", o = o ? this.formatter.wrap(o) : this._indexCommand("unique", this.tableNameRaw, s), f)
        this.pushQuery(
          `alter table ${this.tableName()} add constraint ${o} unique (` + this.formatter.columnize(s) + ")" + c
        );
      else {
        const l = u ? " " + this.client.queryCompiler(u).where() : "";
        this.pushQuery(
          `create unique index ${o} on ${this.tableName()} (${this.formatter.columnize(
            s
          )})${l}`
        );
      }
    }
    index(s, o, c) {
      o = o ? this.formatter.wrap(o) : this._indexCommand("index", this.tableNameRaw, s);
      let f, u;
      n(c) ? u = c : r(c) && ({ indexType: u, predicate: f } = c);
      const l = f ? " " + this.client.queryCompiler(f).where() : "";
      this.pushQuery(
        `create index ${o} on ${this.tableName()}${u && ` using ${u}` || ""} (` + this.formatter.columnize(s) + `)${l}`
      );
    }
    dropPrimary(s) {
      s = s ? this.formatter.wrap(s) : this.formatter.wrap(this.tableNameRaw + "_pkey"), this.pushQuery(
        `alter table ${this.tableName()} drop constraint ${s}`
      );
    }
    dropIndex(s, o) {
      o = o ? this.formatter.wrap(o) : this._indexCommand("index", this.tableNameRaw, s), o = this.schemaNameRaw ? `${this.formatter.wrap(this.schemaNameRaw)}.${o}` : o, this.pushQuery(`drop index ${o}`);
    }
    dropUnique(s, o) {
      o = o ? this.formatter.wrap(o) : this._indexCommand("unique", this.tableNameRaw, s), this.pushQuery(
        `alter table ${this.tableName()} drop constraint ${o}`
      );
    }
    dropForeign(s, o) {
      o = o ? this.formatter.wrap(o) : this._indexCommand("foreign", this.tableNameRaw, s), this.pushQuery(
        `alter table ${this.tableName()} drop constraint ${o}`
      );
    }
  }
  return Dp = i, Dp;
}
var Mp, W1;
function Uv() {
  if (W1)
    return Mp;
  W1 = 1;
  const t = Gi;
  class e extends t {
    constructor(n, i) {
      super(n, i);
    }
    renameColumn(n, i) {
      return this.pushQuery({
        sql: `alter view ${this.viewName()} rename ${this.formatter.wrap(
          n
        )} to ${this.formatter.wrap(i)}`
      });
    }
    defaultTo(n, i) {
      return this.pushQuery({
        sql: `alter view ${this.viewName()} alter ${this.formatter.wrap(
          n
        )} set default ${i}`
      });
    }
    createOrReplace() {
      this.createQuery(this.columns, this.selectQuery, !1, !0);
    }
    createMaterializedView() {
      this.createQuery(this.columns, this.selectQuery, !0);
    }
  }
  return Mp = e, Mp;
}
var qp, G1;
function yae() {
  if (G1)
    return qp;
  G1 = 1;
  const t = bs;
  class e extends t {
    constructor() {
      super(...arguments);
    }
    checkOption() {
      this._single.checkOption = "default_option";
    }
    localCheckOption() {
      this._single.checkOption = "local";
    }
    cascadedCheckOption() {
      this._single.checkOption = "cascaded";
    }
  }
  return qp = e, qp;
}
var jp, Q1;
function NA() {
  if (Q1)
    return jp;
  Q1 = 1;
  const t = Hi;
  class e extends t {
    constructor(n, i) {
      super(n, i);
    }
    // Check whether the current table
    hasTable(n) {
      let i = "select * from information_schema.tables where table_name = ?";
      const a = [n];
      this.schema ? (i += " and table_schema = ?", a.push(this.schema)) : i += " and table_schema = current_schema()", this.pushQuery({
        sql: i,
        bindings: a,
        output(s) {
          return s.rows.length > 0;
        }
      });
    }
    // Compile the query to determine if a column exists in a table.
    hasColumn(n, i) {
      let a = "select * from information_schema.columns where table_name = ? and column_name = ?";
      const s = [n, i];
      this.schema ? (a += " and table_schema = ?", s.push(this.schema)) : a += " and table_schema = current_schema()", this.pushQuery({
        sql: a,
        bindings: s,
        output(o) {
          return o.rows.length > 0;
        }
      });
    }
    qualifiedTableName(n) {
      const i = this.schema ? `${this.schema}.${n}` : n;
      return this.formatter.wrap(i);
    }
    // Compile a rename table command.
    renameTable(n, i) {
      this.pushQuery(
        `alter table ${this.qualifiedTableName(
          n
        )} rename to ${this.formatter.wrap(i)}`
      );
    }
    createSchema(n) {
      this.pushQuery(`create schema ${this.formatter.wrap(n)}`);
    }
    createSchemaIfNotExists(n) {
      this.pushQuery(
        `create schema if not exists ${this.formatter.wrap(n)}`
      );
    }
    dropSchema(n, i = !1) {
      this.pushQuery(
        `drop schema ${this.formatter.wrap(n)}${i ? " cascade" : ""}`
      );
    }
    dropSchemaIfExists(n, i = !1) {
      this.pushQuery(
        `drop schema if exists ${this.formatter.wrap(n)}${i ? " cascade" : ""}`
      );
    }
    dropExtension(n) {
      this.pushQuery(`drop extension ${this.formatter.wrap(n)}`);
    }
    dropExtensionIfExists(n) {
      this.pushQuery(
        `drop extension if exists ${this.formatter.wrap(n)}`
      );
    }
    createExtension(n) {
      this.pushQuery(`create extension ${this.formatter.wrap(n)}`);
    }
    createExtensionIfNotExists(n) {
      this.pushQuery(
        `create extension if not exists ${this.formatter.wrap(n)}`
      );
    }
    renameView(n, i) {
      this.pushQuery(
        this.alterViewPrefix + `${this.formatter.wrap(n)} rename to ${this.formatter.wrap(i)}`
      );
    }
    refreshMaterializedView(n, i = !1) {
      this.pushQuery({
        sql: `refresh materialized view${i ? " concurrently" : ""} ${this.formatter.wrap(n)}`
      });
    }
    dropMaterializedView(n) {
      this._dropView(n, !1, !0);
    }
    dropMaterializedViewIfExists(n) {
      this._dropView(n, !0, !0);
    }
  }
  return jp = e, jp;
}
var Fp, V1;
function vu() {
  if (V1)
    return Fp;
  V1 = 1;
  const t = pu, e = zn, { promisify: r } = nt, n = Gn, i = RA(), a = jv(), s = vae(), o = Fv(), c = Bv(), f = Uv(), u = yae(), l = NA(), { makeEscape: p } = dv, { isString: m } = Je;
  class h extends n {
    constructor(d) {
      super(d), d.returning && (this.defaultReturning = d.returning), d.searchPath && (this.searchPath = d.searchPath);
    }
    transaction() {
      return new i(this, ...arguments);
    }
    queryBuilder() {
      return new s(this);
    }
    queryCompiler(d, y) {
      return new a(this, d, y);
    }
    columnCompiler() {
      return new o(this, ...arguments);
    }
    schemaCompiler() {
      return new l(this, ...arguments);
    }
    tableCompiler() {
      return new c(this, ...arguments);
    }
    viewCompiler() {
      return new f(this, ...arguments);
    }
    viewBuilder() {
      return new u(this, ...arguments);
    }
    _driver() {
      return se;
    }
    wrapIdentifierImpl(d) {
      if (d === "*")
        return d;
      let y = "";
      const x = d.match(/(.*?)(\[[0-9]+\])/);
      return x && (d = x[1], y = x[2]), `"${d.replace(/"/g, '""')}"${y}`;
    }
    _acquireOnlyConnection() {
      const d = new this.driver.Client(this.connectionSettings);
      return d.connect().then(() => d);
    }
    // Get a raw connection, called by the `pool` whenever a new
    // connection needs to be added to the pool.
    acquireRawConnection() {
      const d = this;
      return this._acquireOnlyConnection().then(function(y) {
        return y.on("error", (x) => {
          y.__knex__disposed = x;
        }), y.on("end", (x) => {
          y.__knex__disposed = x || "Connection ended unexpectedly";
        }), d.version ? y : d.checkVersion(y).then(function(x) {
          return d.version = x, y;
        });
      }).then(async function(x) {
        return await d.setSchemaSearchPath(x), x;
      });
    }
    // Used to explicitly close a connection, called internally by the pool
    // when a connection times out or the pool is shutdown.
    async destroyRawConnection(d) {
      return r((x) => d.end(x))();
    }
    // In PostgreSQL, we need to do a version check to do some feature
    // checking on the database.
    checkVersion(d) {
      return new Promise((y, x) => {
        d.query("select version();", (b, w) => {
          if (b)
            return x(b);
          y(this._parseVersion(w.rows[0].version));
        });
      });
    }
    _parseVersion(d) {
      return /^PostgreSQL (.*?)( |$)/.exec(d)[1];
    }
    // Position the bindings for the query. The escape sequence for question mark
    // is \? (e.g. knex.raw("\\?") since javascript requires '\' to be escaped too...)
    positionBindings(d) {
      let y = 0;
      return d.replace(/(\\*)(\?)/g, function(x, b) {
        return b.length % 2 ? "?" : (y++, `$${y}`);
      });
    }
    setSchemaSearchPath(d, y) {
      let x = y || this.searchPath;
      if (!x)
        return Promise.resolve(!0);
      if (!Array.isArray(x) && !m(x))
        throw new TypeError(
          `knex: Expected searchPath to be Array/String, got: ${typeof x}`
        );
      if (m(x)) {
        if (x.includes(",")) {
          const w = `[${x.split(",").map((S) => `'${S}'`).join(", ")}]`;
          this.logger.warn(
            `Detected comma in searchPath "${x}".If you are trying to specify multiple schemas, use Array syntax: ${w}`
          );
        }
        x = [x];
      }
      return x = x.map((b) => `"${b}"`).join(","), new Promise(function(b, w) {
        d.query(`set search_path to ${x}`, function(S) {
          if (S)
            return w(S);
          b(!0);
        });
      });
    }
    _stream(d, y, x, b) {
      if (!y.sql)
        throw new Error("The query is empty");
      const w = process.browser ? void 0 : se, S = y.sql;
      return new Promise(function(T, E) {
        const C = d.query(
          new w(S, y.bindings, b)
        );
        C.on("error", function(A) {
          E(A), x.emit("error", A);
        }), x.on("end", T), C.pipe(x);
      });
    }
    // Runs the query on the specified connection, providing the bindings
    // and any other necessary prep work.
    _query(d, y) {
      if (!y.sql)
        throw new Error("The query is empty");
      let x = {
        text: y.sql,
        values: y.bindings || []
      };
      return y.options && (x = t(x, y.options)), new Promise(function(b, w) {
        d.query(x, function(S, T) {
          if (S)
            return w(S);
          y.response = T, b(y);
        });
      });
    }
    // Ensures the response is returned in the same format as other clients.
    processResponse(d, y) {
      const x = d.response;
      if (d.output)
        return d.output.call(y, x);
      if (d.method === "raw")
        return x;
      const { returning: b } = d;
      if (x.command === "SELECT")
        return d.method === "first" ? x.rows[0] : d.method === "pluck" ? e(x.rows, d.pluck) : x.rows;
      if (b) {
        const w = [];
        for (let S = 0, T = x.rows.length; S < T; S++) {
          const E = x.rows[S];
          w[S] = E;
        }
        return w;
      }
      return x.command === "UPDATE" || x.command === "DELETE" ? x.rowCount : x;
    }
    async cancelQuery(d) {
      const y = await this.acquireRawConnection();
      try {
        return await this._wrappedCancelQueryCall(y, d);
      } finally {
        await this.destroyRawConnection(y).catch((x) => {
          this.logger.warn(`Connection Error: ${x}`);
        });
      }
    }
    _wrappedCancelQueryCall(d, y) {
      return this._query(d, {
        sql: "SELECT pg_cancel_backend($1);",
        bindings: [y.processID],
        options: {}
      });
    }
    toPathForJson(d) {
      const y = /^{.*}$/;
      return d.match(y) ? d : "{" + d.replace(/^(\$\.)/, "").replace(".", ",").replace(/\[([0-9]+)]/, ",$1") + // transform [number] to ,number
      "}";
    }
  }
  Object.assign(h.prototype, {
    dialect: "postgresql",
    driverName: "pg",
    canCancelQuery: !0,
    _escapeBinding: p({
      escapeArray(v, d) {
        return d(g(v, d));
      },
      escapeString(v) {
        let d = !1, y = "'";
        for (let x = 0; x < v.length; x++) {
          const b = v[x];
          b === "'" ? y += b + b : b === "\\" ? (y += b + b, d = !0) : y += b;
        }
        return y += "'", d === !0 && (y = "E" + y), y;
      },
      escapeObject(v, d, y, x = []) {
        if (v && typeof v.toPostgres == "function") {
          if (x = x || [], x.indexOf(v) !== -1)
            throw new Error(
              `circular reference detected while preparing "${v}" for query`
            );
          return x.push(v), d(v.toPostgres(d), x);
        }
        return JSON.stringify(v);
      }
    })
  });
  function g(v, d) {
    let y = "{";
    for (let x = 0; x < v.length; x++) {
      x > 0 && (y += ",");
      const b = v[x];
      b === null || typeof b > "u" ? y += "NULL" : Array.isArray(b) ? y += g(b, d) : typeof b == "number" ? y += b : y += JSON.stringify(typeof b == "string" ? b : d(b));
    }
    return y + "}";
  }
  return Fp = h, Fp;
}
var Bp, K1;
function bae() {
  if (K1)
    return Bp;
  K1 = 1;
  const t = jv(), {
    columnize: e,
    wrap: r,
    operator: n
  } = xt;
  class i extends t {
    truncate() {
      return `truncate ${this.tableName}`;
    }
    upsert() {
      let s = this._upsert();
      if (s === "")
        return s;
      const { returning: o } = this.single;
      return o && (s += this._returning(o)), {
        sql: s,
        returning: o
      };
    }
    _upsert() {
      const s = this.single.upsert || [], o = this.with() + `upsert into ${this.tableName} `, c = this._insertBody(s);
      return c === "" ? "" : o + c;
    }
    _groupOrder(s, o) {
      return this._basicGroupOrder(s, o);
    }
    whereJsonPath(s) {
      let o = "";
      return !isNaN(s.value) && parseInt(s.value) ? o = "::int" : !isNaN(s.value) && parseFloat(s.value) ? o = "::float" : o = " #>> '{}'", `json_extract_path(${this._columnClause(
        s
      )}, ${this.client.toArrayPathFromJsonPath(
        s.jsonPath,
        this.builder,
        this.bindingsHolder
      )})${o} ${n(
        s.operator,
        this.builder,
        this.client,
        this.bindingsHolder
      )} ${this._jsonValueClause(s)}`;
    }
    // Json common functions
    _jsonExtract(s, o) {
      let c;
      return Array.isArray(o.column) ? c = o.column : c = [o], c.map((f) => {
        const u = `json_extract_path(${e(
          f.column || f[0],
          this.builder,
          this.client,
          this.bindingsHolder
        )}, ${this.client.toArrayPathFromJsonPath(
          f.path || f[1],
          this.builder,
          this.bindingsHolder
        )})`, l = f.alias || f[2];
        return l ? this.client.alias(u, this.formatter.wrap(l)) : u;
      }).join(", ");
    }
    _onJsonPathEquals(s, o) {
      return "json_extract_path(" + r(
        o.columnFirst,
        void 0,
        this.builder,
        this.client,
        this.bindingsHolder
      ) + ", " + this.client.toArrayPathFromJsonPath(
        o.jsonPathFirst,
        this.builder,
        this.bindingsHolder
      ) + ") = json_extract_path(" + r(
        o.columnSecond,
        void 0,
        this.builder,
        this.client,
        this.bindingsHolder
      ) + ", " + this.client.toArrayPathFromJsonPath(
        o.jsonPathSecond,
        this.builder,
        this.bindingsHolder
      ) + ")";
    }
  }
  return Bp = i, Bp;
}
var Up, J1;
function wae() {
  if (J1)
    return Up;
  J1 = 1;
  const t = Fv();
  class e extends t {
    uuid(n = { primaryKey: !1 }) {
      return "uuid" + (this.tableCompiler._canBeAddPrimaryKey(n) ? " primary key default gen_random_uuid()" : "");
    }
  }
  return Up = e, Up;
}
var zp, X1;
function xae() {
  if (X1)
    return zp;
  X1 = 1;
  const t = Bv();
  class e extends t {
    constructor(n, i) {
      super(n, i);
    }
    addColumns(n, i, a) {
      if (i === this.alterColumnsPrefix)
        for (const s of a)
          this.client.logger.warn(
            "Experimental alter column in use, see issue: https://github.com/cockroachdb/cockroach/issues/49329"
          ), this.pushQuery({
            sql: "SET enable_experimental_alter_column_type_general = true",
            bindings: []
          }), super._addColumn(s);
      else
        super.addColumns(n, i);
    }
    dropUnique(n, i) {
      i = i ? this.formatter.wrap(i) : this._indexCommand("unique", this.tableNameRaw, n), this.pushQuery(`drop index ${this.tableName()}@${i} cascade `);
    }
  }
  return zp = e, zp;
}
var Hp, Z1;
function _ae() {
  if (Z1)
    return Hp;
  Z1 = 1;
  const t = Uv();
  class e extends t {
    renameColumn(n, i) {
      throw new Error("rename column of views is not supported by this dialect.");
    }
    defaultTo(n, i) {
      throw new Error(
        "change default values of views is not supported by this dialect."
      );
    }
  }
  return Hp = e, Hp;
}
var Wp, Y1;
function Eae() {
  if (Y1)
    return Wp;
  Y1 = 1;
  const t = pn, e = sr;
  return Wp = class extends t {
    upsert(n, i, a) {
      return this._method = "upsert", e(i) || this.returning(i, a), this._single.upsert = n, this;
    }
  }, Wp;
}
var Gp, ex;
function Sae() {
  if (ex)
    return Gp;
  ex = 1;
  const t = vu(), e = RA(), r = bae(), n = wae(), i = xae(), a = _ae(), s = Eae();
  class o extends t {
    transaction() {
      return new e(this, ...arguments);
    }
    queryCompiler(f, u) {
      return new r(this, f, u);
    }
    columnCompiler() {
      return new n(this, ...arguments);
    }
    tableCompiler() {
      return new i(this, ...arguments);
    }
    viewCompiler() {
      return new a(this, ...arguments);
    }
    queryBuilder() {
      return new s(this);
    }
    _parseVersion(f) {
      return f.split(" ")[2];
    }
    async cancelQuery(f) {
      try {
        return await this._wrappedCancelQueryCall(null, f);
      } catch (u) {
        throw this.logger.warn(`Connection Error: ${u}`), u;
      }
    }
    _wrappedCancelQueryCall(f, u) {
      if (!(u.activeQuery.processID === 0 && u.activeQuery.secretKey === 0))
        return u.cancel(
          u,
          u.activeQuery
        );
    }
    toArrayPathFromJsonPath(f, u, l) {
      return f.replace(/^(\$\.)/, "").replace(/\[([0-9]+)]/, ".$1").split(".").map(
        function(p) {
          return this.parameter(p, u, l);
        }.bind(this)
      ).join(", ");
    }
  }
  return Object.assign(o.prototype, {
    // The "dialect", for reference elsewhere.
    driverName: "cockroachdb"
  }), Gp = o, Gp;
}
var Qp, tx;
function Cae() {
  if (tx)
    return Qp;
  tx = 1;
  function t(e) {
    return e == null;
  }
  return Qp = t, Qp;
}
var Vp, rx;
function Tae() {
  if (rx)
    return Vp;
  rx = 1;
  const t = mu;
  class e extends t {
    // Accepts a string or array of columns to wrap as appropriate.
    columnizeWithPrefix(n, i) {
      const a = typeof i == "string" ? [i] : i;
      let s = "", o = -1;
      for (; ++o < a.length; )
        o > 0 && (s += ", "), s += n + this.wrap(a[o]);
      return s;
    }
    /**
     * Returns its argument with single quotes escaped, so it can be included into a single-quoted string.
     *
     * For example, it converts "has'quote" to "has''quote".
     *
     * This assumes QUOTED_IDENTIFIER ON so it is only ' that need escaping,
     * never ", because " cannot be used to quote a string when that's on;
     * otherwise we'd need to be aware of whether the string is quoted with " or '.
     *
     * This assumption is consistent with the SQL Knex generates.
     * @param {string} string
     * @returns {string}
     */
    escapingStringDelimiters(n) {
      return (n || "").replace(/'/g, "''");
    }
  }
  return Vp = e, Vp;
}
var Kp, nx;
function Oae() {
  if (nx)
    return Kp;
  nx = 1;
  const t = ln, e = ar("knex:tx");
  class r extends t {
    begin(o) {
      return e("transaction::begin id=%s", this.txid), new Promise((c, f) => {
        o.beginTransaction(
          (u) => {
            if (u)
              return e(
                "transaction::begin error id=%s message=%s",
                this.txid,
                u.message
              ), f(u);
            c();
          },
          this.outerTx ? this.txid : void 0,
          n(this.isolationLevel)
        );
      }).then(this._resolver, this._rejecter);
    }
    savepoint(o) {
      return e("transaction::savepoint id=%s", this.txid), new Promise((c, f) => {
        o.saveTransaction(
          (u) => {
            if (u)
              return e(
                "transaction::savepoint id=%s message=%s",
                this.txid,
                u.message
              ), f(u);
            this.trxClient.emit("query", {
              __knexUid: this.trxClient.__knexUid,
              __knexTxId: this.trxClient.__knexTxId,
              autogenerated: !0,
              sql: this.outerTx ? `SAVE TRANSACTION [${this.txid}]` : "SAVE TRANSACTION"
            }), c();
          },
          this.outerTx ? this.txid : void 0
        );
      });
    }
    commit(o, c) {
      return e("transaction::commit id=%s", this.txid), new Promise((f, u) => {
        o.commitTransaction(
          (l) => {
            if (l)
              return e(
                "transaction::commit error id=%s message=%s",
                this.txid,
                l.message
              ), u(l);
            this._completed = !0, f(c);
          },
          this.outerTx ? this.txid : void 0
        );
      }).then(() => this._resolver(c), this._rejecter);
    }
    release(o, c) {
      return this._resolver(c);
    }
    rollback(o, c) {
      return this._completed = !0, e("transaction::rollback id=%s", this.txid), new Promise((f, u) => {
        if (!o.inTransaction)
          return u(
            c || new Error("Transaction rejected with non-error: undefined")
          );
        if (o.state.name !== "LoggedIn")
          return u(
            new Error(
              "Can't rollback transaction. There is a request in progress"
            )
          );
        o.rollbackTransaction(
          (l) => {
            l && e(
              "transaction::rollback error id=%s message=%s",
              this.txid,
              l.message
            ), u(
              l || c || new Error("Transaction rejected with non-error: undefined")
            );
          },
          this.outerTx ? this.txid : void 0
        );
      }).catch((f) => {
        if (!c && this.doNotRejectOnRollback) {
          this._resolver();
          return;
        }
        if (c)
          try {
            f.originalError = c;
          } catch {
          }
        this._rejecter(f);
      });
    }
    rollbackTo(o, c) {
      return this.rollback(o, c).then(
        () => void this.trxClient.emit("query", {
          __knexUid: this.trxClient.__knexUid,
          __knexTxId: this.trxClient.__knexTxId,
          autogenerated: !0,
          sql: "ROLLBACK TRANSACTION"
        })
      );
    }
  }
  Kp = r;
  function n(s) {
    if (!s)
      return;
    s = s.toUpperCase().replace(" ", "_");
    const o = i[s];
    if (!o)
      throw new Error(
        `Unknown Isolation level, was expecting one of: ${JSON.stringify(
          a
        )}`
      );
    return o;
  }
  const i = {
    READ_UNCOMMITTED: 1,
    READ_COMMITTED: 2,
    REPEATABLE_READ: 3,
    SERIALIZABLE: 4,
    SNAPSHOT: 5
  }, a = Object.keys(i).map(
    (s) => s.toLowerCase().replace("_", " ")
  );
  return Kp;
}
var Jp, ix;
function Aae() {
  if (ix)
    return Jp;
  ix = 1;
  const t = Hn, e = Mv, r = Wt, n = sr, i = zi, {
    columnize: a
  } = xt, s = [
    "columns",
    "join",
    "lock",
    "where",
    "union",
    "group",
    "having",
    "order",
    "limit",
    "offset"
  ];
  class o extends t {
    constructor(f, u, l) {
      super(f, u, l);
      const { onConflict: p } = this.single;
      if (p)
        throw new Error(".onConflict() is not supported for mssql.");
      this._emptyInsertValue = "default values";
    }
    with() {
      const f = [];
      if (this.grouped.with)
        for (const l of this.grouped.with)
          l.recursive && (f.push(l), l.recursive = !1);
      const u = super.with();
      for (const l of f)
        l.recursive = !0;
      return u;
    }
    select() {
      const f = this.with(), u = s.map((l) => this[l](this));
      return f + e(u).join(" ");
    }
    //#region Insert
    // Compiles an "insert" query, allowing for multiple
    // inserts using a single query statement.
    insert() {
      return this.single.options && this.single.options.includeTriggerModifications ? this.insertWithTriggers() : this.standardInsert();
    }
    insertWithTriggers() {
      const f = this.single.insert || [], { returning: u } = this.single;
      let l = this.with() + `${this._buildTempTable(u)}insert into ${this.tableName} `;
      const p = u ? this._returning("insert", u, !0) + " " : "";
      if (Array.isArray(f)) {
        if (f.length === 0)
          return "";
      } else if (typeof f == "object" && n(f))
        return {
          sql: l + p + this._emptyInsertValue + this._buildReturningSelect(u),
          returning: u
        };
      return l += this._buildInsertData(f, p), u && (l += this._buildReturningSelect(u)), {
        sql: l,
        returning: u
      };
    }
    _buildInsertData(f, u) {
      let l = "";
      const p = this._prepInsert(f);
      if (typeof p == "string")
        l += p;
      else if (p.columns.length)
        l += `(${this.formatter.columnize(p.columns)}`, l += `) ${u}values (` + this._buildInsertValues(p) + ")";
      else if (f.length === 1 && f[0])
        l += u + this._emptyInsertValue;
      else
        return "";
      return l;
    }
    standardInsert() {
      const f = this.single.insert || [];
      let u = this.with() + `insert into ${this.tableName} `;
      const { returning: l } = this.single, p = l ? this._returning("insert", l) + " " : "";
      if (Array.isArray(f)) {
        if (f.length === 0)
          return "";
      } else if (typeof f == "object" && n(f))
        return {
          sql: u + p + this._emptyInsertValue,
          returning: l
        };
      return u += this._buildInsertData(f, p), {
        sql: u,
        returning: l
      };
    }
    //#endregion
    //#region Update
    // Compiles an `update` query, allowing for a return value.
    update() {
      return this.single.options && this.single.options.includeTriggerModifications ? this.updateWithTriggers() : this.standardUpdate();
    }
    updateWithTriggers() {
      const f = this.top(), u = this.with(), l = this._prepUpdate(this.single.update), p = this.join(), m = this.where(), h = this.order(), { returning: g } = this.single, v = this._buildTempTable(g);
      return {
        sql: u + v + `update ${f ? f + " " : ""}${this.tableName} set ` + l.join(", ") + (g ? ` ${this._returning("update", g, !0)}` : "") + (p ? ` from ${this.tableName} ${p}` : "") + (m ? ` ${m}` : "") + (h ? ` ${h}` : "") + (g ? this._buildReturningSelect(g) : this._returning("rowcount", "@@rowcount")),
        returning: g || "@@rowcount"
      };
    }
    _formatGroupsItemValue(f, u) {
      const l = super._formatGroupsItemValue(f);
      if (u && !(f instanceof i)) {
        const p = `IIF(${l} is null,`;
        if (u === "first")
          return `${p}0,1)`;
        if (u === "last")
          return `${p}1,0)`;
      }
      return l;
    }
    standardUpdate() {
      const f = this.top(), u = this.with(), l = this._prepUpdate(this.single.update), p = this.join(), m = this.where(), h = this.order(), { returning: g } = this.single;
      return {
        sql: u + `update ${f ? f + " " : ""}${this.tableName} set ` + l.join(", ") + (g ? ` ${this._returning("update", g)}` : "") + (p ? ` from ${this.tableName} ${p}` : "") + (m ? ` ${m}` : "") + (h ? ` ${h}` : "") + (g ? "" : this._returning("rowcount", "@@rowcount")),
        returning: g || "@@rowcount"
      };
    }
    //#endregion
    //#region Delete
    // Compiles a `delete` query.
    del() {
      return this.single.options && this.single.options.includeTriggerModifications ? this.deleteWithTriggers() : this.standardDelete();
    }
    deleteWithTriggers() {
      const f = this.with(), { tableName: u } = this, l = this.where(), p = this.join(), { returning: m } = this.single, h = m ? ` ${this._returning("del", m, !0)}` : "", g = p ? `${u}${h} ` : "";
      return {
        sql: f + `${this._buildTempTable(
          m
        )}delete ${g}from ${u}` + (p ? "" : h) + (p ? ` ${p}` : "") + (l ? ` ${l}` : "") + (m ? this._buildReturningSelect(m) : this._returning("rowcount", "@@rowcount")),
        returning: m || "@@rowcount"
      };
    }
    standardDelete() {
      const f = this.with(), { tableName: u } = this, l = this.where(), p = this.join(), { returning: m } = this.single, h = m ? ` ${this._returning("del", m)}` : "", g = p ? `${u}${h} ` : "";
      return {
        sql: f + `delete ${g}from ${u}` + (p ? "" : h) + (p ? ` ${p}` : "") + (l ? ` ${l}` : "") + (m ? "" : this._returning("rowcount", "@@rowcount")),
        returning: m || "@@rowcount"
      };
    }
    //#endregion
    // Compiles the columns in the query, specifying if an item was distinct.
    columns() {
      let f = "";
      if (this.onlyUnions())
        return "";
      const u = this.top(), l = this._hintComments(), p = this.grouped.columns || [];
      let m = -1, h = [];
      if (p)
        for (; ++m < p.length; ) {
          const v = p[m];
          if (v.distinct && (f = "distinct "), v.distinctOn) {
            f = this.distinctOn(v.value);
            continue;
          }
          v.type === "aggregate" ? h.push(...this.aggregate(v)) : v.type === "aggregateRaw" ? h.push(this.aggregateRaw(v)) : v.type === "analytic" ? h.push(this.analytic(v)) : v.type === "json" ? h.push(this.json(v)) : v.value && v.value.length > 0 && h.push(this.formatter.columnize(v.value));
        }
      return h.length === 0 && (h = ["*"]), `${this.onlyJson() ? "" : "select "}${l}${f}` + (u ? u + " " : "") + h.join(", ") + (this.tableName ? ` from ${this.tableName}` : "");
    }
    _returning(f, u, l) {
      switch (f) {
        case "update":
        case "insert":
          return u ? `output ${this.formatter.columnizeWithPrefix("inserted.", u)}${l ? " into #out" : ""}` : "";
        case "del":
          return u ? `output ${this.formatter.columnizeWithPrefix("deleted.", u)}${l ? " into #out" : ""}` : "";
        case "rowcount":
          return u ? ";select @@rowcount" : "";
      }
    }
    _buildTempTable(f) {
      if (f && f.length > 0) {
        let u = "";
        Array.isArray(f) ? u = f.map((p) => `[t].${this.formatter.columnize(p)}`).join(",") : u = `[t].${this.formatter.columnize(f)}`;
        let l = `select top(0) ${u} into #out `;
        return l += `from ${this.tableName} as t `, l += `left join ${this.tableName} on 0=1;`, l;
      }
      return "";
    }
    _buildReturningSelect(f) {
      if (f && f.length > 0) {
        let u = "";
        Array.isArray(f) ? u = f.map((p) => `${this.formatter.columnize(p)}`).join(",") : u = this.formatter.columnize(f);
        let l = `; select ${u} from #out; `;
        return l += "drop table #out;", l;
      }
      return "";
    }
    // Compiles a `truncate` query.
    truncate() {
      return `truncate table ${this.tableName}`;
    }
    forUpdate() {
      return "with (UPDLOCK)";
    }
    forShare() {
      return "with (HOLDLOCK)";
    }
    // Compiles a `columnInfo` query.
    columnInfo() {
      const f = this.single.columnInfo;
      let u = this.single.schema;
      const l = this.client.customWrapIdentifier(this.single.table, r);
      u && (u = this.client.customWrapIdentifier(u, r));
      let p = "select [COLUMN_NAME], [COLUMN_DEFAULT], [DATA_TYPE], [CHARACTER_MAXIMUM_LENGTH], [IS_NULLABLE] from INFORMATION_SCHEMA.COLUMNS where table_name = ? and table_catalog = ?";
      const m = [l, this.client.database()];
      return u ? (p += " and table_schema = ?", m.push(u)) : p += " and table_schema = 'dbo'", {
        sql: p,
        bindings: m,
        output(h) {
          const g = h.reduce((v, d) => (v[d[0].value] = {
            defaultValue: d[1].value,
            type: d[2].value,
            maxLength: d[3].value,
            nullable: d[4].value === "YES"
          }, v), {});
          return f && g[f] || g;
        }
      };
    }
    top() {
      const f = !this.single.limit && this.single.limit !== 0, u = !this.single.offset;
      return f || !u ? "" : `top (${this._getValueOrParameterFromAttribute("limit")})`;
    }
    limit() {
      return "";
    }
    offset() {
      const f = !this.single.limit && this.single.limit !== 0, u = !this.single.offset;
      if (u)
        return "";
      let l = `offset ${u ? "0" : this._getValueOrParameterFromAttribute("offset")} rows`;
      return f || (l += ` fetch next ${this._getValueOrParameterFromAttribute(
        "limit"
      )} rows only`), l;
    }
    whereLike(f) {
      return `${this._columnClause(
        f
      )} collate SQL_Latin1_General_CP1_CS_AS ${this._not(
        f,
        "like "
      )}${this._valueClause(f)}`;
    }
    whereILike(f) {
      return `${this._columnClause(
        f
      )} collate SQL_Latin1_General_CP1_CI_AS ${this._not(
        f,
        "like "
      )}${this._valueClause(f)}`;
    }
    jsonExtract(f) {
      return this._jsonExtract(
        f.singleValue ? "JSON_VALUE" : "JSON_QUERY",
        f
      );
    }
    jsonSet(f) {
      return this._jsonSet("JSON_MODIFY", f);
    }
    jsonInsert(f) {
      return this._jsonSet("JSON_MODIFY", f);
    }
    jsonRemove(f) {
      const u = `JSON_MODIFY(${a(
        f.column,
        this.builder,
        this.client,
        this.bindingsHolder
      )},${this.client.parameter(
        f.path,
        this.builder,
        this.bindingsHolder
      )}, NULL)`;
      return f.alias ? this.client.alias(u, this.formatter.wrap(f.alias)) : u;
    }
    whereJsonPath(f) {
      return this._whereJsonPath("JSON_VALUE", f);
    }
    whereJsonSupersetOf(f) {
      throw new Error(
        "Json superset where clause not actually supported by MSSQL"
      );
    }
    whereJsonSubsetOf(f) {
      throw new Error("Json subset where clause not actually supported by MSSQL");
    }
    _getExtracts(f, u) {
      const l = a(
        f.column,
        this.builder,
        this.client,
        this.bindingsHolder
      );
      return (Array.isArray(f.values) ? f.values : [f.values]).map(function(p) {
        return "JSON_VALUE(" + l + "," + this.client.parameter(p, this.builder, this.bindingsHolder) + ")";
      }, this).join(u);
    }
    onJsonPathEquals(f) {
      return this._onJsonPathEquals("JSON_VALUE", f);
    }
  }
  return Jp = o, Jp;
}
var Xp, ax;
function $ae() {
  if (ax)
    return Xp;
  ax = 1;
  const t = Hi;
  class e extends t {
    constructor(i, a) {
      super(i, a);
    }
    dropTableIfExists(i) {
      const a = this.formatter.wrap(r(this.schema, i));
      this.pushQuery(
        `if object_id('${a}', 'U') is not null DROP TABLE ${a}`
      );
    }
    dropViewIfExists(i) {
      const a = this.formatter.wrap(r(this.schema, i));
      this.pushQuery(
        `if object_id('${a}', 'V') is not null DROP VIEW ${a}`
      );
    }
    // Rename a table on the schema.
    renameTable(i, a) {
      this.pushQuery(
        `exec sp_rename ${this.client.parameter(
          r(this.schema, i),
          this.builder,
          this.bindingsHolder
        )}, ${this.client.parameter(a, this.builder, this.bindingsHolder)}`
      );
    }
    renameView(i, a) {
      this.pushQuery(
        `exec sp_rename ${this.client.parameter(
          r(this.schema, i),
          this.builder,
          this.bindingsHolder
        )}, ${this.client.parameter(a, this.builder, this.bindingsHolder)}`
      );
    }
    // Check whether a table exists on the query.
    hasTable(i) {
      const a = this.client.parameter(
        r(this.schema, i),
        this.builder,
        this.bindingsHolder
      ), s = [i];
      let o = `SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = ${a}`;
      this.schema && (o += " AND TABLE_SCHEMA = ?", s.push(this.schema)), this.pushQuery({ sql: o, bindings: s, output: (c) => c.length > 0 });
    }
    // Check whether a column exists on the schema.
    hasColumn(i, a) {
      const s = this.client.parameter(
        a,
        this.builder,
        this.bindingsHolder
      ), o = this.client.parameter(
        this.formatter.wrap(r(this.schema, i)),
        this.builder,
        this.bindingsHolder
      ), c = `select object_id from sys.columns where name = ${s} and object_id = object_id(${o})`;
      this.pushQuery({ sql: c, output: (f) => f.length > 0 });
    }
  }
  e.prototype.dropTablePrefix = "DROP TABLE ";
  function r(n, i) {
    return n ? `${n}.${i}` : i;
  }
  return Xp = e, Xp;
}
var Zp, sx;
function Iae() {
  if (sx)
    return Zp;
  sx = 1;
  const t = Wi, e = wt, { isObject: r } = Je;
  class n extends t {
    constructor(a, s) {
      super(a, s);
    }
    createQuery(a, s, o) {
      let c = s ? `if object_id('${this.tableName()}', 'U') is null ` : "";
      o ? c += `SELECT * INTO ${this.tableName()} FROM ${this.tableNameLike()} WHERE 0=1` : c += "CREATE TABLE " + this.tableName() + (this._formatting ? ` (
    ` : " (") + a.sql.join(this._formatting ? `,
    ` : ", ") + this._addChecks() + ")", this.pushQuery(c), this.single.comment && this.comment(this.single.comment), o && this.addColumns(a, this.addColumnsPrefix);
    }
    comment(a) {
      if (!a)
        return;
      a.length > 7500 / 2 && this.client.logger.warn(
        "Your comment might be longer than the max comment length for MSSQL of 7,500 bytes."
      );
      const s = this.formatter.escapingStringDelimiters(a), o = this.formatter.escapingStringDelimiters(
        this.schemaNameRaw || "dbo"
      ), c = this.formatter.escapingStringDelimiters(
        this.tableNameRaw
      ), f = `N'MS_Description', N'${s}', N'Schema', N'${o}', N'Table', N'${c}'`, u = `EXISTS(SELECT * FROM sys.fn_listextendedproperty(N'MS_Description', N'Schema', N'${o}', N'Table', N'${c}', NULL, NULL))`;
      this.pushQuery(
        `IF ${u}
  EXEC sys.sp_updateextendedproperty ${f}
ELSE
  EXEC sys.sp_addextendedproperty ${f}`
      );
    }
    // Compiles column add.  Multiple columns need only one ADD clause (not one ADD per column) so core addColumns doesn't work.  #1348
    addColumns(a, s) {
      s = s || this.addColumnsPrefix, a.sql.length > 0 && this.pushQuery({
        sql: (this.lowerCase ? "alter table " : "ALTER TABLE ") + this.tableName() + " " + s + a.sql.join(", "),
        bindings: a.bindings
      });
    }
    alterColumns(a, s) {
      for (let o = 0, c = s.length; o < c; o++) {
        const f = s[o];
        if (f.modified.defaultTo) {
          const l = `
              DECLARE @constraint varchar(100) = (SELECT default_constraints.name
                                                  FROM sys.all_columns
                                                  INNER JOIN sys.tables
                                                    ON all_columns.object_id = tables.object_id
                                                  INNER JOIN sys.schemas
                                                    ON tables.schema_id = schemas.schema_id
                                                  INNER JOIN sys.default_constraints
                                                    ON all_columns.default_object_id = default_constraints.object_id
                                                  WHERE schemas.name = '${this.schemaNameRaw || "dbo"}'
                                                  AND tables.name = '${this.tableNameRaw}'
                                                  AND all_columns.name = '${f.getColumnName()}')

              IF @constraint IS NOT NULL EXEC('ALTER TABLE ${this.tableNameRaw} DROP CONSTRAINT ' + @constraint)`;
          this.pushQuery(l);
        }
      }
      a.sql.forEach((o) => {
        this.pushQuery({
          sql: (this.lowerCase ? "alter table " : "ALTER TABLE ") + this.tableName() + " " + (this.lowerCase ? this.alterColumnPrefix.toLowerCase() : this.alterColumnPrefix) + o,
          bindings: a.bindings
        });
      });
    }
    // Compiles column drop.  Multiple columns need only one DROP clause (not one DROP per column) so core dropColumn doesn't work.  #1348
    dropColumn() {
      const a = this, s = e.normalizeArr.apply(null, arguments), c = (Array.isArray(s) ? s : [s]).map((u) => a.formatter.wrap(u)), f = this.schemaNameRaw || "dbo";
      for (const u of s) {
        const l = `
              DECLARE @constraint varchar(100) = (SELECT default_constraints.name
                                                  FROM sys.all_columns
                                                  INNER JOIN sys.tables
                                                    ON all_columns.object_id = tables.object_id
                                                  INNER JOIN sys.schemas
                                                    ON tables.schema_id = schemas.schema_id
                                                  INNER JOIN sys.default_constraints
                                                    ON all_columns.default_object_id = default_constraints.object_id
                                                  WHERE schemas.name = '${f}'
                                                  AND tables.name = '${this.tableNameRaw}'
                                                  AND all_columns.name = '${u}')

              IF @constraint IS NOT NULL EXEC('ALTER TABLE ${this.tableNameRaw} DROP CONSTRAINT ' + @constraint)`;
        this.pushQuery(l);
      }
      this.pushQuery(
        (this.lowerCase ? "alter table " : "ALTER TABLE ") + this.tableName() + " " + this.dropColumnPrefix + c.join(", ")
      );
    }
    changeType() {
    }
    // Renames a column on the table.
    renameColumn(a, s) {
      this.pushQuery(
        `exec sp_rename ${this.client.parameter(
          this.tableName() + "." + a,
          this.tableBuilder,
          this.bindingsHolder
        )}, ${this.client.parameter(
          s,
          this.tableBuilder,
          this.bindingsHolder
        )}, 'COLUMN'`
      );
    }
    dropFKRefs(a, s) {
      const o = this.client.formatter(this.tableBuilder);
      return Promise.all(
        s.map(function(c) {
          const f = o.wrap(c.CONSTRAINT_NAME), u = o.wrap(c.TABLE_NAME);
          return a.query({
            sql: `ALTER TABLE ${u} DROP CONSTRAINT ${f}`
          });
        })
      );
    }
    createFKRefs(a, s) {
      const o = this.client.formatter(this.tableBuilder);
      return Promise.all(
        s.map(function(c) {
          const f = o.wrap(c.TABLE_NAME), u = o.wrap(c.CONSTRAINT_NAME), l = o.columnize(c.COLUMN_NAME), p = o.columnize(c.REFERENCED_COLUMN_NAME), m = o.wrap(c.REFERENCED_TABLE_NAME), h = ` ON UPDATE ${c.UPDATE_RULE}`, g = ` ON DELETE ${c.DELETE_RULE}`;
          return a.query({
            sql: `ALTER TABLE ${f} ADD CONSTRAINT ${u} FOREIGN KEY (` + l + ") REFERENCES " + m + " (" + p + ")" + h + g
          });
        })
      );
    }
    index(a, s, o) {
      s = s ? this.formatter.wrap(s) : this._indexCommand("index", this.tableNameRaw, a);
      let c;
      r(o) && ({ predicate: c } = o);
      const f = c ? " " + this.client.queryCompiler(c).where() : "";
      this.pushQuery(
        `CREATE INDEX ${s} ON ${this.tableName()} (${this.formatter.columnize(
          a
        )})${f}`
      );
    }
    /**
     * Create a primary key.
     *
     * @param {undefined | string | string[]} columns
     * @param {string | {constraintName: string, deferrable?: 'not deferrable'|'deferred'|'immediate' }} constraintName
     */
    primary(a, s) {
      let o;
      r(s) && ({ constraintName: s, deferrable: o } = s), o && o !== "not deferrable" && this.client.logger.warn(
        `mssql: primary key constraint [${s}] will not be deferrable ${o} because mssql does not support deferred constraints.`
      ), s = s ? this.formatter.wrap(s) : this.formatter.wrap(`${this.tableNameRaw}_pkey`), this.forCreate ? this.pushQuery(
        `CONSTRAINT ${s} PRIMARY KEY (${this.formatter.columnize(
          a
        )})`
      ) : this.pushQuery(
        `ALTER TABLE ${this.tableName()} ADD CONSTRAINT ${s} PRIMARY KEY (${this.formatter.columnize(
          a
        )})`
      );
    }
    /**
     * Create a unique index.
     *
     * @param {string | string[]} columns
     * @param {string | {indexName: undefined | string, deferrable?: 'not deferrable'|'deferred'|'immediate', useConstraint?: true|false, predicate?: QueryBuilder }} indexName
     */
    unique(a, s) {
      let o, c = !1, f;
      if (r(s) && ({ indexName: s, deferrable: o, useConstraint: c, predicate: f } = s), o && o !== "not deferrable" && this.client.logger.warn(
        `mssql: unique index [${s}] will not be deferrable ${o} because mssql does not support deferred constraints.`
      ), c && f)
        throw new Error("mssql cannot create constraint with predicate");
      if (s = s ? this.formatter.wrap(s) : this._indexCommand("unique", this.tableNameRaw, a), Array.isArray(a) || (a = [a]), c)
        this.pushQuery(
          `ALTER TABLE ${this.tableName()} ADD CONSTRAINT ${s} UNIQUE (${this.formatter.columnize(
            a
          )})`
        );
      else {
        const u = f ? " " + this.client.queryCompiler(f).where() : " WHERE " + a.map((l) => this.formatter.columnize(l) + " IS NOT NULL").join(" AND ");
        this.pushQuery(
          `CREATE UNIQUE INDEX ${s} ON ${this.tableName()} (${this.formatter.columnize(
            a
          )})${u}`
        );
      }
    }
    // Compile a drop index command.
    dropIndex(a, s) {
      s = s ? this.formatter.wrap(s) : this._indexCommand("index", this.tableNameRaw, a), this.pushQuery(`DROP INDEX ${s} ON ${this.tableName()}`);
    }
    // Compile a drop foreign key command.
    dropForeign(a, s) {
      s = s ? this.formatter.wrap(s) : this._indexCommand("foreign", this.tableNameRaw, a), this.pushQuery(
        `ALTER TABLE ${this.tableName()} DROP CONSTRAINT ${s}`
      );
    }
    // Compile a drop primary key command.
    dropPrimary(a) {
      a = a ? this.formatter.wrap(a) : this.formatter.wrap(`${this.tableNameRaw}_pkey`), this.pushQuery(
        `ALTER TABLE ${this.tableName()} DROP CONSTRAINT ${a}`
      );
    }
    // Compile a drop unique key command.
    dropUnique(a, s) {
      s = s ? this.formatter.wrap(s) : this._indexCommand("unique", this.tableNameRaw, a), this.pushQuery(`DROP INDEX ${s} ON ${this.tableName()}`);
    }
  }
  return n.prototype.createAlterTableMethods = ["foreign", "primary"], n.prototype.lowerCase = !1, n.prototype.addColumnsPrefix = "ADD ", n.prototype.dropColumnPrefix = "DROP COLUMN ", n.prototype.alterColumnPrefix = "ALTER COLUMN ", Zp = n, Zp;
}
var Yp, ox;
function kae() {
  if (ox)
    return Yp;
  ox = 1;
  const t = Gi, {
    columnize: e
  } = xt;
  class r extends t {
    constructor(i, a) {
      super(i, a);
    }
    createQuery(i, a, s, o) {
      let f = "CREATE " + (o ? "OR ALTER " : "") + "VIEW " + this.viewName();
      const u = i ? " (" + e(
        i,
        this.viewBuilder,
        this.client,
        this.bindingsHolder
      ) + ")" : "";
      f += u, f += " AS ", f += a.toString(), this.pushQuery({
        sql: f
      });
    }
    renameColumn(i, a) {
      this.pushQuery(
        `exec sp_rename ${this.client.parameter(
          this.viewName() + "." + i,
          this.viewBuilder,
          this.bindingsHolder
        )}, ${this.client.parameter(
          a,
          this.viewBuilder,
          this.bindingsHolder
        )}, 'COLUMN'`
      );
    }
    createOrReplace() {
      this.createQuery(this.columns, this.selectQuery, !1, !0);
    }
  }
  return Yp = r, Yp;
}
var ef, cx;
function Rae() {
  if (cx)
    return ef;
  cx = 1;
  const t = Wn, { toNumber: e } = wt, { formatDefault: r } = Un, { operator: n } = xt;
  class i extends t {
    constructor(s, o, c) {
      super(s, o, c), this.modifiers = ["nullable", "defaultTo", "first", "after", "comment"], this._addCheckModifiers();
    }
    // Types
    // ------
    double(s, o) {
      return "float";
    }
    floating(s, o) {
      return "float";
    }
    integer() {
      return "int";
    }
    tinyint() {
      return "tinyint";
    }
    varchar(s) {
      return `nvarchar(${e(s, 255)})`;
    }
    timestamp({ useTz: s = !1 } = {}) {
      return s ? "datetimeoffset" : "datetime2";
    }
    bit(s) {
      return s > 1 && this.client.logger.warn("Bit field is exactly 1 bit length for MSSQL"), "bit";
    }
    binary(s) {
      return s ? `varbinary(${e(s)})` : "varbinary(max)";
    }
    // Modifiers
    // ------
    first() {
      return this.client.logger.warn("Column first modifier not available for MSSQL"), "";
    }
    after(s) {
      return this.client.logger.warn("Column after modifier not available for MSSQL"), "";
    }
    defaultTo(s, { constraintName: o } = {}) {
      const c = r(s, this.type, this.client);
      return o = typeof o < "u" ? o : `${this.tableCompiler.tableNameRaw}_${this.getColumnName()}_default`.toLowerCase(), this.columnBuilder._method === "alter" ? (this.pushAdditional(function() {
        this.pushQuery(
          `ALTER TABLE ${this.tableCompiler.tableName()} ADD CONSTRAINT ${this.formatter.wrap(
            o
          )} DEFAULT ${c} FOR ${this.formatter.wrap(
            this.getColumnName()
          )}`
        );
      }), "") : o ? `CONSTRAINT ${this.formatter.wrap(
        o
      )} DEFAULT ${c}` : `DEFAULT ${c}`;
    }
    comment(s) {
      if (!s)
        return;
      s && s.length > 7500 / 2 && this.client.logger.warn(
        "Your comment might be longer than the max comment length for MSSQL of 7,500 bytes."
      );
      const o = this.formatter.escapingStringDelimiters(s), c = this.tableCompiler.schemaNameRaw || "dbo", f = this.formatter.escapingStringDelimiters(
        this.tableCompiler.tableNameRaw
      ), u = this.formatter.escapingStringDelimiters(
        this.args[0] || this.defaults("columnName")
      ), l = `N'MS_Description', N'${o}', N'Schema', N'${c}', N'Table', N'${f}', N'Column', N'${u}'`;
      return this.pushAdditional(function() {
        const p = `EXISTS(SELECT * FROM sys.fn_listextendedproperty(N'MS_Description', N'Schema', N'${c}', N'Table', N'${f}', N'Column', N'${u}'))`;
        this.pushQuery(
          `IF ${p}
  EXEC sys.sp_updateextendedproperty ${l}
ELSE
  EXEC sys.sp_addextendedproperty ${l}`
        );
      }), "";
    }
    checkLength(s, o, c) {
      return this._check(
        `LEN(${this.formatter.wrap(this.getColumnName())}) ${n(
          s,
          this.columnBuilder,
          this.bindingsHolder
        )} ${e(o)}`,
        c
      );
    }
    checkRegex(s, o) {
      return this._check(
        `${this.formatter.wrap(
          this.getColumnName()
        )} LIKE ${this.client._escapeBinding("%" + s + "%")}`,
        o
      );
    }
    increments(s = { primaryKey: !0 }) {
      return "int identity(1,1) not null" + (this.tableCompiler._canBeAddPrimaryKey(s) ? " primary key" : "");
    }
    bigincrements(s = { primaryKey: !0 }) {
      return "bigint identity(1,1) not null" + (this.tableCompiler._canBeAddPrimaryKey(s) ? " primary key" : "");
    }
  }
  return i.prototype.bigint = "bigint", i.prototype.mediumint = "int", i.prototype.smallint = "smallint", i.prototype.text = "nvarchar(max)", i.prototype.mediumtext = "nvarchar(max)", i.prototype.longtext = "nvarchar(max)", i.prototype.json = i.prototype.jsonb = "nvarchar(max)", i.prototype.enu = "nvarchar(100)", i.prototype.uuid = ({ useBinaryUuid: a = !1 } = {}) => a ? "binary(16)" : "uniqueidentifier", i.prototype.datetime = "datetime2", i.prototype.bool = "bit", ef = i, ef;
}
var tf, ux;
function Nae() {
  if (ux)
    return tf;
  ux = 1;
  const t = zn, e = Cae(), r = Gn, n = Tae(), i = Oae(), a = Aae(), s = $ae(), o = Iae(), c = kae(), f = Rae(), u = pn, l = ar("knex:mssql"), p = { MIN: -2147483648, MAX: 2147483647 }, m = { MIN: -9007199254740991, MAX: 9007199254740991 };
  class h extends r {
    constructor(v = {}) {
      super(v);
    }
    /**
     * @param {import('knex').Config} options
     */
    _generateConnection() {
      const v = this.connectionSettings;
      v.options = v.options || {};
      const d = {
        authentication: {
          type: v.type || "default",
          options: {
            userName: v.userName || v.user,
            password: v.password,
            domain: v.domain,
            token: v.token,
            clientId: v.clientId,
            clientSecret: v.clientSecret,
            tenantId: v.tenantId,
            msiEndpoint: v.msiEndpoint
          }
        },
        server: v.server || v.host,
        options: {
          database: v.database,
          encrypt: v.encrypt || !1,
          port: v.port || 1433,
          connectTimeout: v.connectionTimeout || v.timeout || 15e3,
          requestTimeout: e(v.requestTimeout) ? 15e3 : v.requestTimeout,
          rowCollectionOnDone: !1,
          rowCollectionOnRequestCompletion: !1,
          useColumnNames: !1,
          tdsVersion: v.options.tdsVersion || "7_4",
          appName: v.options.appName || "knex",
          trustServerCertificate: !1,
          ...v.options
        }
      };
      return d.options.instanceName && delete d.options.port, isNaN(d.options.requestTimeout) && (d.options.requestTimeout = 15e3), d.options.requestTimeout === 1 / 0 && (d.options.requestTimeout = 0), d.options.requestTimeout < 0 && (d.options.requestTimeout = 0), v.debug && (d.options.debug = {
        packet: !0,
        token: !0,
        data: !0,
        payload: !0
      }), d;
    }
    _driver() {
      return se;
    }
    formatter() {
      return new n(this, ...arguments);
    }
    transaction() {
      return new i(this, ...arguments);
    }
    queryCompiler() {
      return new a(this, ...arguments);
    }
    schemaCompiler() {
      return new s(this, ...arguments);
    }
    tableCompiler() {
      return new o(this, ...arguments);
    }
    viewCompiler() {
      return new c(this, ...arguments);
    }
    queryBuilder() {
      return new u(this);
    }
    columnCompiler() {
      return new f(this, ...arguments);
    }
    wrapIdentifierImpl(v) {
      return v === "*" ? "*" : `[${v.replace(/[[\]]+/g, "")}]`;
    }
    // Get a raw connection, called by the `pool` whenever a new
    // connection needs to be added to the pool.
    acquireRawConnection() {
      return new Promise((v, d) => {
        l("connection::connection new connection requested");
        const y = this._driver(), x = Object.assign({}, this._generateConnection()), b = new y.Connection(x);
        b.connect((w) => w ? (l("connection::connect error: %s", w.message), d(w)) : (l("connection::connect connected to server"), b.connected = !0, b.on("error", (S) => {
          l("connection::error message=%s", S.message), b.__knex__disposed = S, b.connected = !1;
        }), b.once("end", () => {
          b.connected = !1, b.__knex__disposed = "Connection to server was terminated.", l("connection::end connection ended.");
        }), v(b)));
      });
    }
    validateConnection(v) {
      return v && v.connected;
    }
    // Used to explicitly close a connection, called internally by the pool
    // when a connection times out or the pool is shutdown.
    destroyRawConnection(v) {
      return l("connection::destroy"), new Promise((d) => {
        v.once("end", () => {
          d();
        }), v.close();
      });
    }
    // Position the bindings for the query.
    positionBindings(v) {
      let d = -1;
      return v.replace(/\\?\?/g, (y) => y === "\\?" ? "?" : (d += 1, `@p${d}`));
    }
    _chomp(v) {
      if (v.state.name === "LoggedIn") {
        const d = this.requestQueue.pop();
        d && (l(
          "connection::query executing query, %d more in queue",
          this.requestQueue.length
        ), v.execSql(d));
      }
    }
    _enqueueRequest(v, d) {
      this.requestQueue.push(v), this._chomp(d);
    }
    _makeRequest(v, d) {
      const y = this._driver(), x = typeof v == "string" ? v : v.sql;
      let b = 0;
      if (!x)
        throw new Error("The query is empty");
      l("request::request sql=%s", x);
      const w = new y.Request(x, (S, T) => {
        if (S)
          return l("request::error message=%s", S.message), d(S);
        b = T, l("request::callback rowCount=%d", b);
      });
      return w.on("prepared", () => {
        l("request %s::request prepared", this.id);
      }), w.on("done", (S, T) => {
        l("request::done rowCount=%d more=%s", S, T);
      }), w.on("doneProc", (S, T) => {
        l(
          "request::doneProc id=%s rowCount=%d more=%s",
          w.id,
          S,
          T
        );
      }), w.on("doneInProc", (S, T) => {
        l(
          "request::doneInProc id=%s rowCount=%d more=%s",
          w.id,
          S,
          T
        );
      }), w.once("requestCompleted", () => (l("request::completed id=%s", w.id), d(null, b))), w.on("error", (S) => (l("request::error id=%s message=%s", w.id, S.message), d(S))), w;
    }
    // Grab a connection, run the query via the MSSQL streaming interface,
    // and pass that through to the stream we've sent back to the client.
    _stream(v, d, y) {
      return new Promise((x, b) => {
        const w = this._makeRequest(d, (S) => {
          if (S)
            return y.emit("error", S), b(S);
          x();
        });
        w.on("row", (S) => {
          y.write(
            S.reduce(
              (T, E) => ({
                ...T,
                [E.metadata.colName]: E.value
              }),
              {}
            )
          );
        }), w.on("error", (S) => {
          y.emit("error", S), b(S);
        }), w.once("requestCompleted", () => {
          y.end(), x();
        }), this._assignBindings(w, d.bindings), this._enqueueRequest(w, v);
      });
    }
    _assignBindings(v, d) {
      if (Array.isArray(d))
        for (let y = 0; y < d.length; y++) {
          const x = d[y];
          this._setReqInput(v, y, x);
        }
    }
    _scaleForBinding(v) {
      if (v % 1 === 0)
        throw new Error(`The binding value ${v} must be a decimal number.`);
      return { scale: 10 };
    }
    _typeForBinding(v) {
      const d = this._driver();
      if (this.connectionSettings.options && this.connectionSettings.options.mapBinding) {
        const y = this.connectionSettings.options.mapBinding(v);
        if (y)
          return [y.value, y.type];
      }
      switch (typeof v) {
        case "string":
          return [v, d.TYPES.NVarChar];
        case "boolean":
          return [v, d.TYPES.Bit];
        case "number": {
          if (v % 1 !== 0)
            return [v, d.TYPES.Float];
          if (v < p.MIN || v > p.MAX) {
            if (v < m.MIN || v > m.MAX)
              throw new Error(
                `Bigint must be safe integer or must be passed as string, saw ${v}`
              );
            return [v, d.TYPES.BigInt];
          }
          return [v, d.TYPES.Int];
        }
        default:
          return v instanceof Date ? [v, d.TYPES.DateTime] : v instanceof Buffer ? [v, d.TYPES.VarBinary] : [v, d.TYPES.NVarChar];
      }
    }
    // Runs the query on the specified connection, providing the bindings
    // and any other necessary prep work.
    _query(v, d) {
      return new Promise((y, x) => {
        const b = [], w = this._makeRequest(d, (S, T) => {
          if (S)
            return x(S);
          d.response = b, process.nextTick(() => this._chomp(v)), y(d);
        });
        w.on("row", (S) => {
          l("request::row"), b.push(S);
        }), this._assignBindings(w, d.bindings), this._enqueueRequest(w, v);
      });
    }
    // sets a request input parameter. Detects bigints and decimals and sets type appropriately.
    _setReqInput(v, d, y) {
      const [x, b] = this._typeForBinding(y), w = "p".concat(d);
      let S;
      typeof x == "number" && x % 1 !== 0 && (S = this._scaleForBinding(x)), l(
        "request::binding pos=%d type=%s value=%s",
        d,
        b.name,
        x
      ), Buffer.isBuffer(x) && (S = {
        length: "max"
      }), v.addParameter(w, b, x, S);
    }
    // Process the response as returned from the query.
    processResponse(v, d) {
      if (v == null)
        return;
      let { response: y } = v;
      const { method: x } = v;
      if (v.output || (y = y.map(
        (b) => b.reduce((w, S) => {
          const T = S.metadata.colName;
          return w[T] ? (Array.isArray(w[T]) || (w[T] = [w[T]]), w[T].push(S.value)) : w[T] = S.value, w;
        }, {})
      ), v.output))
        return v.output.call(d, y);
      switch (x) {
        case "select":
          return y;
        case "first":
          return y[0];
        case "pluck":
          return t(y, v.pluck);
        case "insert":
        case "del":
        case "update":
        case "counter":
          return v.returning && v.returning === "@@rowcount" ? y[0][""] : y;
        default:
          return y;
      }
    }
  }
  return Object.assign(h.prototype, {
    requestQueue: [],
    dialect: "mssql",
    driverName: "mssql"
  }), tf = h, tf;
}
var rf, lx;
function Lae() {
  if (lx)
    return rf;
  lx = 1;
  var t = "Expected a function";
  function e(r, n, i) {
    if (typeof r != "function")
      throw new TypeError(t);
    return setTimeout(function() {
      r.apply(void 0, i);
    }, n);
  }
  return rf = e, rf;
}
var nf, px;
function Pae() {
  if (px)
    return nf;
  px = 1;
  var t = Lae(), e = Tv, r = e(function(n, i) {
    return t(n, 1, i);
  });
  return nf = r, nf;
}
var af, fx;
function Dae() {
  if (fx)
    return af;
  fx = 1;
  const t = ln, r = ar("knex:tx");
  class n extends t {
    query(a, s, o, c) {
      const f = this, u = this.trxClient.query(a, s).catch((l) => {
        if (l.errno === 1305) {
          this.trxClient.logger.warn(
            "Transaction was implicitly committed, do not mix transactions and DDL with MySQL (#805)"
          );
          return;
        }
        o = 2, c = l, f._completed = !0, r("%s error running transaction query", f.txid);
      }).then(function(l) {
        if (o === 1 && f._resolver(c), o === 2) {
          if (c === void 0) {
            if (f.doNotRejectOnRollback && /^ROLLBACK\b/i.test(s)) {
              f._resolver();
              return;
            }
            c = new Error(`Transaction rejected with non-error: ${c}`);
          }
          f._rejecter(c);
        }
        return l;
      });
      return (o === 1 || o === 2) && (f._completed = !0), u;
    }
  }
  return af = n, af;
}
var sf, hx;
function Mae() {
  if (hx)
    return sf;
  hx = 1;
  const t = se, e = Wt, r = un, n = sr, i = Hn, { wrapAsIdentifier: a } = Un, {
    columnize: s,
    wrap: o
  } = xt, c = (u) => r(u) || Array.isArray(u);
  class f extends i {
    constructor(l, p, m) {
      super(l, p, m);
      const { returning: h } = this.single;
      h && this.client.logger.warn(
        ".returning() is not supported by mysql and will not have any effect."
      ), this._emptyInsertValue = "() values ()";
    }
    // Compiles an `insert` query, allowing for multiple
    // inserts using a single query statement.
    insert() {
      let l = super.insert();
      if (l === "")
        return l;
      const { ignore: p, merge: m, insert: h } = this.single;
      if (p && (l = l.replace("insert into", "insert ignore into")), m && (l += this._merge(m.updates, h), this.where()))
        throw new Error(
          ".onConflict().merge().where() is not supported for mysql"
        );
      return l;
    }
    // Compiles merge for onConflict, allowing for different merge strategies
    _merge(l, p) {
      const m = " on duplicate key update ";
      if (l && Array.isArray(l))
        return m + l.map(
          (h) => a(h, this.formatter.builder, this.client)
        ).map((h) => `${h} = values(${h})`).join(", ");
      if (l && typeof l == "object") {
        const h = this._prepUpdate(l);
        return m + h.join(",");
      } else {
        const h = this._prepInsert(p);
        if (typeof h == "string")
          throw new Error(
            "If using merge with a raw insert query, then updates must be provided"
          );
        return m + h.columns.map((g) => a(g, this.builder, this.client)).map((g) => `${g} = values(${g})`).join(", ");
      }
    }
    // Update method, including joins, wheres, order & limits.
    update() {
      const l = this.with(), p = this.join(), m = this._prepUpdate(this.single.update), h = this.where(), g = this.order(), v = this.limit();
      return l + `update ${this.tableName}` + (p ? ` ${p}` : "") + " set " + m.join(", ") + (h ? ` ${h}` : "") + (g ? ` ${g}` : "") + (v ? ` ${v}` : "");
    }
    forUpdate() {
      return "for update";
    }
    forShare() {
      return "lock in share mode";
    }
    // Only supported on MySQL 8.0+
    skipLocked() {
      return "skip locked";
    }
    // Supported on MySQL 8.0+ and MariaDB 10.3.0+
    noWait() {
      return "nowait";
    }
    // Compiles a `columnInfo` query.
    columnInfo() {
      const l = this.single.columnInfo;
      return {
        sql: "select * from information_schema.columns where table_name = ? and table_schema = ?",
        bindings: [this.client.customWrapIdentifier(this.single.table, e), this.client.database()],
        output(m) {
          const h = m.reduce(function(g, v) {
            return g[v.COLUMN_NAME] = {
              defaultValue: v.COLUMN_DEFAULT === "NULL" ? null : v.COLUMN_DEFAULT,
              type: v.DATA_TYPE,
              maxLength: v.CHARACTER_MAXIMUM_LENGTH,
              nullable: v.IS_NULLABLE === "YES"
            }, g;
          }, {});
          return l && h[l] || h;
        }
      };
    }
    limit() {
      const l = !this.single.limit && this.single.limit !== 0;
      return l && !this.single.offset ? "" : `limit ${this.single.offset && l ? "18446744073709551615" : this._getValueOrParameterFromAttribute("limit")}`;
    }
    whereBasic(l) {
      return t(
        !c(l.value),
        "The values in where clause must not be object or array."
      ), super.whereBasic(l);
    }
    whereRaw(l) {
      return t(
        n(l.value.bindings) || !Object.values(l.value.bindings).some(c),
        "The values in where clause must not be object or array."
      ), super.whereRaw(l);
    }
    whereLike(l) {
      return `${this._columnClause(l)} ${this._not(
        l,
        "like "
      )}${this._valueClause(l)} COLLATE utf8_bin`;
    }
    whereILike(l) {
      return `${this._columnClause(l)} ${this._not(
        l,
        "like "
      )}${this._valueClause(l)}`;
    }
    // Json functions
    jsonExtract(l) {
      return this._jsonExtract(["json_extract", "json_unquote"], l);
    }
    jsonSet(l) {
      return this._jsonSet("json_set", l);
    }
    jsonInsert(l) {
      return this._jsonSet("json_insert", l);
    }
    jsonRemove(l) {
      const p = `json_remove(${s(
        l.column,
        this.builder,
        this.client,
        this.bindingsHolder
      )},${this.client.parameter(
        l.path,
        this.builder,
        this.bindingsHolder
      )})`;
      return l.alias ? this.client.alias(p, this.formatter.wrap(l.alias)) : p;
    }
    whereJsonObject(l) {
      return this._not(
        l,
        `json_contains(${this._columnClause(l)}, ${this._jsonValueClause(
          l
        )})`
      );
    }
    whereJsonPath(l) {
      return this._whereJsonPath("json_extract", l);
    }
    whereJsonSupersetOf(l) {
      return this._not(
        l,
        `json_contains(${o(
          l.column,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        )},${this._jsonValueClause(l)})`
      );
    }
    whereJsonSubsetOf(l) {
      return this._not(
        l,
        `json_contains(${this._jsonValueClause(l)},${o(
          l.column,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        )})`
      );
    }
    onJsonPathEquals(l) {
      return this._onJsonPathEquals("json_extract", l);
    }
  }
  return sf = f, sf;
}
var of, dx;
function qae() {
  if (dx)
    return of;
  dx = 1;
  const t = Hi;
  class e extends t {
    constructor(n, i) {
      super(n, i);
    }
    // Rename a table on the schema.
    renameTable(n, i) {
      this.pushQuery(
        `rename table ${this.formatter.wrap(n)} to ${this.formatter.wrap(
          i
        )}`
      );
    }
    renameView(n, i) {
      this.renameTable(n, i);
    }
    // Check whether a table exists on the query.
    hasTable(n) {
      let i = "select * from information_schema.tables where table_name = ?";
      const a = [n];
      this.schema ? (i += " and table_schema = ?", a.push(this.schema)) : i += " and table_schema = database()", this.pushQuery({
        sql: i,
        bindings: a,
        output: function(o) {
          return o.length > 0;
        }
      });
    }
    // Check whether a column exists on the schema.
    hasColumn(n, i) {
      this.pushQuery({
        sql: `show columns from ${this.formatter.wrap(n)}`,
        output(a) {
          return a.some((s) => this.client.wrapIdentifier(s.Field.toLowerCase()) === this.client.wrapIdentifier(i.toLowerCase()));
        }
      });
    }
  }
  return of = e, of;
}
var cf, mx;
function jae() {
  if (mx)
    return cf;
  mx = 1;
  const t = Wi, { isObject: e, isString: r } = Je;
  class n extends t {
    constructor(a, s) {
      super(a, s);
    }
    createQuery(a, s, o) {
      const c = s ? "create table if not exists " : "create table ", { client: f } = this;
      let u = {}, l = " (" + a.sql.join(", ");
      l += this.primaryKeys() || "", l += this._addChecks(), l += ")";
      let p = c + this.tableName() + (o && this.tableNameLike() ? " like " + this.tableNameLike() : l);
      f.connectionSettings && (u = f.connectionSettings);
      const m = this.single.charset || u.charset || "", h = this.single.collate || u.collate || "", g = this.single.engine || "";
      if (m && !o && (p += ` default character set ${m}`), h && (p += ` collate ${h}`), g && (p += ` engine = ${g}`), this.single.comment) {
        const v = this.single.comment || "", d = 1024;
        v.length > d && this.client.logger.warn(
          `The max length for a table comment is ${d} characters`
        ), p += ` comment = '${v}'`;
      }
      this.pushQuery(p), o && this.addColumns(a, this.addColumnsPrefix);
    }
    // Compiles the comment on the table.
    comment(a) {
      this.pushQuery(`alter table ${this.tableName()} comment = '${a}'`);
    }
    changeType() {
    }
    // Renames a column on the table.
    renameColumn(a, s) {
      const o = this, c = this.tableName(), f = this.formatter.wrap(a) + " " + this.formatter.wrap(s);
      this.pushQuery({
        sql: `show full fields from ${c} where field = ` + this.client.parameter(a, this.tableBuilder, this.bindingsHolder),
        output(u) {
          const l = u[0], p = this;
          return o.getFKRefs(p).then(
            ([m]) => new Promise((h, g) => {
              try {
                m.length || h(), h(o.dropFKRefs(p, m));
              } catch (v) {
                g(v);
              }
            }).then(function() {
              let h = `alter table ${c} change ${f} ${l.Type}`;
              return String(l.Null).toUpperCase() !== "YES" ? h += " NOT NULL" : h += " NULL", l.Default !== void 0 && l.Default !== null && (h += ` DEFAULT '${l.Default}'`), l.Collation !== void 0 && l.Collation !== null && (h += ` COLLATE '${l.Collation}'`), l.Extra == "auto_increment" && (h += " AUTO_INCREMENT"), p.query({
                sql: h
              });
            }).then(function() {
              if (m.length)
                return o.createFKRefs(
                  p,
                  m.map(function(h) {
                    return h.REFERENCED_COLUMN_NAME === a && (h.REFERENCED_COLUMN_NAME = s), h.COLUMN_NAME === a && (h.COLUMN_NAME = s), h;
                  })
                );
            })
          );
        }
      });
    }
    primaryKeys() {
      const a = (this.grouped.alterTable || []).filter(
        (s) => s.method === "primary"
      );
      if (a.length > 0 && a[0].args.length > 0) {
        const s = a[0].args[0];
        let o = a[0].args[1] || "";
        if (o && (o = " constraint " + this.formatter.wrap(o)), this.grouped.columns) {
          const c = this._getIncrementsColumnNames();
          c.length && c.forEach((f) => {
            s.includes(f) || s.unshift(f);
          });
        }
        return `,${o} primary key (${this.formatter.columnize(
          s
        )})`;
      }
    }
    getFKRefs(a) {
      const s = {
        bindings: []
      }, o = "SELECT KCU.CONSTRAINT_NAME, KCU.TABLE_NAME, KCU.COLUMN_NAME,        KCU.REFERENCED_TABLE_NAME, KCU.REFERENCED_COLUMN_NAME,        RC.UPDATE_RULE, RC.DELETE_RULE FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS KCU JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS AS RC        USING(CONSTRAINT_NAME)WHERE KCU.REFERENCED_TABLE_NAME = " + this.client.parameter(
        this.tableNameRaw,
        this.tableBuilder,
        s
      ) + "   AND KCU.CONSTRAINT_SCHEMA = " + this.client.parameter(
        this.client.database(),
        this.tableBuilder,
        s
      ) + "   AND RC.CONSTRAINT_SCHEMA = " + this.client.parameter(
        this.client.database(),
        this.tableBuilder,
        s
      );
      return a.query({
        sql: o,
        bindings: s.bindings
      });
    }
    dropFKRefs(a, s) {
      const o = this.client.formatter(this.tableBuilder);
      return Promise.all(
        s.map(function(c) {
          const f = o.wrap(c.CONSTRAINT_NAME), u = o.wrap(c.TABLE_NAME);
          return a.query({
            sql: `alter table ${u} drop foreign key ${f}`
          });
        })
      );
    }
    createFKRefs(a, s) {
      const o = this.client.formatter(this.tableBuilder);
      return Promise.all(
        s.map(function(c) {
          const f = o.wrap(c.TABLE_NAME), u = o.wrap(c.CONSTRAINT_NAME), l = o.columnize(c.COLUMN_NAME), p = o.columnize(c.REFERENCED_COLUMN_NAME), m = o.wrap(c.REFERENCED_TABLE_NAME), h = ` ON UPDATE ${c.UPDATE_RULE}`, g = ` ON DELETE ${c.DELETE_RULE}`;
          return a.query({
            sql: `alter table ${f} add constraint ${u} foreign key (` + l + ") references " + m + " (" + p + ")" + h + g
          });
        })
      );
    }
    index(a, s, o) {
      let c, f;
      r(o) ? f = o : e(o) && ({ indexType: f, storageEngineIndexType: c } = o), s = s ? this.formatter.wrap(s) : this._indexCommand("index", this.tableNameRaw, a), c = c ? ` using ${c}` : "", this.pushQuery(
        `alter table ${this.tableName()} add${f ? ` ${f}` : ""} index ${s}(${this.formatter.columnize(
          a
        )})${c}`
      );
    }
    primary(a, s) {
      let o;
      e(s) && ({ constraintName: s, deferrable: o } = s), o && o !== "not deferrable" && this.client.logger.warn(
        `mysql: primary key constraint \`${s}\` will not be deferrable ${o} because mysql does not support deferred constraints.`
      ), s = s ? this.formatter.wrap(s) : this.formatter.wrap(`${this.tableNameRaw}_pkey`);
      const c = a;
      let f = [];
      this.grouped.columns && (f = this._getIncrementsColumnNames(), f && f.forEach((u) => {
        c.includes(u) || c.unshift(u);
      })), this.method !== "create" && this.method !== "createIfNot" && this.pushQuery(
        `alter table ${this.tableName()} add primary key ${s}(${this.formatter.columnize(
          c
        )})`
      ), f.length && this.pushQuery(
        `alter table ${this.tableName()} modify column ${this.formatter.columnize(
          f
        )} int unsigned not null auto_increment`
      );
    }
    unique(a, s) {
      let o, c;
      e(s) && ({ indexName: s, deferrable: c, storageEngineIndexType: o } = s), c && c !== "not deferrable" && this.client.logger.warn(
        `mysql: unique index \`${s}\` will not be deferrable ${c} because mysql does not support deferred constraints.`
      ), s = s ? this.formatter.wrap(s) : this._indexCommand("unique", this.tableNameRaw, a), o = o ? ` using ${o}` : "", this.pushQuery(
        `alter table ${this.tableName()} add unique ${s}(${this.formatter.columnize(
          a
        )})${o}`
      );
    }
    // Compile a drop index command.
    dropIndex(a, s) {
      s = s ? this.formatter.wrap(s) : this._indexCommand("index", this.tableNameRaw, a), this.pushQuery(`alter table ${this.tableName()} drop index ${s}`);
    }
    // Compile a drop foreign key command.
    dropForeign(a, s) {
      s = s ? this.formatter.wrap(s) : this._indexCommand("foreign", this.tableNameRaw, a), this.pushQuery(
        `alter table ${this.tableName()} drop foreign key ${s}`
      );
    }
    // Compile a drop primary key command.
    dropPrimary() {
      this.pushQuery(`alter table ${this.tableName()} drop primary key`);
    }
    // Compile a drop unique key command.
    dropUnique(a, s) {
      s = s ? this.formatter.wrap(s) : this._indexCommand("unique", this.tableNameRaw, a), this.pushQuery(`alter table ${this.tableName()} drop index ${s}`);
    }
  }
  return n.prototype.addColumnsPrefix = "add ", n.prototype.alterColumnsPrefix = "modify ", n.prototype.dropColumnPrefix = "drop ", cf = n, cf;
}
var uf, gx;
function Fae() {
  if (gx)
    return uf;
  gx = 1;
  const t = Wn, { isObject: e } = Je, { toNumber: r } = wt, n = new RegExp("(?<!\\\\)'", "g");
  class i extends t {
    constructor(s, o, c) {
      super(s, o, c), this.modifiers = [
        "unsigned",
        "nullable",
        "defaultTo",
        "comment",
        "collate",
        "first",
        "after"
      ], this._addCheckModifiers();
    }
    // Types
    // ------
    double(s, o) {
      return s ? `double(${r(s, 8)}, ${r(o, 2)})` : "double";
    }
    integer(s) {
      return s = s ? `(${r(s, 11)})` : "", `int${s}`;
    }
    tinyint(s) {
      return s = s ? `(${r(s, 1)})` : "", `tinyint${s}`;
    }
    text(s) {
      switch (s) {
        case "medium":
        case "mediumtext":
          return "mediumtext";
        case "long":
        case "longtext":
          return "longtext";
        default:
          return "text";
      }
    }
    mediumtext() {
      return this.text("medium");
    }
    longtext() {
      return this.text("long");
    }
    enu(s) {
      return `enum('${s.join("', '")}')`;
    }
    datetime(s) {
      return e(s) && ({ precision: s } = s), typeof s == "number" ? `datetime(${s})` : "datetime";
    }
    timestamp(s) {
      return e(s) && ({ precision: s } = s), typeof s == "number" ? `timestamp(${s})` : "timestamp";
    }
    time(s) {
      return e(s) && ({ precision: s } = s), typeof s == "number" ? `time(${s})` : "time";
    }
    bit(s) {
      return s ? `bit(${r(s)})` : "bit";
    }
    binary(s) {
      return s ? `varbinary(${r(s)})` : "blob";
    }
    json() {
      return "json";
    }
    jsonb() {
      return "json";
    }
    // Modifiers
    // ------
    defaultTo(s) {
      if (s == null)
        return;
      if ((this.type === "json" || this.type === "jsonb") && e(s))
        return `default ('${JSON.stringify(s)}')`;
      const o = super.defaultTo.apply(this, arguments);
      return this.type !== "blob" && this.type.indexOf("text") === -1 ? o : "";
    }
    unsigned() {
      return "unsigned";
    }
    comment(s) {
      return s && s.length > 255 && this.client.logger.warn(
        "Your comment is longer than the max comment length for MySQL"
      ), s && `comment '${s.replace(n, "\\'")}'`;
    }
    first() {
      return "first";
    }
    after(s) {
      return `after ${this.formatter.wrap(s)}`;
    }
    collate(s) {
      return s && `collate '${s}'`;
    }
    checkRegex(s, o) {
      return this._check(
        `${this.formatter.wrap(
          this.getColumnName()
        )} REGEXP ${this.client._escapeBinding(s)}`,
        o
      );
    }
    increments(s = { primaryKey: !0 }) {
      return "int unsigned not null" + // In MySQL autoincrement are always a primary key. If you already have a primary key, we
      // initialize this column as classic int column then modify it later in table compiler
      (this.tableCompiler._canBeAddPrimaryKey(s) ? " auto_increment primary key" : "");
    }
    bigincrements(s = { primaryKey: !0 }) {
      return "bigint unsigned not null" + // In MySQL autoincrement are always a primary key. If you already have a primary key, we
      // initialize this column as classic int column then modify it later in table compiler
      (this.tableCompiler._canBeAddPrimaryKey(s) ? " auto_increment primary key" : "");
    }
  }
  return i.prototype.bigint = "bigint", i.prototype.mediumint = "mediumint", i.prototype.smallint = "smallint", uf = i, uf;
}
var lf, vx;
function Bae() {
  if (vx)
    return lf;
  vx = 1;
  const t = Gi;
  class e extends t {
    constructor(n, i) {
      super(n, i);
    }
    createOrReplace() {
      this.createQuery(this.columns, this.selectQuery, !1, !0);
    }
  }
  return lf = e, lf;
}
var pf, yx;
function Uae() {
  if (yx)
    return pf;
  yx = 1;
  const t = bs;
  class e extends t {
    constructor() {
      super(...arguments);
    }
    checkOption() {
      this._single.checkOption = "default_option";
    }
    localCheckOption() {
      this._single.checkOption = "local";
    }
    cascadedCheckOption() {
      this._single.checkOption = "cascaded";
    }
  }
  return pf = e, pf;
}
var ff, bx;
function LA() {
  if (bx)
    return ff;
  bx = 1;
  const t = Pae(), e = zn, { promisify: r } = nt, n = Gn, i = Dae(), a = Mae(), s = qae(), o = jae(), c = Fae(), { makeEscape: f } = dv, u = Bae(), l = Uae();
  class p extends n {
    _driver() {
      return se;
    }
    queryCompiler(h, g) {
      return new a(this, h, g);
    }
    schemaCompiler() {
      return new s(this, ...arguments);
    }
    tableCompiler() {
      return new o(this, ...arguments);
    }
    viewCompiler() {
      return new u(this, ...arguments);
    }
    viewBuilder() {
      return new l(this, ...arguments);
    }
    columnCompiler() {
      return new c(this, ...arguments);
    }
    transaction() {
      return new i(this, ...arguments);
    }
    wrapIdentifierImpl(h) {
      return h !== "*" ? `\`${h.replace(/`/g, "``")}\`` : "*";
    }
    // Get a raw connection, called by the `pool` whenever a new
    // connection needs to be added to the pool.
    acquireRawConnection() {
      return new Promise((h, g) => {
        const v = this.driver.createConnection(this.connectionSettings);
        v.on("error", (d) => {
          v.__knex__disposed = d;
        }), v.connect((d) => {
          if (d)
            return v.removeAllListeners(), g(d);
          h(v);
        });
      });
    }
    // Used to explicitly close a connection, called internally by the pool
    // when a connection times out or the pool is shutdown.
    async destroyRawConnection(h) {
      try {
        return await r((v) => h.end(v))();
      } catch (g) {
        h.__knex__disposed = g;
      } finally {
        t(() => h.removeAllListeners());
      }
    }
    validateConnection(h) {
      return h.state === "connected" || h.state === "authenticated";
    }
    // Grab a connection, run the query via the MySQL streaming interface,
    // and pass that through to the stream we've sent back to the client.
    _stream(h, g, v, d) {
      if (!g.sql)
        throw new Error("The query is empty");
      d = d || {};
      const y = Object.assign({ sql: g.sql }, g.options);
      return new Promise((x, b) => {
        v.on("error", b), v.on("end", x);
        const w = h.query(y, g.bindings).stream(d);
        w.on("error", (S) => {
          b(S), v.emit("error", S);
        }), w.pipe(v);
      });
    }
    // Runs the query on the specified connection, providing the bindings
    // and any other necessary prep work.
    _query(h, g) {
      if ((!g || typeof g == "string") && (g = { sql: g }), !g.sql)
        throw new Error("The query is empty");
      return new Promise(function(v, d) {
        if (!g.sql) {
          v();
          return;
        }
        const y = Object.assign({ sql: g.sql }, g.options);
        h.query(
          y,
          g.bindings,
          function(x, b, w) {
            if (x)
              return d(x);
            g.response = [b, w], v(g);
          }
        );
      });
    }
    // Process the response as returned from the query.
    processResponse(h, g) {
      if (h == null)
        return;
      const { response: v } = h, { method: d } = h, y = v[0], x = v[1];
      if (h.output)
        return h.output.call(g, y, x);
      switch (d) {
        case "select":
          return y;
        case "first":
          return y[0];
        case "pluck":
          return e(y, h.pluck);
        case "insert":
          return [y.insertId];
        case "del":
        case "update":
        case "counter":
          return y.affectedRows;
        default:
          return v;
      }
    }
    async cancelQuery(h) {
      const g = await this.acquireRawConnection();
      try {
        return await this._wrappedCancelQueryCall(g, h);
      } finally {
        await this.destroyRawConnection(g), g.__knex__disposed && this.logger.warn(`Connection Error: ${g.__knex__disposed}`);
      }
    }
    _wrappedCancelQueryCall(h, g) {
      return this._query(h, {
        sql: "KILL QUERY ?",
        bindings: [g.threadId],
        options: {}
      });
    }
  }
  return Object.assign(p.prototype, {
    dialect: "mysql",
    driverName: "mysql",
    _escapeBinding: f(),
    canCancelQuery: !0
  }), ff = p, ff;
}
var hf, wx;
function zae() {
  if (wx)
    return hf;
  wx = 1;
  const t = ln, e = ar("knex:tx");
  class r extends t {
    query(i, a, s, o) {
      const c = this, f = this.trxClient.query(i, a).catch((u) => {
        if (u.code === "ER_SP_DOES_NOT_EXIST") {
          this.trxClient.logger.warn(
            "Transaction was implicitly committed, do not mix transactions and DDL with MySQL (#805)"
          );
          return;
        }
        s = 2, o = u, c._completed = !0, e("%s error running transaction query", c.txid);
      }).then(function(u) {
        if (s === 1 && c._resolver(o), s === 2) {
          if (o === void 0) {
            if (c.doNotRejectOnRollback && /^ROLLBACK\b/i.test(a)) {
              c._resolver();
              return;
            }
            o = new Error(`Transaction rejected with non-error: ${o}`);
          }
          return c._rejecter(o), u;
        }
      });
      return (s === 1 || s === 2) && (c._completed = !0), f;
    }
  }
  return hf = r, hf;
}
var df, xx;
function Hae() {
  if (xx)
    return df;
  xx = 1;
  const t = LA(), e = zae();
  class r extends t {
    transaction() {
      return new e(this, ...arguments);
    }
    _driver() {
      return se;
    }
    validateConnection(i) {
      return i && !i._fatalError && !i._protocolError && !i._closing && !i.stream.destroyed;
    }
  }
  return Object.assign(r.prototype, {
    // The "dialect", for reference elsewhere.
    driverName: "mysql2"
  }), df = r, df;
}
var mf, _x;
function On() {
  if (_x)
    return mf;
  _x = 1;
  function t(i, a, s, o) {
    const c = se, f = 30;
    Array.isArray(o) || (o = o ? [o] : []);
    const u = s.replace(/\.|-/g, "_"), l = o.join("_");
    let p = `${u}_${l.length ? l + "_" : ""}${a}`.toLowerCase();
    return p.length > f && (i.warn(
      `Automatically generated name "${p}" exceeds ${f} character limit for Oracle. Using base64 encoded sha1 of that name instead.`
    ), p = c.createHash("sha1").update(p).digest("base64").replace("=", "")), p;
  }
  function e(i, a) {
    return `begin execute immediate '${i.replace(/'/g, "''")}'; exception when others then if sqlcode != ${a} then raise; end if; end;`;
  }
  function r(i) {
    this.columnName = i;
  }
  r.prototype.toString = function() {
    return `[object ReturningHelper:${this.columnName}]`;
  };
  function n(i) {
    return [
      "DPI-1010",
      // not connected
      "DPI-1080",
      // connection was closed by ORA-%d
      "ORA-03114",
      // not connected to ORACLE
      "ORA-03113",
      // end-of-file on communication channel
      "ORA-03135",
      // connection lost contact
      "ORA-12514",
      // listener does not currently know of service requested in connect descriptor
      "ORA-00022",
      // invalid session ID; access denied
      "ORA-00028",
      // your session has been killed
      "ORA-00031",
      // your session has been marked for kill
      "ORA-00045",
      // your session has been terminated with no replay
      "ORA-00378",
      // buffer pools cannot be created as specified
      "ORA-00602",
      // internal programming exception
      "ORA-00603",
      // ORACLE server session terminated by fatal error
      "ORA-00609",
      // could not attach to incoming connection
      "ORA-01012",
      // not logged on
      "ORA-01041",
      // internal error. hostdef extension doesn't exist
      "ORA-01043",
      // user side memory corruption
      "ORA-01089",
      // immediate shutdown or close in progress
      "ORA-01092",
      // ORACLE instance terminated. Disconnection forced
      "ORA-02396",
      // exceeded maximum idle time, please connect again
      "ORA-03122",
      // attempt to close ORACLE-side window on user side
      "ORA-12153",
      // TNS'not connected
      "ORA-12537",
      // TNS'connection closed
      "ORA-12547",
      // TNS'lost contact
      "ORA-12570",
      // TNS'packet reader failure
      "ORA-12583",
      // TNS'no reader
      "ORA-27146",
      // post/wait initialization failed
      "ORA-28511",
      // lost RPC connection
      "ORA-56600",
      // an illegal OCI function call was issued
      "NJS-024",
      "NJS-003"
    ].some(function(a) {
      return i.message.indexOf(a) === 0;
    });
  }
  return mf = {
    generateCombinedName: t,
    isConnectionError: n,
    wrapSqlWithCatch: e,
    ReturningHelper: r
  }, mf;
}
var gf, Ex;
function zv() {
  if (Ex)
    return gf;
  Ex = 1;
  const t = On();
  return gf = {
    renameColumnTrigger: function(r, n, i, a) {
      const s = t.generateCombinedName(
        r,
        "autoinc_trg",
        n
      ), o = t.generateCombinedName(r, "seq", n);
      return `DECLARE PK_NAME VARCHAR(200); IS_AUTOINC NUMBER := 0; BEGIN  EXECUTE IMMEDIATE ('ALTER TABLE "${n}" RENAME COLUMN "${i}" TO "${a}"');  SELECT COUNT(*) INTO IS_AUTOINC from "USER_TRIGGERS" where trigger_name = '${s}';  IF (IS_AUTOINC > 0) THEN    SELECT cols.column_name INTO PK_NAME    FROM all_constraints cons, all_cons_columns cols    WHERE cons.constraint_type = 'P'    AND cons.constraint_name = cols.constraint_name    AND cons.owner = cols.owner    AND cols.table_name = '${n}';    IF ('${a}' = PK_NAME) THEN      EXECUTE IMMEDIATE ('DROP TRIGGER "${s}"');      EXECUTE IMMEDIATE ('create or replace trigger "${s}"      BEFORE INSERT on "${n}" for each row        declare        checking number := 1;        begin          if (:new."${a}" is null) then            while checking >= 1 loop              select "${o}".nextval into :new."${a}" from dual;              select count("${a}") into checking from "${n}"              where "${a}" = :new."${a}";            end loop;          end if;        end;');    end if;  end if;END;`;
    },
    createAutoIncrementTrigger: function(r, n, i) {
      const a = `"${n}"`, s = n, o = i ? `"${i}".` : "", c = i ? `'${i}'` : "cols.owner", f = t.generateCombinedName(
        r,
        "autoinc_trg",
        n
      ), l = `"${t.generateCombinedName(
        r,
        "seq",
        n
      )}"`;
      return `DECLARE PK_NAME VARCHAR(200); BEGIN  EXECUTE IMMEDIATE ('CREATE SEQUENCE ${o}${l}');  SELECT cols.column_name INTO PK_NAME  FROM all_constraints cons, all_cons_columns cols  WHERE cons.constraint_type = 'P'  AND cons.constraint_name = cols.constraint_name  AND cons.owner = ${c}  AND cols.table_name = '${s}';  execute immediate ('create or replace trigger ${o}"${f}"  BEFORE INSERT on ${o}${a}  for each row  declare  checking number := 1;  begin    if (:new."' || PK_NAME || '" is null) then      while checking >= 1 loop        select ${o}${l}.nextval into :new."' || PK_NAME || '" from dual;        select count("' || PK_NAME || '") into checking from ${o}${a}        where "' || PK_NAME || '" = :new."' || PK_NAME || '";      end loop;    end if;  end;'); END;`;
    },
    renameTableAndAutoIncrementTrigger: function(r, n, i) {
      const a = t.generateCombinedName(
        r,
        "autoinc_trg",
        n
      ), s = t.generateCombinedName(r, "seq", n), o = t.generateCombinedName(r, "autoinc_trg", i), c = t.generateCombinedName(r, "seq", i);
      return `DECLARE PK_NAME VARCHAR(200); IS_AUTOINC NUMBER := 0; BEGIN  EXECUTE IMMEDIATE ('RENAME "${n}" TO "${i}"');  SELECT COUNT(*) INTO IS_AUTOINC from "USER_TRIGGERS" where trigger_name = '${a}';  IF (IS_AUTOINC > 0) THEN    EXECUTE IMMEDIATE ('DROP TRIGGER "${a}"');    EXECUTE IMMEDIATE ('RENAME "${s}" TO "${c}"');    SELECT cols.column_name INTO PK_NAME    FROM all_constraints cons, all_cons_columns cols    WHERE cons.constraint_type = 'P'    AND cons.constraint_name = cols.constraint_name    AND cons.owner = cols.owner    AND cols.table_name = '${i}';    EXECUTE IMMEDIATE ('create or replace trigger "${o}"    BEFORE INSERT on "${i}" for each row      declare      checking number := 1;      begin        if (:new."' || PK_NAME || '" is null) then          while checking >= 1 loop            select "${c}".nextval into :new."' || PK_NAME || '" from dual;            select count("' || PK_NAME || '") into checking from "${i}"            where "' || PK_NAME || '" = :new."' || PK_NAME || '";          end loop;        end if;      end;');  end if;END;`;
    }
  }, gf;
}
var vf, Sx;
function Wae() {
  if (Sx)
    return vf;
  Sx = 1;
  const t = Hi, e = On(), r = zv();
  class n extends t {
    constructor() {
      super(...arguments);
    }
    // Rename a table on the schema.
    renameTable(a, s) {
      const o = r.renameTableAndAutoIncrementTrigger(
        this.client.logger,
        a,
        s
      );
      this.pushQuery(o);
    }
    // Check whether a table exists on the query.
    hasTable(a) {
      this.pushQuery({
        sql: "select TABLE_NAME from USER_TABLES where TABLE_NAME = " + this.client.parameter(a, this.builder, this.bindingsHolder),
        output(s) {
          return s.length > 0;
        }
      });
    }
    // Check whether a column exists on the schema.
    hasColumn(a, s) {
      const o = `select COLUMN_NAME from ALL_TAB_COLUMNS where TABLE_NAME = ${this.client.parameter(
        a,
        this.builder,
        this.bindingsHolder
      )} and COLUMN_NAME = ${this.client.parameter(
        s,
        this.builder,
        this.bindingsHolder
      )}`;
      this.pushQuery({ sql: o, output: (c) => c.length > 0 });
    }
    dropSequenceIfExists(a) {
      const s = this.schema ? `"${this.schema}".` : "";
      this.pushQuery(
        e.wrapSqlWithCatch(
          `drop sequence ${s}${this.formatter.wrap(a)}`,
          -2289
        )
      );
    }
    _dropRelatedSequenceIfExists(a) {
      const s = e.generateCombinedName(
        this.client.logger,
        "seq",
        a
      );
      this.dropSequenceIfExists(s);
    }
    dropTable(a) {
      const s = this.schema ? `"${this.schema}".` : "";
      this.pushQuery(`drop table ${s}${this.formatter.wrap(a)}`), this._dropRelatedSequenceIfExists(a);
    }
    dropTableIfExists(a) {
      this.dropObject(a, "table");
    }
    dropViewIfExists(a) {
      this.dropObject(a, "view");
    }
    dropObject(a, s) {
      const o = this.schema ? `"${this.schema}".` : "";
      let c = -942;
      s === "materialized view" && (c = -12003), this.pushQuery(
        e.wrapSqlWithCatch(
          `drop ${s} ${o}${this.formatter.wrap(a)}`,
          c
        )
      ), this._dropRelatedSequenceIfExists(a);
    }
    refreshMaterializedView(a) {
      return this.pushQuery({
        sql: `BEGIN DBMS_MVIEW.REFRESH('${this.schemaNameRaw ? this.schemaNameRaw + "." : ""}${a}'); END;`
      });
    }
    dropMaterializedView(a) {
      this._dropView(a, !1, !0);
    }
    dropMaterializedViewIfExists(a) {
      this.dropObject(a, "materialized view");
    }
  }
  return vf = n, vf;
}
var yf, Cx;
function Gae() {
  if (Cx)
    return yf;
  Cx = 1;
  const t = du, e = ms;
  class r extends t {
    constructor() {
      super(...arguments);
    }
    // checkIn added to the builder to allow the column compiler to change the
    // order via the modifiers ("check" must be after "default")
    checkIn() {
      return this._modifiers.checkIn = e(arguments), this;
    }
  }
  return yf = r, yf;
}
var bf, Tx;
function Qae() {
  if (Tx)
    return bf;
  Tx = 1;
  var t = _A;
  function e(r, n) {
    var i = r == null ? 0 : r.length;
    return !!i && t(r, n, 0) > -1;
  }
  return bf = e, bf;
}
var wf, Ox;
function Vae() {
  if (Ox)
    return wf;
  Ox = 1;
  function t(e, r, n) {
    for (var i = -1, a = e == null ? 0 : e.length; ++i < a; )
      if (n(r, e[i]))
        return !0;
    return !1;
  }
  return wf = t, wf;
}
var xf, Ax;
function Kae() {
  if (Ax)
    return xf;
  Ax = 1;
  function t() {
  }
  return xf = t, xf;
}
var _f, $x;
function Jae() {
  if ($x)
    return _f;
  $x = 1;
  var t = pO, e = Kae(), r = ru, n = 1 / 0, i = t && 1 / r(new t([, -0]))[1] == n ? function(a) {
    return new t(a);
  } : e;
  return _f = i, _f;
}
var Ef, Ix;
function Xae() {
  if (Ix)
    return Ef;
  Ix = 1;
  var t = KO(), e = Qae(), r = Vae(), n = XO, i = Jae(), a = ru, s = 200;
  function o(c, f, u) {
    var l = -1, p = e, m = c.length, h = !0, g = [], v = g;
    if (u)
      h = !1, p = r;
    else if (m >= s) {
      var d = f ? null : i(c);
      if (d)
        return a(d);
      h = !1, p = n, v = new t();
    } else
      v = f ? [] : g;
    e:
      for (; ++l < m; ) {
        var y = c[l], x = f ? f(y) : y;
        if (y = u || y !== 0 ? y : 0, h && x === x) {
          for (var b = v.length; b--; )
            if (v[b] === x)
              continue e;
          f && v.push(x), g.push(y);
        } else
          p(v, x, u) || (v !== g && v.push(x), g.push(y));
      }
    return g;
  }
  return Ef = o, Ef;
}
var Sf, kx;
function Zae() {
  if (kx)
    return Sf;
  kx = 1;
  var t = Xae();
  function e(r) {
    return r && r.length ? t(r) : [];
  }
  return Sf = e, Sf;
}
var Cf, Rx;
function Yae() {
  if (Rx)
    return Cf;
  Rx = 1;
  const t = zv();
  function e(r) {
    r.pushAdditional(function() {
      const n = this.tableCompiler.tableNameRaw, i = this.tableCompiler.schemaNameRaw, a = t.createAutoIncrementTrigger(
        this.client.logger,
        n,
        i
      );
      this.pushQuery(a);
    });
  }
  return Cf = {
    createAutoIncrementTriggerAndSequence: e
  }, Cf;
}
var Tf, Nx;
function PA() {
  if (Nx)
    return Tf;
  Nx = 1;
  const t = Zae(), e = zi, r = Wn, {
    createAutoIncrementTriggerAndSequence: n
  } = Yae(), { toNumber: i } = wt;
  class a extends r {
    constructor() {
      super(...arguments), this.modifiers = ["defaultTo", "checkIn", "nullable", "comment"];
    }
    increments(o = { primaryKey: !0 }) {
      return n(this), "integer not null" + (this.tableCompiler._canBeAddPrimaryKey(o) ? " primary key" : "");
    }
    bigincrements(o = { primaryKey: !0 }) {
      return n(this), "number(20, 0) not null" + (this.tableCompiler._canBeAddPrimaryKey(o) ? " primary key" : "");
    }
    floating(o) {
      const c = i(o, 0);
      return `float${c ? `(${c})` : ""}`;
    }
    double(o, c) {
      return `number(${i(o, 8)}, ${i(c, 2)})`;
    }
    decimal(o, c) {
      return o === null ? "decimal" : `decimal(${i(o, 8)}, ${i(c, 2)})`;
    }
    integer(o) {
      return o ? `number(${i(o, 11)})` : "integer";
    }
    enu(o) {
      o = t(o);
      const c = (o || []).reduce(
        (f, u) => Math.max(f, String(u).length),
        1
      );
      return this.columnBuilder._modifiers.checkIn = [o], `varchar2(${c})`;
    }
    datetime(o) {
      return o ? "timestamp" : "timestamp with time zone";
    }
    timestamp(o) {
      return o ? "timestamp" : "timestamp with time zone";
    }
    bool() {
      return this.columnBuilder._modifiers.checkIn = [[0, 1]], "number(1, 0)";
    }
    varchar(o) {
      return `varchar2(${i(o, 255)})`;
    }
    // Modifiers
    // ------
    comment(o) {
      const c = this.args[0] || this.defaults("columnName");
      this.pushAdditional(function() {
        this.pushQuery(
          `comment on column ${this.tableCompiler.tableName()}.` + this.formatter.wrap(c) + " is '" + (o || "") + "'"
        );
      }, o);
    }
    checkIn(o) {
      return o === void 0 ? "" : (o instanceof e ? o = o.toQuery() : Array.isArray(o) ? o = o.map((c) => `'${c}'`).join(", ") : o = `'${o}'`, `check (${this.formatter.wrap(this.args[0])} in (${o}))`);
    }
  }
  return a.prototype.tinyint = "smallint", a.prototype.smallint = "smallint", a.prototype.mediumint = "integer", a.prototype.biginteger = "number(20, 0)", a.prototype.text = "clob", a.prototype.time = "timestamp with time zone", a.prototype.bit = "clob", a.prototype.json = "clob", Tf = a, Tf;
}
var Of, Lx;
function DA() {
  if (Lx)
    return Of;
  Lx = 1;
  const t = On(), e = Wi, r = wt, n = zv(), { isObject: i } = Je;
  class a extends e {
    constructor() {
      super(...arguments);
    }
    addColumns(o, c) {
      if (o.sql.length > 0) {
        c = c || this.addColumnsPrefix;
        const f = o.sql;
        let l = `${this.lowerCase ? "alter table " : "ALTER TABLE "}${this.tableName()} ${c}`;
        o.sql.length > 1 ? l += `(${f.join(", ")})` : l += f.join(", "), this.pushQuery({
          sql: l,
          bindings: o.bindings
        });
      }
    }
    // Compile a rename column command.
    renameColumn(o, c) {
      const f = this.tableName().slice(1, -1);
      return this.pushQuery(
        n.renameColumnTrigger(this.client.logger, f, o, c)
      );
    }
    compileAdd(o) {
      const c = this.formatter.wrap(o), f = this.prefixArray("add column", this.getColumns(o));
      return this.pushQuery({
        sql: `alter table ${c} ${f.join(", ")}`
      });
    }
    // Adds the "create" query to the query sequence.
    createQuery(o, c, f) {
      const u = f && this.tableNameLike() ? " as (select * from " + this.tableNameLike() + " where 0=1)" : " (" + o.sql.join(", ") + this._addChecks() + ")", l = `create table ${this.tableName()}${u}`;
      this.pushQuery({
        // catch "name is already used by an existing object" for workaround for "if not exists"
        sql: c ? t.wrapSqlWithCatch(l, -955) : l,
        bindings: o.bindings
      }), this.single.comment && this.comment(this.single.comment), f && this.addColumns(o, this.addColumnsPrefix);
    }
    // Compiles the comment on the table.
    comment(o) {
      this.pushQuery(`comment on table ${this.tableName()} is '${o}'`);
    }
    dropColumn() {
      const o = r.normalizeArr.apply(null, arguments);
      this.pushQuery(
        `alter table ${this.tableName()} drop (${this.formatter.columnize(
          o
        )})`
      );
    }
    _indexCommand(o, c, f) {
      return this.formatter.wrap(
        t.generateCombinedName(this.client.logger, o, c, f)
      );
    }
    primary(o, c) {
      let f;
      i(c) && ({ constraintName: c, deferrable: f } = c), f = f ? ` deferrable initially ${f}` : "", c = c ? this.formatter.wrap(c) : this.formatter.wrap(`${this.tableNameRaw}_pkey`);
      const u = o;
      let l = [];
      this.grouped.columns && (l = this._getIncrementsColumnNames(), l && l.forEach((p) => {
        u.includes(p) || u.unshift(p);
      })), this.pushQuery(
        `alter table ${this.tableName()} add constraint ${c} primary key (${this.formatter.columnize(
          u
        )})${f}`
      );
    }
    dropPrimary(o) {
      o = o ? this.formatter.wrap(o) : this.formatter.wrap(this.tableNameRaw + "_pkey"), this.pushQuery(
        `alter table ${this.tableName()} drop constraint ${o}`
      );
    }
    index(o, c) {
      c = c ? this.formatter.wrap(c) : this._indexCommand("index", this.tableNameRaw, o), this.pushQuery(
        `create index ${c} on ${this.tableName()} (` + this.formatter.columnize(o) + ")"
      );
    }
    dropIndex(o, c) {
      c = c ? this.formatter.wrap(c) : this._indexCommand("index", this.tableNameRaw, o), this.pushQuery(`drop index ${c}`);
    }
    unique(o, c) {
      let f;
      i(c) && ({ indexName: c, deferrable: f } = c), f = f ? ` deferrable initially ${f}` : "", c = c ? this.formatter.wrap(c) : this._indexCommand("unique", this.tableNameRaw, o), this.pushQuery(
        `alter table ${this.tableName()} add constraint ${c} unique (` + this.formatter.columnize(o) + ")" + f
      );
    }
    dropUnique(o, c) {
      c = c ? this.formatter.wrap(c) : this._indexCommand("unique", this.tableNameRaw, o), this.pushQuery(
        `alter table ${this.tableName()} drop constraint ${c}`
      );
    }
    dropForeign(o, c) {
      c = c ? this.formatter.wrap(c) : this._indexCommand("foreign", this.tableNameRaw, o), this.pushQuery(
        `alter table ${this.tableName()} drop constraint ${c}`
      );
    }
  }
  return a.prototype.addColumnsPrefix = "add ", a.prototype.alterColumnsPrefix = "modify ", Of = a, Of;
}
var Af, Px;
function MA() {
  if (Px)
    return Af;
  Px = 1;
  const { ReturningHelper: t } = On(), { isConnectionError: e } = On(), r = Gn, n = Wae(), i = Gae(), a = PA(), s = DA();
  class o extends r {
    schemaCompiler() {
      return new n(this, ...arguments);
    }
    columnBuilder() {
      return new i(this, ...arguments);
    }
    columnCompiler() {
      return new a(this, ...arguments);
    }
    tableCompiler() {
      return new s(this, ...arguments);
    }
    // Return the database for the Oracle client.
    database() {
      return this.connectionSettings.database;
    }
    // Position the bindings for the query.
    positionBindings(f) {
      let u = 0;
      return f.replace(/\?/g, function() {
        return u += 1, `:${u}`;
      });
    }
    _stream(f, u, l, p) {
      if (!u.sql)
        throw new Error("The query is empty");
      return new Promise(function(m, h) {
        l.on("error", (v) => {
          e(v) && (f.__knex__disposed = v), h(v);
        }), l.on("end", m);
        const g = f.queryStream(
          u.sql,
          u.bindings,
          p
        );
        g.pipe(l), g.on("error", function(v) {
          h(v), l.emit("error", v);
        });
      });
    }
    // Formatter part
    alias(f, u) {
      return f + " " + u;
    }
    parameter(f, u, l) {
      return f instanceof t && this.driver ? f = new this.driver.OutParam(this.driver.OCCISTRING) : typeof f == "boolean" && (f = f ? 1 : 0), super.parameter(f, u, l);
    }
  }
  return Object.assign(o.prototype, {
    dialect: "oracle",
    driverName: "oracle"
  }), Af = o, Af;
}
var $f, Dx;
function ese() {
  if (Dx)
    return $f;
  Dx = 1;
  const t = Mv, e = Wt, r = sr, n = un, i = gs, a = Hn, { ReturningHelper: s } = On(), { isString: o } = Je, c = [
    "columns",
    "join",
    "where",
    "union",
    "group",
    "having",
    "order",
    "lock"
  ];
  class f extends a {
    constructor(l, p, m) {
      super(l, p, m);
      const { onConflict: h } = this.single;
      if (h)
        throw new Error(".onConflict() is not supported for oracledb.");
      this.first = this.select;
    }
    // Compiles an "insert" query, allowing for multiple
    // inserts using a single query statement.
    insert() {
      let l = this.single.insert || [], { returning: p } = this.single;
      if (!Array.isArray(l) && n(this.single.insert) && (l = [this.single.insert]), p && !Array.isArray(p) && (p = [p]), Array.isArray(l) && l.length === 1 && r(l[0]))
        return this._addReturningToSqlAndConvert(
          `insert into ${this.tableName} (${this.formatter.wrap(
            this.single.returning
          )}) values (default)`,
          p,
          this.tableName
        );
      if (r(this.single.insert) && typeof this.single.insert != "function")
        return "";
      const m = this._prepInsert(l), h = {};
      if (o(m))
        return this._addReturningToSqlAndConvert(
          `insert into ${this.tableName} ${m}`,
          p
        );
      if (m.values.length === 1)
        return this._addReturningToSqlAndConvert(
          `insert into ${this.tableName} (${this.formatter.columnize(
            m.columns
          )}) values (${this.client.parameterize(
            m.values[0],
            void 0,
            this.builder,
            this.bindingsHolder
          )})`,
          p,
          this.tableName
        );
      const g = m.columns.length === 0;
      return h.sql = "begin " + m.values.map((v) => {
        let d;
        const y = g ? "" : this.client.parameterize(
          v,
          this.client.valueForUndefined,
          this.builder,
          this.bindingsHolder
        ), x = Array.isArray(p) ? p : [p];
        let b = `insert into ${this.tableName} `;
        p && (d = new s(x.join(":")), h.outParams = (h.outParams || []).concat(d)), g ? b += `(${this.formatter.wrap(
          this.single.returning
        )}) values (default)` : b += `(${this.formatter.columnize(
          m.columns
        )}) values (${y})`, b += p ? ` returning ROWID into ${this.client.parameter(
          d,
          this.builder,
          this.bindingsHolder
        )}` : "", b = this.formatter.client.positionBindings(b);
        const w = y.replace("DEFAULT, ", "").replace(", DEFAULT", "");
        return `execute immediate '${b.replace(/'/g, "''")}` + (w || p ? "' using " : "") + w + (w && p ? ", " : "") + (p ? "out ?" : "") + ";";
      }).join(" ") + "end;", p && (h.returning = p, h.returningSql = `select ${this.formatter.columnize(p)} from ` + this.tableName + " where ROWID in (" + h.outParams.map((v, d) => `:${d + 1}`).join(", ") + ") order by case ROWID " + h.outParams.map((v, d) => `when CHARTOROWID(:${d + 1}) then ${d}`).join(" ") + " end"), h;
    }
    // Update method, including joins, wheres, order & limits.
    update() {
      const l = this._prepUpdate(this.single.update), p = this.where();
      let { returning: m } = this.single;
      const h = `update ${this.tableName} set ` + l.join(", ") + (p ? ` ${p}` : "");
      return m ? (Array.isArray(m) || (m = [m]), this._addReturningToSqlAndConvert(h, m, this.tableName)) : h;
    }
    // Compiles a `truncate` query.
    truncate() {
      return `truncate table ${this.tableName}`;
    }
    forUpdate() {
      return "for update";
    }
    forShare() {
      return this.client.logger.warn(
        "lock for share is not supported by oracle dialect"
      ), "";
    }
    // Compiles a `columnInfo` query.
    columnInfo() {
      const l = this.single.columnInfo;
      return {
        sql: `select * from xmltable( '/ROWSET/ROW'
      passing dbms_xmlgen.getXMLType('
      select char_col_decl_length, column_name, data_type, data_default, nullable
      from all_tab_columns where table_name = ''${this.client.customWrapIdentifier(this.single.table, e)}'' ')
      columns
      CHAR_COL_DECL_LENGTH number, COLUMN_NAME varchar2(200), DATA_TYPE varchar2(106),
      DATA_DEFAULT clob, NULLABLE varchar2(1))`,
        output(h) {
          const g = i(
            h,
            function(v, d) {
              return v[d.COLUMN_NAME] = {
                type: d.DATA_TYPE,
                defaultValue: d.DATA_DEFAULT,
                maxLength: d.CHAR_COL_DECL_LENGTH,
                nullable: d.NULLABLE === "Y"
              }, v;
            },
            {}
          );
          return l && g[l] || g;
        }
      };
    }
    select() {
      let l = this.with();
      const p = c.map((m) => this[m]());
      return l += t(p).join(" "), this._surroundQueryWithLimitAndOffset(l);
    }
    aggregate(l) {
      return this._aggregate(l, { aliasSeparator: " " });
    }
    // for single commands only
    _addReturningToSqlAndConvert(l, p, m) {
      const h = {
        sql: l
      };
      if (!p)
        return h;
      const g = Array.isArray(p) ? p : [p], v = new s(g.join(":"));
      return h.sql = l + " returning ROWID into " + this.client.parameter(v, this.builder, this.bindingsHolder), h.returningSql = `select ${this.formatter.columnize(
        p
      )} from ${m} where ROWID = :1`, h.outParams = [v], h.returning = p, h;
    }
    _surroundQueryWithLimitAndOffset(l) {
      let { limit: p } = this.single;
      const { offset: m } = this.single, h = p || p === 0 || p === "0";
      if (p = +p, !h && !m)
        return l;
      if (l = l || "", h && !m)
        return `select * from (${l}) where rownum <= ${this._getValueOrParameterFromAttribute(
          "limit",
          p
        )}`;
      const g = +m + (h ? p : 1e13);
      return "select * from (select row_.*, ROWNUM rownum_ from (" + l + ") row_ where rownum <= " + (this.single.skipBinding.offset ? g : this.client.parameter(g, this.builder, this.bindingsHolder)) + ") where rownum_ > " + this._getValueOrParameterFromAttribute("offset", m);
    }
  }
  return $f = f, $f;
}
var If, Mx;
function pg() {
  if (Mx)
    return If;
  Mx = 1;
  const t = On(), { promisify: e } = nt, r = se;
  function n(o, c) {
    this.columnName = o, this.value = c, this.returning = !1;
  }
  n.prototype.toString = function() {
    return "[object BlobHelper:" + this.columnName + "]";
  };
  function i(o, c) {
    return new Promise((f, u) => {
      let l = c === "string" ? "" : Buffer.alloc(0);
      o.on("error", function(p) {
        u(p);
      }), o.on("data", function(p) {
        c === "string" ? l += p : l = Buffer.concat([l, p]);
      }), o.on("end", function() {
        f(l);
      });
    });
  }
  const a = function(o) {
    const c = se;
    let f;
    if (o.type)
      o.type === c.BLOB ? f = "buffer" : o.type === c.CLOB && (f = "string");
    else if (o.iLob)
      o.iLob.type === c.CLOB ? f = "string" : o.iLob.type === c.BLOB && (f = "buffer");
    else
      throw new Error("Unrecognized oracledb lob stream type");
    return f === "string" && o.setEncoding("utf-8"), i(o, f);
  };
  function s(o, c) {
    if (o.executeAsync)
      return;
    o.commitAsync = function() {
      return new Promise((u, l) => {
        this.commit(function(p) {
          if (p)
            return l(p);
          u();
        });
      });
    }, o.rollbackAsync = function() {
      return new Promise((u, l) => {
        this.rollback(function(p) {
          if (p)
            return l(p);
          u();
        });
      });
    };
    const f = e(function(u, l, p, m) {
      if (p = p || {}, p.outFormat = c.driver.OUT_FORMAT_OBJECT || c.driver.OBJECT, !p.outFormat)
        throw new Error("not found oracledb.outFormat constants");
      p.resultSet ? o.execute(
        u,
        l || [],
        p,
        function(h, g) {
          if (h)
            return t.isConnectionError(h) && (o.close().catch(function(x) {
            }), o.__knex__disposed = h), m(h);
          const v = { rows: [], resultSet: g.resultSet }, d = 100, y = function(x, b, w) {
            b.getRows(w, function(S, T) {
              if (S)
                t.isConnectionError(S) && (x.close().catch(function(E) {
                }), x.__knex__disposed = S), b.close(function() {
                  return m(S);
                });
              else {
                if (T.length === 0)
                  return m(null, v);
                if (T.length > 0)
                  if (T.length === w)
                    v.rows = v.rows.concat(T), y(x, b, w);
                  else
                    return v.rows = v.rows.concat(T), m(null, v);
              }
            });
          };
          y(o, g.resultSet, d);
        }
      ) : o.execute(
        u,
        l || [],
        p,
        function(h, g) {
          return h ? (t.isConnectionError(h) && (o.close().catch(function(v) {
          }), o.__knex__disposed = h), m(h)) : m(null, g);
        }
      );
    });
    o.executeAsync = function(u, l, p) {
      return f(u, l, p).then(async (m) => {
        const h = () => m.resultSet ? e(m.resultSet.close).call(m.resultSet) : Promise.resolve(), g = [];
        if (m.rows && Array.isArray(m.rows))
          for (let v = 0; v < m.rows.length; v++) {
            const d = m.rows[v];
            for (const y in d)
              d[y] instanceof r.Readable && g.push({ index: v, key: y, stream: d[y] });
          }
        try {
          for (const v of g)
            m.rows[v.index][v.key] = await a(v.stream);
        } catch (v) {
          throw await h().catch(() => {
          }), v;
        }
        return await h(), m;
      });
    };
  }
  return t.BlobHelper = n, t.monkeyPatchConnection = s, If = t, If;
}
var kf, qx;
function tse() {
  if (qx)
    return kf;
  qx = 1;
  const t = Av, e = hs, r = sr, n = un, i = ese(), a = pg().ReturningHelper, s = pg().BlobHelper, { isString: o } = Je, {
    columnize: c
  } = xt;
  class f extends i {
    // Compiles an "insert" query, allowing for multiple
    // inserts using a single query statement.
    insert() {
      const l = this, p = this._prepOutbindings(
        this.single.insert,
        this.single.returning
      ), m = p.outBinding, h = p.returning, g = p.values;
      if (Array.isArray(g) && g.length === 1 && r(g[0])) {
        const x = this.single.returning ? " (" + this.formatter.wrap(this.single.returning) + ")" : "";
        return this._addReturningToSqlAndConvert(
          "insert into " + this.tableName + x + " values (default)",
          m[0],
          this.tableName,
          h
        );
      }
      if (r(this.single.insert) && typeof this.single.insert != "function")
        return "";
      const v = this._prepInsert(g), d = {};
      if (o(v))
        return this._addReturningToSqlAndConvert(
          "insert into " + this.tableName + " " + v,
          m[0],
          this.tableName,
          h
        );
      if (v.values.length === 1)
        return this._addReturningToSqlAndConvert(
          "insert into " + this.tableName + " (" + this.formatter.columnize(v.columns) + ") values (" + this.client.parameterize(
            v.values[0],
            void 0,
            this.builder,
            this.bindingsHolder
          ) + ")",
          m[0],
          this.tableName,
          h
        );
      const y = v.columns.length === 0;
      return d.returning = h, d.sql = "begin " + v.values.map(function(x, b) {
        const w = y ? "" : l.client.parameterize(
          x,
          l.client.valueForUndefined,
          l.builder,
          l.bindingsHolder
        );
        let S = "insert into " + l.tableName;
        y ? S += " (" + l.formatter.wrap(l.single.returning) + ") values (default)" : S += " (" + l.formatter.columnize(v.columns) + ") values (" + w + ")";
        let T = "", E = "", C = "", A = "";
        e(x, function(D) {
          D instanceof s || (C += " ?,");
        }), C = C.slice(0, -1), m[b].forEach(function(D) {
          const F = D.columnName || D;
          if (T += l.formatter.wrap(F) + ",", E += " ?,", A += " out ?,", D instanceof s)
            return l.formatter.bindings.push(D);
          l.formatter.bindings.push(new a(F));
        }), T = T.slice(0, -1), E = E.slice(0, -1), A = A.slice(0, -1), T && E && (S += " returning " + T + " into" + E), S = l.formatter.client.positionBindings(S);
        const R = w.replace(/DEFAULT, /g, "").replace(/, DEFAULT/g, "").replace("EMPTY_BLOB(), ", "").replace(", EMPTY_BLOB()", "");
        return "execute immediate '" + S.replace(/'/g, "''") + (R || x ? "' using " : "") + R + (R && A ? "," : "") + A + ";";
      }).join(" ") + "end;", d.outBinding = m, h[0] === "*" && (d.returningSql = function() {
        return "select * from " + l.tableName + " where ROWID in (" + this.outBinding.map(function(x, b) {
          return ":" + (b + 1);
        }).join(", ") + ") order by case ROWID " + this.outBinding.map(function(x, b) {
          return "when CHARTOROWID(:" + (b + 1) + ") then " + b;
        }).join(" ") + " end";
      }), d;
    }
    with() {
      const l = [];
      if (this.grouped.with)
        for (const m of this.grouped.with)
          m.recursive && (l.push(m), m.recursive = !1);
      const p = super.with();
      for (const m of l)
        m.recursive = !0;
      return p;
    }
    _addReturningToSqlAndConvert(l, p, m, h) {
      const g = this, v = {
        sql: l
      };
      if (!p)
        return v;
      const d = Array.isArray(p) ? p : [p];
      let y = "", x = "";
      return d.forEach(function(b) {
        const w = b.columnName || b;
        if (y += g.formatter.wrap(w) + ",", x += "?,", b instanceof s)
          return g.formatter.bindings.push(b);
        g.formatter.bindings.push(new a(w));
      }), v.sql = l, y = y.slice(0, -1), x = x.slice(0, -1), y && x && (v.sql += " returning " + y + " into " + x), v.outBinding = [p], h[0] === "*" && (v.returningSql = function() {
        return "select * from " + g.tableName + " where ROWID = :1";
      }), v.returning = h, v;
    }
    _prepOutbindings(l, p) {
      const m = {};
      let h = l || [], g = p || [];
      !Array.isArray(h) && n(l) && (h = [h]), g && !Array.isArray(g) && (g = [g]);
      const v = [];
      return e(h, function(d, y) {
        g[0] === "*" ? v[y] = ["ROWID"] : v[y] = t(g), e(d, function(x, b) {
          if (x instanceof Buffer) {
            d[b] = new s(b, x);
            const w = v[y].indexOf(b);
            w >= 0 && (v[y].splice(w, 1), d[b].returning = !0), v[y].push(d[b]);
          }
          x === void 0 && delete h[y][b];
        });
      }), m.returning = g, m.outBinding = v, m.values = h, m;
    }
    _groupOrder(l, p) {
      return super._groupOrderNulls(l, p);
    }
    update() {
      const l = this, p = {}, m = this._prepOutbindings(
        this.single.update || this.single.counter,
        this.single.returning
      ), h = m.outBinding, g = m.returning, v = this._prepUpdate(this.single.update), d = this.where();
      let y = "", x = "";
      return r(v) && typeof this.single.update != "function" ? "" : (h.forEach(function(b) {
        b.forEach(function(w) {
          const S = w.columnName || w;
          if (y += l.formatter.wrap(S) + ",", x += " ?,", w instanceof s)
            return l.formatter.bindings.push(w);
          l.formatter.bindings.push(new a(S));
        });
      }), y = y.slice(0, -1), x = x.slice(0, -1), p.outBinding = h, p.returning = g, p.sql = "update " + this.tableName + " set " + v.join(", ") + (d ? " " + d : ""), h.length && !r(h[0]) && (p.sql += " returning " + y + " into" + x), g[0] === "*" && (p.returningSql = function() {
        let b = "select * from " + l.tableName;
        const w = this.rowsAffected.length || this.rowsAffected;
        let S = " where ROWID in (", T = ") order by case ROWID ";
        for (let E = 0; E < w; E++)
          this.returning[0] === "*" && (S += ":" + (E + 1) + ", ", T += "when CHARTOROWID(:" + (E + 1) + ") then " + E + " ");
        return this.returning[0] === "*" && (this.returning = this.returning.slice(0, -1), S = S.slice(0, -2), T = T.slice(0, -1)), b += S + T + " end";
      }), p);
    }
    _jsonPathWrap(l) {
      return `'${l.path || l[1]}'`;
    }
    // Json functions
    jsonExtract(l) {
      return this._jsonExtract(
        l.singleValue ? "json_value" : "json_query",
        l
      );
    }
    jsonSet(l) {
      return `json_transform(${c(
        l.column,
        this.builder,
        this.client,
        this.bindingsHolder
      )}, set ${this.client.parameter(
        l.path,
        this.builder,
        this.bindingsHolder
      )} = ${this.client.parameter(
        l.value,
        this.builder,
        this.bindingsHolder
      )})`;
    }
    jsonInsert(l) {
      return `json_transform(${c(
        l.column,
        this.builder,
        this.client,
        this.bindingsHolder
      )}, insert ${this.client.parameter(
        l.path,
        this.builder,
        this.bindingsHolder
      )} = ${this.client.parameter(
        l.value,
        this.builder,
        this.bindingsHolder
      )})`;
    }
    jsonRemove(l) {
      const p = `json_transform(${c(
        l.column,
        this.builder,
        this.client,
        this.bindingsHolder
      )}, remove ${this.client.parameter(
        l.path,
        this.builder,
        this.bindingsHolder
      )})`;
      return l.alias ? this.client.alias(p, this.formatter.wrap(l.alias)) : p;
    }
    whereJsonPath(l) {
      return this._whereJsonPath("json_value", l);
    }
    whereJsonSupersetOf(l) {
      throw new Error(
        "Json superset where clause not actually supported by Oracle"
      );
    }
    whereJsonSubsetOf(l) {
      throw new Error(
        "Json subset where clause not actually supported by Oracle"
      );
    }
    onJsonPathEquals(l) {
      return this._onJsonPathEquals("json_value", l);
    }
  }
  return kf = f, kf;
}
var Rf, jx;
function rse() {
  if (jx)
    return Rf;
  jx = 1;
  const t = DA();
  class e extends t {
    constructor(n, i) {
      super(n, i);
    }
    _setNullableState(n, i) {
      const a = i ? "NULL" : "NOT NULL", s = `alter table ${this.tableName()} modify (${this.formatter.wrap(
        n
      )} ${a})`;
      return this.pushQuery({
        sql: s
      });
    }
  }
  return Rf = e, Rf;
}
var Nf, Fx;
function nse() {
  if (Fx)
    return Nf;
  Fx = 1;
  const t = PA(), { isObject: e } = Je;
  class r extends t {
    constructor() {
      super(...arguments), this.modifiers = ["defaultTo", "nullable", "comment"], this._addCheckModifiers();
    }
    datetime(i) {
      let a;
      return e(i) ? { useTz: a } = i : a = !i, a ? "timestamp with local time zone" : "timestamp";
    }
    timestamp(i) {
      let a;
      return e(i) ? { useTz: a } = i : a = !i, a ? "timestamp with local time zone" : "timestamp";
    }
    checkRegex(i, a) {
      return this._check(
        `REGEXP_LIKE(${this.formatter.wrap(
          this.getColumnName()
        )},${this.client._escapeBinding(i)})`,
        a
      );
    }
    json() {
      return `varchar2(4000) check (${this.formatter.columnize(
        this.getColumnName()
      )} is json)`;
    }
    jsonb() {
      return this.json();
    }
  }
  return r.prototype.time = "timestamp with local time zone", r.prototype.uuid = ({ useBinaryUuid: n = !1 } = {}) => n ? "raw(16)" : "char(36)", Nf = r, Nf;
}
var Lf, Bx;
function ise() {
  if (Bx)
    return Lf;
  Bx = 1;
  const t = Gi;
  class e extends t {
    constructor(n, i) {
      super(n, i);
    }
    createOrReplace() {
      this.createQuery(this.columns, this.selectQuery, !1, !0);
    }
    createMaterializedView() {
      this.createQuery(this.columns, this.selectQuery, !0);
    }
  }
  return Lf = e, Lf;
}
var Pf, Ux;
function ase() {
  if (Ux)
    return Pf;
  Ux = 1;
  const t = bs;
  class e extends t {
    constructor() {
      super(...arguments);
    }
    checkOption() {
      this._single.checkOption = "default_option";
    }
  }
  return Pf = e, Pf;
}
var Df, zx;
function sse() {
  if (zx)
    return Df;
  zx = 1;
  const t = ln, { timeout: e, KnexTimeoutError: r } = cn, n = ar("knex:tx");
  return Df = class extends t {
    // disable autocommit to allow correct behavior (default is true)
    begin(a) {
      return this.isolationLevel && this.client.logger.warn(
        "Transaction isolation is not currently supported for Oracle"
      ), Promise.resolve();
    }
    async commit(a, s) {
      this._completed = !0;
      try {
        await a.commitAsync(), this._resolver(s);
      } catch (o) {
        this._rejecter(o);
      }
    }
    release(a, s) {
      return this._resolver(s);
    }
    rollback(a, s) {
      return this._completed = !0, n("%s: rolling back", this.txid), e(a.rollbackAsync(), 5e3).catch((o) => {
        if (!(o instanceof r))
          return Promise.reject(o);
        this._rejecter(o);
      }).then(() => {
        if (s === void 0) {
          if (this.doNotRejectOnRollback) {
            this._resolver();
            return;
          }
          s = new Error(`Transaction rejected with non-error: ${s}`);
        }
        this._rejecter(s);
      });
    }
    savepoint(a) {
      return this.query(a, `SAVEPOINT ${this.txid}`);
    }
    async acquireConnection(a, s) {
      const o = a && a.connection, c = o || await this.client.acquireConnection();
      try {
        return c.__knexTxId = this.txid, c.isTransaction = !0, await s(c);
      } finally {
        n("%s: releasing connection", this.txid), c.isTransaction = !1;
        try {
          await c.commitAsync();
        } catch (f) {
          this._rejecter(f);
        } finally {
          o ? n("%s: not releasing external connection", this.txid) : await this.client.releaseConnection(c);
        }
      }
    }
  }, Df;
}
var Mf, Hx;
function ose() {
  if (Hx)
    return Mf;
  Hx = 1;
  const t = hs, e = qO, r = sr, n = zn, i = mu, a = tse(), s = rse(), o = nse(), {
    BlobHelper: c,
    ReturningHelper: f,
    monkeyPatchConnection: u
  } = pg(), l = ise(), p = ase(), m = sse(), h = MA(), { isString: g } = Je, { outputQuery: v, unwrapRaw: d } = xt, { compileCallback: y } = Un;
  class x extends h {
    constructor(S) {
      super(S), this.driver && (process.env.UV_THREADPOOL_SIZE = process.env.UV_THREADPOOL_SIZE || 1, process.env.UV_THREADPOOL_SIZE = parseInt(process.env.UV_THREADPOOL_SIZE) + this.driver.poolMax);
    }
    _driver() {
      const S = this, T = se;
      return S.fetchAsString = [], this.config.fetchAsString && Array.isArray(this.config.fetchAsString) && this.config.fetchAsString.forEach(function(E) {
        g(E) && (E = E.toUpperCase(), T[E] && (E !== "NUMBER" && E !== "DATE" && E !== "CLOB" && E !== "BUFFER" && this.logger.warn(
          'Only "date", "number", "clob" and "buffer" are supported for fetchAsString'
        ), S.fetchAsString.push(T[E])));
      }), T;
    }
    queryCompiler(S, T) {
      return new a(this, S, T);
    }
    tableCompiler() {
      return new s(this, ...arguments);
    }
    columnCompiler() {
      return new o(this, ...arguments);
    }
    viewBuilder() {
      return new p(this, ...arguments);
    }
    viewCompiler() {
      return new l(this, ...arguments);
    }
    formatter(S) {
      return new i(this, S);
    }
    transaction() {
      return new m(this, ...arguments);
    }
    prepBindings(S) {
      return n(S, (T) => T instanceof c && this.driver ? { type: this.driver.BLOB, dir: this.driver.BIND_OUT } : T instanceof f && this.driver ? { type: this.driver.STRING, dir: this.driver.BIND_OUT } : typeof T == "boolean" ? T ? 1 : 0 : T);
    }
    // Checks whether a value is a function... if it is, we compile it
    // otherwise we check whether it's a raw
    parameter(S, T, E) {
      return typeof S == "function" ? v(
        y(S, void 0, this, E),
        !0,
        T,
        this
      ) : S instanceof c ? (E.bindings.push(S.value), "?") : d(S, !0, T, this, E) || "?";
    }
    // Get a raw connection, called by the `pool` whenever a new
    // connection needs to be added to the pool.
    acquireRawConnection() {
      const S = this;
      return new Promise(function(E, C) {
        const A = S.connectionSettings.externalAuth ? { externalAuth: S.connectionSettings.externalAuth } : {
          user: S.connectionSettings.user,
          password: S.connectionSettings.password
        };
        A.connectString = b(
          S.connectionSettings
        ), S.connectionSettings.prefetchRowCount && (A.prefetchRows = S.connectionSettings.prefetchRowCount), S.connectionSettings.stmtCacheSize !== void 0 && (A.stmtCacheSize = S.connectionSettings.stmtCacheSize), S.driver.fetchAsString = S.fetchAsString, S.driver.getConnection(A, function(R, D) {
          if (R)
            return C(R);
          u(D, S), E(D);
        });
      });
    }
    // Used to explicitly close a connection, called internally by the pool
    // when a connection times out or the pool is shutdown.
    destroyRawConnection(S) {
      return S.release();
    }
    // Runs the query on the specified connection, providing the bindings
    // and any other necessary prep work.
    _query(S, T) {
      if (!T.sql)
        throw new Error("The query is empty");
      const E = { autoCommit: !1 };
      return T.method === "select" && (E.resultSet = !0), S.executeAsync(T.sql, T.bindings, E).then(async function(C) {
        let A = e(C.outBinds);
        if (T.response = C.rows || [], T.rowsAffected = C.rows ? C.rows.rowsAffected : C.rowsAffected, T.method === "raw" && A.length > 0)
          return {
            response: A
          };
        if (T.method === "update") {
          const F = T.rowsAffected.length || T.rowsAffected, K = [], V = [], ne = ($) => function(L, P) {
            const H = P * F;
            V.push(A[$ + H]);
          };
          for (let $ = 0; $ < F; $++)
            K.push(T.outBinding[0]), t(T.outBinding[0], ne($));
          A = V, T.outBinding = K;
        }
        if (!T.returning && A.length === 0)
          return S.isTransaction || await S.commitAsync(), T;
        const R = [];
        let D = 0;
        for (let F = 0; F < T.outBinding.length; F++) {
          const K = T.outBinding[F];
          D = D + (T.outBinding[F - 1] ? T.outBinding[F - 1].length : 0);
          for (let V = 0; V < K.length; V++) {
            const ne = K[V];
            await new Promise(function($, L) {
              if (ne instanceof c) {
                const P = A[V + D];
                ne.returning && (T.response[F] = T.response[F] || {}, T.response[F][ne.columnName] = ne.value), P.on("error", function(H) {
                  L(H);
                }), P.on("finish", function() {
                  $();
                }), P.write(ne.value), P.end();
              } else
                T.outBinding[F][V] === "ROWID" ? (R.push(A[V + D]), $()) : (T.response[F] = T.response[F] || {}, T.response[F][ne] = A[V + D], $());
            });
          }
        }
        if (S.isTransaction)
          return T;
        if (await S.commitAsync(), T.returningSql) {
          const F = await S.executeAsync(
            T.returningSql(),
            R,
            { resultSet: !0 }
          );
          T.response = F.rows;
        }
        return T;
      });
    }
    // Process the response as returned from the query.
    processResponse(S, T) {
      const { response: E } = S;
      if (S.output)
        return S.output.call(T, E);
      switch (S.method) {
        case "select":
          return E;
        case "first":
          return E[0];
        case "pluck":
          return n(E, S.pluck);
        case "insert":
        case "del":
        case "update":
        case "counter":
          return S.returning && !r(S.returning) ? E : S.rowsAffected !== void 0 ? S.rowsAffected : 1;
        default:
          return E;
      }
    }
    processPassedConnection(S) {
      u(S, this);
    }
  }
  x.prototype.driverName = "oracledb";
  function b(w) {
    return w.connectString ? w.connectString : w.port ? w.host + ":" + w.port + "/" + w.database : w.host + "/" + w.database;
  }
  return Mf = x, Mf;
}
var qf, Wx;
function cse() {
  if (Wx)
    return qf;
  Wx = 1;
  const t = vu();
  class e extends t {
    constructor(...n) {
      super(...n), this.driverName = "pgnative", this.canCancelQuery = !0;
    }
    _driver() {
      return se.native;
    }
    _stream(n, i, a, s) {
      if (!i.sql)
        throw new Error("The query is empty");
      const o = this;
      return new Promise((c, f) => (a.on("error", f), a.on("end", c), o._query(n, i).then((u) => u.response).then(({ rows: u }) => u.forEach((l) => a.write(l))).catch(function(u) {
        a.emit("error", u);
      }).then(function() {
        a.end();
      })));
    }
    async cancelQuery(n) {
      try {
        return await this._wrappedCancelQueryCall(null, n);
      } catch (i) {
        throw this.logger.warn(`Connection Error: ${i}`), i;
      }
    }
    _wrappedCancelQueryCall(n, i) {
      return new Promise(function(a, s) {
        i.native.cancel(function(o) {
          if (o) {
            s(o);
            return;
          }
          a(!0);
        });
      });
    }
  }
  return qf = e, qf;
}
var jf, Gx;
function use() {
  if (Gx)
    return jf;
  Gx = 1;
  const t = ln;
  return jf = class extends t {
    begin(r) {
      return this.isolationLevel ? this.query(r, `BEGIN ISOLATION LEVEL ${this.isolationLevel};`) : this.query(r, "BEGIN;");
    }
    savepoint(r) {
      return this.trxClient.logger("Redshift does not support savepoints."), Promise.resolve();
    }
    release(r, n) {
      return this.trxClient.logger("Redshift does not support savepoints."), Promise.resolve();
    }
    rollbackTo(r, n) {
      return this.trxClient.logger("Redshift does not support savepoints."), Promise.resolve();
    }
  }, jf;
}
var Ff, Qx;
function lse() {
  if (Qx)
    return Ff;
  Qx = 1;
  const t = Hn, e = jv(), r = Wt, {
    columnize: n
  } = xt;
  class i extends e {
    truncate() {
      return `truncate ${this.tableName.toLowerCase()}`;
    }
    // Compiles an `insert` query, allowing for multiple
    // inserts using a single query statement.
    insert() {
      const s = t.prototype.insert.apply(this, arguments);
      return s === "" ? s : (this._slightReturn(), {
        sql: s
      });
    }
    // Compiles an `update` query, warning on unsupported returning
    update() {
      const s = t.prototype.update.apply(this, arguments);
      return this._slightReturn(), {
        sql: s
      };
    }
    // Compiles an `delete` query, warning on unsupported returning
    del() {
      const s = t.prototype.del.apply(this, arguments);
      return this._slightReturn(), {
        sql: s
      };
    }
    // simple: if trying to return, warn
    _slightReturn() {
      this.single.isReturning && this.client.logger.warn(
        "insert/update/delete returning is not supported by redshift dialect"
      );
    }
    forUpdate() {
      return this.client.logger.warn("table lock is not supported by redshift dialect"), "";
    }
    forShare() {
      return this.client.logger.warn(
        "lock for share is not supported by redshift dialect"
      ), "";
    }
    forNoKeyUpdate() {
      return this.client.logger.warn("table lock is not supported by redshift dialect"), "";
    }
    forKeyShare() {
      return this.client.logger.warn(
        "lock for share is not supported by redshift dialect"
      ), "";
    }
    // Compiles a columnInfo query
    columnInfo() {
      const s = this.single.columnInfo;
      let o = this.single.schema;
      const c = this.client.customWrapIdentifier(this.single.table, r);
      o && (o = this.client.customWrapIdentifier(o, r));
      const f = "select * from information_schema.columns where table_name = ? and table_catalog = ?", u = [
        c.toLowerCase(),
        this.client.database().toLowerCase()
      ];
      return this._buildColumnInfoQuery(o, f, u, s);
    }
    jsonExtract(s) {
      let o;
      return Array.isArray(s.column) ? o = s.column : o = [s], o.map((c) => {
        const f = `json_extract_path_text(${n(
          c.column || c[0],
          this.builder,
          this.client,
          this.bindingsHolder
        )}, ${this.client.toPathForJson(
          s.path || c[1],
          this.builder,
          this.bindingsHolder
        )})`, u = c.alias || c[2];
        return u ? this.client.alias(f, this.formatter.wrap(u)) : f;
      }).join(", ");
    }
    jsonSet(s) {
      throw new Error("Json set is not supported by Redshift");
    }
    jsonInsert(s) {
      throw new Error("Json insert is not supported by Redshift");
    }
    jsonRemove(s) {
      throw new Error("Json remove is not supported by Redshift");
    }
    whereJsonPath(s) {
      return this._whereJsonPath(
        "json_extract_path_text",
        Object.assign({}, s, {
          path: this.client.toPathForJson(s.path)
        })
      );
    }
    whereJsonSupersetOf(s) {
      throw new Error("Json superset is not supported by Redshift");
    }
    whereJsonSubsetOf(s) {
      throw new Error("Json subset is not supported by Redshift");
    }
    onJsonPathEquals(s) {
      return this._onJsonPathEquals("json_extract_path_text", s);
    }
  }
  return Ff = i, Ff;
}
var Bf, Vx;
function pse() {
  if (Vx)
    return Bf;
  Vx = 1;
  const t = du;
  class e extends t {
    constructor() {
      super(...arguments);
    }
    // primary needs to set not null on non-preexisting columns, or fail
    primary() {
      return this.notNullable(), super.primary(...arguments);
    }
    index() {
      return this.client.logger.warn(
        "Redshift does not support the creation of indexes."
      ), this;
    }
  }
  return Bf = e, Bf;
}
var Uf, Kx;
function fse() {
  if (Kx)
    return Uf;
  Kx = 1;
  const t = Fv(), e = Wn;
  class r extends t {
    constructor() {
      super(...arguments);
    }
    // Types:
    // ------
    bit(i) {
      return i.length !== !1 ? `char(${i.length})` : "char(1)";
    }
    datetime(i) {
      return i ? "timestamp" : "timestamptz";
    }
    timestamp(i) {
      return i ? "timestamp" : "timestamptz";
    }
    // Modifiers:
    // ------
    comment(i) {
      this.pushAdditional(function() {
        this.pushQuery(
          `comment on column ${this.tableCompiler.tableName()}.` + this.formatter.wrap(this.args[0]) + " is " + (i ? `'${i}'` : "NULL")
        );
      }, i);
    }
  }
  return r.prototype.increments = ({ primaryKey: n = !0 } = {}) => "integer identity(1,1)" + (n ? " primary key" : "") + " not null", r.prototype.bigincrements = ({
    primaryKey: n = !0
  } = {}) => "bigint identity(1,1)" + (n ? " primary key" : "") + " not null", r.prototype.binary = "varchar(max)", r.prototype.blob = "varchar(max)", r.prototype.enu = "varchar(255)", r.prototype.enum = "varchar(255)", r.prototype.json = "varchar(max)", r.prototype.jsonb = "varchar(max)", r.prototype.longblob = "varchar(max)", r.prototype.mediumblob = "varchar(16777218)", r.prototype.set = "text", r.prototype.text = "varchar(max)", r.prototype.tinyblob = "varchar(256)", r.prototype.uuid = e.prototype.uuid, r.prototype.varbinary = "varchar(max)", r.prototype.bigint = "bigint", r.prototype.bool = "boolean", r.prototype.double = "double precision", r.prototype.floating = "real", r.prototype.smallint = "smallint", r.prototype.tinyint = "smallint", Uf = r, Uf;
}
var zf, Jx;
function hse() {
  if (Jx)
    return zf;
  Jx = 1;
  const t = ou, e = Bv();
  class r extends e {
    constructor() {
      super(...arguments);
    }
    index(i, a, s) {
      this.client.logger.warn(
        "Redshift does not support the creation of indexes."
      );
    }
    dropIndex(i, a) {
      this.client.logger.warn(
        "Redshift does not support the deletion of indexes."
      );
    }
    // TODO: have to disable setting not null on columns that already exist...
    // Adds the "create" query to the query sequence.
    createQuery(i, a, s) {
      const o = a ? "create table if not exists " : "create table ", c = " (" + i.sql.join(", ") + this._addChecks() + ")";
      let f = o + this.tableName() + (s && this.tableNameLike() ? " (like " + this.tableNameLike() + ")" : c);
      this.single.inherits && (f += ` like (${this.formatter.wrap(this.single.inherits)})`), this.pushQuery({
        sql: f,
        bindings: i.bindings
      }), t(this.single, "comment") && this.comment(this.single.comment), s && this.addColumns(i, this.addColumnsPrefix);
    }
    primary(i, a) {
      const s = this;
      a = a ? s.formatter.wrap(a) : s.formatter.wrap(`${this.tableNameRaw}_pkey`), i.constructor !== Array && (i = [i]);
      const o = s.grouped.columns;
      if (o)
        for (let c = 0; c < i.length; c++) {
          let f = o.find(
            (l) => l.grouping === "columns" && l.builder && l.builder._method === "add" && l.builder._args && l.builder._args.indexOf(i[c]) > -1
          );
          if (f && (f = f.builder), !(f && f._modifiers && f._modifiers.nullable && f._modifiers.nullable[0] === !1))
            return f ? this.client.logger.warn(
              "Redshift does not allow primary keys to contain nullable columns."
            ) : this.client.logger.warn(
              "Redshift does not allow primary keys to contain nonexistent columns."
            );
        }
      return s.pushQuery(
        `alter table ${s.tableName()} add constraint ${a} primary key (${s.formatter.columnize(
          i
        )})`
      );
    }
    // Compiles column add. Redshift can only add one column per ALTER TABLE, so core addColumns doesn't work.  #2545
    addColumns(i, a, s) {
      if (a === this.alterColumnsPrefix)
        super.addColumns(i, a, s);
      else {
        a = a || this.addColumnsPrefix, s = s || this.getColumns();
        for (const o of s) {
          const c = this.tableName(), f = o.compileColumn();
          this.pushQuery({
            sql: `alter table ${c} ${a}${f}`,
            bindings: []
          });
        }
      }
    }
  }
  return zf = r, zf;
}
var Hf, Xx;
function dse() {
  if (Xx)
    return Hf;
  Xx = 1;
  const t = NA();
  class e extends t {
    constructor() {
      super(...arguments);
    }
  }
  return Hf = e, Hf;
}
var Wf, Zx;
function mse() {
  if (Zx)
    return Wf;
  Zx = 1;
  const t = Uv();
  class e extends t {
    constructor(n, i) {
      super(n, i);
    }
  }
  return Wf = e, Wf;
}
var Gf, Yx;
function gse() {
  if (Yx)
    return Gf;
  Yx = 1;
  const t = vu(), e = zn, r = use(), n = lse(), i = pse(), a = fse(), s = hse(), o = dse(), c = mse();
  class f extends t {
    transaction() {
      return new r(this, ...arguments);
    }
    queryCompiler(l, p) {
      return new n(this, l, p);
    }
    columnBuilder() {
      return new i(this, ...arguments);
    }
    columnCompiler() {
      return new a(this, ...arguments);
    }
    tableCompiler() {
      return new s(this, ...arguments);
    }
    schemaCompiler() {
      return new o(this, ...arguments);
    }
    viewCompiler() {
      return new c(this, ...arguments);
    }
    _driver() {
      return se;
    }
    // Ensures the response is returned in the same format as other clients.
    processResponse(l, p) {
      const m = l.response;
      return l.output ? l.output.call(p, m) : l.method === "raw" ? m : m.command === "SELECT" ? l.method === "first" ? m.rows[0] : l.method === "pluck" ? e(m.rows, l.pluck) : m.rows : m.command === "INSERT" || m.command === "UPDATE" || m.command === "DELETE" ? m.rowCount : m;
    }
    toPathForJson(l, p, m) {
      return l.replace(/^(\$\.)/, "").split(".").map(
        function(h) {
          return this.parameter(h, p, m);
        }.bind(this)
      ).join(", ");
    }
  }
  return Object.assign(f.prototype, {
    dialect: "redshift",
    driverName: "pg-redshift"
  }), Gf = f, Gf;
}
Object.defineProperty(gu, "__esModule", { value: !0 });
gu.getDialectByNameOrAlias = void 0;
const { resolveClientNameWithAliases: vse } = wt, yse = Object.freeze({
  "better-sqlite3": () => gae(),
  cockroachdb: () => Sae(),
  mssql: () => Nae(),
  mysql: () => LA(),
  mysql2: () => Hae(),
  oracle: () => MA(),
  oracledb: () => ose(),
  pgnative: () => cse(),
  postgres: () => vu(),
  redshift: () => gse(),
  sqlite3: () => kA()
});
function bse(t) {
  const e = vse(t), r = yse[e];
  if (!r)
    throw new Error(`Invalid clientName given: ${t}`);
  return r();
}
gu.getDialectByNameOrAlias = bse;
const wse = Gn, { SUPPORTED_CLIENTS: xse } = Rv, e_ = Xie, { getDialectByNameOrAlias: _se } = gu;
function Ese(t) {
  let e, r;
  const n = typeof t == "string" ? Object.assign(e_(t), arguments[2]) : t;
  if (arguments.length === 0 || !n.client && !n.dialect)
    e = wse;
  else if (typeof n.client == "function")
    e = n.client;
  else {
    const i = n.client || n.dialect;
    if (!xse.includes(i))
      throw new Error(
        `knex: Unknown configuration option 'client' value ${i}. Note that it is case-sensitive, check documentation for supported values.`
      );
    e = _se(i);
  }
  return typeof n.connection == "string" ? r = Object.assign({}, n, {
    connection: e_(n.connection).connection
  }) : r = Object.assign({}, n), {
    resolvedConfig: r,
    Dialect: e
  };
}
var Sse = {
  resolveConfig: Ese
};
const Cse = Gn, Tse = pn, Ose = $O, Ase = UO, { KnexTimeoutError: $se } = cn, { resolveConfig: Ise } = Sse, kse = bA, Rse = bs, Nse = du, Lse = xA;
function fn(t) {
  const { resolvedConfig: e, Dialect: r } = Ise(...arguments), n = Ase(new r(e));
  return e.userParams && (n.userParams = e.userParams), n;
}
fn.Client = Cse;
fn.KnexTimeoutError = $se;
fn.QueryBuilder = {
  extend: function(t, e) {
    Tse.extend(t, e), Ose.push(t);
  }
};
fn.SchemaBuilder = {
  extend: function(t, e) {
    kse.extend(t, e);
  }
};
fn.ViewBuilder = {
  extend: function(t, e) {
    Rse.extend(t, e);
  }
};
fn.ColumnBuilder = {
  extend: function(t, e) {
    Nse.extend(t, e);
  }
};
fn.TableBuilder = {
  extend: function(t, e) {
    Lse.extend(t, e);
  }
};
var Pse = fn;
const Dse = Pse;
var Mse = Dse;
const Ba = Mse;
Ba.knex = Ba;
Ba.default = Ba;
var qse = Ba;
iq();
const Zr = {
  name: process.env.DBNAME || "",
  port: process.env.DBPORT || "",
  host: process.env.DBHOST || "",
  user: process.env.DBUSER || "",
  pass: process.env.DBPASS || "",
  schema: process.env.DBSCHEMA || ""
}, Qn = () => qse.knex({
  client: "pg",
  connection: {
    host: Zr.host,
    user: Zr.user,
    password: Zr.pass,
    database: Zr.name
  }
});
function jse(t) {
  Object.defineProperty(t, "__esModule", { value: !0, configurable: !0 });
}
function Qi(t, e, r, n) {
  Object.defineProperty(t, e, { get: r, set: n, enumerable: !0, configurable: !0 });
}
const Fse = (t, e) => {
  let r = t, n;
  try {
    let i = e.split(".");
    for (i.length === 0 && (i = [
      e
    ]); i.length > 0; ) {
      if (n = i.shift(), !n)
        return;
      r = r[n];
    }
    return r;
  } catch (i) {
    console.error("JSON pointer failed", i);
    return;
  }
};
var fg = Fse;
const Ft = (t) => `0${t}`.slice(-2), Bse = () => {
  const t = /* @__PURE__ */ new Date(), e = t.getUTCFullYear(), r = Ft(t.getUTCMonth() + 1), n = Ft(t.getUTCDate()), i = Ft(t.getUTCHours()), a = Ft(t.getUTCMinutes()), s = Ft(t.getUTCSeconds());
  return `${e}-${r}-${n} ${i}:${a}:${s}`;
}, Use = () => {
  const t = /* @__PURE__ */ new Date(), e = t.getUTCFullYear(), r = Ft(t.getUTCMonth() + 1), n = Ft(t.getUTCDate());
  return `${e}-${r}-${n}`;
}, zse = () => {
  const t = /* @__PURE__ */ new Date(), e = t.getFullYear(), r = Ft(t.getMonth() + 1), n = Ft(t.getDate());
  return `${e}-${r}-${n}`;
}, Hse = (t) => {
  const e = new Date(t), r = e.getUTCFullYear(), n = Ft(e.getUTCMonth() + 1), i = Ft(e.getUTCDate());
  return `${r}/${n}/${i}`;
}, Wse = (t) => (t ? new Date(t) : /* @__PURE__ */ new Date()).toLocaleTimeString();
var Gse = {
  getTimestamp: Bse,
  getDateStamp: Use,
  getDateStampLocal: zse,
  addLeadZero: Ft,
  readableFromValue: Hse,
  localTime: Wse
}, Vn = {};
jse(Vn);
Qi(Vn, "hasProp", () => yu);
Qi(Vn, "cleanCopy", () => qA);
Qi(Vn, "updateObj", () => jA);
Qi(Vn, "setObjField", () => FA);
Qi(Vn, "objPointer", () => BA);
Qi(Vn, "default", () => Qse);
const yu = (t, e) => Object.prototype.hasOwnProperty.call(t, e), qA = (t) => Object.assign({}, t), jA = (t, e) => {
  for (const [r, n] of Object.entries(e))
    yu(t, r) && (t[r] = n);
}, FA = (t, e, r) => {
  let n = t, i, a = e.split(".");
  a.length === 0 && (a = [
    e
  ]);
  try {
    for (; a.length > 0; ) {
      if (i = a.shift(), !i)
        return;
      a.length !== 0 ? n = n[i] : n[i] = r;
    }
  } catch {
    console.error("Failed to set object", t, e, r);
  }
}, BA = (t, e) => {
  let r = t, n;
  try {
    let i = e.split(".");
    for (i.length === 0 && (i = [
      e
    ]); i.length > 0; ) {
      if (n = i.shift(), !n)
        return;
      r = r[n];
    }
    return r;
  } catch (i) {
    console.error("Failed to find pointer", i);
  }
};
var Qse = {
  hasProp: yu,
  cleanCopy: qA,
  updateObj: jA,
  setObjField: FA,
  objPointer: BA
};
const Vse = (t, e, r, n) => t.filter((i) => {
  if (!yu(i, e))
    return !1;
  switch (n) {
    case "NE":
      return i[e] !== r;
    default:
      return i[e] === r;
  }
}), Kse = (t, e, r) => {
  let n, i = -1;
  for (let a = 0, s = t.length; a < s; a++)
    if (n = fg(t[a], e), n != null && n === r) {
      i = a;
      break;
    }
  return i;
}, Jse = (t, e, r = !1) => {
  const n = e.length;
  return t.sort((i, a) => {
    let s = 0, o, c;
    for (let f = 0; f < n; f++)
      return s = 0, o = fg(i, e[f]), c = fg(a, e[f]), typeof o == "string" && (o = o.toLowerCase()), typeof c == "string" && (c = c.toLowerCase()), o === c ? 0 : (s = o < c ? -1 : 1, r ? s * -1 : s);
    return s;
  });
}, Xse = (t, e) => new Promise(async function(r) {
  const n = [], i = [];
  for (let s = 0, o = t.length; s < o; s++)
    n.push(e(t[s], s, t));
  const a = (s) => {
    s.status === "fulfilled" && i.push(s.value);
  };
  Promise.allSettled(n).then((s) => {
    s.forEach(a), r(i);
  });
});
var Zse = {
  filterBy: Vse,
  indexBy: Kse,
  sortBy: Jse,
  asyncForEach: Xse
};
const Yse = (t) => {
  let e = t.replace(/[-_]+(.)?/g, (r, n) => n ? n.toUpperCase() : "");
  return e.substring(0, 1).toLowerCase() + e.substring(1);
}, eoe = (t) => JSON.stringify(t, null, 4), toe = (t) => t.trim().toLowerCase(), UA = (t) => t.replace(/^[A-Z|a-z]/g, (e) => e.toUpperCase()), roe = (t) => UA(t).replace(/[-_]+(.)?/g, (e, r) => r ? r.toUpperCase() : ""), noe = (t) => t.replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[\s_]+/g, "-").toLowerCase(), ioe = (t) => t.toLowerCase().replace(/[^\p{L}0-9]+/gu, "").replace(/\s/g, ""), aoe = (t) => /^[a-zA-Z]+$/.test(t), soe = (t) => /^([a-zA-Z]+(-|_)*)+/g.test(t), ooe = (t) => /^([a-zA-Z\d\D]+(-|_)*)+/g.test(t), coe = (t) => {
  const n = 214 - "@owlui/".length, i = t.length, a = i <= n, s = n - i, o = s * -1;
  return {
    valid: a,
    maxLn: n,
    ln: i,
    remain: s,
    over: o
  };
};
var uoe = {
  toCamelCase: Yse,
  toPascalCase: roe,
  toKebabCase: noe,
  toScormCase: ioe,
  prettyJson: eoe,
  toLower: toe,
  toCapitalize: UA,
  hasLettersOnly: aoe,
  isValidComponentInputName: soe,
  isValidPackageName: coe,
  isValidOptionInputName: ooe
};
const loe = Gse, hg = Zse, Qf = uoe, zA = (t, e) => (console.log(`dropping table ${e}`), t.raw(`DROP TABLE IF EXISTS ${e} CASCADE`)), poe = (t, e, r = "id") => {
  switch (r) {
    case "id":
      e.uuid(r).primary().notNullable().unique().defaultTo(t.raw("uuid_generate_v4()"));
      break;
    default:
      e.uuid(r).notNullable().unique().defaultTo(t.raw("uuid_generate_v4()"));
      break;
  }
}, foe = (t, e) => {
  console.log(`creating foreign key ${e.col} for ${e.table}`), t.foreign(e.col).references(`${e.table}.id`);
}, HA = (t, e, r, n) => t.schema.withSchema(n.schema).createTable(e, (i) => {
  const a = r.length;
  let s = 0, o = "";
  for (; s < a; ) {
    switch (o = r[s].column.name, r[s].column.type) {
      case "uuid":
        poe(t, i, o);
        break;
      case "string":
        i.string(o).defaultTo("");
        break;
      case "integer":
        i.integer(o);
        break;
      case "decimal":
        i.decimal(o);
        break;
      case "foreign":
        i.uuid(o), foe(i, {
          col: o,
          table: r[s].column.table || ""
        });
        break;
      case "datetime":
        i.datetime(o).defaultTo(t.fn.now());
        break;
      case "json":
        i.json(o);
        break;
      case "boolean":
        i.boolean(o);
        break;
    }
    s++;
  }
}), WA = (t, e, r) => {
  const n = (i) => (console.log(`inserting entry into ${e} 
`, JSON.stringify(i, null, 2)), t(e).returning("id").insert(i));
  return hg.asyncForEach(r, n);
}, hoe = {
  drop: zA,
  create: HA,
  insert: WA
}, doe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  create: HA,
  default: hoe,
  drop: zA,
  insert: WA
}, Symbol.toStringTag, { value: "Module" })), Yt = doe, dg = "assets", GA = [
  {
    column: {
      name: "id",
      type: "uuid"
    }
  },
  {
    column: {
      name: "workspaceId",
      type: "foreign",
      table: dr
    }
  },
  {
    column: {
      name: "createdAt",
      type: "datetime"
    }
  },
  {
    column: {
      name: "deletedAt",
      type: "datetime"
    }
  },
  {
    column: {
      name: "title",
      type: "string"
    }
  },
  {
    column: {
      name: "isResource",
      type: "boolean"
    }
  },
  {
    column: {
      name: "description",
      type: "string"
    }
  },
  {
    column: {
      name: "filename",
      type: "string"
    }
  },
  {
    column: {
      name: "ext",
      type: "string"
    }
  },
  {
    column: {
      name: "type",
      type: "string"
    }
  },
  {
    column: {
      name: "size",
      type: "integer"
    }
  },
  {
    column: {
      name: "sourceExt",
      type: "string"
    }
  },
  {
    column: {
      name: "sourceFilename",
      type: "string"
    }
  }
], moe = (t) => new Promise(async (e, r) => {
  try {
    await Yt.drop(t, dg), await Yt.create(t, dg, GA, Zr), e(!0);
  } catch (n) {
    r(n);
  }
}), goe = {
  table: dg,
  definition: GA,
  seed: moe
}, voe = (t) => new Promise(async (e, r) => {
  try {
    console.log("seeding DB"), console.log("adding uuid support"), await t.raw('CREATE EXTENSION IF NOT EXISTS "uuid-ossp"'), await woe.seed(t), console.log("seeding workspaces"), await Soe.seed(t), console.log("seeding projects"), await vhe.seed(t), console.log("seeding assets"), await goe.seed(t), console.log("finished"), e({
      completed: !0
    });
  } catch (n) {
    r(n);
  }
}), yoe = (t) => new Promise(async (e, r) => {
  try {
    await Yt.drop(t, Sn), await Yt.create(t, Sn, UT, Zr), e(!0);
  } catch (n) {
    r(n);
  }
}), boe = {
  name: "/users/create",
  type: "invoke",
  method: "POST",
  fn: async (t, e) => {
    const r = Qn(), n = {
      name: "test user"
    };
    try {
      const a = (await Yt.insert(r, Sn, [n]))[0][0].id, [s] = await r.select().from(Sn).where(`${Sn}.id`, a);
      e.send({
        error: !1,
        data: s
      });
    } catch (i) {
      e.send({
        error: !0,
        message: "unexpected error while creating user",
        data: {
          trace: i
        }
      });
    }
  }
}, QA = {
  create: boe
}, woe = {
  table: Sn,
  definition: UT,
  seed: yoe,
  api: QA
}, dr = "workspaces", VA = [
  {
    column: {
      name: "id",
      type: "uuid"
    }
  },
  {
    column: {
      name: "createdAt",
      type: "datetime"
    }
  },
  {
    column: {
      name: "userId",
      type: "foreign",
      table: Sn
    }
  },
  {
    column: {
      name: "deletedAt",
      type: "datetime"
    }
  },
  {
    column: {
      name: "openedAt",
      type: "datetime"
    }
  },
  {
    column: {
      name: "updatedAt",
      type: "datetime"
    }
  },
  {
    column: {
      name: "versions",
      type: "json"
    }
  },
  {
    column: {
      name: "publishing",
      type: "json"
    }
  }
], xoe = (t) => new Promise(async (e, r) => {
  try {
    await Yt.drop(t, dr), await Yt.create(t, dr, VA, Zr), e(!0);
  } catch (n) {
    r(n);
  }
}), _oe = {
  name: "/workspaces/create",
  type: "invoke",
  method: "POST",
  fn: async (t, e) => {
    const r = t.body;
    if (!r.userId) {
      e.send({
        error: !0,
        message: "unable to create workspace: user id required",
        data: r
      });
      return;
    }
    const n = Qn(), i = {
      userId: r.userId
    };
    try {
      const s = (await Yt.insert(n, dr, [i]))[0][0].id, [o] = await n.select().from(dr).where(`${dr}.id`, s);
      e.send({
        error: !1,
        data: o
      });
    } catch (a) {
      e.send({
        error: !0,
        message: "unexpected error while creating workspace",
        data: {
          trace: a
        }
      });
    }
  }
}, Eoe = {
  name: "/workspaces",
  type: "invoke",
  fn: async (t, e) => {
    const { workspaceId: r } = t.query;
    if (!r) {
      e.send({
        error: !0,
        message: "unable to get workspace: id required"
      });
      return;
    }
    const n = Qn();
    try {
      const [i] = await n.select().from(dr).where(`${dr}.id`, r);
      e.send({
        error: !1,
        data: i
      });
    } catch (i) {
      e.send({
        error: !0,
        message: "unable to get workspace: unexpected error",
        data: {
          trace: i,
          query: t.query
        }
      });
    }
  }
}, KA = {
  create: _oe,
  get: Eoe
}, Soe = {
  table: dr,
  definition: VA,
  seed: xoe,
  api: KA
}, Xt = "projects", JA = [
  {
    column: {
      name: "id",
      type: "uuid"
    }
  },
  {
    column: {
      name: "createdAt",
      type: "datetime"
    }
  },
  {
    column: {
      name: "deletedAt",
      type: "datetime"
    }
  },
  {
    column: {
      name: "workspaceId",
      type: "foreign",
      table: dr
    }
  },
  {
    column: {
      name: "meta",
      type: "json"
    }
  },
  {
    column: {
      name: "scorm",
      type: "json"
    }
  },
  {
    column: {
      name: "modules",
      type: "json"
    }
  },
  {
    column: {
      name: "lessons",
      type: "json"
    }
  },
  {
    column: {
      name: "glossary",
      type: "json"
    }
  },
  {
    column: {
      name: "resources",
      type: "json"
    }
  }
], Coe = {
  name: "/projects/create",
  type: "invoke",
  method: "POST",
  fn: async (t, e) => {
    const r = t.body;
    if (!r.workspaceId) {
      e.send({
        error: !0,
        message: "unable to create project: workspace id required",
        data: r
      });
      return;
    }
    const n = Qn(), i = T5("default");
    i.workspaceId = r.workspaceId, i.modules = JSON.stringify(i.modules), i.lessons = JSON.stringify(i.lessons), i.glossary = JSON.stringify(i.glossary), i.resources = JSON.stringify(i.resources);
    try {
      const s = (await Yt.insert(n, Xt, [i]))[0][0].id, [o] = await n.select().from(Xt).where(`${Xt}.id`, s);
      e.send({
        error: !1,
        data: o
      });
    } catch (a) {
      e.send({
        error: !0,
        message: "unexpected error while creating project",
        data: {
          trace: a
        }
      });
    }
  }
}, Toe = {
  name: "/projects/list",
  type: "invoke",
  fn: (t, e) => {
  }
}, Ooe = {
  name: "/projects/open",
  type: "invoke",
  fn: (t, e) => {
  }
};
var ws = { exports: {} }, Hv = {}, Aoe = Hv.require = function() {
  if (typeof process == "object" && process.versions && process.versions.electron)
    try {
      const t = Aoe("original-fs");
      if (Object.keys(t).length > 0)
        return t;
    } catch {
    }
  return se;
}, XA = {
  /* The local file header */
  LOCHDR: 30,
  // LOC header size
  LOCSIG: 67324752,
  // "PK\003\004"
  LOCVER: 4,
  // version needed to extract
  LOCFLG: 6,
  // general purpose bit flag
  LOCHOW: 8,
  // compression method
  LOCTIM: 10,
  // modification time (2 bytes time, 2 bytes date)
  LOCCRC: 14,
  // uncompressed file crc-32 value
  LOCSIZ: 18,
  // compressed size
  LOCLEN: 22,
  // uncompressed size
  LOCNAM: 26,
  // filename length
  LOCEXT: 28,
  // extra field length
  /* The Data descriptor */
  EXTSIG: 134695760,
  // "PK\007\008"
  EXTHDR: 16,
  // EXT header size
  EXTCRC: 4,
  // uncompressed file crc-32 value
  EXTSIZ: 8,
  // compressed size
  EXTLEN: 12,
  // uncompressed size
  /* The central directory file header */
  CENHDR: 46,
  // CEN header size
  CENSIG: 33639248,
  // "PK\001\002"
  CENVEM: 4,
  // version made by
  CENVER: 6,
  // version needed to extract
  CENFLG: 8,
  // encrypt, decrypt flags
  CENHOW: 10,
  // compression method
  CENTIM: 12,
  // modification time (2 bytes time, 2 bytes date)
  CENCRC: 16,
  // uncompressed file crc-32 value
  CENSIZ: 20,
  // compressed size
  CENLEN: 24,
  // uncompressed size
  CENNAM: 28,
  // filename length
  CENEXT: 30,
  // extra field length
  CENCOM: 32,
  // file comment length
  CENDSK: 34,
  // volume number start
  CENATT: 36,
  // internal file attributes
  CENATX: 38,
  // external file attributes (host system dependent)
  CENOFF: 42,
  // LOC header offset
  /* The entries in the end of central directory */
  ENDHDR: 22,
  // END header size
  ENDSIG: 101010256,
  // "PK\005\006"
  ENDSUB: 8,
  // number of entries on this disk
  ENDTOT: 10,
  // total number of entries
  ENDSIZ: 12,
  // central directory size in bytes
  ENDOFF: 16,
  // offset of first CEN header
  ENDCOM: 20,
  // zip file comment length
  END64HDR: 20,
  // zip64 END header size
  END64SIG: 117853008,
  // zip64 Locator signature, "PK\006\007"
  END64START: 4,
  // number of the disk with the start of the zip64
  END64OFF: 8,
  // relative offset of the zip64 end of central directory
  END64NUMDISKS: 16,
  // total number of disks
  ZIP64SIG: 101075792,
  // zip64 signature, "PK\006\006"
  ZIP64HDR: 56,
  // zip64 record minimum size
  ZIP64LEAD: 12,
  // leading bytes at the start of the record, not counted by the value stored in ZIP64SIZE
  ZIP64SIZE: 4,
  // zip64 size of the central directory record
  ZIP64VEM: 12,
  // zip64 version made by
  ZIP64VER: 14,
  // zip64 version needed to extract
  ZIP64DSK: 16,
  // zip64 number of this disk
  ZIP64DSKDIR: 20,
  // number of the disk with the start of the record directory
  ZIP64SUB: 24,
  // number of entries on this disk
  ZIP64TOT: 32,
  // total number of entries
  ZIP64SIZB: 40,
  // zip64 central directory size in bytes
  ZIP64OFF: 48,
  // offset of start of central directory with respect to the starting disk number
  ZIP64EXTRA: 56,
  // extensible data sector
  /* Compression methods */
  STORED: 0,
  // no compression
  SHRUNK: 1,
  // shrunk
  REDUCED1: 2,
  // reduced with compression factor 1
  REDUCED2: 3,
  // reduced with compression factor 2
  REDUCED3: 4,
  // reduced with compression factor 3
  REDUCED4: 5,
  // reduced with compression factor 4
  IMPLODED: 6,
  // imploded
  // 7 reserved for Tokenizing compression algorithm
  DEFLATED: 8,
  // deflated
  ENHANCED_DEFLATED: 9,
  // enhanced deflated
  PKWARE: 10,
  // PKWare DCL imploded
  // 11 reserved by PKWARE
  BZIP2: 12,
  //  compressed using BZIP2
  // 13 reserved by PKWARE
  LZMA: 14,
  // LZMA
  // 15-17 reserved by PKWARE
  IBM_TERSE: 18,
  // compressed using IBM TERSE
  IBM_LZ77: 19,
  // IBM LZ77 z
  AES_ENCRYPT: 99,
  // WinZIP AES encryption method
  /* General purpose bit flag */
  // values can obtained with expression 2**bitnr
  FLG_ENC: 1,
  // Bit 0: encrypted file
  FLG_COMP1: 2,
  // Bit 1, compression option
  FLG_COMP2: 4,
  // Bit 2, compression option
  FLG_DESC: 8,
  // Bit 3, data descriptor
  FLG_ENH: 16,
  // Bit 4, enhanced deflating
  FLG_PATCH: 32,
  // Bit 5, indicates that the file is compressed patched data.
  FLG_STR: 64,
  // Bit 6, strong encryption (patented)
  // Bits 7-10: Currently unused.
  FLG_EFS: 2048,
  // Bit 11: Language encoding flag (EFS)
  // Bit 12: Reserved by PKWARE for enhanced compression.
  // Bit 13: encrypted the Central Directory (patented).
  // Bits 14-15: Reserved by PKWARE.
  FLG_MSK: 4096,
  // mask header values
  /* Load type */
  FILE: 2,
  BUFFER: 1,
  NONE: 0,
  /* 4.5 Extensible data fields */
  EF_ID: 0,
  EF_SIZE: 2,
  /* Header IDs */
  ID_ZIP64: 1,
  ID_AVINFO: 7,
  ID_PFS: 8,
  ID_OS2: 9,
  ID_NTFS: 10,
  ID_OPENVMS: 12,
  ID_UNIX: 13,
  ID_FORK: 14,
  ID_PATCH: 15,
  ID_X509_PKCS7: 20,
  ID_X509_CERTID_F: 21,
  ID_X509_CERTID_C: 22,
  ID_STRONGENC: 23,
  ID_RECORD_MGT: 24,
  ID_X509_PKCS7_RL: 25,
  ID_IBM1: 101,
  ID_IBM2: 102,
  ID_POSZIP: 18064,
  EF_ZIP64_OR_32: 4294967295,
  EF_ZIP64_OR_16: 65535,
  EF_ZIP64_SUNCOMP: 0,
  EF_ZIP64_SCOMP: 8,
  EF_ZIP64_RHO: 16,
  EF_ZIP64_DSN: 24
}, ZA = {
  /* Header error messages */
  INVALID_LOC: "Invalid LOC header (bad signature)",
  INVALID_CEN: "Invalid CEN header (bad signature)",
  INVALID_END: "Invalid END header (bad signature)",
  /* ZipEntry error messages*/
  NO_DATA: "Nothing to decompress",
  BAD_CRC: "CRC32 checksum failed",
  FILE_IN_THE_WAY: "There is a file in the way: %s",
  UNKNOWN_METHOD: "Invalid/unsupported compression method",
  /* Inflater error messages */
  AVAIL_DATA: "inflate::Available inflate data did not terminate",
  INVALID_DISTANCE: "inflate::Invalid literal/length or distance code in fixed or dynamic block",
  TO_MANY_CODES: "inflate::Dynamic block code description: too many length or distance codes",
  INVALID_REPEAT_LEN: "inflate::Dynamic block code description: repeat more than specified lengths",
  INVALID_REPEAT_FIRST: "inflate::Dynamic block code description: repeat lengths with no first length",
  INCOMPLETE_CODES: "inflate::Dynamic block code description: code lengths codes incomplete",
  INVALID_DYN_DISTANCE: "inflate::Dynamic block code description: invalid distance code lengths",
  INVALID_CODES_LEN: "inflate::Dynamic block code description: invalid literal/length code lengths",
  INVALID_STORE_BLOCK: "inflate::Stored block length did not match one's complement",
  INVALID_BLOCK_TYPE: "inflate::Invalid block type (type == 3)",
  /* ADM-ZIP error messages */
  CANT_EXTRACT_FILE: "Could not extract the file",
  CANT_OVERRIDE: "Target file already exists",
  NO_ZIP: "No zip file was loaded",
  NO_ENTRY: "Entry doesn't exist",
  DIRECTORY_CONTENT_ERROR: "A directory cannot have content",
  FILE_NOT_FOUND: "File not found: %s",
  NOT_IMPLEMENTED: "Not implemented",
  INVALID_FILENAME: "Invalid filename",
  INVALID_FORMAT: "Invalid or unsupported zip format. No END header found"
};
const $oe = Hv.require(), Ot = se, t_ = XA, Ioe = ZA, koe = typeof process == "object" && process.platform === "win32", r_ = (t) => t && typeof t == "object", Wv = new Uint32Array(256).map((t, e) => {
  for (let r = 0; r < 8; r++)
    e & 1 ? e = 3988292384 ^ e >>> 1 : e >>>= 1;
  return e >>> 0;
});
function yt(t) {
  this.sep = Ot.sep, this.fs = $oe, r_(t) && r_(t.fs) && typeof t.fs.statSync == "function" && (this.fs = t.fs);
}
var Roe = yt;
yt.prototype.makeDir = function(t) {
  const e = this;
  function r(n) {
    let i = n.split(e.sep)[0];
    n.split(e.sep).forEach(function(a) {
      if (!(!a || a.substr(-1, 1) === ":")) {
        i += e.sep + a;
        var s;
        try {
          s = e.fs.statSync(i);
        } catch {
          e.fs.mkdirSync(i);
        }
        if (s && s.isFile())
          throw Ioe.FILE_IN_THE_WAY.replace("%s", i);
      }
    });
  }
  r(t);
};
yt.prototype.writeFileTo = function(t, e, r, n) {
  const i = this;
  if (i.fs.existsSync(t)) {
    if (!r)
      return !1;
    var a = i.fs.statSync(t);
    if (a.isDirectory())
      return !1;
  }
  var s = Ot.dirname(t);
  i.fs.existsSync(s) || i.makeDir(s);
  var o;
  try {
    o = i.fs.openSync(t, "w", 438);
  } catch {
    i.fs.chmodSync(t, 438), o = i.fs.openSync(t, "w", 438);
  }
  if (o)
    try {
      i.fs.writeSync(o, e, 0, e.length, 0);
    } finally {
      i.fs.closeSync(o);
    }
  return i.fs.chmodSync(t, n || 438), !0;
};
yt.prototype.writeFileToAsync = function(t, e, r, n, i) {
  typeof n == "function" && (i = n, n = void 0);
  const a = this;
  a.fs.exists(t, function(s) {
    if (s && !r)
      return i(!1);
    a.fs.stat(t, function(o, c) {
      if (s && c.isDirectory())
        return i(!1);
      var f = Ot.dirname(t);
      a.fs.exists(f, function(u) {
        u || a.makeDir(f), a.fs.open(t, "w", 438, function(l, p) {
          l ? a.fs.chmod(t, 438, function() {
            a.fs.open(t, "w", 438, function(m, h) {
              a.fs.write(h, e, 0, e.length, 0, function() {
                a.fs.close(h, function() {
                  a.fs.chmod(t, n || 438, function() {
                    i(!0);
                  });
                });
              });
            });
          }) : p ? a.fs.write(p, e, 0, e.length, 0, function() {
            a.fs.close(p, function() {
              a.fs.chmod(t, n || 438, function() {
                i(!0);
              });
            });
          }) : a.fs.chmod(t, n || 438, function() {
            i(!0);
          });
        });
      });
    });
  });
};
yt.prototype.findFiles = function(t) {
  const e = this;
  function r(n, i, a) {
    typeof i == "boolean" && (a = i, i = void 0);
    let s = [];
    return e.fs.readdirSync(n).forEach(function(o) {
      var c = Ot.join(n, o);
      e.fs.statSync(c).isDirectory() && a && (s = s.concat(r(c, i, a))), (!i || i.test(c)) && s.push(Ot.normalize(c) + (e.fs.statSync(c).isDirectory() ? e.sep : ""));
    }), s;
  }
  return r(t, void 0, !0);
};
yt.prototype.getAttributes = function() {
};
yt.prototype.setAttributes = function() {
};
yt.crc32update = function(t, e) {
  return Wv[(t ^ e) & 255] ^ t >>> 8;
};
yt.crc32 = function(t) {
  typeof t == "string" && (t = Buffer.from(t, "utf8")), Wv.length || genCRCTable();
  let e = t.length, r = -1;
  for (let n = 0; n < e; )
    r = yt.crc32update(r, t[n++]);
  return ~r >>> 0;
};
yt.methodToString = function(t) {
  switch (t) {
    case t_.STORED:
      return "STORED (" + t + ")";
    case t_.DEFLATED:
      return "DEFLATED (" + t + ")";
    default:
      return "UNSUPPORTED (" + t + ")";
  }
};
yt.canonical = function(t) {
  if (!t)
    return "";
  var e = Ot.posix.normalize("/" + t.split("\\").join("/"));
  return Ot.join(".", e);
};
yt.sanitize = function(t, e) {
  t = Ot.resolve(Ot.normalize(t));
  for (var r = e.split("/"), n = 0, i = r.length; n < i; n++) {
    var a = Ot.normalize(Ot.join(t, r.slice(n, i).join(Ot.sep)));
    if (a.indexOf(t) === 0)
      return a;
  }
  return Ot.normalize(Ot.join(t, Ot.basename(e)));
};
yt.toBuffer = function(e) {
  return Buffer.isBuffer(e) ? e : e instanceof Uint8Array ? Buffer.from(e) : typeof e == "string" ? Buffer.from(e, "utf8") : Buffer.alloc(0);
};
yt.readBigUInt64LE = function(t, e) {
  var r = Buffer.from(t.slice(e, e + 8));
  return r.swap64(), parseInt(`0x${r.toString("hex")}`);
};
yt.isWin = koe;
yt.crcTable = Wv;
const Jo = Hv.require(), YA = se;
Jo.existsSync = Jo.existsSync || YA.existsSync;
var Noe = function(t) {
  var e = t || "", r = i(), n = null;
  function i() {
    return {
      directory: !1,
      readonly: !1,
      hidden: !1,
      executable: !1,
      mtime: 0,
      atime: 0
    };
  }
  return e && Jo.existsSync(e) ? (n = Jo.statSync(e), r.directory = n.isDirectory(), r.mtime = n.mtime, r.atime = n.atime, r.executable = (73 & n.mode) !== 0, r.readonly = (128 & n.mode) === 0, r.hidden = YA.basename(e)[0] === ".") : console.warn("Invalid path: " + e), {
    get directory() {
      return r.directory;
    },
    get readOnly() {
      return r.readonly;
    },
    get hidden() {
      return r.hidden;
    },
    get mtime() {
      return r.mtime;
    },
    get atime() {
      return r.atime;
    },
    get executable() {
      return r.executable;
    },
    decodeAttributes: function() {
    },
    encodeAttributes: function() {
    },
    toJSON: function() {
      return {
        path: e,
        isDirectory: r.directory,
        isReadOnly: r.readonly,
        isHidden: r.hidden,
        isExecutable: r.executable,
        mTime: r.mtime,
        aTime: r.atime
      };
    },
    toString: function() {
      return JSON.stringify(this.toJSON(), null, "	");
    }
  };
};
ws.exports = Roe;
ws.exports.Constants = XA;
ws.exports.Errors = ZA;
ws.exports.FileAttr = Noe;
var xs = ws.exports, bu = {}, ha = xs, we = ha.Constants, Loe = function() {
  var t = 20, e = 10, r = 0, n = 0, i = 0, a = 0, s = 0, o = 0, c = 0, f = 0, u = 0, l = 0, p = 0, m = 0, h = 0;
  t |= ha.isWin ? 2560 : 768, r |= we.FLG_EFS;
  var g = {};
  function v(d) {
    d = new Date(d), i = (d.getFullYear() - 1980 & 127) << 25 | // b09-16 years from 1980
    d.getMonth() + 1 << 21 | // b05-08 month
    d.getDate() << 16 | // b00-04 hour
    // 2 bytes time
    d.getHours() << 11 | // b11-15 hour
    d.getMinutes() << 5 | // b05-10 minute
    d.getSeconds() >> 1;
  }
  return v(+/* @__PURE__ */ new Date()), {
    get made() {
      return t;
    },
    set made(d) {
      t = d;
    },
    get version() {
      return e;
    },
    set version(d) {
      e = d;
    },
    get flags() {
      return r;
    },
    set flags(d) {
      r = d;
    },
    get method() {
      return n;
    },
    set method(d) {
      switch (d) {
        case we.STORED:
          this.version = 10;
        case we.DEFLATED:
        default:
          this.version = 20;
      }
      n = d;
    },
    get time() {
      return new Date((i >> 25 & 127) + 1980, (i >> 21 & 15) - 1, i >> 16 & 31, i >> 11 & 31, i >> 5 & 63, (i & 31) << 1);
    },
    set time(d) {
      v(d);
    },
    get crc() {
      return a;
    },
    set crc(d) {
      a = Math.max(0, d) >>> 0;
    },
    get compressedSize() {
      return s;
    },
    set compressedSize(d) {
      s = Math.max(0, d) >>> 0;
    },
    get size() {
      return o;
    },
    set size(d) {
      o = Math.max(0, d) >>> 0;
    },
    get fileNameLength() {
      return c;
    },
    set fileNameLength(d) {
      c = d;
    },
    get extraLength() {
      return f;
    },
    set extraLength(d) {
      f = d;
    },
    get commentLength() {
      return u;
    },
    set commentLength(d) {
      u = d;
    },
    get diskNumStart() {
      return l;
    },
    set diskNumStart(d) {
      l = Math.max(0, d) >>> 0;
    },
    get inAttr() {
      return p;
    },
    set inAttr(d) {
      p = Math.max(0, d) >>> 0;
    },
    get attr() {
      return m;
    },
    set attr(d) {
      m = Math.max(0, d) >>> 0;
    },
    // get Unix file permissions
    get fileAttr() {
      return m ? (m >>> 0 | 0) >> 16 & 4095 : 0;
    },
    get offset() {
      return h;
    },
    set offset(d) {
      h = Math.max(0, d) >>> 0;
    },
    get encripted() {
      return (r & 1) === 1;
    },
    get entryHeaderSize() {
      return we.CENHDR + c + f + u;
    },
    get realDataOffset() {
      return h + we.LOCHDR + g.fnameLen + g.extraLen;
    },
    get dataHeader() {
      return g;
    },
    loadDataHeaderFromBinary: function(d) {
      var y = d.slice(h, h + we.LOCHDR);
      if (y.readUInt32LE(0) !== we.LOCSIG)
        throw new Error(ha.Errors.INVALID_LOC);
      g = {
        // version needed to extract
        version: y.readUInt16LE(we.LOCVER),
        // general purpose bit flag
        flags: y.readUInt16LE(we.LOCFLG),
        // compression method
        method: y.readUInt16LE(we.LOCHOW),
        // modification time (2 bytes time, 2 bytes date)
        time: y.readUInt32LE(we.LOCTIM),
        // uncompressed file crc-32 value
        crc: y.readUInt32LE(we.LOCCRC),
        // compressed size
        compressedSize: y.readUInt32LE(we.LOCSIZ),
        // uncompressed size
        size: y.readUInt32LE(we.LOCLEN),
        // filename length
        fnameLen: y.readUInt16LE(we.LOCNAM),
        // extra field length
        extraLen: y.readUInt16LE(we.LOCEXT)
      };
    },
    loadFromBinary: function(d) {
      if (d.length !== we.CENHDR || d.readUInt32LE(0) !== we.CENSIG)
        throw new Error(ha.Errors.INVALID_CEN);
      t = d.readUInt16LE(we.CENVEM), e = d.readUInt16LE(we.CENVER), r = d.readUInt16LE(we.CENFLG), n = d.readUInt16LE(we.CENHOW), i = d.readUInt32LE(we.CENTIM), a = d.readUInt32LE(we.CENCRC), s = d.readUInt32LE(we.CENSIZ), o = d.readUInt32LE(we.CENLEN), c = d.readUInt16LE(we.CENNAM), f = d.readUInt16LE(we.CENEXT), u = d.readUInt16LE(we.CENCOM), l = d.readUInt16LE(we.CENDSK), p = d.readUInt16LE(we.CENATT), m = d.readUInt32LE(we.CENATX), h = d.readUInt32LE(we.CENOFF);
    },
    dataHeaderToBinary: function() {
      var d = Buffer.alloc(we.LOCHDR);
      return d.writeUInt32LE(we.LOCSIG, 0), d.writeUInt16LE(e, we.LOCVER), d.writeUInt16LE(r, we.LOCFLG), d.writeUInt16LE(n, we.LOCHOW), d.writeUInt32LE(i, we.LOCTIM), d.writeUInt32LE(a, we.LOCCRC), d.writeUInt32LE(s, we.LOCSIZ), d.writeUInt32LE(o, we.LOCLEN), d.writeUInt16LE(c, we.LOCNAM), d.writeUInt16LE(f, we.LOCEXT), d;
    },
    entryHeaderToBinary: function() {
      var d = Buffer.alloc(we.CENHDR + c + f + u);
      return d.writeUInt32LE(we.CENSIG, 0), d.writeUInt16LE(t, we.CENVEM), d.writeUInt16LE(e, we.CENVER), d.writeUInt16LE(r, we.CENFLG), d.writeUInt16LE(n, we.CENHOW), d.writeUInt32LE(i, we.CENTIM), d.writeUInt32LE(a, we.CENCRC), d.writeUInt32LE(s, we.CENSIZ), d.writeUInt32LE(o, we.CENLEN), d.writeUInt16LE(c, we.CENNAM), d.writeUInt16LE(f, we.CENEXT), d.writeUInt16LE(u, we.CENCOM), d.writeUInt16LE(l, we.CENDSK), d.writeUInt16LE(p, we.CENATT), d.writeUInt32LE(m, we.CENATX), d.writeUInt32LE(h, we.CENOFF), d.fill(0, we.CENHDR), d;
    },
    toJSON: function() {
      const d = function(y) {
        return y + " bytes";
      };
      return {
        made: t,
        version: e,
        flags: r,
        method: ha.methodToString(n),
        time: this.time,
        crc: "0x" + a.toString(16).toUpperCase(),
        compressedSize: d(s),
        size: d(o),
        fileNameLength: d(c),
        extraLength: d(f),
        commentLength: d(u),
        diskNumStart: l,
        inAttr: p,
        attr: m,
        offset: h,
        entryHeaderSize: d(we.CENHDR + c + f + u)
      };
    },
    toString: function() {
      return JSON.stringify(this.toJSON(), null, "	");
    }
  };
}, oi = xs, Ze = oi.Constants, Poe = function() {
  var t = 0, e = 0, r = 0, n = 0, i = 0;
  return {
    get diskEntries() {
      return t;
    },
    set diskEntries(a) {
      t = e = a;
    },
    get totalEntries() {
      return e;
    },
    set totalEntries(a) {
      e = t = a;
    },
    get size() {
      return r;
    },
    set size(a) {
      r = a;
    },
    get offset() {
      return n;
    },
    set offset(a) {
      n = a;
    },
    get commentLength() {
      return i;
    },
    set commentLength(a) {
      i = a;
    },
    get mainHeaderSize() {
      return Ze.ENDHDR + i;
    },
    loadFromBinary: function(a) {
      if ((a.length !== Ze.ENDHDR || a.readUInt32LE(0) !== Ze.ENDSIG) && (a.length < Ze.ZIP64HDR || a.readUInt32LE(0) !== Ze.ZIP64SIG))
        throw new Error(oi.Errors.INVALID_END);
      a.readUInt32LE(0) === Ze.ENDSIG ? (t = a.readUInt16LE(Ze.ENDSUB), e = a.readUInt16LE(Ze.ENDTOT), r = a.readUInt32LE(Ze.ENDSIZ), n = a.readUInt32LE(Ze.ENDOFF), i = a.readUInt16LE(Ze.ENDCOM)) : (t = oi.readBigUInt64LE(a, Ze.ZIP64SUB), e = oi.readBigUInt64LE(a, Ze.ZIP64TOT), r = oi.readBigUInt64LE(a, Ze.ZIP64SIZE), n = oi.readBigUInt64LE(a, Ze.ZIP64OFF), i = 0);
    },
    toBinary: function() {
      var a = Buffer.alloc(Ze.ENDHDR + i);
      return a.writeUInt32LE(Ze.ENDSIG, 0), a.writeUInt32LE(0, 4), a.writeUInt16LE(t, Ze.ENDSUB), a.writeUInt16LE(e, Ze.ENDTOT), a.writeUInt32LE(r, Ze.ENDSIZ), a.writeUInt32LE(n, Ze.ENDOFF), a.writeUInt16LE(i, Ze.ENDCOM), a.fill(" ", Ze.ENDHDR), a;
    },
    toJSON: function() {
      const a = function(s, o) {
        let c = s.toString(16).toUpperCase();
        for (; c.length < o; )
          c = "0" + c;
        return "0x" + c;
      };
      return {
        diskEntries: t,
        totalEntries: e,
        size: r + " bytes",
        offset: a(n, 4),
        commentLength: i
      };
    },
    toString: function() {
      return JSON.stringify(this.toJSON(), null, "	");
    }
  };
};
bu.EntryHeader = Loe;
bu.MainHeader = Poe;
var wu = {}, Doe = function(t) {
  var e = se, r = { chunkSize: (parseInt(t.length / 1024) + 1) * 1024 };
  return {
    deflate: function() {
      return e.deflateRawSync(t, r);
    },
    deflateAsync: function(n) {
      var i = e.createDeflateRaw(r), a = [], s = 0;
      i.on("data", function(o) {
        a.push(o), s += o.length;
      }), i.on("end", function() {
        var o = Buffer.alloc(s), c = 0;
        o.fill(0);
        for (var f = 0; f < a.length; f++) {
          var u = a[f];
          u.copy(o, c), c += u.length;
        }
        n && n(o);
      }), i.end(t);
    }
  };
}, Moe = function(t) {
  var e = se;
  return {
    inflate: function() {
      return e.inflateRawSync(t);
    },
    inflateAsync: function(r) {
      var n = e.createInflateRaw(), i = [], a = 0;
      n.on("data", function(s) {
        i.push(s), a += s.length;
      }), n.on("end", function() {
        var s = Buffer.alloc(a), o = 0;
        s.fill(0);
        for (var c = 0; c < i.length; c++) {
          var f = i[c];
          f.copy(s, o), o += f.length;
        }
        r && r(s);
      }), n.end(t);
    }
  };
};
const { randomFillSync: n_ } = se, qoe = new Uint32Array(256).map((t, e) => {
  for (let r = 0; r < 8; r++)
    e & 1 ? e = e >>> 1 ^ 3988292384 : e >>>= 1;
  return e >>> 0;
}), e4 = (t, e) => Math.imul(t, e) >>> 0, i_ = (t, e) => qoe[(t ^ e) & 255] ^ t >>> 8, Ua = () => typeof n_ == "function" ? n_(Buffer.alloc(12)) : Ua.node();
Ua.node = () => {
  const t = Buffer.alloc(12), e = t.length;
  for (let r = 0; r < e; r++)
    t[r] = Math.random() * 256 & 255;
  return t;
};
const $o = {
  genSalt: Ua
};
function xu(t) {
  const e = Buffer.isBuffer(t) ? t : Buffer.from(t);
  this.keys = new Uint32Array([305419896, 591751049, 878082192]);
  for (let r = 0; r < e.length; r++)
    this.updateKeys(e[r]);
}
xu.prototype.updateKeys = function(t) {
  const e = this.keys;
  return e[0] = i_(e[0], t), e[1] += e[0] & 255, e[1] = e4(e[1], 134775813) + 1, e[2] = i_(e[2], e[1] >>> 24), t;
};
xu.prototype.next = function() {
  const t = (this.keys[2] | 2) >>> 0;
  return e4(t, t ^ 1) >> 8 & 255;
};
function joe(t) {
  const e = new xu(t);
  return function(r) {
    const n = Buffer.alloc(r.length);
    let i = 0;
    for (let a of r)
      n[i++] = e.updateKeys(a ^ e.next());
    return n;
  };
}
function Foe(t) {
  const e = new xu(t);
  return function(r, n, i = 0) {
    n || (n = Buffer.alloc(r.length));
    for (let a of r) {
      const s = e.next();
      n[i++] = a ^ s, e.updateKeys(a);
    }
    return n;
  };
}
function Boe(t, e, r) {
  if (!t || !Buffer.isBuffer(t) || t.length < 12)
    return Buffer.alloc(0);
  const n = joe(r);
  if (n(t.slice(0, 12))[11] !== e.crc >>> 24)
    throw "ADM-ZIP: Wrong Password";
  return n(t.slice(12));
}
function Uoe(t) {
  Buffer.isBuffer(t) && t.length >= 12 ? $o.genSalt = function() {
    return t.slice(0, 12);
  } : t === "node" ? $o.genSalt = Ua.node : $o.genSalt = Ua;
}
function zoe(t, e, r, n = !1) {
  t == null && (t = Buffer.alloc(0)), Buffer.isBuffer(t) || (t = Buffer.from(t.toString()));
  const i = Foe(r), a = $o.genSalt();
  a[11] = e.crc >>> 24 & 255, n && (a[10] = e.crc >>> 16 & 255);
  const s = Buffer.alloc(t.length + 12);
  return i(a, s), i(t, s, 12);
}
var Hoe = { decrypt: Boe, encrypt: zoe, _salter: Uoe };
wu.Deflater = Doe;
wu.Inflater = Moe;
wu.ZipCrypto = Hoe;
var st = xs, Woe = bu, Pt = st.Constants, Vf = wu, t4 = function(t) {
  var e = new Woe.EntryHeader(), r = Buffer.alloc(0), n = Buffer.alloc(0), i = !1, a = null, s = Buffer.alloc(0);
  function o() {
    return !t || !Buffer.isBuffer(t) ? Buffer.alloc(0) : (e.loadDataHeaderFromBinary(t), t.slice(e.realDataOffset, e.realDataOffset + e.compressedSize));
  }
  function c(h) {
    return !((e.flags & 8) !== 8 && st.crc32(h) !== e.dataHeader.crc);
  }
  function f(h, g, v) {
    if (typeof g > "u" && typeof h == "string" && (v = h, h = void 0), i)
      return h && g && g(Buffer.alloc(0), st.Errors.DIRECTORY_CONTENT_ERROR), Buffer.alloc(0);
    var d = o();
    if (d.length === 0)
      return h && g && g(d), d;
    if (e.encripted) {
      if (typeof v != "string" && !Buffer.isBuffer(v))
        throw new Error("ADM-ZIP: Incompatible password parameter");
      d = Vf.ZipCrypto.decrypt(d, e, v);
    }
    var y = Buffer.alloc(e.size);
    switch (e.method) {
      case st.Constants.STORED:
        if (d.copy(y), c(y))
          return h && g && g(y), y;
        throw h && g && g(y, st.Errors.BAD_CRC), new Error(st.Errors.BAD_CRC);
      case st.Constants.DEFLATED:
        var x = new Vf.Inflater(d);
        if (h)
          x.inflateAsync(function(b) {
            b.copy(b, 0), g && (c(b) ? g(b) : g(b, st.Errors.BAD_CRC));
          });
        else {
          if (x.inflate(y).copy(y, 0), !c(y))
            throw new Error(st.Errors.BAD_CRC + " " + r.toString());
          return y;
        }
        break;
      default:
        throw h && g && g(Buffer.alloc(0), st.Errors.UNKNOWN_METHOD), new Error(st.Errors.UNKNOWN_METHOD);
    }
  }
  function u(h, g) {
    if ((!a || !a.length) && Buffer.isBuffer(t))
      return h && g && g(o()), o();
    if (a.length && !i) {
      var v;
      switch (e.method) {
        case st.Constants.STORED:
          return e.compressedSize = e.size, v = Buffer.alloc(a.length), a.copy(v), h && g && g(v), v;
        default:
        case st.Constants.DEFLATED:
          var d = new Vf.Deflater(a);
          if (h)
            d.deflateAsync(function(x) {
              v = Buffer.alloc(x.length), e.compressedSize = x.length, x.copy(v), g && g(v);
            });
          else {
            var y = d.deflate();
            return e.compressedSize = y.length, y;
          }
          d = null;
          break;
      }
    } else if (h && g)
      g(Buffer.alloc(0));
    else
      return Buffer.alloc(0);
  }
  function l(h, g) {
    return (h.readUInt32LE(g + 4) << 4) + h.readUInt32LE(g);
  }
  function p(h) {
    for (var g = 0, v, d, y; g < h.length; )
      v = h.readUInt16LE(g), g += 2, d = h.readUInt16LE(g), g += 2, y = h.slice(g, g + d), g += d, Pt.ID_ZIP64 === v && m(y);
  }
  function m(h) {
    var g, v, d, y;
    h.length >= Pt.EF_ZIP64_SCOMP && (g = l(h, Pt.EF_ZIP64_SUNCOMP), e.size === Pt.EF_ZIP64_OR_32 && (e.size = g)), h.length >= Pt.EF_ZIP64_RHO && (v = l(h, Pt.EF_ZIP64_SCOMP), e.compressedSize === Pt.EF_ZIP64_OR_32 && (e.compressedSize = v)), h.length >= Pt.EF_ZIP64_DSN && (d = l(h, Pt.EF_ZIP64_RHO), e.offset === Pt.EF_ZIP64_OR_32 && (e.offset = d)), h.length >= Pt.EF_ZIP64_DSN + 4 && (y = h.readUInt32LE(Pt.EF_ZIP64_DSN), e.diskNumStart === Pt.EF_ZIP64_OR_16 && (e.diskNumStart = y));
  }
  return {
    get entryName() {
      return r.toString();
    },
    get rawEntryName() {
      return r;
    },
    set entryName(h) {
      r = st.toBuffer(h);
      var g = r[r.length - 1];
      i = g === 47 || g === 92, e.fileNameLength = r.length;
    },
    get extra() {
      return s;
    },
    set extra(h) {
      s = h, e.extraLength = h.length, p(h);
    },
    get comment() {
      return n.toString();
    },
    set comment(h) {
      n = st.toBuffer(h), e.commentLength = n.length;
    },
    get name() {
      var h = r.toString();
      return i ? h.substr(h.length - 1).split("/").pop() : h.split("/").pop();
    },
    get isDirectory() {
      return i;
    },
    getCompressedData: function() {
      return u(!1, null);
    },
    getCompressedDataAsync: function(h) {
      u(!0, h);
    },
    setData: function(h) {
      a = st.toBuffer(h), !i && a.length ? (e.size = a.length, e.method = st.Constants.DEFLATED, e.crc = st.crc32(h), e.changed = !0) : e.method = st.Constants.STORED;
    },
    getData: function(h) {
      return e.changed ? a : f(!1, null, h);
    },
    getDataAsync: function(h, g) {
      e.changed ? h(a) : f(!0, h, g);
    },
    set attr(h) {
      e.attr = h;
    },
    get attr() {
      return e.attr;
    },
    set header(h) {
      e.loadFromBinary(h);
    },
    get header() {
      return e;
    },
    packHeader: function() {
      var h = e.entryHeaderToBinary(), g = st.Constants.CENHDR;
      return r.copy(h, g), g += r.length, e.extraLength && (s.copy(h, g), g += e.extraLength), e.commentLength && n.copy(h, g), h;
    },
    toJSON: function() {
      const h = function(g) {
        return "<" + (g && g.length + " bytes buffer" || "null") + ">";
      };
      return {
        entryName: this.entryName,
        name: this.name,
        comment: this.comment,
        isDirectory: this.isDirectory,
        header: e.toJSON(),
        compressedData: h(t),
        data: h(a)
      };
    },
    toString: function() {
      return JSON.stringify(this.toJSON(), null, "	");
    }
  };
};
const a_ = t4, Goe = bu, _t = xs;
var Qoe = function(t, e) {
  var r = [], n = {}, i = Buffer.alloc(0), a = new Goe.MainHeader(), s = !1;
  const o = Object.assign(/* @__PURE__ */ Object.create(null), e), { noSort: c } = o;
  t ? l(o.readEntries) : s = !0;
  function f(m) {
    const h = a.diskEntries;
    let g = a.offset;
    for (let v = 0; v < h; v++) {
      let d = g;
      const y = new a_(t);
      y.header = t.slice(d, d += _t.Constants.CENHDR), y.entryName = t.slice(d, d += y.header.fileNameLength), g += y.header.entryHeaderSize, m(y);
    }
  }
  function u() {
    s = !0, n = {}, r = new Array(a.diskEntries);
    for (var m = a.offset, h = 0; h < r.length; h++) {
      var g = m, v = new a_(t);
      v.header = t.slice(g, g += _t.Constants.CENHDR), v.entryName = t.slice(g, g += v.header.fileNameLength), v.header.extraLength && (v.extra = t.slice(g, g += v.header.extraLength)), v.header.commentLength && (v.comment = t.slice(g, g + v.header.commentLength)), m += v.header.entryHeaderSize, r[h] = v, n[v.entryName] = v;
    }
  }
  function l(m) {
    var h = t.length - _t.Constants.ENDHDR, g = Math.max(0, h - 65535), v = g, d = t.length, y = -1, x = 0;
    for (h; h >= v; h--)
      if (t[h] === 80) {
        if (t.readUInt32LE(h) === _t.Constants.ENDSIG) {
          y = h, x = h, d = h + _t.Constants.ENDHDR, v = h - _t.Constants.END64HDR;
          continue;
        }
        if (t.readUInt32LE(h) === _t.Constants.END64SIG) {
          v = g;
          continue;
        }
        if (t.readUInt32LE(h) === _t.Constants.ZIP64SIG) {
          y = h, d = h + _t.readBigUInt64LE(t, h + _t.Constants.ZIP64SIZE) + _t.Constants.ZIP64LEAD;
          break;
        }
      }
    if (!~y)
      throw new Error(_t.Errors.INVALID_FORMAT);
    a.loadFromBinary(t.slice(y, d)), a.commentLength && (i = t.slice(x + _t.Constants.ENDHDR)), m && u();
  }
  function p() {
    r.length > 1 && !c && r.sort((m, h) => m.entryName.toLowerCase().localeCompare(h.entryName.toLowerCase()));
  }
  return {
    /**
     * Returns an array of ZipEntry objects existent in the current opened archive
     * @return Array
     */
    get entries() {
      return s || u(), r;
    },
    /**
     * Archive comment
     * @return {String}
     */
    get comment() {
      return i.toString();
    },
    set comment(m) {
      i = _t.toBuffer(m), a.commentLength = i.length;
    },
    getEntryCount: function() {
      return s ? r.length : a.diskEntries;
    },
    forEach: function(m) {
      if (!s) {
        f(m);
        return;
      }
      r.forEach(m);
    },
    /**
     * Returns a reference to the entry with the given name or null if entry is inexistent
     *
     * @param entryName
     * @return ZipEntry
     */
    getEntry: function(m) {
      return s || u(), n[m] || null;
    },
    /**
     * Adds the given entry to the entry list
     *
     * @param entry
     */
    setEntry: function(m) {
      s || u(), r.push(m), n[m.entryName] = m, a.totalEntries = r.length;
    },
    /**
     * Removes the entry with the given name from the entry list.
     *
     * If the entry is a directory, then all nested files and directories will be removed
     * @param entryName
     */
    deleteEntry: function(m) {
      s || u();
      var h = n[m];
      if (h && h.isDirectory) {
        var g = this;
        this.getEntryChildren(h).forEach(function(v) {
          v.entryName !== m && g.deleteEntry(v.entryName);
        });
      }
      r.splice(r.indexOf(h), 1), delete n[m], a.totalEntries = r.length;
    },
    /**
     *  Iterates and returns all nested files and directories of the given entry
     *
     * @param entry
     * @return Array
     */
    getEntryChildren: function(m) {
      if (s || u(), m && m.isDirectory) {
        const h = [], g = m.entryName, v = g.length;
        return r.forEach(function(d) {
          d.entryName.substr(0, v) === g && h.push(d);
        }), h;
      }
      return [];
    },
    /**
     * Returns the zip file
     *
     * @return Buffer
     */
    compressToBuffer: function() {
      s || u(), p();
      const m = [], h = [];
      let g = 0, v = 0;
      a.size = 0, a.offset = 0;
      for (const x of r) {
        const b = x.getCompressedData();
        x.header.offset = v;
        const w = x.header.dataHeaderToBinary(), S = x.rawEntryName.length, T = Buffer.alloc(S + x.extra.length);
        x.rawEntryName.copy(T, 0), T.copy(x.extra, S);
        const E = w.length + T.length + b.length;
        v += E, m.push(w), m.push(T), m.push(b);
        const C = x.packHeader();
        h.push(C), a.size += C.length, g += E + C.length;
      }
      g += a.mainHeaderSize, a.offset = v, v = 0;
      const d = Buffer.alloc(g);
      for (const x of m)
        x.copy(d, v), v += x.length;
      for (const x of h)
        x.copy(d, v), v += x.length;
      const y = a.toBinary();
      return i && i.copy(y, _t.Constants.ENDHDR), y.copy(d, v), d;
    },
    toAsyncBuffer: function(m, h, g, v) {
      try {
        s || u(), p();
        const d = [], y = [];
        let x = 0, b = 0;
        a.size = 0, a.offset = 0;
        const w = function(S) {
          if (S.length) {
            const T = S.pop(), E = T.entryName + T.extra.toString();
            g && g(E), T.getCompressedDataAsync(function(C) {
              v && v(E), T.header.offset = b;
              const A = T.header.dataHeaderToBinary(), R = Buffer.alloc(E.length, E), D = A.length + R.length + C.length;
              b += D, d.push(A), d.push(R), d.push(C);
              const F = T.packHeader();
              y.push(F), a.size += F.length, x += D + F.length, w(S);
            });
          } else {
            x += a.mainHeaderSize, a.offset = b, b = 0;
            const T = Buffer.alloc(x);
            d.forEach(function(C) {
              C.copy(T, b), b += C.length;
            }), y.forEach(function(C) {
              C.copy(T, b), b += C.length;
            });
            const E = a.toBinary();
            i && i.copy(E, _t.Constants.ENDHDR), E.copy(T, b), m(T);
          }
        };
        w(r);
      } catch (d) {
        h(d);
      }
    }
  };
};
const lt = xs, pr = se, Voe = t4, Koe = Qoe, yn = (t, e) => typeof t == "boolean" ? t : e, Kf = (t, e) => typeof t == "string" ? t : e, Joe = {
  // option "noSort" : if true it disables files sorting
  noSort: !1,
  // read entries during load (initial loading may be slower)
  readEntries: !1,
  // default method is none
  method: lt.Constants.NONE,
  // file system
  fs: null
};
var Xoe = function(t, e) {
  let r = null;
  const n = Object.assign(/* @__PURE__ */ Object.create(null), Joe);
  t && typeof t == "object" && (t instanceof Uint8Array || (Object.assign(n, t), t = n.input ? n.input : void 0, n.input && delete n.input), Buffer.isBuffer(t) && (r = t, n.method = lt.Constants.BUFFER, t = void 0)), Object.assign(n, e);
  const i = new lt(n);
  if (t && typeof t == "string")
    if (i.fs.existsSync(t))
      n.method = lt.Constants.FILE, n.filename = t, r = i.fs.readFileSync(t);
    else
      throw new Error(lt.Errors.INVALID_FILENAME);
  const a = new Koe(r, n), { canonical: s, sanitize: o } = lt;
  function c(u) {
    if (u && a) {
      var l;
      if (typeof u == "string" && (l = a.getEntry(u)), typeof u == "object" && typeof u.entryName < "u" && typeof u.header < "u" && (l = a.getEntry(u.entryName)), l)
        return l;
    }
    return null;
  }
  function f(u) {
    const { join: l, normalize: p, sep: m } = pr.posix;
    return l(".", p(m + u.split("\\").join(m) + m));
  }
  return {
    /**
     * Extracts the given entry from the archive and returns the content as a Buffer object
     * @param entry ZipEntry object or String with the full path of the entry
     *
     * @return Buffer or Null in case of error
     */
    readFile: function(u, l) {
      var p = c(u);
      return p && p.getData(l) || null;
    },
    /**
     * Asynchronous readFile
     * @param entry ZipEntry object or String with the full path of the entry
     * @param callback
     *
     * @return Buffer or Null in case of error
     */
    readFileAsync: function(u, l) {
      var p = c(u);
      p ? p.getDataAsync(l) : l(null, "getEntry failed for:" + u);
    },
    /**
     * Extracts the given entry from the archive and returns the content as plain text in the given encoding
     * @param entry ZipEntry object or String with the full path of the entry
     * @param encoding Optional. If no encoding is specified utf8 is used
     *
     * @return String
     */
    readAsText: function(u, l) {
      var p = c(u);
      if (p) {
        var m = p.getData();
        if (m && m.length)
          return m.toString(l || "utf8");
      }
      return "";
    },
    /**
     * Asynchronous readAsText
     * @param entry ZipEntry object or String with the full path of the entry
     * @param callback
     * @param encoding Optional. If no encoding is specified utf8 is used
     *
     * @return String
     */
    readAsTextAsync: function(u, l, p) {
      var m = c(u);
      m ? m.getDataAsync(function(h, g) {
        if (g) {
          l(h, g);
          return;
        }
        h && h.length ? l(h.toString(p || "utf8")) : l("");
      }) : l("");
    },
    /**
     * Remove the entry from the file or the entry and all it's nested directories and files if the given entry is a directory
     *
     * @param entry
     */
    deleteFile: function(u) {
      var l = c(u);
      l && a.deleteEntry(l.entryName);
    },
    /**
     * Adds a comment to the zip. The zip must be rewritten after adding the comment.
     *
     * @param comment
     */
    addZipComment: function(u) {
      a.comment = u;
    },
    /**
     * Returns the zip comment
     *
     * @return String
     */
    getZipComment: function() {
      return a.comment || "";
    },
    /**
     * Adds a comment to a specified zipEntry. The zip must be rewritten after adding the comment
     * The comment cannot exceed 65535 characters in length
     *
     * @param entry
     * @param comment
     */
    addZipEntryComment: function(u, l) {
      var p = c(u);
      p && (p.comment = l);
    },
    /**
     * Returns the comment of the specified entry
     *
     * @param entry
     * @return String
     */
    getZipEntryComment: function(u) {
      var l = c(u);
      return l && l.comment || "";
    },
    /**
     * Updates the content of an existing entry inside the archive. The zip must be rewritten after updating the content
     *
     * @param entry
     * @param content
     */
    updateFile: function(u, l) {
      var p = c(u);
      p && p.setData(l);
    },
    /**
     * Adds a file from the disk to the archive
     *
     * @param localPath File to add to zip
     * @param zipPath Optional path inside the zip
     * @param zipName Optional name for the file
     */
    addLocalFile: function(u, l, p, m) {
      if (i.fs.existsSync(u)) {
        l = l ? f(l) : "";
        var h = u.split("\\").join("/").split("/").pop();
        l += p || h;
        const g = i.fs.statSync(u);
        this.addFile(l, i.fs.readFileSync(u), m, g);
      } else
        throw new Error(lt.Errors.FILE_NOT_FOUND.replace("%s", u));
    },
    /**
     * Adds a local directory and all its nested files and directories to the archive
     *
     * @param localPath
     * @param zipPath optional path inside zip
     * @param filter optional RegExp or Function if files match will
     *               be included.
     * @param {number | object} attr - number as unix file permissions, object as filesystem Stats object
     */
    addLocalFolder: function(u, l, p, m) {
      if (p instanceof RegExp ? p = function(h) {
        return function(g) {
          return h.test(g);
        };
      }(p) : typeof p != "function" && (p = function() {
        return !0;
      }), l = l ? f(l) : "", u = pr.normalize(u), i.fs.existsSync(u)) {
        const h = i.findFiles(u), g = this;
        h.length && h.forEach(function(v) {
          var d = pr.relative(u, v).split("\\").join("/");
          if (p(d)) {
            var y = i.fs.statSync(v);
            y.isFile() ? g.addFile(l + d, i.fs.readFileSync(v), "", m || y) : g.addFile(l + d + "/", Buffer.alloc(0), "", m || y);
          }
        });
      } else
        throw new Error(lt.Errors.FILE_NOT_FOUND.replace("%s", u));
    },
    /**
     * Asynchronous addLocalFile
     * @param localPath
     * @param callback
     * @param zipPath optional path inside zip
     * @param filter optional RegExp or Function if files match will
     *               be included.
     */
    addLocalFolderAsync: function(u, l, p, m) {
      m instanceof RegExp ? m = function(g) {
        return function(v) {
          return g.test(v);
        };
      }(m) : typeof m != "function" && (m = function() {
        return !0;
      }), p = p ? f(p) : "", u = pr.normalize(u);
      var h = this;
      i.fs.open(u, "r", function(g) {
        if (g && g.code === "ENOENT")
          l(void 0, lt.Errors.FILE_NOT_FOUND.replace("%s", u));
        else if (g)
          l(void 0, g);
        else {
          var v = i.findFiles(u), d = -1, y = function() {
            if (d += 1, d < v.length) {
              var x = v[d], b = pr.relative(u, x).split("\\").join("/");
              b = b.normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^\x20-\x7E]/g, ""), m(b) ? i.fs.stat(x, function(w, S) {
                w && l(void 0, w), S.isFile() ? i.fs.readFile(x, function(T, E) {
                  T ? l(void 0, T) : (h.addFile(p + b, E, "", S), y());
                }) : (h.addFile(p + b + "/", Buffer.alloc(0), "", S), y());
              }) : process.nextTick(() => {
                y();
              });
            } else
              l(!0, void 0);
          };
          y();
        }
      });
    },
    /**
     *
     * @param {string} localPath - path where files will be extracted
     * @param {object} props - optional properties
     * @param {string} props.zipPath - optional path inside zip
     * @param {regexp, function} props.filter - RegExp or Function if files match will be included.
     */
    addLocalFolderPromise: function(u, l) {
      return new Promise((p, m) => {
        const { filter: h, zipPath: g } = Object.assign({}, l);
        this.addLocalFolderAsync(
          u,
          (v, d) => {
            d && m(d), v && p(this);
          },
          g,
          h
        );
      });
    },
    /**
     * Allows you to create a entry (file or directory) in the zip file.
     * If you want to create a directory the entryName must end in / and a null buffer should be provided.
     * Comment and attributes are optional
     *
     * @param {string} entryName
     * @param {Buffer | string} content - file content as buffer or utf8 coded string
     * @param {string} comment - file comment
     * @param {number | object} attr - number as unix file permissions, object as filesystem Stats object
     */
    addFile: function(u, l, p, m) {
      let h = c(u);
      const g = h != null;
      g || (h = new Voe(), h.entryName = u), h.comment = p || "";
      const v = typeof m == "object" && m instanceof i.fs.Stats;
      v && (h.header.time = m.mtime);
      var d = h.isDirectory ? 16 : 0;
      let y = h.isDirectory ? 16384 : 32768;
      v ? y |= 4095 & m.mode : typeof m == "number" ? y |= 4095 & m : y |= h.isDirectory ? 493 : 420, d = (d | y << 16) >>> 0, h.attr = d, h.setData(l), g || a.setEntry(h);
    },
    /**
     * Returns an array of ZipEntry objects representing the files and folders inside the archive
     *
     * @return Array
     */
    getEntries: function() {
      return a ? a.entries : [];
    },
    /**
     * Returns a ZipEntry object representing the file or folder specified by ``name``.
     *
     * @param name
     * @return ZipEntry
     */
    getEntry: function(u) {
      return c(u);
    },
    getEntryCount: function() {
      return a.getEntryCount();
    },
    forEach: function(u) {
      return a.forEach(u);
    },
    /**
     * Extracts the given entry to the given targetPath
     * If the entry is a directory inside the archive, the entire directory and it's subdirectories will be extracted
     *
     * @param entry ZipEntry object or String with the full path of the entry
     * @param targetPath Target folder where to write the file
     * @param maintainEntryPath If maintainEntryPath is true and the entry is inside a folder, the entry folder
     *                          will be created in targetPath as well. Default is TRUE
     * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.
     *                  Default is FALSE
     * @param keepOriginalPermission The file will be set as the permission from the entry if this is true.
     *                  Default is FALSE
     * @param outFileName String If set will override the filename of the extracted file (Only works if the entry is a file)
     *
     * @return Boolean
     */
    extractEntryTo: function(u, l, p, m, h, g) {
      m = yn(m, !1), h = yn(h, !1), p = yn(p, !0), g = Kf(g, Kf(h, void 0));
      var v = c(u);
      if (!v)
        throw new Error(lt.Errors.NO_ENTRY);
      var d = s(v.entryName), y = o(l, g && !v.isDirectory ? g : p ? d : pr.basename(d));
      if (v.isDirectory) {
        var x = a.getEntryChildren(v);
        return x.forEach(function(S) {
          if (S.isDirectory)
            return;
          var T = S.getData();
          if (!T)
            throw new Error(lt.Errors.CANT_EXTRACT_FILE);
          var E = s(S.entryName), C = o(l, p ? E : pr.basename(E));
          const A = h ? S.header.fileAttr : void 0;
          i.writeFileTo(C, T, m, A);
        }), !0;
      }
      var b = v.getData();
      if (!b)
        throw new Error(lt.Errors.CANT_EXTRACT_FILE);
      if (i.fs.existsSync(y) && !m)
        throw new Error(lt.Errors.CANT_OVERRIDE);
      const w = h ? u.header.fileAttr : void 0;
      return i.writeFileTo(y, b, m, w), !0;
    },
    /**
     * Test the archive
     *
     */
    test: function(u) {
      if (!a)
        return !1;
      for (var l in a.entries)
        try {
          if (l.isDirectory)
            continue;
          var p = a.entries[l].getData(u);
          if (!p)
            return !1;
        } catch {
          return !1;
        }
      return !0;
    },
    /**
     * Extracts the entire archive to the given location
     *
     * @param targetPath Target location
     * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.
     *                  Default is FALSE
     * @param keepOriginalPermission The file will be set as the permission from the entry if this is true.
     *                  Default is FALSE
     */
    extractAllTo: function(u, l, p, m) {
      if (l = yn(l, !1), m = Kf(p, m), p = yn(p, !1), !a)
        throw new Error(lt.Errors.NO_ZIP);
      a.entries.forEach(function(h) {
        var g = o(u, s(h.entryName.toString()));
        if (h.isDirectory) {
          i.makeDir(g);
          return;
        }
        var v = h.getData(m);
        if (!v)
          throw new Error(lt.Errors.CANT_EXTRACT_FILE);
        const d = p ? h.header.fileAttr : void 0;
        i.writeFileTo(g, v, l, d);
        try {
          i.fs.utimesSync(g, h.header.time, h.header.time);
        } catch {
          throw new Error(lt.Errors.CANT_EXTRACT_FILE);
        }
      });
    },
    /**
     * Asynchronous extractAllTo
     *
     * @param targetPath Target location
     * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.
     *                  Default is FALSE
     * @param keepOriginalPermission The file will be set as the permission from the entry if this is true.
     *                  Default is FALSE
     * @param callback The callback will be executed when all entries are extracted successfully or any error is thrown.
     */
    extractAllToAsync: function(u, l, p, m) {
      if (l = yn(l, !1), typeof p == "function" && !m && (m = p), p = yn(p, !1), m || (m = function(x) {
        throw new Error(x);
      }), !a) {
        m(new Error(lt.Errors.NO_ZIP));
        return;
      }
      u = pr.resolve(u);
      const h = (x) => o(u, pr.normalize(s(x.entryName.toString()))), g = (x, b) => new Error(x + ': "' + b + '"'), v = [], d = /* @__PURE__ */ new Set();
      a.entries.forEach((x) => {
        x.isDirectory ? v.push(x) : d.add(x);
      });
      for (const x of v) {
        const b = h(x), w = p ? x.header.fileAttr : void 0;
        try {
          i.makeDir(b), w && i.fs.chmodSync(b, w), i.fs.utimesSync(b, x.header.time, x.header.time);
        } catch {
          m(g("Unable to create folder", b));
        }
      }
      const y = () => {
        d.size === 0 && m();
      };
      for (const x of d.values()) {
        const b = pr.normalize(s(x.entryName.toString())), w = o(u, b);
        x.getDataAsync(function(S, T) {
          if (T) {
            m(new Error(T));
            return;
          }
          if (!S)
            m(new Error(lt.Errors.CANT_EXTRACT_FILE));
          else {
            const E = p ? x.header.fileAttr : void 0;
            i.writeFileToAsync(w, S, l, E, function(C) {
              if (!C) {
                m(g("Unable to write file", w));
                return;
              }
              i.fs.utimes(w, x.header.time, x.header.time, function(A) {
                if (A) {
                  m(g("Unable to set times", w));
                  return;
                }
                d.delete(x), y();
              });
            });
          }
        });
      }
      y();
    },
    /**
     * Writes the newly created zip file to disk at the specified location or if a zip was opened and no ``targetFileName`` is provided, it will overwrite the opened zip
     *
     * @param targetFileName
     * @param callback
     */
    writeZip: function(u, l) {
      if (arguments.length === 1 && typeof u == "function" && (l = u, u = ""), !u && n.filename && (u = n.filename), !!u) {
        var p = a.compressToBuffer();
        if (p) {
          var m = i.writeFileTo(u, p, !0);
          typeof l == "function" && l(m ? null : new Error("failed"), "");
        }
      }
    },
    writeZipPromise: function(u, l) {
      const { overwrite: p, perm: m } = Object.assign({ overwrite: !0 }, l);
      return new Promise((h, g) => {
        !u && n.filename && (u = n.filename), u || g("ADM-ZIP: ZIP File Name Missing"), this.toBufferPromise().then((v) => {
          const d = (y) => y ? h(y) : g("ADM-ZIP: Wasn't able to write zip file");
          i.writeFileToAsync(u, v, p, m, d);
        }, g);
      });
    },
    toBufferPromise: function() {
      return new Promise((u, l) => {
        a.toAsyncBuffer(u, l);
      });
    },
    /**
     * Returns the content of the entire zip file as a Buffer object
     *
     * @return Buffer
     */
    toBuffer: function(u, l, p, m) {
      return this.valueOf = 2, typeof u == "function" ? (a.toAsyncBuffer(u, l, p, m), null) : a.compressToBuffer();
    }
  };
};
const Zoe = /* @__PURE__ */ Oi(Xoe);
let ro;
const Yoe = new Uint8Array(16);
function ece() {
  if (!ro && (ro = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !ro))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return ro(Yoe);
}
const gt = [];
for (let t = 0; t < 256; ++t)
  gt.push((t + 256).toString(16).slice(1));
function tce(t, e = 0) {
  return (gt[t[e + 0]] + gt[t[e + 1]] + gt[t[e + 2]] + gt[t[e + 3]] + "-" + gt[t[e + 4]] + gt[t[e + 5]] + "-" + gt[t[e + 6]] + gt[t[e + 7]] + "-" + gt[t[e + 8]] + gt[t[e + 9]] + "-" + gt[t[e + 10]] + gt[t[e + 11]] + gt[t[e + 12]] + gt[t[e + 13]] + gt[t[e + 14]] + gt[t[e + 15]]).toLowerCase();
}
const rce = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), s_ = {
  randomUUID: rce
};
function nce(t, e, r) {
  if (s_.randomUUID && !e && !t)
    return s_.randomUUID();
  t = t || {};
  const n = t.random || (t.rng || ece)();
  if (n[6] = n[6] & 15 | 64, n[8] = n[8] & 63 | 128, e) {
    r = r || 0;
    for (let i = 0; i < 16; ++i)
      e[r + i] = n[i];
    return e;
  }
  return tce(n);
}
var Kn = {};
(function(t) {
  const e = ze.fromCallback, r = Me, n = [
    "access",
    "appendFile",
    "chmod",
    "chown",
    "close",
    "copyFile",
    "fchmod",
    "fchown",
    "fdatasync",
    "fstat",
    "fsync",
    "ftruncate",
    "futimes",
    "lchmod",
    "lchown",
    "link",
    "lstat",
    "mkdir",
    "mkdtemp",
    "open",
    "opendir",
    "readdir",
    "readFile",
    "readlink",
    "realpath",
    "rename",
    "rm",
    "rmdir",
    "stat",
    "symlink",
    "truncate",
    "unlink",
    "utimes",
    "writeFile"
  ].filter((i) => typeof r[i] == "function");
  Object.assign(t, r), n.forEach((i) => {
    t[i] = e(r[i]);
  }), t.exists = function(i, a) {
    return typeof a == "function" ? r.exists(i, a) : new Promise((s) => r.exists(i, s));
  }, t.read = function(i, a, s, o, c, f) {
    return typeof f == "function" ? r.read(i, a, s, o, c, f) : new Promise((u, l) => {
      r.read(i, a, s, o, c, (p, m, h) => {
        if (p)
          return l(p);
        u({ bytesRead: m, buffer: h });
      });
    });
  }, t.write = function(i, a, ...s) {
    return typeof s[s.length - 1] == "function" ? r.write(i, a, ...s) : new Promise((o, c) => {
      r.write(i, a, ...s, (f, u, l) => {
        if (f)
          return c(f);
        o({ bytesWritten: u, buffer: l });
      });
    });
  }, typeof r.writev == "function" && (t.writev = function(i, a, ...s) {
    return typeof s[s.length - 1] == "function" ? r.writev(i, a, ...s) : new Promise((o, c) => {
      r.writev(i, a, ...s, (f, u, l) => {
        if (f)
          return c(f);
        o({ bytesWritten: u, buffers: l });
      });
    });
  }), typeof r.realpath.native == "function" ? t.realpath.native = e(r.realpath.native) : process.emitWarning(
    "fs.realpath.native is not a function. Is fs being monkey-patched?",
    "Warning",
    "fs-extra-WARN0003"
  );
})(Kn);
var Gv = {}, r4 = {};
const ice = se;
r4.checkPath = function(e) {
  if (process.platform === "win32" && /[<>:"|?*]/.test(e.replace(ice.parse(e).root, ""))) {
    const n = new Error(`Path contains invalid characters: ${e}`);
    throw n.code = "EINVAL", n;
  }
};
const n4 = Kn, { checkPath: i4 } = r4, a4 = (t) => {
  const e = { mode: 511 };
  return typeof t == "number" ? t : { ...e, ...t }.mode;
};
Gv.makeDir = async (t, e) => (i4(t), n4.mkdir(t, {
  mode: a4(e),
  recursive: !0
}));
Gv.makeDirSync = (t, e) => (i4(t), n4.mkdirSync(t, {
  mode: a4(e),
  recursive: !0
}));
const ace = ze.fromPromise, { makeDir: sce, makeDirSync: Jf } = Gv, Xf = ace(sce);
var Er = {
  mkdirs: Xf,
  mkdirsSync: Jf,
  // alias
  mkdirp: Xf,
  mkdirpSync: Jf,
  ensureDir: Xf,
  ensureDirSync: Jf
};
const oce = ze.fromPromise, s4 = Kn;
function cce(t) {
  return s4.access(t).then(() => !0).catch(() => !1);
}
var Jn = {
  pathExists: oce(cce),
  pathExistsSync: s4.existsSync
};
const fi = Me;
function uce(t, e, r, n) {
  fi.open(t, "r+", (i, a) => {
    if (i)
      return n(i);
    fi.futimes(a, e, r, (s) => {
      fi.close(a, (o) => {
        n && n(s || o);
      });
    });
  });
}
function lce(t, e, r) {
  const n = fi.openSync(t, "r+");
  return fi.futimesSync(n, e, r), fi.closeSync(n);
}
var o4 = {
  utimesMillis: uce,
  utimesMillisSync: lce
};
const wi = Kn, ft = se, pce = nt;
function fce(t, e, r) {
  const n = r.dereference ? (i) => wi.stat(i, { bigint: !0 }) : (i) => wi.lstat(i, { bigint: !0 });
  return Promise.all([
    n(t),
    n(e).catch((i) => {
      if (i.code === "ENOENT")
        return null;
      throw i;
    })
  ]).then(([i, a]) => ({ srcStat: i, destStat: a }));
}
function hce(t, e, r) {
  let n;
  const i = r.dereference ? (s) => wi.statSync(s, { bigint: !0 }) : (s) => wi.lstatSync(s, { bigint: !0 }), a = i(t);
  try {
    n = i(e);
  } catch (s) {
    if (s.code === "ENOENT")
      return { srcStat: a, destStat: null };
    throw s;
  }
  return { srcStat: a, destStat: n };
}
function dce(t, e, r, n, i) {
  pce.callbackify(fce)(t, e, n, (a, s) => {
    if (a)
      return i(a);
    const { srcStat: o, destStat: c } = s;
    if (c) {
      if (_s(o, c)) {
        const f = ft.basename(t), u = ft.basename(e);
        return r === "move" && f !== u && f.toLowerCase() === u.toLowerCase() ? i(null, { srcStat: o, destStat: c, isChangingCase: !0 }) : i(new Error("Source and destination must not be the same."));
      }
      if (o.isDirectory() && !c.isDirectory())
        return i(new Error(`Cannot overwrite non-directory '${e}' with directory '${t}'.`));
      if (!o.isDirectory() && c.isDirectory())
        return i(new Error(`Cannot overwrite directory '${e}' with non-directory '${t}'.`));
    }
    return o.isDirectory() && Qv(t, e) ? i(new Error(_u(t, e, r))) : i(null, { srcStat: o, destStat: c });
  });
}
function mce(t, e, r, n) {
  const { srcStat: i, destStat: a } = hce(t, e, n);
  if (a) {
    if (_s(i, a)) {
      const s = ft.basename(t), o = ft.basename(e);
      if (r === "move" && s !== o && s.toLowerCase() === o.toLowerCase())
        return { srcStat: i, destStat: a, isChangingCase: !0 };
      throw new Error("Source and destination must not be the same.");
    }
    if (i.isDirectory() && !a.isDirectory())
      throw new Error(`Cannot overwrite non-directory '${e}' with directory '${t}'.`);
    if (!i.isDirectory() && a.isDirectory())
      throw new Error(`Cannot overwrite directory '${e}' with non-directory '${t}'.`);
  }
  if (i.isDirectory() && Qv(t, e))
    throw new Error(_u(t, e, r));
  return { srcStat: i, destStat: a };
}
function c4(t, e, r, n, i) {
  const a = ft.resolve(ft.dirname(t)), s = ft.resolve(ft.dirname(r));
  if (s === a || s === ft.parse(s).root)
    return i();
  wi.stat(s, { bigint: !0 }, (o, c) => o ? o.code === "ENOENT" ? i() : i(o) : _s(e, c) ? i(new Error(_u(t, r, n))) : c4(t, e, s, n, i));
}
function u4(t, e, r, n) {
  const i = ft.resolve(ft.dirname(t)), a = ft.resolve(ft.dirname(r));
  if (a === i || a === ft.parse(a).root)
    return;
  let s;
  try {
    s = wi.statSync(a, { bigint: !0 });
  } catch (o) {
    if (o.code === "ENOENT")
      return;
    throw o;
  }
  if (_s(e, s))
    throw new Error(_u(t, r, n));
  return u4(t, e, a, n);
}
function _s(t, e) {
  return e.ino && e.dev && e.ino === t.ino && e.dev === t.dev;
}
function Qv(t, e) {
  const r = ft.resolve(t).split(ft.sep).filter((i) => i), n = ft.resolve(e).split(ft.sep).filter((i) => i);
  return r.reduce((i, a, s) => i && n[s] === a, !0);
}
function _u(t, e, r) {
  return `Cannot ${r} '${t}' to a subdirectory of itself, '${e}'.`;
}
var Vi = {
  checkPaths: dce,
  checkPathsSync: mce,
  checkParentPaths: c4,
  checkParentPathsSync: u4,
  isSrcSubdir: Qv,
  areIdentical: _s
};
const Rt = Me, za = se, gce = Er.mkdirs, vce = Jn.pathExists, yce = o4.utimesMillis, Ha = Vi;
function bce(t, e, r, n) {
  typeof r == "function" && !n ? (n = r, r = {}) : typeof r == "function" && (r = { filter: r }), n = n || function() {
  }, r = r || {}, r.clobber = "clobber" in r ? !!r.clobber : !0, r.overwrite = "overwrite" in r ? !!r.overwrite : r.clobber, r.preserveTimestamps && process.arch === "ia32" && process.emitWarning(
    `Using the preserveTimestamps option in 32-bit node is not recommended;

	see https://github.com/jprichardson/node-fs-extra/issues/269`,
    "Warning",
    "fs-extra-WARN0001"
  ), Ha.checkPaths(t, e, "copy", r, (i, a) => {
    if (i)
      return n(i);
    const { srcStat: s, destStat: o } = a;
    Ha.checkParentPaths(t, s, e, "copy", (c) => c ? n(c) : r.filter ? l4(o_, o, t, e, r, n) : o_(o, t, e, r, n));
  });
}
function o_(t, e, r, n, i) {
  const a = za.dirname(r);
  vce(a, (s, o) => {
    if (s)
      return i(s);
    if (o)
      return Xo(t, e, r, n, i);
    gce(a, (c) => c ? i(c) : Xo(t, e, r, n, i));
  });
}
function l4(t, e, r, n, i, a) {
  Promise.resolve(i.filter(r, n)).then((s) => s ? t(e, r, n, i, a) : a(), (s) => a(s));
}
function wce(t, e, r, n, i) {
  return n.filter ? l4(Xo, t, e, r, n, i) : Xo(t, e, r, n, i);
}
function Xo(t, e, r, n, i) {
  (n.dereference ? Rt.stat : Rt.lstat)(e, (s, o) => s ? i(s) : o.isDirectory() ? Oce(o, t, e, r, n, i) : o.isFile() || o.isCharacterDevice() || o.isBlockDevice() ? xce(o, t, e, r, n, i) : o.isSymbolicLink() ? Ice(t, e, r, n, i) : o.isSocket() ? i(new Error(`Cannot copy a socket file: ${e}`)) : o.isFIFO() ? i(new Error(`Cannot copy a FIFO pipe: ${e}`)) : i(new Error(`Unknown file: ${e}`)));
}
function xce(t, e, r, n, i, a) {
  return e ? _ce(t, r, n, i, a) : p4(t, r, n, i, a);
}
function _ce(t, e, r, n, i) {
  if (n.overwrite)
    Rt.unlink(r, (a) => a ? i(a) : p4(t, e, r, n, i));
  else
    return n.errorOnExist ? i(new Error(`'${r}' already exists`)) : i();
}
function p4(t, e, r, n, i) {
  Rt.copyFile(e, r, (a) => a ? i(a) : n.preserveTimestamps ? Ece(t.mode, e, r, i) : Eu(r, t.mode, i));
}
function Ece(t, e, r, n) {
  return Sce(t) ? Cce(r, t, (i) => i ? n(i) : c_(t, e, r, n)) : c_(t, e, r, n);
}
function Sce(t) {
  return (t & 128) === 0;
}
function Cce(t, e, r) {
  return Eu(t, e | 128, r);
}
function c_(t, e, r, n) {
  Tce(e, r, (i) => i ? n(i) : Eu(r, t, n));
}
function Eu(t, e, r) {
  return Rt.chmod(t, e, r);
}
function Tce(t, e, r) {
  Rt.stat(t, (n, i) => n ? r(n) : yce(e, i.atime, i.mtime, r));
}
function Oce(t, e, r, n, i, a) {
  return e ? f4(r, n, i, a) : Ace(t.mode, r, n, i, a);
}
function Ace(t, e, r, n, i) {
  Rt.mkdir(r, (a) => {
    if (a)
      return i(a);
    f4(e, r, n, (s) => s ? i(s) : Eu(r, t, i));
  });
}
function f4(t, e, r, n) {
  Rt.readdir(t, (i, a) => i ? n(i) : h4(a, t, e, r, n));
}
function h4(t, e, r, n, i) {
  const a = t.pop();
  return a ? $ce(t, a, e, r, n, i) : i();
}
function $ce(t, e, r, n, i, a) {
  const s = za.join(r, e), o = za.join(n, e);
  Ha.checkPaths(s, o, "copy", i, (c, f) => {
    if (c)
      return a(c);
    const { destStat: u } = f;
    wce(u, s, o, i, (l) => l ? a(l) : h4(t, r, n, i, a));
  });
}
function Ice(t, e, r, n, i) {
  Rt.readlink(e, (a, s) => {
    if (a)
      return i(a);
    if (n.dereference && (s = za.resolve(process.cwd(), s)), t)
      Rt.readlink(r, (o, c) => o ? o.code === "EINVAL" || o.code === "UNKNOWN" ? Rt.symlink(s, r, i) : i(o) : (n.dereference && (c = za.resolve(process.cwd(), c)), Ha.isSrcSubdir(s, c) ? i(new Error(`Cannot copy '${s}' to a subdirectory of itself, '${c}'.`)) : t.isDirectory() && Ha.isSrcSubdir(c, s) ? i(new Error(`Cannot overwrite '${c}' with '${s}'.`)) : kce(s, r, i)));
    else
      return Rt.symlink(s, r, i);
  });
}
function kce(t, e, r) {
  Rt.unlink(e, (n) => n ? r(n) : Rt.symlink(t, e, r));
}
var Rce = bce;
const St = Me, Wa = se, Nce = Er.mkdirsSync, Lce = o4.utimesMillisSync, Ga = Vi;
function Pce(t, e, r) {
  typeof r == "function" && (r = { filter: r }), r = r || {}, r.clobber = "clobber" in r ? !!r.clobber : !0, r.overwrite = "overwrite" in r ? !!r.overwrite : r.clobber, r.preserveTimestamps && process.arch === "ia32" && process.emitWarning(
    `Using the preserveTimestamps option in 32-bit node is not recommended;

	see https://github.com/jprichardson/node-fs-extra/issues/269`,
    "Warning",
    "fs-extra-WARN0002"
  );
  const { srcStat: n, destStat: i } = Ga.checkPathsSync(t, e, "copy", r);
  return Ga.checkParentPathsSync(t, n, e, "copy"), Dce(i, t, e, r);
}
function Dce(t, e, r, n) {
  if (n.filter && !n.filter(e, r))
    return;
  const i = Wa.dirname(r);
  return St.existsSync(i) || Nce(i), d4(t, e, r, n);
}
function Mce(t, e, r, n) {
  if (!(n.filter && !n.filter(e, r)))
    return d4(t, e, r, n);
}
function d4(t, e, r, n) {
  const a = (n.dereference ? St.statSync : St.lstatSync)(e);
  if (a.isDirectory())
    return Hce(a, t, e, r, n);
  if (a.isFile() || a.isCharacterDevice() || a.isBlockDevice())
    return qce(a, t, e, r, n);
  if (a.isSymbolicLink())
    return Qce(t, e, r, n);
  throw a.isSocket() ? new Error(`Cannot copy a socket file: ${e}`) : a.isFIFO() ? new Error(`Cannot copy a FIFO pipe: ${e}`) : new Error(`Unknown file: ${e}`);
}
function qce(t, e, r, n, i) {
  return e ? jce(t, r, n, i) : m4(t, r, n, i);
}
function jce(t, e, r, n) {
  if (n.overwrite)
    return St.unlinkSync(r), m4(t, e, r, n);
  if (n.errorOnExist)
    throw new Error(`'${r}' already exists`);
}
function m4(t, e, r, n) {
  return St.copyFileSync(e, r), n.preserveTimestamps && Fce(t.mode, e, r), Vv(r, t.mode);
}
function Fce(t, e, r) {
  return Bce(t) && Uce(r, t), zce(e, r);
}
function Bce(t) {
  return (t & 128) === 0;
}
function Uce(t, e) {
  return Vv(t, e | 128);
}
function Vv(t, e) {
  return St.chmodSync(t, e);
}
function zce(t, e) {
  const r = St.statSync(t);
  return Lce(e, r.atime, r.mtime);
}
function Hce(t, e, r, n, i) {
  return e ? g4(r, n, i) : Wce(t.mode, r, n, i);
}
function Wce(t, e, r, n) {
  return St.mkdirSync(r), g4(e, r, n), Vv(r, t);
}
function g4(t, e, r) {
  St.readdirSync(t).forEach((n) => Gce(n, t, e, r));
}
function Gce(t, e, r, n) {
  const i = Wa.join(e, t), a = Wa.join(r, t), { destStat: s } = Ga.checkPathsSync(i, a, "copy", n);
  return Mce(s, i, a, n);
}
function Qce(t, e, r, n) {
  let i = St.readlinkSync(e);
  if (n.dereference && (i = Wa.resolve(process.cwd(), i)), t) {
    let a;
    try {
      a = St.readlinkSync(r);
    } catch (s) {
      if (s.code === "EINVAL" || s.code === "UNKNOWN")
        return St.symlinkSync(i, r);
      throw s;
    }
    if (n.dereference && (a = Wa.resolve(process.cwd(), a)), Ga.isSrcSubdir(i, a))
      throw new Error(`Cannot copy '${i}' to a subdirectory of itself, '${a}'.`);
    if (St.statSync(r).isDirectory() && Ga.isSrcSubdir(a, i))
      throw new Error(`Cannot overwrite '${a}' with '${i}'.`);
    return Vce(i, r);
  } else
    return St.symlinkSync(i, r);
}
function Vce(t, e) {
  return St.unlinkSync(e), St.symlinkSync(t, e);
}
var Kce = Pce;
const Jce = ze.fromCallback;
var Kv = {
  copy: Jce(Rce),
  copySync: Kce
};
const u_ = Me, v4 = se, Be = se, Qa = process.platform === "win32";
function y4(t) {
  [
    "unlink",
    "chmod",
    "stat",
    "lstat",
    "rmdir",
    "readdir"
  ].forEach((r) => {
    t[r] = t[r] || u_[r], r = r + "Sync", t[r] = t[r] || u_[r];
  }), t.maxBusyTries = t.maxBusyTries || 3;
}
function Jv(t, e, r) {
  let n = 0;
  typeof e == "function" && (r = e, e = {}), Be(t, "rimraf: missing path"), Be.strictEqual(typeof t, "string", "rimraf: path should be a string"), Be.strictEqual(typeof r, "function", "rimraf: callback function required"), Be(e, "rimraf: invalid options argument provided"), Be.strictEqual(typeof e, "object", "rimraf: options should be object"), y4(e), l_(t, e, function i(a) {
    if (a) {
      if ((a.code === "EBUSY" || a.code === "ENOTEMPTY" || a.code === "EPERM") && n < e.maxBusyTries) {
        n++;
        const s = n * 100;
        return setTimeout(() => l_(t, e, i), s);
      }
      a.code === "ENOENT" && (a = null);
    }
    r(a);
  });
}
function l_(t, e, r) {
  Be(t), Be(e), Be(typeof r == "function"), e.lstat(t, (n, i) => {
    if (n && n.code === "ENOENT")
      return r(null);
    if (n && n.code === "EPERM" && Qa)
      return p_(t, e, n, r);
    if (i && i.isDirectory())
      return Io(t, e, n, r);
    e.unlink(t, (a) => {
      if (a) {
        if (a.code === "ENOENT")
          return r(null);
        if (a.code === "EPERM")
          return Qa ? p_(t, e, a, r) : Io(t, e, a, r);
        if (a.code === "EISDIR")
          return Io(t, e, a, r);
      }
      return r(a);
    });
  });
}
function p_(t, e, r, n) {
  Be(t), Be(e), Be(typeof n == "function"), e.chmod(t, 438, (i) => {
    i ? n(i.code === "ENOENT" ? null : r) : e.stat(t, (a, s) => {
      a ? n(a.code === "ENOENT" ? null : r) : s.isDirectory() ? Io(t, e, r, n) : e.unlink(t, n);
    });
  });
}
function f_(t, e, r) {
  let n;
  Be(t), Be(e);
  try {
    e.chmodSync(t, 438);
  } catch (i) {
    if (i.code === "ENOENT")
      return;
    throw r;
  }
  try {
    n = e.statSync(t);
  } catch (i) {
    if (i.code === "ENOENT")
      return;
    throw r;
  }
  n.isDirectory() ? ko(t, e, r) : e.unlinkSync(t);
}
function Io(t, e, r, n) {
  Be(t), Be(e), Be(typeof n == "function"), e.rmdir(t, (i) => {
    i && (i.code === "ENOTEMPTY" || i.code === "EEXIST" || i.code === "EPERM") ? Xce(t, e, n) : i && i.code === "ENOTDIR" ? n(r) : n(i);
  });
}
function Xce(t, e, r) {
  Be(t), Be(e), Be(typeof r == "function"), e.readdir(t, (n, i) => {
    if (n)
      return r(n);
    let a = i.length, s;
    if (a === 0)
      return e.rmdir(t, r);
    i.forEach((o) => {
      Jv(v4.join(t, o), e, (c) => {
        if (!s) {
          if (c)
            return r(s = c);
          --a === 0 && e.rmdir(t, r);
        }
      });
    });
  });
}
function b4(t, e) {
  let r;
  e = e || {}, y4(e), Be(t, "rimraf: missing path"), Be.strictEqual(typeof t, "string", "rimraf: path should be a string"), Be(e, "rimraf: missing options"), Be.strictEqual(typeof e, "object", "rimraf: options should be object");
  try {
    r = e.lstatSync(t);
  } catch (n) {
    if (n.code === "ENOENT")
      return;
    n.code === "EPERM" && Qa && f_(t, e, n);
  }
  try {
    r && r.isDirectory() ? ko(t, e, null) : e.unlinkSync(t);
  } catch (n) {
    if (n.code === "ENOENT")
      return;
    if (n.code === "EPERM")
      return Qa ? f_(t, e, n) : ko(t, e, n);
    if (n.code !== "EISDIR")
      throw n;
    ko(t, e, n);
  }
}
function ko(t, e, r) {
  Be(t), Be(e);
  try {
    e.rmdirSync(t);
  } catch (n) {
    if (n.code === "ENOTDIR")
      throw r;
    if (n.code === "ENOTEMPTY" || n.code === "EEXIST" || n.code === "EPERM")
      Zce(t, e);
    else if (n.code !== "ENOENT")
      throw n;
  }
}
function Zce(t, e) {
  if (Be(t), Be(e), e.readdirSync(t).forEach((r) => b4(v4.join(t, r), e)), Qa) {
    const r = Date.now();
    do
      try {
        return e.rmdirSync(t, e);
      } catch {
      }
    while (Date.now() - r < 500);
  } else
    return e.rmdirSync(t, e);
}
var Yce = Jv;
Jv.sync = b4;
const Zo = Me, eue = ze.fromCallback, w4 = Yce;
function tue(t, e) {
  if (Zo.rm)
    return Zo.rm(t, { recursive: !0, force: !0 }, e);
  w4(t, e);
}
function rue(t) {
  if (Zo.rmSync)
    return Zo.rmSync(t, { recursive: !0, force: !0 });
  w4.sync(t);
}
var Su = {
  remove: eue(tue),
  removeSync: rue
};
const nue = ze.fromPromise, x4 = Kn, _4 = se, E4 = Er, S4 = Su, h_ = nue(async function(e) {
  let r;
  try {
    r = await x4.readdir(e);
  } catch {
    return E4.mkdirs(e);
  }
  return Promise.all(r.map((n) => S4.remove(_4.join(e, n))));
});
function d_(t) {
  let e;
  try {
    e = x4.readdirSync(t);
  } catch {
    return E4.mkdirsSync(t);
  }
  e.forEach((r) => {
    r = _4.join(t, r), S4.removeSync(r);
  });
}
var iue = {
  emptyDirSync: d_,
  emptydirSync: d_,
  emptyDir: h_,
  emptydir: h_
};
const aue = ze.fromCallback, C4 = se, Yr = Me, T4 = Er;
function sue(t, e) {
  function r() {
    Yr.writeFile(t, "", (n) => {
      if (n)
        return e(n);
      e();
    });
  }
  Yr.stat(t, (n, i) => {
    if (!n && i.isFile())
      return e();
    const a = C4.dirname(t);
    Yr.stat(a, (s, o) => {
      if (s)
        return s.code === "ENOENT" ? T4.mkdirs(a, (c) => {
          if (c)
            return e(c);
          r();
        }) : e(s);
      o.isDirectory() ? r() : Yr.readdir(a, (c) => {
        if (c)
          return e(c);
      });
    });
  });
}
function oue(t) {
  let e;
  try {
    e = Yr.statSync(t);
  } catch {
  }
  if (e && e.isFile())
    return;
  const r = C4.dirname(t);
  try {
    Yr.statSync(r).isDirectory() || Yr.readdirSync(r);
  } catch (n) {
    if (n && n.code === "ENOENT")
      T4.mkdirsSync(r);
    else
      throw n;
  }
  Yr.writeFileSync(t, "");
}
var cue = {
  createFile: aue(sue),
  createFileSync: oue
};
const uue = ze.fromCallback, O4 = se, Qr = Me, A4 = Er, lue = Jn.pathExists, { areIdentical: $4 } = Vi;
function pue(t, e, r) {
  function n(i, a) {
    Qr.link(i, a, (s) => {
      if (s)
        return r(s);
      r(null);
    });
  }
  Qr.lstat(e, (i, a) => {
    Qr.lstat(t, (s, o) => {
      if (s)
        return s.message = s.message.replace("lstat", "ensureLink"), r(s);
      if (a && $4(o, a))
        return r(null);
      const c = O4.dirname(e);
      lue(c, (f, u) => {
        if (f)
          return r(f);
        if (u)
          return n(t, e);
        A4.mkdirs(c, (l) => {
          if (l)
            return r(l);
          n(t, e);
        });
      });
    });
  });
}
function fue(t, e) {
  let r;
  try {
    r = Qr.lstatSync(e);
  } catch {
  }
  try {
    const a = Qr.lstatSync(t);
    if (r && $4(a, r))
      return;
  } catch (a) {
    throw a.message = a.message.replace("lstat", "ensureLink"), a;
  }
  const n = O4.dirname(e);
  return Qr.existsSync(n) || A4.mkdirsSync(n), Qr.linkSync(t, e);
}
var hue = {
  createLink: uue(pue),
  createLinkSync: fue
};
const en = se, ba = Me, due = Jn.pathExists;
function mue(t, e, r) {
  if (en.isAbsolute(t))
    return ba.lstat(t, (n) => n ? (n.message = n.message.replace("lstat", "ensureSymlink"), r(n)) : r(null, {
      toCwd: t,
      toDst: t
    }));
  {
    const n = en.dirname(e), i = en.join(n, t);
    return due(i, (a, s) => a ? r(a) : s ? r(null, {
      toCwd: i,
      toDst: t
    }) : ba.lstat(t, (o) => o ? (o.message = o.message.replace("lstat", "ensureSymlink"), r(o)) : r(null, {
      toCwd: t,
      toDst: en.relative(n, t)
    })));
  }
}
function gue(t, e) {
  let r;
  if (en.isAbsolute(t)) {
    if (r = ba.existsSync(t), !r)
      throw new Error("absolute srcpath does not exist");
    return {
      toCwd: t,
      toDst: t
    };
  } else {
    const n = en.dirname(e), i = en.join(n, t);
    if (r = ba.existsSync(i), r)
      return {
        toCwd: i,
        toDst: t
      };
    if (r = ba.existsSync(t), !r)
      throw new Error("relative srcpath does not exist");
    return {
      toCwd: t,
      toDst: en.relative(n, t)
    };
  }
}
var vue = {
  symlinkPaths: mue,
  symlinkPathsSync: gue
};
const I4 = Me;
function yue(t, e, r) {
  if (r = typeof e == "function" ? e : r, e = typeof e == "function" ? !1 : e, e)
    return r(null, e);
  I4.lstat(t, (n, i) => {
    if (n)
      return r(null, "file");
    e = i && i.isDirectory() ? "dir" : "file", r(null, e);
  });
}
function bue(t, e) {
  let r;
  if (e)
    return e;
  try {
    r = I4.lstatSync(t);
  } catch {
    return "file";
  }
  return r && r.isDirectory() ? "dir" : "file";
}
var wue = {
  symlinkType: yue,
  symlinkTypeSync: bue
};
const xue = ze.fromCallback, k4 = se, Jt = Kn, R4 = Er, _ue = R4.mkdirs, Eue = R4.mkdirsSync, N4 = vue, Sue = N4.symlinkPaths, Cue = N4.symlinkPathsSync, L4 = wue, Tue = L4.symlinkType, Oue = L4.symlinkTypeSync, Aue = Jn.pathExists, { areIdentical: P4 } = Vi;
function $ue(t, e, r, n) {
  n = typeof r == "function" ? r : n, r = typeof r == "function" ? !1 : r, Jt.lstat(e, (i, a) => {
    !i && a.isSymbolicLink() ? Promise.all([
      Jt.stat(t),
      Jt.stat(e)
    ]).then(([s, o]) => {
      if (P4(s, o))
        return n(null);
      m_(t, e, r, n);
    }) : m_(t, e, r, n);
  });
}
function m_(t, e, r, n) {
  Sue(t, e, (i, a) => {
    if (i)
      return n(i);
    t = a.toDst, Tue(a.toCwd, r, (s, o) => {
      if (s)
        return n(s);
      const c = k4.dirname(e);
      Aue(c, (f, u) => {
        if (f)
          return n(f);
        if (u)
          return Jt.symlink(t, e, o, n);
        _ue(c, (l) => {
          if (l)
            return n(l);
          Jt.symlink(t, e, o, n);
        });
      });
    });
  });
}
function Iue(t, e, r) {
  let n;
  try {
    n = Jt.lstatSync(e);
  } catch {
  }
  if (n && n.isSymbolicLink()) {
    const o = Jt.statSync(t), c = Jt.statSync(e);
    if (P4(o, c))
      return;
  }
  const i = Cue(t, e);
  t = i.toDst, r = Oue(i.toCwd, r);
  const a = k4.dirname(e);
  return Jt.existsSync(a) || Eue(a), Jt.symlinkSync(t, e, r);
}
var kue = {
  createSymlink: xue($ue),
  createSymlinkSync: Iue
};
const { createFile: g_, createFileSync: v_ } = cue, { createLink: y_, createLinkSync: b_ } = hue, { createSymlink: w_, createSymlinkSync: x_ } = kue;
var Rue = {
  // file
  createFile: g_,
  createFileSync: v_,
  ensureFile: g_,
  ensureFileSync: v_,
  // link
  createLink: y_,
  createLinkSync: b_,
  ensureLink: y_,
  ensureLinkSync: b_,
  // symlink
  createSymlink: w_,
  createSymlinkSync: x_,
  ensureSymlink: w_,
  ensureSymlinkSync: x_
};
const no = gT;
var Nue = {
  // jsonfile exports
  readJson: no.readFile,
  readJsonSync: no.readFileSync,
  writeJson: no.writeFile,
  writeJsonSync: no.writeFileSync
};
const Lue = ze.fromCallback, wa = Me, D4 = se, M4 = Er, Pue = Jn.pathExists;
function Due(t, e, r, n) {
  typeof r == "function" && (n = r, r = "utf8");
  const i = D4.dirname(t);
  Pue(i, (a, s) => {
    if (a)
      return n(a);
    if (s)
      return wa.writeFile(t, e, r, n);
    M4.mkdirs(i, (o) => {
      if (o)
        return n(o);
      wa.writeFile(t, e, r, n);
    });
  });
}
function Mue(t, ...e) {
  const r = D4.dirname(t);
  if (wa.existsSync(r))
    return wa.writeFileSync(t, ...e);
  M4.mkdirsSync(r), wa.writeFileSync(t, ...e);
}
var Xv = {
  outputFile: Lue(Due),
  outputFileSync: Mue
};
const { stringify: que } = as, { outputFile: jue } = Xv;
async function Fue(t, e, r = {}) {
  const n = que(e, r);
  await jue(t, n, r);
}
var Bue = Fue;
const { stringify: Uue } = as, { outputFileSync: zue } = Xv;
function Hue(t, e, r) {
  const n = Uue(e, r);
  zue(t, n, r);
}
var Wue = Hue;
const Gue = ze.fromPromise, $t = Nue;
$t.outputJson = Gue(Bue);
$t.outputJsonSync = Wue;
$t.outputJSON = $t.outputJson;
$t.outputJSONSync = $t.outputJsonSync;
$t.writeJSON = $t.writeJson;
$t.writeJSONSync = $t.writeJsonSync;
$t.readJSON = $t.readJson;
$t.readJSONSync = $t.readJsonSync;
var Que = $t;
const Vue = Me, mg = se, Kue = Kv.copy, q4 = Su.remove, Jue = Er.mkdirp, Xue = Jn.pathExists, __ = Vi;
function Zue(t, e, r, n) {
  typeof r == "function" && (n = r, r = {}), r = r || {};
  const i = r.overwrite || r.clobber || !1;
  __.checkPaths(t, e, "move", r, (a, s) => {
    if (a)
      return n(a);
    const { srcStat: o, isChangingCase: c = !1 } = s;
    __.checkParentPaths(t, o, e, "move", (f) => {
      if (f)
        return n(f);
      if (Yue(e))
        return E_(t, e, i, c, n);
      Jue(mg.dirname(e), (u) => u ? n(u) : E_(t, e, i, c, n));
    });
  });
}
function Yue(t) {
  const e = mg.dirname(t);
  return mg.parse(e).root === e;
}
function E_(t, e, r, n, i) {
  if (n)
    return Zf(t, e, r, i);
  if (r)
    return q4(e, (a) => a ? i(a) : Zf(t, e, r, i));
  Xue(e, (a, s) => a ? i(a) : s ? i(new Error("dest already exists.")) : Zf(t, e, r, i));
}
function Zf(t, e, r, n) {
  Vue.rename(t, e, (i) => i ? i.code !== "EXDEV" ? n(i) : ele(t, e, r, n) : n());
}
function ele(t, e, r, n) {
  Kue(t, e, {
    overwrite: r,
    errorOnExist: !0
  }, (a) => a ? n(a) : q4(t, n));
}
var tle = Zue;
const j4 = Me, gg = se, rle = Kv.copySync, F4 = Su.removeSync, nle = Er.mkdirpSync, S_ = Vi;
function ile(t, e, r) {
  r = r || {};
  const n = r.overwrite || r.clobber || !1, { srcStat: i, isChangingCase: a = !1 } = S_.checkPathsSync(t, e, "move", r);
  return S_.checkParentPathsSync(t, i, e, "move"), ale(e) || nle(gg.dirname(e)), sle(t, e, n, a);
}
function ale(t) {
  const e = gg.dirname(t);
  return gg.parse(e).root === e;
}
function sle(t, e, r, n) {
  if (n)
    return Yf(t, e, r);
  if (r)
    return F4(e), Yf(t, e, r);
  if (j4.existsSync(e))
    throw new Error("dest already exists.");
  return Yf(t, e, r);
}
function Yf(t, e, r) {
  try {
    j4.renameSync(t, e);
  } catch (n) {
    if (n.code !== "EXDEV")
      throw n;
    return ole(t, e, r);
  }
}
function ole(t, e, r) {
  return rle(t, e, {
    overwrite: r,
    errorOnExist: !0
  }), F4(t);
}
var cle = ile;
const ule = ze.fromCallback;
var lle = {
  move: ule(tle),
  moveSync: cle
}, ple = {
  // Export promiseified graceful-fs:
  ...Kn,
  // Export extra methods:
  ...Kv,
  ...iue,
  ...Rue,
  ...Que,
  ...Er,
  ...lle,
  ...Xv,
  ...Jn,
  ...Su
};
function B4(t, ...e) {
  return (...r) => t(...e, ...r);
}
function Es(t) {
  return function(...e) {
    var r = e.pop();
    return t.call(this, e, r);
  };
}
var fle = typeof queueMicrotask == "function" && queueMicrotask, U4 = typeof setImmediate == "function" && setImmediate, z4 = typeof process == "object" && typeof process.nextTick == "function";
function H4(t) {
  setTimeout(t, 0);
}
function W4(t) {
  return (e, ...r) => t(() => e(...r));
}
var da;
fle ? da = queueMicrotask : U4 ? da = setImmediate : z4 ? da = process.nextTick : da = H4;
var nn = W4(da);
function Va(t) {
  return Ss(t) ? function(...e) {
    const r = e.pop(), n = t.apply(this, e);
    return C_(n, r);
  } : Es(function(e, r) {
    var n;
    try {
      n = t.apply(this, e);
    } catch (i) {
      return r(i);
    }
    if (n && typeof n.then == "function")
      return C_(n, r);
    r(null, n);
  });
}
function C_(t, e) {
  return t.then((r) => {
    T_(e, null, r);
  }, (r) => {
    T_(e, r && r.message ? r : new Error(r));
  });
}
function T_(t, e, r) {
  try {
    t(e, r);
  } catch (n) {
    nn((i) => {
      throw i;
    }, n);
  }
}
function Ss(t) {
  return t[Symbol.toStringTag] === "AsyncFunction";
}
function hle(t) {
  return t[Symbol.toStringTag] === "AsyncGenerator";
}
function dle(t) {
  return typeof t[Symbol.asyncIterator] == "function";
}
function ke(t) {
  if (typeof t != "function")
    throw new Error("expected a function");
  return Ss(t) ? Va(t) : t;
}
function Ie(t, e = t.length) {
  if (!e)
    throw new Error("arity is undefined");
  function r(...n) {
    return typeof n[e - 1] == "function" ? t.apply(this, n) : new Promise((i, a) => {
      n[e - 1] = (s, ...o) => {
        if (s)
          return a(s);
        i(o.length > 1 ? o : o[0]);
      }, t.apply(this, n);
    });
  }
  return r;
}
function G4(t) {
  return function(r, ...n) {
    return Ie(function(a) {
      var s = this;
      return t(r, (o, c) => {
        ke(o).apply(s, n.concat(c));
      }, a);
    });
  };
}
function Zv(t, e, r, n) {
  e = e || [];
  var i = [], a = 0, s = ke(r);
  return t(e, (o, c, f) => {
    var u = a++;
    s(o, (l, p) => {
      i[u] = p, f(l);
    });
  }, (o) => {
    n(o, i);
  });
}
function Cu(t) {
  return t && typeof t.length == "number" && t.length >= 0 && t.length % 1 === 0;
}
const Tu = {};
function hn(t) {
  function e(...r) {
    if (t !== null) {
      var n = t;
      t = null, n.apply(this, r);
    }
  }
  return Object.assign(e, t), e;
}
function mle(t) {
  return t[Symbol.iterator] && t[Symbol.iterator]();
}
function gle(t) {
  var e = -1, r = t.length;
  return function() {
    return ++e < r ? { value: t[e], key: e } : null;
  };
}
function vle(t) {
  var e = -1;
  return function() {
    var n = t.next();
    return n.done ? null : (e++, { value: n.value, key: e });
  };
}
function yle(t) {
  var e = t ? Object.keys(t) : [], r = -1, n = e.length;
  return function i() {
    var a = e[++r];
    return a === "__proto__" ? i() : r < n ? { value: t[a], key: a } : null;
  };
}
function ble(t) {
  if (Cu(t))
    return gle(t);
  var e = mle(t);
  return e ? vle(e) : yle(t);
}
function dn(t) {
  return function(...e) {
    if (t === null)
      throw new Error("Callback was already called.");
    var r = t;
    t = null, r.apply(this, e);
  };
}
function O_(t, e, r, n) {
  let i = !1, a = !1, s = !1, o = 0, c = 0;
  function f() {
    o >= e || s || i || (s = !0, t.next().then(({ value: p, done: m }) => {
      if (!(a || i)) {
        if (s = !1, m) {
          i = !0, o <= 0 && n(null);
          return;
        }
        o++, r(p, c, u), c++, f();
      }
    }).catch(l));
  }
  function u(p, m) {
    if (o -= 1, !a) {
      if (p)
        return l(p);
      if (p === !1) {
        i = !0, a = !0;
        return;
      }
      if (m === Tu || i && o <= 0)
        return i = !0, n(null);
      f();
    }
  }
  function l(p) {
    a || (s = !1, i = !0, n(p));
  }
  f();
}
var or = (t) => (e, r, n) => {
  if (n = hn(n), t <= 0)
    throw new RangeError("concurrency limit cannot be less than 1");
  if (!e)
    return n(null);
  if (hle(e))
    return O_(e, t, r, n);
  if (dle(e))
    return O_(e[Symbol.asyncIterator](), t, r, n);
  var i = ble(e), a = !1, s = !1, o = 0, c = !1;
  function f(l, p) {
    if (!s)
      if (o -= 1, l)
        a = !0, n(l);
      else if (l === !1)
        a = !0, s = !0;
      else {
        if (p === Tu || a && o <= 0)
          return a = !0, n(null);
        c || u();
      }
  }
  function u() {
    for (c = !0; o < t && !a; ) {
      var l = i();
      if (l === null) {
        a = !0, o <= 0 && n(null);
        return;
      }
      o += 1, r(l.value, l.key, dn(f));
    }
    c = !1;
  }
  u();
};
function wle(t, e, r, n) {
  return or(e)(t, ke(r), n);
}
var xi = Ie(wle, 4);
function xle(t, e, r) {
  r = hn(r);
  var n = 0, i = 0, { length: a } = t, s = !1;
  a === 0 && r(null);
  function o(c, f) {
    c === !1 && (s = !0), s !== !0 && (c ? r(c) : (++i === a || f === Tu) && r(null));
  }
  for (; n < a; n++)
    e(t[n], n, dn(o));
}
function _le(t, e, r) {
  return xi(t, 1 / 0, e, r);
}
function Ele(t, e, r) {
  var n = Cu(t) ? xle : _le;
  return n(t, ke(e), r);
}
var Mt = Ie(Ele, 3);
function Sle(t, e, r) {
  return Zv(Mt, t, e, r);
}
var Ou = Ie(Sle, 3), Q4 = G4(Ou);
function Cle(t, e, r) {
  return xi(t, 1, e, r);
}
var er = Ie(Cle, 3);
function Tle(t, e, r) {
  return Zv(er, t, e, r);
}
var Yv = Ie(Tle, 3), V4 = G4(Yv);
const Ki = Symbol("promiseCallback");
function _i() {
  let t, e;
  function r(n, ...i) {
    if (n)
      return e(n);
    t(i.length > 1 ? i : i[0]);
  }
  return r[Ki] = new Promise((n, i) => {
    t = n, e = i;
  }), r;
}
function ey(t, e, r) {
  typeof e != "number" && (r = e, e = null), r = hn(r || _i());
  var n = Object.keys(t).length;
  if (!n)
    return r(null);
  e || (e = n);
  var i = {}, a = 0, s = !1, o = !1, c = /* @__PURE__ */ Object.create(null), f = [], u = [], l = {};
  Object.keys(t).forEach((x) => {
    var b = t[x];
    if (!Array.isArray(b)) {
      p(x, [b]), u.push(x);
      return;
    }
    var w = b.slice(0, b.length - 1), S = w.length;
    if (S === 0) {
      p(x, b), u.push(x);
      return;
    }
    l[x] = S, w.forEach((T) => {
      if (!t[T])
        throw new Error("async.auto task `" + x + "` has a non-existent dependency `" + T + "` in " + w.join(", "));
      h(T, () => {
        S--, S === 0 && p(x, b);
      });
    });
  }), d(), m();
  function p(x, b) {
    f.push(() => v(x, b));
  }
  function m() {
    if (!s) {
      if (f.length === 0 && a === 0)
        return r(null, i);
      for (; f.length && a < e; ) {
        var x = f.shift();
        x();
      }
    }
  }
  function h(x, b) {
    var w = c[x];
    w || (w = c[x] = []), w.push(b);
  }
  function g(x) {
    var b = c[x] || [];
    b.forEach((w) => w()), m();
  }
  function v(x, b) {
    if (!o) {
      var w = dn((T, ...E) => {
        if (a--, T === !1) {
          s = !0;
          return;
        }
        if (E.length < 2 && ([E] = E), T) {
          var C = {};
          if (Object.keys(i).forEach((A) => {
            C[A] = i[A];
          }), C[x] = E, o = !0, c = /* @__PURE__ */ Object.create(null), s)
            return;
          r(T, C);
        } else
          i[x] = E, g(x);
      });
      a++;
      var S = ke(b[b.length - 1]);
      b.length > 1 ? S(i, w) : S(w);
    }
  }
  function d() {
    for (var x, b = 0; u.length; )
      x = u.pop(), b++, y(x).forEach((w) => {
        --l[w] === 0 && u.push(w);
      });
    if (b !== n)
      throw new Error(
        "async.auto cannot execute tasks due to a recursive dependency"
      );
  }
  function y(x) {
    var b = [];
    return Object.keys(t).forEach((w) => {
      const S = t[w];
      Array.isArray(S) && S.indexOf(x) >= 0 && b.push(w);
    }), b;
  }
  return r[Ki];
}
var Ole = /^(?:async\s+)?(?:function)?\s*\w*\s*\(\s*([^)]+)\s*\)(?:\s*{)/, Ale = /^(?:async\s+)?\(?\s*([^)=]+)\s*\)?(?:\s*=>)/, $le = /,/, Ile = /(=.+)?(\s*)$/;
function kle(t) {
  let e = "", r = 0, n = t.indexOf("*/");
  for (; r < t.length; )
    if (t[r] === "/" && t[r + 1] === "/") {
      let i = t.indexOf(`
`, r);
      r = i === -1 ? t.length : i;
    } else if (n !== -1 && t[r] === "/" && t[r + 1] === "*") {
      let i = t.indexOf("*/", r);
      i !== -1 ? (r = i + 2, n = t.indexOf("*/", r)) : (e += t[r], r++);
    } else
      e += t[r], r++;
  return e;
}
function Rle(t) {
  const e = kle(t.toString());
  let r = e.match(Ole);
  if (r || (r = e.match(Ale)), !r)
    throw new Error(`could not parse args in autoInject
Source:
` + e);
  let [, n] = r;
  return n.replace(/\s/g, "").split($le).map((i) => i.replace(Ile, "").trim());
}
function K4(t, e) {
  var r = {};
  return Object.keys(t).forEach((n) => {
    var i = t[n], a, s = Ss(i), o = !s && i.length === 1 || s && i.length === 0;
    if (Array.isArray(i))
      a = [...i], i = a.pop(), r[n] = a.concat(a.length > 0 ? c : i);
    else if (o)
      r[n] = i;
    else {
      if (a = Rle(i), i.length === 0 && !s && a.length === 0)
        throw new Error("autoInject task functions require explicit parameters.");
      s || a.pop(), r[n] = a.concat(c);
    }
    function c(f, u) {
      var l = a.map((p) => f[p]);
      l.push(u), ke(i)(...l);
    }
  }), ey(r, e);
}
class Nle {
  constructor() {
    this.head = this.tail = null, this.length = 0;
  }
  removeLink(e) {
    return e.prev ? e.prev.next = e.next : this.head = e.next, e.next ? e.next.prev = e.prev : this.tail = e.prev, e.prev = e.next = null, this.length -= 1, e;
  }
  empty() {
    for (; this.head; )
      this.shift();
    return this;
  }
  insertAfter(e, r) {
    r.prev = e, r.next = e.next, e.next ? e.next.prev = r : this.tail = r, e.next = r, this.length += 1;
  }
  insertBefore(e, r) {
    r.prev = e.prev, r.next = e, e.prev ? e.prev.next = r : this.head = r, e.prev = r, this.length += 1;
  }
  unshift(e) {
    this.head ? this.insertBefore(this.head, e) : A_(this, e);
  }
  push(e) {
    this.tail ? this.insertAfter(this.tail, e) : A_(this, e);
  }
  shift() {
    return this.head && this.removeLink(this.head);
  }
  pop() {
    return this.tail && this.removeLink(this.tail);
  }
  toArray() {
    return [...this];
  }
  *[Symbol.iterator]() {
    for (var e = this.head; e; )
      yield e.data, e = e.next;
  }
  remove(e) {
    for (var r = this.head; r; ) {
      var { next: n } = r;
      e(r) && this.removeLink(r), r = n;
    }
    return this;
  }
}
function A_(t, e) {
  t.length = 1, t.head = t.tail = e;
}
function ty(t, e, r) {
  if (e == null)
    e = 1;
  else if (e === 0)
    throw new RangeError("Concurrency must not be zero");
  var n = ke(t), i = 0, a = [];
  const s = {
    error: [],
    drain: [],
    saturated: [],
    unsaturated: [],
    empty: []
  };
  function o(y, x) {
    s[y].push(x);
  }
  function c(y, x) {
    const b = (...w) => {
      f(y, b), x(...w);
    };
    s[y].push(b);
  }
  function f(y, x) {
    if (!y)
      return Object.keys(s).forEach((b) => s[b] = []);
    if (!x)
      return s[y] = [];
    s[y] = s[y].filter((b) => b !== x);
  }
  function u(y, ...x) {
    s[y].forEach((b) => b(...x));
  }
  var l = !1;
  function p(y, x, b, w) {
    if (w != null && typeof w != "function")
      throw new Error("task callback must be a function");
    d.started = !0;
    var S, T;
    function E(A, ...R) {
      if (A)
        return b ? T(A) : S();
      if (R.length <= 1)
        return S(R[0]);
      S(R);
    }
    var C = d._createTaskItem(
      y,
      b ? E : w || E
    );
    if (x ? d._tasks.unshift(C) : d._tasks.push(C), l || (l = !0, nn(() => {
      l = !1, d.process();
    })), b || !w)
      return new Promise((A, R) => {
        S = A, T = R;
      });
  }
  function m(y) {
    return function(x, ...b) {
      i -= 1;
      for (var w = 0, S = y.length; w < S; w++) {
        var T = y[w], E = a.indexOf(T);
        E === 0 ? a.shift() : E > 0 && a.splice(E, 1), T.callback(x, ...b), x != null && u("error", x, T.data);
      }
      i <= d.concurrency - d.buffer && u("unsaturated"), d.idle() && u("drain"), d.process();
    };
  }
  function h(y) {
    return y.length === 0 && d.idle() ? (nn(() => u("drain")), !0) : !1;
  }
  const g = (y) => (x) => {
    if (!x)
      return new Promise((b, w) => {
        c(y, (S, T) => {
          if (S)
            return w(S);
          b(T);
        });
      });
    f(y), o(y, x);
  };
  var v = !1, d = {
    _tasks: new Nle(),
    _createTaskItem(y, x) {
      return {
        data: y,
        callback: x
      };
    },
    *[Symbol.iterator]() {
      yield* d._tasks[Symbol.iterator]();
    },
    concurrency: e,
    payload: r,
    buffer: e / 4,
    started: !1,
    paused: !1,
    push(y, x) {
      return Array.isArray(y) ? h(y) ? void 0 : y.map((b) => p(b, !1, !1, x)) : p(y, !1, !1, x);
    },
    pushAsync(y, x) {
      return Array.isArray(y) ? h(y) ? void 0 : y.map((b) => p(b, !1, !0, x)) : p(y, !1, !0, x);
    },
    kill() {
      f(), d._tasks.empty();
    },
    unshift(y, x) {
      return Array.isArray(y) ? h(y) ? void 0 : y.map((b) => p(b, !0, !1, x)) : p(y, !0, !1, x);
    },
    unshiftAsync(y, x) {
      return Array.isArray(y) ? h(y) ? void 0 : y.map((b) => p(b, !0, !0, x)) : p(y, !0, !0, x);
    },
    remove(y) {
      d._tasks.remove(y);
    },
    process() {
      if (!v) {
        for (v = !0; !d.paused && i < d.concurrency && d._tasks.length; ) {
          var y = [], x = [], b = d._tasks.length;
          d.payload && (b = Math.min(b, d.payload));
          for (var w = 0; w < b; w++) {
            var S = d._tasks.shift();
            y.push(S), a.push(S), x.push(S.data);
          }
          i += 1, d._tasks.length === 0 && u("empty"), i === d.concurrency && u("saturated");
          var T = dn(m(y));
          n(x, T);
        }
        v = !1;
      }
    },
    length() {
      return d._tasks.length;
    },
    running() {
      return i;
    },
    workersList() {
      return a;
    },
    idle() {
      return d._tasks.length + i === 0;
    },
    pause() {
      d.paused = !0;
    },
    resume() {
      d.paused !== !1 && (d.paused = !1, nn(d.process));
    }
  };
  return Object.defineProperties(d, {
    saturated: {
      writable: !1,
      value: g("saturated")
    },
    unsaturated: {
      writable: !1,
      value: g("unsaturated")
    },
    empty: {
      writable: !1,
      value: g("empty")
    },
    drain: {
      writable: !1,
      value: g("drain")
    },
    error: {
      writable: !1,
      value: g("error")
    }
  }), d;
}
function J4(t, e) {
  return ty(t, 1, e);
}
function X4(t, e, r) {
  return ty(t, e, r);
}
function Lle(t, e, r, n) {
  n = hn(n);
  var i = ke(r);
  return er(t, (a, s, o) => {
    i(e, a, (c, f) => {
      e = f, o(c);
    });
  }, (a) => n(a, e));
}
var an = Ie(Lle, 4);
function ry(...t) {
  var e = t.map(ke);
  return function(...r) {
    var n = this, i = r[r.length - 1];
    return typeof i == "function" ? r.pop() : i = _i(), an(
      e,
      r,
      (a, s, o) => {
        s.apply(n, a.concat((c, ...f) => {
          o(c, f);
        }));
      },
      (a, s) => i(a, ...s)
    ), i[Ki];
  };
}
function Z4(...t) {
  return ry(...t.reverse());
}
function Ple(t, e, r, n) {
  return Zv(or(e), t, r, n);
}
var Cs = Ie(Ple, 4);
function Dle(t, e, r, n) {
  var i = ke(r);
  return Cs(t, e, (a, s) => {
    i(a, (o, ...c) => o ? s(o) : s(o, c));
  }, (a, s) => {
    for (var o = [], c = 0; c < s.length; c++)
      s[c] && (o = o.concat(...s[c]));
    return n(a, o);
  });
}
var Ei = Ie(Dle, 4);
function Mle(t, e, r) {
  return Ei(t, 1 / 0, e, r);
}
var Yo = Ie(Mle, 3);
function qle(t, e, r) {
  return Ei(t, 1, e, r);
}
var ec = Ie(qle, 3);
function Y4(...t) {
  return function(...e) {
    var r = e.pop();
    return r(null, ...t);
  };
}
function Br(t, e) {
  return (r, n, i, a) => {
    var s = !1, o;
    const c = ke(i);
    r(n, (f, u, l) => {
      c(f, (p, m) => {
        if (p || p === !1)
          return l(p);
        if (t(m) && !o)
          return s = !0, o = e(!0, f), l(null, Tu);
        l();
      });
    }, (f) => {
      if (f)
        return a(f);
      a(null, s ? o : e(!1));
    });
  };
}
function jle(t, e, r) {
  return Br((n) => n, (n, i) => i)(Mt, t, e, r);
}
var tc = Ie(jle, 3);
function Fle(t, e, r, n) {
  return Br((i) => i, (i, a) => a)(or(e), t, r, n);
}
var rc = Ie(Fle, 4);
function Ble(t, e, r) {
  return Br((n) => n, (n, i) => i)(or(1), t, e, r);
}
var nc = Ie(Ble, 3);
function e$(t) {
  return (e, ...r) => ke(e)(...r, (n, ...i) => {
    typeof console == "object" && (n ? console.error && console.error(n) : console[t] && i.forEach((a) => console[t](a)));
  });
}
var t$ = e$("dir");
function Ule(t, e, r) {
  r = dn(r);
  var n = ke(t), i = ke(e), a;
  function s(c, ...f) {
    if (c)
      return r(c);
    c !== !1 && (a = f, i(...f, o));
  }
  function o(c, f) {
    if (c)
      return r(c);
    if (c !== !1) {
      if (!f)
        return r(null, ...a);
      n(s);
    }
  }
  return o(null, !0);
}
var Ka = Ie(Ule, 3);
function r$(t, e, r) {
  const n = ke(e);
  return Ka(t, (...i) => {
    const a = i.pop();
    n(...i, (s, o) => a(s, !o));
  }, r);
}
function n$(t) {
  return (e, r, n) => t(e, n);
}
function zle(t, e, r) {
  return Mt(t, n$(ke(e)), r);
}
var ic = Ie(zle, 3);
function Hle(t, e, r, n) {
  return or(e)(t, n$(ke(r)), n);
}
var Ja = Ie(Hle, 4);
function Wle(t, e, r) {
  return Ja(t, 1, e, r);
}
var Xa = Ie(Wle, 3);
function ny(t) {
  return Ss(t) ? t : function(...e) {
    var r = e.pop(), n = !0;
    e.push((...i) => {
      n ? nn(() => r(...i)) : r(...i);
    }), t.apply(this, e), n = !1;
  };
}
function Gle(t, e, r) {
  return Br((n) => !n, (n) => !n)(Mt, t, e, r);
}
var ac = Ie(Gle, 3);
function Qle(t, e, r, n) {
  return Br((i) => !i, (i) => !i)(or(e), t, r, n);
}
var sc = Ie(Qle, 4);
function Vle(t, e, r) {
  return Br((n) => !n, (n) => !n)(er, t, e, r);
}
var oc = Ie(Vle, 3);
function Kle(t, e, r, n) {
  var i = new Array(e.length);
  t(e, (a, s, o) => {
    r(a, (c, f) => {
      i[s] = !!f, o(c);
    });
  }, (a) => {
    if (a)
      return n(a);
    for (var s = [], o = 0; o < e.length; o++)
      i[o] && s.push(e[o]);
    n(null, s);
  });
}
function Jle(t, e, r, n) {
  var i = [];
  t(e, (a, s, o) => {
    r(a, (c, f) => {
      if (c)
        return o(c);
      f && i.push({ index: s, value: a }), o(c);
    });
  }, (a) => {
    if (a)
      return n(a);
    n(null, i.sort((s, o) => s.index - o.index).map((s) => s.value));
  });
}
function Au(t, e, r, n) {
  var i = Cu(e) ? Kle : Jle;
  return i(t, e, ke(r), n);
}
function Xle(t, e, r) {
  return Au(Mt, t, e, r);
}
var cc = Ie(Xle, 3);
function Zle(t, e, r, n) {
  return Au(or(e), t, r, n);
}
var uc = Ie(Zle, 4);
function Yle(t, e, r) {
  return Au(er, t, e, r);
}
var lc = Ie(Yle, 3);
function epe(t, e) {
  var r = dn(e), n = ke(ny(t));
  function i(a) {
    if (a)
      return r(a);
    a !== !1 && n(i);
  }
  return i();
}
var i$ = Ie(epe, 2);
function tpe(t, e, r, n) {
  var i = ke(r);
  return Cs(t, e, (a, s) => {
    i(a, (o, c) => o ? s(o) : s(o, { key: c, val: a }));
  }, (a, s) => {
    for (var o = {}, { hasOwnProperty: c } = Object.prototype, f = 0; f < s.length; f++)
      if (s[f]) {
        var { key: u } = s[f], { val: l } = s[f];
        c.call(o, u) ? o[u].push(l) : o[u] = [l];
      }
    return n(a, o);
  });
}
var $u = Ie(tpe, 4);
function a$(t, e, r) {
  return $u(t, 1 / 0, e, r);
}
function s$(t, e, r) {
  return $u(t, 1, e, r);
}
var o$ = e$("log");
function rpe(t, e, r, n) {
  n = hn(n);
  var i = {}, a = ke(r);
  return or(e)(t, (s, o, c) => {
    a(s, o, (f, u) => {
      if (f)
        return c(f);
      i[o] = u, c(f);
    });
  }, (s) => n(s, i));
}
var Iu = Ie(rpe, 4);
function c$(t, e, r) {
  return Iu(t, 1 / 0, e, r);
}
function u$(t, e, r) {
  return Iu(t, 1, e, r);
}
function l$(t, e = (r) => r) {
  var r = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null), i = ke(t), a = Es((s, o) => {
    var c = e(...s);
    c in r ? nn(() => o(null, ...r[c])) : c in n ? n[c].push(o) : (n[c] = [o], i(...s, (f, ...u) => {
      f || (r[c] = u);
      var l = n[c];
      delete n[c];
      for (var p = 0, m = l.length; p < m; p++)
        l[p](f, ...u);
    }));
  });
  return a.memo = r, a.unmemoized = t, a;
}
var Ro;
z4 ? Ro = process.nextTick : U4 ? Ro = setImmediate : Ro = H4;
var p$ = W4(Ro), iy = Ie((t, e, r) => {
  var n = Cu(e) ? [] : {};
  t(e, (i, a, s) => {
    ke(i)((o, ...c) => {
      c.length < 2 && ([c] = c), n[a] = c, s(o);
    });
  }, (i) => r(i, n));
}, 3);
function f$(t, e) {
  return iy(Mt, t, e);
}
function h$(t, e, r) {
  return iy(or(e), t, r);
}
function ay(t, e) {
  var r = ke(t);
  return ty((n, i) => {
    r(n[0], i);
  }, e, 1);
}
class npe {
  constructor() {
    this.heap = [], this.pushCount = Number.MIN_SAFE_INTEGER;
  }
  get length() {
    return this.heap.length;
  }
  empty() {
    return this.heap = [], this;
  }
  percUp(e) {
    let r;
    for (; e > 0 && eh(this.heap[e], this.heap[r = $_(e)]); ) {
      let n = this.heap[e];
      this.heap[e] = this.heap[r], this.heap[r] = n, e = r;
    }
  }
  percDown(e) {
    let r;
    for (; (r = ipe(e)) < this.heap.length && (r + 1 < this.heap.length && eh(this.heap[r + 1], this.heap[r]) && (r = r + 1), !eh(this.heap[e], this.heap[r])); ) {
      let n = this.heap[e];
      this.heap[e] = this.heap[r], this.heap[r] = n, e = r;
    }
  }
  push(e) {
    e.pushCount = ++this.pushCount, this.heap.push(e), this.percUp(this.heap.length - 1);
  }
  unshift(e) {
    return this.heap.push(e);
  }
  shift() {
    let [e] = this.heap;
    return this.heap[0] = this.heap[this.heap.length - 1], this.heap.pop(), this.percDown(0), e;
  }
  toArray() {
    return [...this];
  }
  *[Symbol.iterator]() {
    for (let e = 0; e < this.heap.length; e++)
      yield this.heap[e].data;
  }
  remove(e) {
    let r = 0;
    for (let n = 0; n < this.heap.length; n++)
      e(this.heap[n]) || (this.heap[r] = this.heap[n], r++);
    this.heap.splice(r);
    for (let n = $_(this.heap.length - 1); n >= 0; n--)
      this.percDown(n);
    return this;
  }
}
function ipe(t) {
  return (t << 1) + 1;
}
function $_(t) {
  return (t + 1 >> 1) - 1;
}
function eh(t, e) {
  return t.priority !== e.priority ? t.priority < e.priority : t.pushCount < e.pushCount;
}
function d$(t, e) {
  var r = ay(t, e), {
    push: n,
    pushAsync: i
  } = r;
  r._tasks = new npe(), r._createTaskItem = ({ data: s, priority: o }, c) => ({
    data: s,
    priority: o,
    callback: c
  });
  function a(s, o) {
    return Array.isArray(s) ? s.map((c) => ({ data: c, priority: o })) : { data: s, priority: o };
  }
  return r.push = function(s, o = 0, c) {
    return n(a(s, o), c);
  }, r.pushAsync = function(s, o = 0, c) {
    return i(a(s, o), c);
  }, delete r.unshift, delete r.unshiftAsync, r;
}
function ape(t, e) {
  if (e = hn(e), !Array.isArray(t))
    return e(new TypeError("First argument to race must be an array of functions"));
  if (!t.length)
    return e();
  for (var r = 0, n = t.length; r < n; r++)
    ke(t[r])(e);
}
var m$ = Ie(ape, 2);
function pc(t, e, r, n) {
  var i = [...t].reverse();
  return an(i, e, r, n);
}
function fc(t) {
  var e = ke(t);
  return Es(function(n, i) {
    return n.push((a, ...s) => {
      let o = {};
      if (a && (o.error = a), s.length > 0) {
        var c = s;
        s.length <= 1 && ([c] = s), o.value = c;
      }
      i(null, o);
    }), e.apply(this, n);
  });
}
function g$(t) {
  var e;
  return Array.isArray(t) ? e = t.map(fc) : (e = {}, Object.keys(t).forEach((r) => {
    e[r] = fc.call(this, t[r]);
  })), e;
}
function sy(t, e, r, n) {
  const i = ke(r);
  return Au(t, e, (a, s) => {
    i(a, (o, c) => {
      s(o, !c);
    });
  }, n);
}
function spe(t, e, r) {
  return sy(Mt, t, e, r);
}
var v$ = Ie(spe, 3);
function ope(t, e, r, n) {
  return sy(or(e), t, r, n);
}
var y$ = Ie(ope, 4);
function cpe(t, e, r) {
  return sy(er, t, e, r);
}
var b$ = Ie(cpe, 3);
function w$(t) {
  return function() {
    return t;
  };
}
const vg = 5, x$ = 0;
function hc(t, e, r) {
  var n = {
    times: vg,
    intervalFunc: w$(x$)
  };
  if (arguments.length < 3 && typeof t == "function" ? (r = e || _i(), e = t) : (upe(n, t), r = r || _i()), typeof e != "function")
    throw new Error("Invalid arguments for async.retry");
  var i = ke(e), a = 1;
  function s() {
    i((o, ...c) => {
      o !== !1 && (o && a++ < n.times && (typeof n.errorFilter != "function" || n.errorFilter(o)) ? setTimeout(s, n.intervalFunc(a - 1)) : r(o, ...c));
    });
  }
  return s(), r[Ki];
}
function upe(t, e) {
  if (typeof e == "object")
    t.times = +e.times || vg, t.intervalFunc = typeof e.interval == "function" ? e.interval : w$(+e.interval || x$), t.errorFilter = e.errorFilter;
  else if (typeof e == "number" || typeof e == "string")
    t.times = +e || vg;
  else
    throw new Error("Invalid arguments for async.retry");
}
function _$(t, e) {
  e || (e = t, t = null);
  let r = t && t.arity || e.length;
  Ss(e) && (r += 1);
  var n = ke(e);
  return Es((i, a) => {
    (i.length < r - 1 || a == null) && (i.push(a), a = _i());
    function s(o) {
      n(...i, o);
    }
    return t ? hc(t, s, a) : hc(s, a), a[Ki];
  });
}
function E$(t, e) {
  return iy(er, t, e);
}
function lpe(t, e, r) {
  return Br(Boolean, (n) => n)(Mt, t, e, r);
}
var dc = Ie(lpe, 3);
function ppe(t, e, r, n) {
  return Br(Boolean, (i) => i)(or(e), t, r, n);
}
var mc = Ie(ppe, 4);
function fpe(t, e, r) {
  return Br(Boolean, (n) => n)(er, t, e, r);
}
var gc = Ie(fpe, 3);
function hpe(t, e, r) {
  var n = ke(e);
  return Ou(t, (a, s) => {
    n(a, (o, c) => {
      if (o)
        return s(o);
      s(o, { value: a, criteria: c });
    });
  }, (a, s) => {
    if (a)
      return r(a);
    r(null, s.sort(i).map((o) => o.value));
  });
  function i(a, s) {
    var o = a.criteria, c = s.criteria;
    return o < c ? -1 : o > c ? 1 : 0;
  }
}
var S$ = Ie(hpe, 3);
function C$(t, e, r) {
  var n = ke(t);
  return Es((i, a) => {
    var s = !1, o;
    function c() {
      var f = t.name || "anonymous", u = new Error('Callback function "' + f + '" timed out.');
      u.code = "ETIMEDOUT", r && (u.info = r), s = !0, a(u);
    }
    i.push((...f) => {
      s || (a(...f), clearTimeout(o));
    }), o = setTimeout(c, e), n(...i);
  });
}
function dpe(t) {
  for (var e = Array(t); t--; )
    e[t] = t;
  return e;
}
function ku(t, e, r, n) {
  var i = ke(r);
  return Cs(dpe(t), e, i, n);
}
function T$(t, e, r) {
  return ku(t, 1 / 0, e, r);
}
function O$(t, e, r) {
  return ku(t, 1, e, r);
}
function A$(t, e, r, n) {
  arguments.length <= 3 && typeof e == "function" && (n = r, r = e, e = Array.isArray(t) ? [] : {}), n = hn(n || _i());
  var i = ke(r);
  return Mt(t, (a, s, o) => {
    i(e, a, s, o);
  }, (a) => n(a, e)), n[Ki];
}
function mpe(t, e) {
  var r = null, n;
  return Xa(t, (i, a) => {
    ke(i)((s, ...o) => {
      if (s === !1)
        return a(s);
      o.length < 2 ? [n] = o : n = o, r = s, a(s ? null : {});
    });
  }, () => e(r, n));
}
var $$ = Ie(mpe);
function I$(t) {
  return (...e) => (t.unmemoized || t)(...e);
}
function gpe(t, e, r) {
  r = dn(r);
  var n = ke(e), i = ke(t), a = [];
  function s(c, ...f) {
    if (c)
      return r(c);
    a = f, c !== !1 && i(o);
  }
  function o(c, f) {
    if (c)
      return r(c);
    if (c !== !1) {
      if (!f)
        return r(null, ...a);
      n(s);
    }
  }
  return i(o);
}
var Za = Ie(gpe, 3);
function k$(t, e, r) {
  const n = ke(t);
  return Za((i) => n((a, s) => i(a, !s)), e, r);
}
function vpe(t, e) {
  if (e = hn(e), !Array.isArray(t))
    return e(new Error("First argument to waterfall must be an array of functions"));
  if (!t.length)
    return e();
  var r = 0;
  function n(a) {
    var s = ke(t[r++]);
    s(...a, dn(i));
  }
  function i(a, ...s) {
    if (a !== !1) {
      if (a || r === t.length)
        return e(a, ...s);
      n(s);
    }
  }
  n([]);
}
var R$ = Ie(vpe), ype = {
  apply: B4,
  applyEach: Q4,
  applyEachSeries: V4,
  asyncify: Va,
  auto: ey,
  autoInject: K4,
  cargo: J4,
  cargoQueue: X4,
  compose: Z4,
  concat: Yo,
  concatLimit: Ei,
  concatSeries: ec,
  constant: Y4,
  detect: tc,
  detectLimit: rc,
  detectSeries: nc,
  dir: t$,
  doUntil: r$,
  doWhilst: Ka,
  each: ic,
  eachLimit: Ja,
  eachOf: Mt,
  eachOfLimit: xi,
  eachOfSeries: er,
  eachSeries: Xa,
  ensureAsync: ny,
  every: ac,
  everyLimit: sc,
  everySeries: oc,
  filter: cc,
  filterLimit: uc,
  filterSeries: lc,
  forever: i$,
  groupBy: a$,
  groupByLimit: $u,
  groupBySeries: s$,
  log: o$,
  map: Ou,
  mapLimit: Cs,
  mapSeries: Yv,
  mapValues: c$,
  mapValuesLimit: Iu,
  mapValuesSeries: u$,
  memoize: l$,
  nextTick: p$,
  parallel: f$,
  parallelLimit: h$,
  priorityQueue: d$,
  queue: ay,
  race: m$,
  reduce: an,
  reduceRight: pc,
  reflect: fc,
  reflectAll: g$,
  reject: v$,
  rejectLimit: y$,
  rejectSeries: b$,
  retry: hc,
  retryable: _$,
  seq: ry,
  series: E$,
  setImmediate: nn,
  some: dc,
  someLimit: mc,
  someSeries: gc,
  sortBy: S$,
  timeout: C$,
  times: T$,
  timesLimit: ku,
  timesSeries: O$,
  transform: A$,
  tryEach: $$,
  unmemoize: I$,
  until: k$,
  waterfall: R$,
  whilst: Za,
  // aliases
  all: ac,
  allLimit: sc,
  allSeries: oc,
  any: dc,
  anyLimit: mc,
  anySeries: gc,
  find: tc,
  findLimit: rc,
  findSeries: nc,
  flatMap: Yo,
  flatMapLimit: Ei,
  flatMapSeries: ec,
  forEach: ic,
  forEachSeries: Xa,
  forEachLimit: Ja,
  forEachOf: Mt,
  forEachOfSeries: er,
  forEachOfLimit: xi,
  inject: an,
  foldl: an,
  foldr: pc,
  select: cc,
  selectLimit: uc,
  selectSeries: lc,
  wrapSync: Va,
  during: Za,
  doDuring: Ka
};
const bpe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  all: ac,
  allLimit: sc,
  allSeries: oc,
  any: dc,
  anyLimit: mc,
  anySeries: gc,
  apply: B4,
  applyEach: Q4,
  applyEachSeries: V4,
  asyncify: Va,
  auto: ey,
  autoInject: K4,
  cargo: J4,
  cargoQueue: X4,
  compose: Z4,
  concat: Yo,
  concatLimit: Ei,
  concatSeries: ec,
  constant: Y4,
  default: ype,
  detect: tc,
  detectLimit: rc,
  detectSeries: nc,
  dir: t$,
  doDuring: Ka,
  doUntil: r$,
  doWhilst: Ka,
  during: Za,
  each: ic,
  eachLimit: Ja,
  eachOf: Mt,
  eachOfLimit: xi,
  eachOfSeries: er,
  eachSeries: Xa,
  ensureAsync: ny,
  every: ac,
  everyLimit: sc,
  everySeries: oc,
  filter: cc,
  filterLimit: uc,
  filterSeries: lc,
  find: tc,
  findLimit: rc,
  findSeries: nc,
  flatMap: Yo,
  flatMapLimit: Ei,
  flatMapSeries: ec,
  foldl: an,
  foldr: pc,
  forEach: ic,
  forEachLimit: Ja,
  forEachOf: Mt,
  forEachOfLimit: xi,
  forEachOfSeries: er,
  forEachSeries: Xa,
  forever: i$,
  groupBy: a$,
  groupByLimit: $u,
  groupBySeries: s$,
  inject: an,
  log: o$,
  map: Ou,
  mapLimit: Cs,
  mapSeries: Yv,
  mapValues: c$,
  mapValuesLimit: Iu,
  mapValuesSeries: u$,
  memoize: l$,
  nextTick: p$,
  parallel: f$,
  parallelLimit: h$,
  priorityQueue: d$,
  queue: ay,
  race: m$,
  reduce: an,
  reduceRight: pc,
  reflect: fc,
  reflectAll: g$,
  reject: v$,
  rejectLimit: y$,
  rejectSeries: b$,
  retry: hc,
  retryable: _$,
  select: cc,
  selectLimit: uc,
  selectSeries: lc,
  seq: ry,
  series: E$,
  setImmediate: nn,
  some: dc,
  someLimit: mc,
  someSeries: gc,
  sortBy: S$,
  timeout: C$,
  times: T$,
  timesLimit: ku,
  timesSeries: O$,
  transform: A$,
  tryEach: $$,
  unmemoize: I$,
  until: k$,
  waterfall: R$,
  whilst: Za,
  wrapSync: Va
}, Symbol.toStringTag, { value: "Module" })), N$ = /* @__PURE__ */ p2(bpe);
var I_ = se, wpe = se, xpe = N$;
function L$(t, e, r) {
  var n, i;
  r ? (n = r, i = e) : (n = e, i = null), I_.lstat(t, function(s, o) {
    var c = s ? 0 : o.size || 0;
    !s && o.isDirectory() ? I_.readdir(t, function(u, l) {
      if (u)
        return n(u);
      xpe.forEach(
        l,
        function(m, h) {
          L$(
            wpe.join(t, m),
            i,
            function(v, d) {
              v || (c += d), h(v);
            }
          );
        },
        function(m) {
          n(m, c);
        }
      );
    }) : (i && i.test(t) && (c = 0), n(s, c));
  });
}
var _pe = L$, k_ = se, ui = se, Epe = se, P$ = function(t, e, r) {
  var n = k_.readdirSync(t), i = [];
  return n.forEach(function(a) {
    var s = k_.statSync(ui.join(t, a)).isDirectory();
    if (s) {
      var o = ui.join(t, a);
      P$(o, e, function(u) {
        i = i.concat(u);
      });
    } else {
      var c = ui.join(t, a), f = ui.extname(a);
      e ? f !== ".xsd" && f !== ".dtd" && a !== "metadata.xml" && a !== "imsmanifest.xml" && i.push(c) : i.push(c);
    }
  }), r(i);
}, Spe = function(t, e) {
  var r = [];
  return t = ui.normalize(t), P$(t, e, function(n) {
    n.forEach(function(i) {
      i = i.split(t + ui.sep)[1] || i, r.push(Epe.format(i));
    });
  }), r;
}, D$ = Spe, R_ = se, ci = /* @__PURE__ */ new Date(), M$ = ci.getTime(), Cpe = function() {
  return ci.setDate(ci.getDate()), ci.getFullYear() + "-" + ("0" + (ci.getMonth() + 1)).slice(-2) + "-" + ("0" + ci.getDate()).slice(-2);
}, io = function(t) {
  if (t instanceof Array)
    return t;
  if (typeof t == "string") {
    var e = [];
    return t && e.push(t), e;
  } else {
    var r = [];
    for (var n in t)
      t[n] && r.push(t[n]);
    return r;
  }
}, Tpe = function() {
  var t = M$, e = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(r) {
    var n = (t + Math.random() * 16) % 16 | 0;
    return t = Math.floor(t / 16), (r == "x" ? n : n & 3 | 8).toString(16);
  });
  return e;
}, q$ = function(t) {
  return t.package || (t.package = {}), t.package.vcard || (t.package.vcard = {}), {
    uuid: t.uuid || Tpe(),
    version: t.version || "1.2",
    language: t.language || "en",
    organization: t.organization || "",
    title: t.title || "",
    identifier: t.identifier,
    masteryScore: t.masteryScore != null ? t.masteryScore : 80,
    startingPage: t.startingPage || "index.html",
    package: {
      name: t.package.name || t.title || "",
      author: t.package.author || "",
      description: t.package.description || t.description || "",
      organization: t.package.organization || t.organization || "",
      date: t.package.date || Cpe(),
      timestamp: M$,
      size: t.package.size || "",
      version: t.package.version || process.env.npm_package_version || "1.0.0",
      outputFolder: t.package.outputFolder || "./scorm",
      duration: t.package.duration || "PT0H0M0S",
      typicalDuration: t.package.typicalDuration || t.package.duration || "PT0H0M0S",
      educational: t.package.educational || t.package.description || t.description || "",
      rights: t.package.rights || ` ${t.organization || ""}. All rights reserved.`,
      requirements: t.package.requirements || [],
      keywords: io(t.package.keywords || ""),
      status: t.package.status || "final",
      vcard: {
        version: t.package.vcard.version || t.package.version || process.env.npm_package_version || "1.0.0",
        author: t.package.vcard.author || t.package.author || "",
        org: t.package.vcard.org || t.package.organization || t.organization || "",
        tel: io(t.package.vcard.tel || ""),
        address: io(t.package.vcard.address || ""),
        mail: io(t.package.vcard.mail || ""),
        url: t.package.vcard.url || ""
      },
      zip: t.package.zip,
      appendTimeToOutput: typeof t.package.appendTimeToOutput == "boolean" ? t.package.appendTimeToOutput : !1
    },
    source: t.source ? R_.normalize(t.source) : R_.normalize("./")
  };
}, j$ = {
  cleanAndTrim: function(t) {
    var e = t.replace(/[^\p{L}0-9]+/gu, "");
    return e.replace(/\s/g, "");
  },
  acronym: function(t) {
    if (!t)
      return "";
    var e = function(r) {
      return r ? r[0] : "";
    };
    return t.split(" ").map(e).join("");
  },
  uuid: function() {
    var t = /* @__PURE__ */ new Date(), e = t.getTime(), r = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(
      /[xy]/g,
      function(n) {
        var i = (e + Math.random() * 16) % 16 | 0;
        return e = Math.floor(e / 16), (n == "x" ? i : i & 3 | 8).toString(16);
      }
    );
    return r;
  }
}, th = j$, oy = function(t) {
  var e = th.acronym(t.package.author || "c o m"), r = th.cleanAndTrim(t.package.organization || "company"), n = th.cleanAndTrim(t.title, "");
  return e + "." + r + "." + n + "." + t.uuid;
}, Ope = oy, $r = `\r
`, oa = function(t, r) {
  var r = r || {}, n = "BEGIN:VCARD" + $r;
  return n += "VERSION:2.1" + $r, t && (t.author && (n += "FN:" + t.author + $r), t.version && !r.version && (n += "NOTE:version " + t.version + " " + $r), t.org && !r.org && (n += "ORG:" + t.org + $r), t.tel && !r.tel && t.tel.length > 0 && (n += "TEL;WORK;VOICE:" + t.tel.join(";") + $r), t.address && !r.address && t.address.length > 0 && (n += "ADR;WORK:;;" + t.address.join(";") + $r), t.mail && !r.mail && t.mail.length > 0 && (n += "EMAIL;PREF;INTERNET:" + t.mail.join(";") + $r), t.url && !r.url && (n += "URL:" + t.url + $r)), n += "END:VCARD  ", n;
}, Ape = function(t) {
  let e = [];
  if (t.length)
    for (var r = 0, n = t.length; r < n; r += 1) {
      var i = t[r];
      if (i.type && i.name) {
        var a = {
          type: {
            source: {
              "#text": "LOMv1.0"
            },
            value: {
              "#cdata": i.type
            }
          },
          name: {
            source: {
              "#text": "LOMv1.0"
            },
            value: {
              "#cdata": i.name
            }
          },
          minimumversion: {
            "#cdata": i.version || ""
          }
        };
        e.push(a);
      }
    }
  return e;
}, $pe = function(t, e) {
  let r = [];
  for (var n = 0, i = t.length; n < i; n += 1)
    r.push({
      string: {
        "@language": e,
        "#cdata": t[n]
      }
    });
  return r;
}, Ipe = function(t) {
  var e = t.package.name, r = Ope(t);
  return {
    "@xmlns": "http://ltsc.ieee.org/xsd/LOM",
    "@xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance",
    "@xmlns:pkgprop": "http://www.scorm.com/xsd/ScormEnginePackageProperties",
    "@xsi:schemaLocation": "http://ltsc.ieee.org/xsd/LOM lomLoose.xsd http://www.scorm.com/xsd/ScormEnginePackageProperties ScormEnginePackageProperties.xsd",
    metametadata: {
      metadataSchema: ["LOMv1.0", "ADL SCORM " + t.version],
      identifier: {
        catalog: "URI",
        entry: r
      },
      language: {
        "#text": t.language
      },
      contribute: {
        role: {
          source: {
            "#text": "LOMv1.0"
          },
          value: {
            "#text": "Creator"
          }
        },
        entity: {
          "#cdata": oa(t.package.vcard, {
            version: !0
          })
        },
        date: {
          dateTime: t.package.date,
          description: {
            "@language": t.language,
            "#cdata": t.package.timestamp
          }
        }
      }
    },
    general: {
      identifier: {
        catalog: "URI",
        entry: r
      },
      title: {
        string: {
          "@language": t.language,
          "#cdata": e
        }
      },
      language: {
        "#text": t.language
      },
      description: {
        string: {
          "@language": t.language,
          "#cdata": t.package.description
        }
      },
      structure: {
        source: {
          "#text": "LOMv1.0"
        },
        value: {
          "#text": "atomic"
        }
      },
      aggregationLevel: {
        source: {
          "#text": "LOMv1.0"
        },
        value: {
          "#text": "1"
        }
      },
      keyword: $pe(t.package.keywords, t.language)
    },
    lifeCycle: {
      version: {
        string: {
          "@language": t.language,
          "#text": t.package.version
        }
      },
      status: {
        source: "LOMv1.0",
        value: t.package.status
      },
      contribute: [
        {
          entity: {
            "#cdata": oa(t.package.vcard, {
              version: !0
            })
          },
          date: {
            dateTime: t.package.date,
            description: {
              "@language": t.language,
              "#cdata": t.package.timestamp
            }
          }
        },
        {
          role: {
            source: {
              "#text": "LOMv1.0"
            },
            value: {
              "#text": "Author"
            }
          },
          entity: {
            "#cdata": oa(t.package.vcard, {
              version: !0
            })
          },
          date: {
            dateTime: t.package.date,
            description: {
              "@language": t.language,
              "#cdata": t.package.timestamp
            }
          }
        },
        {
          role: {
            source: {
              "#text": "LOMv1.0"
            },
            value: {
              "#text": "Publisher"
            }
          },
          entity: {
            "#cdata": oa(t.package.vcard)
          },
          date: {
            dateTime: t.package.date,
            description: {
              "@language": t.language,
              "#cdata": t.package.timestamp
            }
          }
        },
        {
          role: {
            source: {
              "#text": "LOMv1.0"
            },
            value: {
              "#text": "Technical Implementer"
            }
          },
          entity: {
            "#cdata": oa(t.package.vcard, {
              version: !0
            })
          },
          date: {
            dateTime: t.package.date,
            description: {
              "@language": t.language,
              "#cdata": t.package.timestamp
            }
          }
        }
      ]
    },
    technical: {
      format: ["text/html", "application/x-javascript", "text/css"],
      size: t.package.size,
      location: t.startingPage,
      requirement: Ape(t.package.requirements),
      duration: {
        duration: t.package.duration,
        description: {
          string: {
            "@language": t.language,
            "#cdata": "The time it will take to watch the entire module from start to finish."
          }
        }
      },
      "pkgprop:ScormEnginePackageProperties": {
        "@xmlns": "http://www.scorm.com/xsd/ScormEnginePackageProperties",
        appearance: {
          displayStage: {
            desired: {
              width: 1280,
              height: 720,
              fullscreen: "yes"
            },
            required: {
              width: 300,
              height: 300,
              fullscreen: "no"
            }
          }
        },
        behavior: {
          alwaysFlowToFirstSco: "yes",
          rollupEmptySetToUnknown: "yes"
        }
      }
    },
    educational: {
      typicalLearningTime: {
        duration: t.package.typicalDuration,
        description: {
          string: {
            "@language": t.language,
            "#cdata": "The average time for a learner to complete this course."
          }
        }
      },
      description: {
        string: {
          "#cdata": t.package.educational
        }
      },
      language: {
        "#text": t.language
      }
    },
    rights: {
      copyrightAndOtherRestrictions: {
        source: "LOMv1.0",
        value: "no"
      },
      description: {
        string: {
          "@language": t.language,
          "#cdata": t.package.rights
        }
      }
    }
  };
}, kpe = oy, Rpe = function(t) {
  var e = kpe(t), r = "item_" + e, n = "resource_" + e, i = t.organization.replace(/ /g, "_");
  if (t.identifier && t.identifier.trim()) {
    var a = t.identifier.replace(/ /g, "");
    e = a, r = "item_" + a, n = "resource_" + a;
  }
  return {
    "@identifier": e,
    "@version": 1,
    "@xmlns:adlcp": "http://www.adlnet.org/xsd/adlcp_rootv1p2",
    "@xmlns": "http://www.imsproject.org/xsd/imscp_rootv1p1p2",
    "@xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance",
    "@xsi:schemaLocation": "http://www.imsproject.org/xsd/imscp_rootv1p1p2 imscp_rootv1p1p2.xsd http://www.imsglobal.org/xsd/imsmd_rootv1p2p1 imsmd_rootv1p2p1.xsd http://www.adlnet.org/xsd/adlcp_rootv1p2 adlcp_rootv1p2.xsd",
    metadata: {
      schema: "ADL SCORM",
      schemaversion: t.version,
      "adlcp:location": "metadata.xml"
    },
    organizations: {
      "@default": i,
      organization: {
        "@identifier": i,
        title: t.title,
        item: {
          "@identifier": r,
          "@identifierref": n,
          title: t.title,
          "adlcp:masteryscore": t.masteryScore,
          metadata: {
            schema: "ADL SCORM",
            schemaversion: t.version,
            "adlcp:location": "metadata.xml"
          }
        },
        metadata: {
          schema: "ADL SCORM",
          schemaversion: t.version,
          "adlcp:location": "metadata.xml"
        }
      }
    },
    resources: {
      metadata: {
        schema: "ADL SCORM",
        schemaversion: t.version,
        "adlcp:location": "metadata.xml"
      },
      resource: {
        "@identifier": n,
        "@type": "webcontent",
        "@href": t.startingPage,
        "@adlcp:scormtype": "sco",
        metadata: {
          schema: "ADL SCORM",
          schemaversion: t.version,
          "adlcp:location": "metadata.xml"
        },
        file: t.files
      }
    }
  };
}, Npe = oy, Lpe = function(t) {
  var e = Npe(t), r = "item_" + e, n = "resource_" + e, i = t.organization.replace(/ /g, "_");
  if (t.identifier && t.identifier.trim()) {
    var a = t.identifier.replace(/ /g, "");
    e = a, r = "item_" + a, n = "resource_" + a;
  }
  return {
    "@identifier": e,
    "@version": 1,
    "@xmlns:adlnav": "http://www.adlnet.org/xsd/adlnav_v1p3",
    "@xmlns": "http://www.imsglobal.org/xsd/imscp_v1p1",
    "@xmlns:adlseq": "http://www.adlnet.org/xsd/adlseq_v1p3",
    "@xmlns:imsss": "http://www.imsglobal.org/xsd/imsss",
    "@xmlns:adlcp": "http://www.adlnet.org/xsd/adlcp_v1p3",
    "@xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance",
    "@xsi:schemaLocation": "http://www.imsglobal.org/xsd/imscp_v1p1 imscp_v1p1.xsd http://www.adlnet.org/xsd/adlcp_v1p3 adlcp_v1p3.xsd http://www.adlnet.org/xsd/adlseq_v1p3 adlseq_v1p3.xsd http://www.adlnet.org/xsd/adlnav_v1p3 adlnav_v1p3.xsd http://www.imsglobal.org/xsd/imsss imsss_v1p0.xsd",
    metadata: {
      schema: "ADL SCORM",
      schemaversion: t.version,
      "adlcp:location": "metadata.xml"
    },
    organizations: {
      "@default": i,
      organization: {
        "@identifier": i,
        title: t.title,
        item: {
          "@identifier": r,
          "@identifierref": n,
          title: t.title,
          "imsss:sequencing": {
            "imsss:objectives": {
              "imsss:primaryObjective": {
                "@objectiveID": "PRIMARYOBJ",
                "@satisfiedByMeasure": "true",
                "imsss:minNormalizedMeasure": t.masteryScore / 100
              }
            },
            "imsss:deliveryControls": {
              "@completionSetByContent": "true",
              "@objectiveSetByContent": "true"
            }
          },
          metadata: {
            schema: "ADL SCORM",
            schemaversion: t.version,
            "adlcp:location": "metadata.xml"
          }
        },
        metadata: {
          schema: "ADL SCORM",
          schemaversion: t.version,
          "adlcp:location": "metadata.xml"
        },
        "imsss:sequencing": {
          "imsss:controlMode": {
            "@choice": "true",
            "@flow": "true"
          }
        }
      }
    },
    resources: {
      metadata: {
        schema: "ADL SCORM",
        schemaversion: t.version,
        "adlcp:location": "metadata.xml"
      },
      resource: {
        "@identifier": n,
        "@type": "webcontent",
        "@href": t.startingPage,
        "@adlcp:scormType": "sco",
        metadata: {
          schema: "ADL SCORM",
          schemaversion: t.version,
          "adlcp:location": "metadata.xml"
        },
        file: t.files
      }
    }
  };
}, F$ = {
  config: q$,
  metadata: Ipe,
  scorm12: Rpe,
  scorm2004: Lpe
}, Rr = {}, Ir = {}, N_;
function Ur() {
  return N_ || (N_ = 1, function() {
    var t, e, r, n, i, a, s, o = {}.hasOwnProperty;
    t = function(c, ...f) {
      var u, l, p, m;
      if (i(Object.assign))
        Object.assign.apply(null, arguments);
      else
        for (u = 0, p = f.length; u < p; u++)
          if (m = f[u], m != null)
            for (l in m)
              o.call(m, l) && (c[l] = m[l]);
      return c;
    }, i = function(c) {
      return !!c && Object.prototype.toString.call(c) === "[object Function]";
    }, a = function(c) {
      var f;
      return !!c && ((f = typeof c) == "function" || f === "object");
    }, r = function(c) {
      return i(Array.isArray) ? Array.isArray(c) : Object.prototype.toString.call(c) === "[object Array]";
    }, n = function(c) {
      var f;
      if (r(c))
        return !c.length;
      for (f in c)
        if (o.call(c, f))
          return !1;
      return !0;
    }, s = function(c) {
      var f, u;
      return a(c) && (u = Object.getPrototypeOf(c)) && (f = u.constructor) && typeof f == "function" && f instanceof f && Function.prototype.toString.call(f) === Function.prototype.toString.call(Object);
    }, e = function(c) {
      return i(c.valueOf) ? c.valueOf() : c;
    }, Ir.assign = t, Ir.isFunction = i, Ir.isObject = a, Ir.isArray = r, Ir.isEmpty = n, Ir.isPlainObject = s, Ir.getValue = e;
  }.call(ve)), Ir;
}
var rh = { exports: {} }, L_;
function B$() {
  return L_ || (L_ = 1, function() {
    rh.exports = class {
      // Tests if the DOM implementation implements a specific feature.
      // `feature` package name of the feature to test. In Level 1, the
      //           legal values are "HTML" and "XML" (case-insensitive).
      // `version` version number of the package name to test. 
      //           In Level 1, this is the string "1.0". If the version is 
      //           not specified, supporting any version of the feature will 
      //           cause the method to return true.
      hasFeature(e, r) {
        return !0;
      }
      // Creates a new document type declaration.
      // `qualifiedName` qualified name of the document type to be created
      // `publicId` public identifier of the external subset
      // `systemId` system identifier of the external subset
      createDocumentType(e, r, n) {
        throw new Error("This DOM method is not implemented.");
      }
      // Creates a new document.
      // `namespaceURI` namespace URI of the document element to create
      // `qualifiedName` the qualified name of the document to be created
      // `doctype` the type of document to be created or null
      createDocument(e, r, n) {
        throw new Error("This DOM method is not implemented.");
      }
      // Creates a new HTML document.
      // `title` document title
      createHTMLDocument(e) {
        throw new Error("This DOM method is not implemented.");
      }
      // Returns a specialized object which implements the specialized APIs 
      // of the specified feature and version.
      // `feature` name of the feature requested.
      // `version` version number of the feature to test
      getFeature(e, r) {
        throw new Error("This DOM method is not implemented.");
      }
    };
  }.call(ve)), rh.exports;
}
var nh = { exports: {} }, ih = { exports: {} }, ah = { exports: {} }, P_;
function Ppe() {
  return P_ || (P_ = 1, function() {
    ah.exports = class {
      // Initializes a new instance of `XMLDOMErrorHandler`
      constructor() {
      }
      // Called on the error handler when an error occurs.
      // `error` the error message as a string
      handleError(e) {
        throw new Error(e);
      }
    };
  }.call(ve)), ah.exports;
}
var sh = { exports: {} }, D_;
function Dpe() {
  return D_ || (D_ = 1, function() {
    sh.exports = function() {
      class t {
        // Initializes a new instance of `XMLDOMStringList`
        // This is just a wrapper around an ordinary
        // JS array.
        // `arr` the array of string values
        constructor(r) {
          this.arr = r || [];
        }
        // Returns the indexth item in the collection.
        // `index` index into the collection
        item(r) {
          return this.arr[r] || null;
        }
        // Test if a string is part of this DOMStringList.
        // `str` the string to look for
        contains(r) {
          return this.arr.indexOf(r) !== -1;
        }
      }
      return Object.defineProperty(t.prototype, "length", {
        get: function() {
          return this.arr.length;
        }
      }), t;
    }.call(this);
  }.call(ve)), sh.exports;
}
var M_;
function Mpe() {
  return M_ || (M_ = 1, function() {
    var t, e;
    t = Ppe(), e = Dpe(), ih.exports = function() {
      class r {
        constructor() {
          this.defaultParams = {
            "canonical-form": !1,
            "cdata-sections": !1,
            comments: !1,
            "datatype-normalization": !1,
            "element-content-whitespace": !0,
            entities: !0,
            "error-handler": new t(),
            infoset: !0,
            "validate-if-schema": !1,
            namespaces: !0,
            "namespace-declarations": !0,
            "normalize-characters": !1,
            "schema-location": "",
            "schema-type": "",
            "split-cdata-sections": !0,
            validate: !1,
            "well-formed": !0
          }, this.params = Object.create(this.defaultParams);
        }
        // Gets the value of a parameter.
        // `name` name of the parameter
        getParameter(i) {
          return this.params.hasOwnProperty(i) ? this.params[i] : null;
        }
        // Checks if setting a parameter to a specific value is supported.
        // `name` name of the parameter
        // `value` parameter value
        canSetParameter(i, a) {
          return !0;
        }
        // Sets the value of a parameter.
        // `name` name of the parameter
        // `value` new value or null if the user wishes to unset the parameter
        setParameter(i, a) {
          return a != null ? this.params[i] = a : delete this.params[i];
        }
      }
      return Object.defineProperty(r.prototype, "parameterNames", {
        get: function() {
          return new e(Object.keys(this.defaultParams));
        }
      }), r;
    }.call(this);
  }.call(ve)), ih.exports;
}
var oh = { exports: {} }, ch = { exports: {} }, uh = { exports: {} }, q_;
function ot() {
  return q_ || (q_ = 1, function() {
    uh.exports = {
      Element: 1,
      Attribute: 2,
      Text: 3,
      CData: 4,
      EntityReference: 5,
      EntityDeclaration: 6,
      ProcessingInstruction: 7,
      Comment: 8,
      Document: 9,
      DocType: 10,
      DocumentFragment: 11,
      NotationDeclaration: 12,
      // Numeric codes up to 200 are reserved to W3C for possible future use.
      // Following are types internal to this library:
      Declaration: 201,
      Raw: 202,
      AttributeDeclaration: 203,
      ElementDeclaration: 204,
      Dummy: 205
    };
  }.call(ve)), uh.exports;
}
var lh = { exports: {} }, j_;
function U$() {
  return j_ || (j_ = 1, function() {
    var t;
    t = ot(), Gt(), lh.exports = function() {
      class e {
        // Initializes a new instance of `XMLAttribute`
        // `parent` the parent node
        // `name` attribute target
        // `value` attribute value
        constructor(n, i, a) {
          if (this.parent = n, this.parent && (this.options = this.parent.options, this.stringify = this.parent.stringify), i == null)
            throw new Error("Missing attribute name. " + this.debugInfo(i));
          this.name = this.stringify.name(i), this.value = this.stringify.attValue(a), this.type = t.Attribute, this.isId = !1, this.schemaTypeInfo = null;
        }
        // Creates and returns a deep clone of `this`
        clone() {
          return Object.create(this);
        }
        // Converts the XML fragment to string
        // `options.pretty` pretty prints the result
        // `options.indent` indentation for pretty print
        // `options.offset` how many indentations to add to every line for pretty print
        // `options.newline` newline sequence for pretty print
        toString(n) {
          return this.options.writer.attribute(this, this.options.writer.filterOptions(n));
        }
        // Returns debug string for this node
        debugInfo(n) {
          return n = n || this.name, n == null ? "parent: <" + this.parent.name + ">" : "attribute: {" + n + "}, parent: <" + this.parent.name + ">";
        }
        isEqualNode(n) {
          return !(n.namespaceURI !== this.namespaceURI || n.prefix !== this.prefix || n.localName !== this.localName || n.value !== this.value);
        }
      }
      return Object.defineProperty(e.prototype, "nodeType", {
        get: function() {
          return this.type;
        }
      }), Object.defineProperty(e.prototype, "ownerElement", {
        get: function() {
          return this.parent;
        }
      }), Object.defineProperty(e.prototype, "textContent", {
        get: function() {
          return this.value;
        },
        set: function(r) {
          return this.value = r || "";
        }
      }), Object.defineProperty(e.prototype, "namespaceURI", {
        get: function() {
          return "";
        }
      }), Object.defineProperty(e.prototype, "prefix", {
        get: function() {
          return "";
        }
      }), Object.defineProperty(e.prototype, "localName", {
        get: function() {
          return this.name;
        }
      }), Object.defineProperty(e.prototype, "specified", {
        get: function() {
          return !0;
        }
      }), e;
    }.call(this);
  }.call(ve)), lh.exports;
}
var ph = { exports: {} }, F_;
function cy() {
  return F_ || (F_ = 1, function() {
    ph.exports = function() {
      class t {
        // Initializes a new instance of `XMLNamedNodeMap`
        // This is just a wrapper around an ordinary
        // JS object.
        // `nodes` the object containing nodes.
        constructor(r) {
          this.nodes = r;
        }
        // Creates and returns a deep clone of `this`
        clone() {
          return this.nodes = null;
        }
        // DOM Level 1
        getNamedItem(r) {
          return this.nodes[r];
        }
        setNamedItem(r) {
          var n;
          return n = this.nodes[r.nodeName], this.nodes[r.nodeName] = r, n || null;
        }
        removeNamedItem(r) {
          var n;
          return n = this.nodes[r], delete this.nodes[r], n || null;
        }
        item(r) {
          return this.nodes[Object.keys(this.nodes)[r]] || null;
        }
        // DOM level 2 functions to be implemented later
        getNamedItemNS(r, n) {
          throw new Error("This DOM method is not implemented.");
        }
        setNamedItemNS(r) {
          throw new Error("This DOM method is not implemented.");
        }
        removeNamedItemNS(r, n) {
          throw new Error("This DOM method is not implemented.");
        }
      }
      return Object.defineProperty(t.prototype, "length", {
        get: function() {
          return Object.keys(this.nodes).length || 0;
        }
      }), t;
    }.call(this);
  }.call(ve)), ph.exports;
}
var B_;
function uy() {
  return B_ || (B_ = 1, function() {
    var t, e, r, n, i, a, s, o = {}.hasOwnProperty;
    ({ isObject: s, isFunction: a, getValue: i } = Ur()), n = Gt(), t = ot(), e = U$(), r = cy(), ch.exports = function() {
      class c extends n {
        // Initializes a new instance of `XMLElement`
        // `parent` the parent node
        // `name` element name
        // `attributes` an object containing name/value pairs of attributes
        constructor(u, l, p) {
          var m, h, g, v;
          if (super(u), l == null)
            throw new Error("Missing element name. " + this.debugInfo());
          if (this.name = this.stringify.name(l), this.type = t.Element, this.attribs = {}, this.schemaTypeInfo = null, p != null && this.attribute(p), u.type === t.Document && (this.isRoot = !0, this.documentObject = u, u.rootObject = this, u.children)) {
            for (v = u.children, h = 0, g = v.length; h < g; h++)
              if (m = v[h], m.type === t.DocType) {
                m.name = this.name;
                break;
              }
          }
        }
        // Creates and returns a deep clone of `this`
        clone() {
          var u, l, p, m;
          p = Object.create(this), p.isRoot && (p.documentObject = null), p.attribs = {}, m = this.attribs;
          for (l in m)
            o.call(m, l) && (u = m[l], p.attribs[l] = u.clone());
          return p.children = [], this.children.forEach(function(h) {
            var g;
            return g = h.clone(), g.parent = p, p.children.push(g);
          }), p;
        }
        // Adds or modifies an attribute
        // `name` attribute name
        // `value` attribute value
        attribute(u, l) {
          var p, m;
          if (u != null && (u = i(u)), s(u))
            for (p in u)
              o.call(u, p) && (m = u[p], this.attribute(p, m));
          else
            a(l) && (l = l.apply()), this.options.keepNullAttributes && l == null ? this.attribs[u] = new e(this, u, "") : l != null && (this.attribs[u] = new e(this, u, l));
          return this;
        }
        // Removes an attribute
        // `name` attribute name
        removeAttribute(u) {
          var l, p, m;
          if (u == null)
            throw new Error("Missing attribute name. " + this.debugInfo());
          if (u = i(u), Array.isArray(u))
            for (p = 0, m = u.length; p < m; p++)
              l = u[p], delete this.attribs[l];
          else
            delete this.attribs[u];
          return this;
        }
        // Converts the XML fragment to string
        // `options.pretty` pretty prints the result
        // `options.indent` indentation for pretty print
        // `options.offset` how many indentations to add to every line for pretty print
        // `options.newline` newline sequence for pretty print
        // `options.allowEmpty` do not self close empty element tags
        toString(u) {
          return this.options.writer.element(this, this.options.writer.filterOptions(u));
        }
        // Aliases
        att(u, l) {
          return this.attribute(u, l);
        }
        a(u, l) {
          return this.attribute(u, l);
        }
        // DOM Level 1
        getAttribute(u) {
          return this.attribs.hasOwnProperty(u) ? this.attribs[u].value : null;
        }
        setAttribute(u, l) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        getAttributeNode(u) {
          return this.attribs.hasOwnProperty(u) ? this.attribs[u] : null;
        }
        setAttributeNode(u) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        removeAttributeNode(u) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        getElementsByTagName(u) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        // DOM Level 2
        getAttributeNS(u, l) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        setAttributeNS(u, l, p) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        removeAttributeNS(u, l) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        getAttributeNodeNS(u, l) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        setAttributeNodeNS(u) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        getElementsByTagNameNS(u, l) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        hasAttribute(u) {
          return this.attribs.hasOwnProperty(u);
        }
        hasAttributeNS(u, l) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        // DOM Level 3
        setIdAttribute(u, l) {
          return this.attribs.hasOwnProperty(u) ? this.attribs[u].isId : l;
        }
        setIdAttributeNS(u, l, p) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        setIdAttributeNode(u, l) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        // DOM Level 4
        getElementsByTagName(u) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        getElementsByTagNameNS(u, l) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        getElementsByClassName(u) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        isEqualNode(u) {
          var l, p, m;
          if (!super.isEqualNode(u) || u.namespaceURI !== this.namespaceURI || u.prefix !== this.prefix || u.localName !== this.localName || u.attribs.length !== this.attribs.length)
            return !1;
          for (l = p = 0, m = this.attribs.length - 1; 0 <= m ? p <= m : p >= m; l = 0 <= m ? ++p : --p)
            if (!this.attribs[l].isEqualNode(u.attribs[l]))
              return !1;
          return !0;
        }
      }
      return Object.defineProperty(c.prototype, "tagName", {
        get: function() {
          return this.name;
        }
      }), Object.defineProperty(c.prototype, "namespaceURI", {
        get: function() {
          return "";
        }
      }), Object.defineProperty(c.prototype, "prefix", {
        get: function() {
          return "";
        }
      }), Object.defineProperty(c.prototype, "localName", {
        get: function() {
          return this.name;
        }
      }), Object.defineProperty(c.prototype, "id", {
        get: function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      }), Object.defineProperty(c.prototype, "className", {
        get: function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      }), Object.defineProperty(c.prototype, "classList", {
        get: function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      }), Object.defineProperty(c.prototype, "attributes", {
        get: function() {
          return (!this.attributeMap || !this.attributeMap.nodes) && (this.attributeMap = new r(this.attribs)), this.attributeMap;
        }
      }), c;
    }.call(this);
  }.call(ve)), ch.exports;
}
var fh = { exports: {} }, hh = { exports: {} }, U_;
function Ru() {
  return U_ || (U_ = 1, function() {
    var t;
    t = Gt(), hh.exports = function() {
      class e extends t {
        // Initializes a new instance of `XMLCharacterData`
        constructor(n) {
          super(n), this.value = "";
        }
        // Creates and returns a deep clone of `this`
        clone() {
          return Object.create(this);
        }
        // DOM level 1 functions to be implemented later
        substringData(n, i) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        appendData(n) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        insertData(n, i) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        deleteData(n, i) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        replaceData(n, i, a) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        isEqualNode(n) {
          return !(!super.isEqualNode(n) || n.data !== this.data);
        }
      }
      return Object.defineProperty(e.prototype, "data", {
        get: function() {
          return this.value;
        },
        set: function(r) {
          return this.value = r || "";
        }
      }), Object.defineProperty(e.prototype, "length", {
        get: function() {
          return this.value.length;
        }
      }), Object.defineProperty(e.prototype, "textContent", {
        get: function() {
          return this.value;
        },
        set: function(r) {
          return this.value = r || "";
        }
      }), e;
    }.call(this);
  }.call(ve)), hh.exports;
}
var z_;
function ly() {
  return z_ || (z_ = 1, function() {
    var t, e;
    t = ot(), e = Ru(), fh.exports = class extends e {
      // Initializes a new instance of `XMLCData`
      // `text` CDATA text
      constructor(n, i) {
        if (super(n), i == null)
          throw new Error("Missing CDATA text. " + this.debugInfo());
        this.name = "#cdata-section", this.type = t.CData, this.value = this.stringify.cdata(i);
      }
      // Creates and returns a deep clone of `this`
      clone() {
        return Object.create(this);
      }
      // Converts the XML fragment to string
      // `options.pretty` pretty prints the result
      // `options.indent` indentation for pretty print
      // `options.offset` how many indentations to add to every line for pretty print
      // `options.newline` newline sequence for pretty print
      toString(n) {
        return this.options.writer.cdata(this, this.options.writer.filterOptions(n));
      }
    };
  }.call(ve)), fh.exports;
}
var dh = { exports: {} }, H_;
function py() {
  return H_ || (H_ = 1, function() {
    var t, e;
    t = ot(), e = Ru(), dh.exports = class extends e {
      // Initializes a new instance of `XMLComment`
      // `text` comment text
      constructor(n, i) {
        if (super(n), i == null)
          throw new Error("Missing comment text. " + this.debugInfo());
        this.name = "#comment", this.type = t.Comment, this.value = this.stringify.comment(i);
      }
      // Creates and returns a deep clone of `this`
      clone() {
        return Object.create(this);
      }
      // Converts the XML fragment to string
      // `options.pretty` pretty prints the result
      // `options.indent` indentation for pretty print
      // `options.offset` how many indentations to add to every line for pretty print
      // `options.newline` newline sequence for pretty print
      toString(n) {
        return this.options.writer.comment(this, this.options.writer.filterOptions(n));
      }
    };
  }.call(ve)), dh.exports;
}
var mh = { exports: {} }, W_;
function fy() {
  return W_ || (W_ = 1, function() {
    var t, e, r;
    ({ isObject: r } = Ur()), e = Gt(), t = ot(), mh.exports = class extends e {
      // Initializes a new instance of `XMLDeclaration`
      // `parent` the document object
      // `version` A version number string, e.g. 1.0
      // `encoding` Encoding declaration, e.g. UTF-8
      // `standalone` standalone document declaration: true or false
      constructor(i, a, s, o) {
        super(i), r(a) && ({ version: a, encoding: s, standalone: o } = a), a || (a = "1.0"), this.type = t.Declaration, this.version = this.stringify.xmlVersion(a), s != null && (this.encoding = this.stringify.xmlEncoding(s)), o != null && (this.standalone = this.stringify.xmlStandalone(o));
      }
      // Converts to string
      // `options.pretty` pretty prints the result
      // `options.indent` indentation for pretty print
      // `options.offset` how many indentations to add to every line for pretty print
      // `options.newline` newline sequence for pretty print
      toString(i) {
        return this.options.writer.declaration(this, this.options.writer.filterOptions(i));
      }
    };
  }.call(ve)), mh.exports;
}
var gh = { exports: {} }, vh = { exports: {} }, G_;
function hy() {
  return G_ || (G_ = 1, function() {
    var t, e;
    e = Gt(), t = ot(), vh.exports = class extends e {
      // Initializes a new instance of `XMLDTDAttList`
      // `parent` the parent `XMLDocType` element
      // `elementName` the name of the element containing this attribute
      // `attributeName` attribute name
      // `attributeType` type of the attribute
      // `defaultValueType` default value type (either #REQUIRED, #IMPLIED,
      //                    #FIXED or #DEFAULT)
      // `defaultValue` default value of the attribute
      //                (only used for #FIXED or #DEFAULT)
      constructor(n, i, a, s, o, c) {
        if (super(n), i == null)
          throw new Error("Missing DTD element name. " + this.debugInfo());
        if (a == null)
          throw new Error("Missing DTD attribute name. " + this.debugInfo(i));
        if (!s)
          throw new Error("Missing DTD attribute type. " + this.debugInfo(i));
        if (!o)
          throw new Error("Missing DTD attribute default. " + this.debugInfo(i));
        if (o.indexOf("#") !== 0 && (o = "#" + o), !o.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/))
          throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. " + this.debugInfo(i));
        if (c && !o.match(/^(#FIXED|#DEFAULT)$/))
          throw new Error("Default value only applies to #FIXED or #DEFAULT. " + this.debugInfo(i));
        this.elementName = this.stringify.name(i), this.type = t.AttributeDeclaration, this.attributeName = this.stringify.name(a), this.attributeType = this.stringify.dtdAttType(s), c && (this.defaultValue = this.stringify.dtdAttDefault(c)), this.defaultValueType = o;
      }
      // Converts the XML fragment to string
      // `options.pretty` pretty prints the result
      // `options.indent` indentation for pretty print
      // `options.offset` how many indentations to add to every line for pretty print
      // `options.newline` newline sequence for pretty print
      toString(n) {
        return this.options.writer.dtdAttList(this, this.options.writer.filterOptions(n));
      }
    };
  }.call(ve)), vh.exports;
}
var yh = { exports: {} }, Q_;
function dy() {
  return Q_ || (Q_ = 1, function() {
    var t, e, r;
    ({ isObject: r } = Ur()), e = Gt(), t = ot(), yh.exports = function() {
      class n extends e {
        // Initializes a new instance of `XMLDTDEntity`
        // `parent` the parent `XMLDocType` element
        // `pe` whether this is a parameter entity or a general entity
        //      defaults to `false` (general entity)
        // `name` the name of the entity
        // `value` internal entity value or an object with external entity details
        // `value.pubID` public identifier
        // `value.sysID` system identifier
        // `value.nData` notation declaration
        constructor(a, s, o, c) {
          if (super(a), o == null)
            throw new Error("Missing DTD entity name. " + this.debugInfo(o));
          if (c == null)
            throw new Error("Missing DTD entity value. " + this.debugInfo(o));
          if (this.pe = !!s, this.name = this.stringify.name(o), this.type = t.EntityDeclaration, !r(c))
            this.value = this.stringify.dtdEntityValue(c), this.internal = !0;
          else {
            if (!c.pubID && !c.sysID)
              throw new Error("Public and/or system identifiers are required for an external entity. " + this.debugInfo(o));
            if (c.pubID && !c.sysID)
              throw new Error("System identifier is required for a public external entity. " + this.debugInfo(o));
            if (this.internal = !1, c.pubID != null && (this.pubID = this.stringify.dtdPubID(c.pubID)), c.sysID != null && (this.sysID = this.stringify.dtdSysID(c.sysID)), c.nData != null && (this.nData = this.stringify.dtdNData(c.nData)), this.pe && this.nData)
              throw new Error("Notation declaration is not allowed in a parameter entity. " + this.debugInfo(o));
          }
        }
        // Converts the XML fragment to string
        // `options.pretty` pretty prints the result
        // `options.indent` indentation for pretty print
        // `options.offset` how many indentations to add to every line for pretty print
        // `options.newline` newline sequence for pretty print
        toString(a) {
          return this.options.writer.dtdEntity(this, this.options.writer.filterOptions(a));
        }
      }
      return Object.defineProperty(n.prototype, "publicId", {
        get: function() {
          return this.pubID;
        }
      }), Object.defineProperty(n.prototype, "systemId", {
        get: function() {
          return this.sysID;
        }
      }), Object.defineProperty(n.prototype, "notationName", {
        get: function() {
          return this.nData || null;
        }
      }), Object.defineProperty(n.prototype, "inputEncoding", {
        get: function() {
          return null;
        }
      }), Object.defineProperty(n.prototype, "xmlEncoding", {
        get: function() {
          return null;
        }
      }), Object.defineProperty(n.prototype, "xmlVersion", {
        get: function() {
          return null;
        }
      }), n;
    }.call(this);
  }.call(ve)), yh.exports;
}
var bh = { exports: {} }, V_;
function my() {
  return V_ || (V_ = 1, function() {
    var t, e;
    e = Gt(), t = ot(), bh.exports = class extends e {
      // Initializes a new instance of `XMLDTDElement`
      // `parent` the parent `XMLDocType` element
      // `name` element name
      // `value` element content (defaults to #PCDATA)
      constructor(n, i, a) {
        if (super(n), i == null)
          throw new Error("Missing DTD element name. " + this.debugInfo());
        a || (a = "(#PCDATA)"), Array.isArray(a) && (a = "(" + a.join(",") + ")"), this.name = this.stringify.name(i), this.type = t.ElementDeclaration, this.value = this.stringify.dtdElementValue(a);
      }
      // Converts the XML fragment to string
      // `options.pretty` pretty prints the result
      // `options.indent` indentation for pretty print
      // `options.offset` how many indentations to add to every line for pretty print
      // `options.newline` newline sequence for pretty print
      toString(n) {
        return this.options.writer.dtdElement(this, this.options.writer.filterOptions(n));
      }
    };
  }.call(ve)), bh.exports;
}
var wh = { exports: {} }, K_;
function gy() {
  return K_ || (K_ = 1, function() {
    var t, e;
    e = Gt(), t = ot(), wh.exports = function() {
      class r extends e {
        // Initializes a new instance of `XMLDTDNotation`
        // `parent` the parent `XMLDocType` element
        // `name` the name of the notation
        // `value` an object with external entity details
        // `value.pubID` public identifier
        // `value.sysID` system identifier
        constructor(i, a, s) {
          if (super(i), a == null)
            throw new Error("Missing DTD notation name. " + this.debugInfo(a));
          if (!s.pubID && !s.sysID)
            throw new Error("Public or system identifiers are required for an external entity. " + this.debugInfo(a));
          this.name = this.stringify.name(a), this.type = t.NotationDeclaration, s.pubID != null && (this.pubID = this.stringify.dtdPubID(s.pubID)), s.sysID != null && (this.sysID = this.stringify.dtdSysID(s.sysID));
        }
        // Converts the XML fragment to string
        // `options.pretty` pretty prints the result
        // `options.indent` indentation for pretty print
        // `options.offset` how many indentations to add to every line for pretty print
        // `options.newline` newline sequence for pretty print
        toString(i) {
          return this.options.writer.dtdNotation(this, this.options.writer.filterOptions(i));
        }
      }
      return Object.defineProperty(r.prototype, "publicId", {
        get: function() {
          return this.pubID;
        }
      }), Object.defineProperty(r.prototype, "systemId", {
        get: function() {
          return this.sysID;
        }
      }), r;
    }.call(this);
  }.call(ve)), wh.exports;
}
var J_;
function vy() {
  return J_ || (J_ = 1, function() {
    var t, e, r, n, i, a, s, o;
    ({ isObject: o } = Ur()), s = Gt(), t = ot(), e = hy(), n = dy(), r = my(), i = gy(), a = cy(), gh.exports = function() {
      class c extends s {
        // Initializes a new instance of `XMLDocType`
        // `parent` the document object
        // `pubID` public identifier of the external subset
        // `sysID` system identifier of the external subset
        constructor(u, l, p) {
          var m, h, g, v;
          if (super(u), this.type = t.DocType, u.children) {
            for (v = u.children, h = 0, g = v.length; h < g; h++)
              if (m = v[h], m.type === t.Element) {
                this.name = m.name;
                break;
              }
          }
          this.documentObject = u, o(l) && ({ pubID: l, sysID: p } = l), p == null && ([p, l] = [l, p]), l != null && (this.pubID = this.stringify.dtdPubID(l)), p != null && (this.sysID = this.stringify.dtdSysID(p));
        }
        // Creates an element type declaration
        // `name` element name
        // `value` element content (defaults to #PCDATA)
        element(u, l) {
          var p;
          return p = new r(this, u, l), this.children.push(p), this;
        }
        // Creates an attribute declaration
        // `elementName` the name of the element containing this attribute
        // `attributeName` attribute name
        // `attributeType` type of the attribute (defaults to CDATA)
        // `defaultValueType` default value type (either #REQUIRED, #IMPLIED, #FIXED or
        //                    #DEFAULT) (defaults to #IMPLIED)
        // `defaultValue` default value of the attribute
        //                (only used for #FIXED or #DEFAULT)
        attList(u, l, p, m, h) {
          var g;
          return g = new e(this, u, l, p, m, h), this.children.push(g), this;
        }
        // Creates a general entity declaration
        // `name` the name of the entity
        // `value` internal entity value or an object with external entity details
        // `value.pubID` public identifier
        // `value.sysID` system identifier
        // `value.nData` notation declaration
        entity(u, l) {
          var p;
          return p = new n(this, !1, u, l), this.children.push(p), this;
        }
        // Creates a parameter entity declaration
        // `name` the name of the entity
        // `value` internal entity value or an object with external entity details
        // `value.pubID` public identifier
        // `value.sysID` system identifier
        pEntity(u, l) {
          var p;
          return p = new n(this, !0, u, l), this.children.push(p), this;
        }
        // Creates a NOTATION declaration
        // `name` the name of the notation
        // `value` an object with external entity details
        // `value.pubID` public identifier
        // `value.sysID` system identifier
        notation(u, l) {
          var p;
          return p = new i(this, u, l), this.children.push(p), this;
        }
        // Converts to string
        // `options.pretty` pretty prints the result
        // `options.indent` indentation for pretty print
        // `options.offset` how many indentations to add to every line for pretty print
        // `options.newline` newline sequence for pretty print
        toString(u) {
          return this.options.writer.docType(this, this.options.writer.filterOptions(u));
        }
        // Aliases
        ele(u, l) {
          return this.element(u, l);
        }
        att(u, l, p, m, h) {
          return this.attList(u, l, p, m, h);
        }
        ent(u, l) {
          return this.entity(u, l);
        }
        pent(u, l) {
          return this.pEntity(u, l);
        }
        not(u, l) {
          return this.notation(u, l);
        }
        up() {
          return this.root() || this.documentObject;
        }
        isEqualNode(u) {
          return !(!super.isEqualNode(u) || u.name !== this.name || u.publicId !== this.publicId || u.systemId !== this.systemId);
        }
      }
      return Object.defineProperty(c.prototype, "entities", {
        get: function() {
          var f, u, l, p, m;
          for (p = {}, m = this.children, u = 0, l = m.length; u < l; u++)
            f = m[u], f.type === t.EntityDeclaration && !f.pe && (p[f.name] = f);
          return new a(p);
        }
      }), Object.defineProperty(c.prototype, "notations", {
        get: function() {
          var f, u, l, p, m;
          for (p = {}, m = this.children, u = 0, l = m.length; u < l; u++)
            f = m[u], f.type === t.NotationDeclaration && (p[f.name] = f);
          return new a(p);
        }
      }), Object.defineProperty(c.prototype, "publicId", {
        get: function() {
          return this.pubID;
        }
      }), Object.defineProperty(c.prototype, "systemId", {
        get: function() {
          return this.sysID;
        }
      }), Object.defineProperty(c.prototype, "internalSubset", {
        get: function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      }), c;
    }.call(this);
  }.call(ve)), gh.exports;
}
var xh = { exports: {} }, X_;
function yy() {
  return X_ || (X_ = 1, function() {
    var t, e;
    t = ot(), e = Gt(), xh.exports = class extends e {
      // Initializes a new instance of `XMLRaw`
      // `text` raw text
      constructor(n, i) {
        if (super(n), i == null)
          throw new Error("Missing raw text. " + this.debugInfo());
        this.type = t.Raw, this.value = this.stringify.raw(i);
      }
      // Creates and returns a deep clone of `this`
      clone() {
        return Object.create(this);
      }
      // Converts the XML fragment to string
      // `options.pretty` pretty prints the result
      // `options.indent` indentation for pretty print
      // `options.offset` how many indentations to add to every line for pretty print
      // `options.newline` newline sequence for pretty print
      toString(n) {
        return this.options.writer.raw(this, this.options.writer.filterOptions(n));
      }
    };
  }.call(ve)), xh.exports;
}
var _h = { exports: {} }, Z_;
function by() {
  return Z_ || (Z_ = 1, function() {
    var t, e;
    t = ot(), e = Ru(), _h.exports = function() {
      class r extends e {
        // Initializes a new instance of `XMLText`
        // `text` element text
        constructor(i, a) {
          if (super(i), a == null)
            throw new Error("Missing element text. " + this.debugInfo());
          this.name = "#text", this.type = t.Text, this.value = this.stringify.text(a);
        }
        // Creates and returns a deep clone of `this`
        clone() {
          return Object.create(this);
        }
        // Converts the XML fragment to string
        // `options.pretty` pretty prints the result
        // `options.indent` indentation for pretty print
        // `options.offset` how many indentations to add to every line for pretty print
        // `options.newline` newline sequence for pretty print
        toString(i) {
          return this.options.writer.text(this, this.options.writer.filterOptions(i));
        }
        // DOM level 1 functions to be implemented later
        splitText(i) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        // DOM level 3 functions to be implemented later
        replaceWholeText(i) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      }
      return Object.defineProperty(r.prototype, "isElementContentWhitespace", {
        get: function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      }), Object.defineProperty(r.prototype, "wholeText", {
        get: function() {
          var n, i, a;
          for (a = "", i = this.previousSibling; i; )
            a = i.data + a, i = i.previousSibling;
          for (a += this.data, n = this.nextSibling; n; )
            a = a + n.data, n = n.nextSibling;
          return a;
        }
      }), r;
    }.call(this);
  }.call(ve)), _h.exports;
}
var Eh = { exports: {} }, Y_;
function wy() {
  return Y_ || (Y_ = 1, function() {
    var t, e;
    t = ot(), e = Ru(), Eh.exports = class extends e {
      // Initializes a new instance of `XMLProcessingInstruction`
      // `parent` the parent node
      // `target` instruction target
      // `value` instruction value
      constructor(n, i, a) {
        if (super(n), i == null)
          throw new Error("Missing instruction target. " + this.debugInfo());
        this.type = t.ProcessingInstruction, this.target = this.stringify.insTarget(i), this.name = this.target, a && (this.value = this.stringify.insValue(a));
      }
      // Creates and returns a deep clone of `this`
      clone() {
        return Object.create(this);
      }
      // Converts the XML fragment to string
      // `options.pretty` pretty prints the result
      // `options.indent` indentation for pretty print
      // `options.offset` how many indentations to add to every line for pretty print
      // `options.newline` newline sequence for pretty print
      toString(n) {
        return this.options.writer.processingInstruction(this, this.options.writer.filterOptions(n));
      }
      isEqualNode(n) {
        return !(!super.isEqualNode(n) || n.target !== this.target);
      }
    };
  }.call(ve)), Eh.exports;
}
var Sh = { exports: {} }, eE;
function z$() {
  return eE || (eE = 1, function() {
    var t, e;
    e = Gt(), t = ot(), Sh.exports = class extends e {
      // Initializes a new instance of `XMLDummy`
      // `XMLDummy` is a special node representing a node with 
      // a null value. Dummy nodes are created while recursively
      // building the XML tree. Simply skipping null values doesn't
      // work because that would break the recursive chain.
      constructor(n) {
        super(n), this.type = t.Dummy;
      }
      // Creates and returns a deep clone of `this`
      clone() {
        return Object.create(this);
      }
      // Converts the XML fragment to string
      // `options.pretty` pretty prints the result
      // `options.indent` indentation for pretty print
      // `options.offset` how many indentations to add to every line for pretty print
      // `options.newline` newline sequence for pretty print
      toString(n) {
        return "";
      }
    };
  }.call(ve)), Sh.exports;
}
var Ch = { exports: {} }, tE;
function qpe() {
  return tE || (tE = 1, function() {
    Ch.exports = function() {
      class t {
        // Initializes a new instance of `XMLNodeList`
        // This is just a wrapper around an ordinary
        // JS array.
        // `nodes` the array containing nodes.
        constructor(r) {
          this.nodes = r;
        }
        // Creates and returns a deep clone of `this`
        clone() {
          return this.nodes = null;
        }
        // DOM Level 1
        item(r) {
          return this.nodes[r] || null;
        }
      }
      return Object.defineProperty(t.prototype, "length", {
        get: function() {
          return this.nodes.length || 0;
        }
      }), t;
    }.call(this);
  }.call(ve)), Ch.exports;
}
var Th = { exports: {} }, rE;
function jpe() {
  return rE || (rE = 1, function() {
    Th.exports = {
      Disconnected: 1,
      Preceding: 2,
      Following: 4,
      Contains: 8,
      ContainedBy: 16,
      ImplementationSpecific: 32
    };
  }.call(ve)), Th.exports;
}
var nE;
function Gt() {
  return nE || (nE = 1, function() {
    var t, e, r, n, i, a, s, o, c, f, u, l, p, m, h, g, v = {}.hasOwnProperty, d = [].splice;
    ({ isObject: g, isFunction: h, isEmpty: m, getValue: p } = Ur()), o = null, r = null, n = null, i = null, a = null, u = null, l = null, f = null, s = null, e = null, c = null, t = null, oh.exports = function() {
      class y {
        // Initializes a new instance of `XMLNode`
        // `parent` the parent node
        constructor(b) {
          this.parent = b, this.parent && (this.options = this.parent.options, this.stringify = this.parent.stringify), this.value = null, this.children = [], this.baseURI = null, o || (o = uy(), r = ly(), n = py(), i = fy(), a = vy(), u = yy(), l = by(), f = wy(), s = z$(), e = ot(), c = qpe(), cy(), t = jpe());
        }
        // Sets the parent node of this node and its children recursively
        // `parent` the parent node
        setParent(b) {
          var w, S, T, E, C;
          for (this.parent = b, b && (this.options = b.options, this.stringify = b.stringify), E = this.children, C = [], S = 0, T = E.length; S < T; S++)
            w = E[S], C.push(w.setParent(this));
          return C;
        }
        // Creates a child element node
        // `name` node name or an object describing the XML tree
        // `attributes` an object containing name/value pairs of attributes
        // `text` element text
        element(b, w, S) {
          var T, E, C, A, R, D, F, K, V;
          if (D = null, w === null && S == null && ([w, S] = [{}, null]), w == null && (w = {}), w = p(w), g(w) || ([S, w] = [w, S]), b != null && (b = p(b)), Array.isArray(b))
            for (C = 0, F = b.length; C < F; C++)
              E = b[C], D = this.element(E);
          else if (h(b))
            D = this.element(b.apply());
          else if (g(b)) {
            for (R in b)
              if (v.call(b, R))
                if (V = b[R], h(V) && (V = V.apply()), !this.options.ignoreDecorators && this.stringify.convertAttKey && R.indexOf(this.stringify.convertAttKey) === 0)
                  D = this.attribute(R.substr(this.stringify.convertAttKey.length), V);
                else if (!this.options.separateArrayItems && Array.isArray(V) && m(V))
                  D = this.dummy();
                else if (g(V) && m(V))
                  D = this.element(R);
                else if (!this.options.keepNullNodes && V == null)
                  D = this.dummy();
                else if (!this.options.separateArrayItems && Array.isArray(V))
                  for (A = 0, K = V.length; A < K; A++)
                    E = V[A], T = {}, T[R] = E, D = this.element(T);
                else
                  g(V) ? !this.options.ignoreDecorators && this.stringify.convertTextKey && R.indexOf(this.stringify.convertTextKey) === 0 ? D = this.element(V) : (D = this.element(R), D.element(V)) : D = this.element(R, V);
          } else
            !this.options.keepNullNodes && S === null ? D = this.dummy() : !this.options.ignoreDecorators && this.stringify.convertTextKey && b.indexOf(this.stringify.convertTextKey) === 0 ? D = this.text(S) : !this.options.ignoreDecorators && this.stringify.convertCDataKey && b.indexOf(this.stringify.convertCDataKey) === 0 ? D = this.cdata(S) : !this.options.ignoreDecorators && this.stringify.convertCommentKey && b.indexOf(this.stringify.convertCommentKey) === 0 ? D = this.comment(S) : !this.options.ignoreDecorators && this.stringify.convertRawKey && b.indexOf(this.stringify.convertRawKey) === 0 ? D = this.raw(S) : !this.options.ignoreDecorators && this.stringify.convertPIKey && b.indexOf(this.stringify.convertPIKey) === 0 ? D = this.instruction(b.substr(this.stringify.convertPIKey.length), S) : D = this.node(b, w, S);
          if (D == null)
            throw new Error("Could not create any elements with: " + b + ". " + this.debugInfo());
          return D;
        }
        // Creates a child element node before the current node
        // `name` node name or an object describing the XML tree
        // `attributes` an object containing name/value pairs of attributes
        // `text` element text
        insertBefore(b, w, S) {
          var T, E, C, A, R;
          if (b != null && b.type)
            return C = b, A = w, C.setParent(this), A ? (E = children.indexOf(A), R = children.splice(E), children.push(C), Array.prototype.push.apply(children, R)) : children.push(C), C;
          if (this.isRoot)
            throw new Error("Cannot insert elements at root level. " + this.debugInfo(b));
          return E = this.parent.children.indexOf(this), R = this.parent.children.splice(E), T = this.parent.element(b, w, S), Array.prototype.push.apply(this.parent.children, R), T;
        }
        // Creates a child element node after the current node
        // `name` node name or an object describing the XML tree
        // `attributes` an object containing name/value pairs of attributes
        // `text` element text
        insertAfter(b, w, S) {
          var T, E, C;
          if (this.isRoot)
            throw new Error("Cannot insert elements at root level. " + this.debugInfo(b));
          return E = this.parent.children.indexOf(this), C = this.parent.children.splice(E + 1), T = this.parent.element(b, w, S), Array.prototype.push.apply(this.parent.children, C), T;
        }
        // Deletes a child element node
        remove() {
          var b;
          if (this.isRoot)
            throw new Error("Cannot remove the root element. " + this.debugInfo());
          return b = this.parent.children.indexOf(this), d.apply(this.parent.children, [b, b - b + 1].concat([])), this.parent;
        }
        // Creates a node
        // `name` name of the node
        // `attributes` an object containing name/value pairs of attributes
        // `text` element text
        node(b, w, S) {
          var T;
          return b != null && (b = p(b)), w || (w = {}), w = p(w), g(w) || ([S, w] = [w, S]), T = new o(this, b, w), S != null && T.text(S), this.children.push(T), T;
        }
        // Creates a text node
        // `value` element text
        text(b) {
          var w;
          return g(b) && this.element(b), w = new l(this, b), this.children.push(w), this;
        }
        // Creates a CDATA node
        // `value` element text without CDATA delimiters
        cdata(b) {
          var w;
          return w = new r(this, b), this.children.push(w), this;
        }
        // Creates a comment node
        // `value` comment text
        comment(b) {
          var w;
          return w = new n(this, b), this.children.push(w), this;
        }
        // Creates a comment node before the current node
        // `value` comment text
        commentBefore(b) {
          var w, S;
          return w = this.parent.children.indexOf(this), S = this.parent.children.splice(w), this.parent.comment(b), Array.prototype.push.apply(this.parent.children, S), this;
        }
        // Creates a comment node after the current node
        // `value` comment text
        commentAfter(b) {
          var w, S;
          return w = this.parent.children.indexOf(this), S = this.parent.children.splice(w + 1), this.parent.comment(b), Array.prototype.push.apply(this.parent.children, S), this;
        }
        // Adds unescaped raw text
        // `value` text
        raw(b) {
          var w;
          return w = new u(this, b), this.children.push(w), this;
        }
        // Adds a dummy node
        dummy() {
          var b;
          return b = new s(this), b;
        }
        // Adds a processing instruction
        // `target` instruction target
        // `value` instruction value
        instruction(b, w) {
          var S, T, E, C, A;
          if (b != null && (b = p(b)), w != null && (w = p(w)), Array.isArray(b))
            for (C = 0, A = b.length; C < A; C++)
              S = b[C], this.instruction(S);
          else if (g(b))
            for (S in b)
              v.call(b, S) && (T = b[S], this.instruction(S, T));
          else
            h(w) && (w = w.apply()), E = new f(this, b, w), this.children.push(E);
          return this;
        }
        // Creates a processing instruction node before the current node
        // `target` instruction target
        // `value` instruction value
        instructionBefore(b, w) {
          var S, T;
          return S = this.parent.children.indexOf(this), T = this.parent.children.splice(S), this.parent.instruction(b, w), Array.prototype.push.apply(this.parent.children, T), this;
        }
        // Creates a processing instruction node after the current node
        // `target` instruction target
        // `value` instruction value
        instructionAfter(b, w) {
          var S, T;
          return S = this.parent.children.indexOf(this), T = this.parent.children.splice(S + 1), this.parent.instruction(b, w), Array.prototype.push.apply(this.parent.children, T), this;
        }
        // Creates the xml declaration
        // `version` A version number string, e.g. 1.0
        // `encoding` Encoding declaration, e.g. UTF-8
        // `standalone` standalone document declaration: true or false
        declaration(b, w, S) {
          var T, E;
          return T = this.document(), E = new i(T, b, w, S), T.children.length === 0 ? T.children.unshift(E) : T.children[0].type === e.Declaration ? T.children[0] = E : T.children.unshift(E), T.root() || T;
        }
        // Creates the document type declaration
        // `pubID` the public identifier of the external subset
        // `sysID` the system identifier of the external subset
        dtd(b, w) {
          var S, T, E, C, A, R, D, F, K, V;
          for (T = this.document(), E = new a(T, b, w), K = T.children, C = A = 0, D = K.length; A < D; C = ++A)
            if (S = K[C], S.type === e.DocType)
              return T.children[C] = E, E;
          for (V = T.children, C = R = 0, F = V.length; R < F; C = ++R)
            if (S = V[C], S.isRoot)
              return T.children.splice(C, 0, E), E;
          return T.children.push(E), E;
        }
        // Gets the parent node
        up() {
          if (this.isRoot)
            throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
          return this.parent;
        }
        // Gets the root node
        root() {
          var b;
          for (b = this; b; ) {
            if (b.type === e.Document)
              return b.rootObject;
            if (b.isRoot)
              return b;
            b = b.parent;
          }
        }
        // Gets the node representing the XML document
        document() {
          var b;
          for (b = this; b; ) {
            if (b.type === e.Document)
              return b;
            b = b.parent;
          }
        }
        // Ends the document and converts string
        end(b) {
          return this.document().end(b);
        }
        // Gets the previous node
        prev() {
          var b;
          if (b = this.parent.children.indexOf(this), b < 1)
            throw new Error("Already at the first node. " + this.debugInfo());
          return this.parent.children[b - 1];
        }
        // Gets the next node
        next() {
          var b;
          if (b = this.parent.children.indexOf(this), b === -1 || b === this.parent.children.length - 1)
            throw new Error("Already at the last node. " + this.debugInfo());
          return this.parent.children[b + 1];
        }
        // Imports cloned root from another XML document
        // `doc` the XML document to insert nodes from
        importDocument(b) {
          var w, S, T, E, C;
          if (S = b.root().clone(), S.parent = this, S.isRoot = !1, this.children.push(S), this.type === e.Document && (S.isRoot = !0, S.documentObject = this, this.rootObject = S, this.children)) {
            for (C = this.children, T = 0, E = C.length; T < E; T++)
              if (w = C[T], w.type === e.DocType) {
                w.name = S.name;
                break;
              }
          }
          return this;
        }
        // Returns debug string for this node
        debugInfo(b) {
          var w, S;
          return b = b || this.name, b == null && !((w = this.parent) != null && w.name) ? "" : b == null ? "parent: <" + this.parent.name + ">" : (S = this.parent) != null && S.name ? "node: <" + b + ">, parent: <" + this.parent.name + ">" : "node: <" + b + ">";
        }
        // Aliases
        ele(b, w, S) {
          return this.element(b, w, S);
        }
        nod(b, w, S) {
          return this.node(b, w, S);
        }
        txt(b) {
          return this.text(b);
        }
        dat(b) {
          return this.cdata(b);
        }
        com(b) {
          return this.comment(b);
        }
        ins(b, w) {
          return this.instruction(b, w);
        }
        doc() {
          return this.document();
        }
        dec(b, w, S) {
          return this.declaration(b, w, S);
        }
        e(b, w, S) {
          return this.element(b, w, S);
        }
        n(b, w, S) {
          return this.node(b, w, S);
        }
        t(b) {
          return this.text(b);
        }
        d(b) {
          return this.cdata(b);
        }
        c(b) {
          return this.comment(b);
        }
        r(b) {
          return this.raw(b);
        }
        i(b, w) {
          return this.instruction(b, w);
        }
        u() {
          return this.up();
        }
        // can be deprecated in a future release
        importXMLBuilder(b) {
          return this.importDocument(b);
        }
        // Adds or modifies an attribute.
        // `name` attribute name
        // `value` attribute value
        attribute(b, w) {
          throw new Error("attribute() applies to element nodes only.");
        }
        att(b, w) {
          return this.attribute(b, w);
        }
        a(b, w) {
          return this.attribute(b, w);
        }
        // Removes an attribute
        // `name` attribute name
        removeAttribute(b) {
          throw new Error("attribute() applies to element nodes only.");
        }
        // DOM level 1 functions to be implemented later
        replaceChild(b, w) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        removeChild(b) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        appendChild(b) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        hasChildNodes() {
          return this.children.length !== 0;
        }
        cloneNode(b) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        normalize() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        // DOM level 2
        isSupported(b, w) {
          return !0;
        }
        hasAttributes() {
          return this.attribs.length !== 0;
        }
        // DOM level 3 functions to be implemented later
        compareDocumentPosition(b) {
          var w, S;
          return w = this, w === b ? 0 : this.document() !== b.document() ? (S = t.Disconnected | t.ImplementationSpecific, Math.random() < 0.5 ? S |= t.Preceding : S |= t.Following, S) : w.isAncestor(b) ? t.Contains | t.Preceding : w.isDescendant(b) ? t.Contains | t.Following : w.isPreceding(b) ? t.Preceding : t.Following;
        }
        isSameNode(b) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        lookupPrefix(b) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        isDefaultNamespace(b) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        lookupNamespaceURI(b) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        isEqualNode(b) {
          var w, S, T;
          if (b.nodeType !== this.nodeType || b.children.length !== this.children.length)
            return !1;
          for (w = S = 0, T = this.children.length - 1; 0 <= T ? S <= T : S >= T; w = 0 <= T ? ++S : --S)
            if (!this.children[w].isEqualNode(b.children[w]))
              return !1;
          return !0;
        }
        getFeature(b, w) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        setUserData(b, w, S) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        getUserData(b) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        // Returns true if other is an inclusive descendant of node,
        // and false otherwise.
        contains(b) {
          return b ? b === this || this.isDescendant(b) : !1;
        }
        // An object A is called a descendant of an object B, if either A is 
        // a child of B or A is a child of an object C that is a descendant of B.
        isDescendant(b) {
          var w, S, T, E, C;
          for (C = this.children, T = 0, E = C.length; T < E; T++)
            if (w = C[T], b === w || (S = w.isDescendant(b), S))
              return !0;
          return !1;
        }
        // An object A is called an ancestor of an object B if and only if
        // B is a descendant of A.
        isAncestor(b) {
          return b.isDescendant(this);
        }
        // An object A is preceding an object B if A and B are in the 
        // same tree and A comes before B in tree order.
        isPreceding(b) {
          var w, S;
          return w = this.treePosition(b), S = this.treePosition(this), w === -1 || S === -1 ? !1 : w < S;
        }
        // An object A is folllowing an object B if A and B are in the 
        // same tree and A comes after B in tree order.
        isFollowing(b) {
          var w, S;
          return w = this.treePosition(b), S = this.treePosition(this), w === -1 || S === -1 ? !1 : w > S;
        }
        // Returns the preorder position of the given node in the tree, or -1
        // if the node is not in the tree.
        treePosition(b) {
          var w, S;
          return S = 0, w = !1, this.foreachTreeNode(this.document(), function(T) {
            if (S++, !w && T === b)
              return w = !0;
          }), w ? S : -1;
        }
        // Depth-first preorder traversal through the XML tree
        foreachTreeNode(b, w) {
          var S, T, E, C, A;
          for (b || (b = this.document()), C = b.children, T = 0, E = C.length; T < E; T++) {
            if (S = C[T], A = w(S))
              return A;
            if (A = this.foreachTreeNode(S, w), A)
              return A;
          }
        }
      }
      return Object.defineProperty(y.prototype, "nodeName", {
        get: function() {
          return this.name;
        }
      }), Object.defineProperty(y.prototype, "nodeType", {
        get: function() {
          return this.type;
        }
      }), Object.defineProperty(y.prototype, "nodeValue", {
        get: function() {
          return this.value;
        }
      }), Object.defineProperty(y.prototype, "parentNode", {
        get: function() {
          return this.parent;
        }
      }), Object.defineProperty(y.prototype, "childNodes", {
        get: function() {
          return (!this.childNodeList || !this.childNodeList.nodes) && (this.childNodeList = new c(this.children)), this.childNodeList;
        }
      }), Object.defineProperty(y.prototype, "firstChild", {
        get: function() {
          return this.children[0] || null;
        }
      }), Object.defineProperty(y.prototype, "lastChild", {
        get: function() {
          return this.children[this.children.length - 1] || null;
        }
      }), Object.defineProperty(y.prototype, "previousSibling", {
        get: function() {
          var x;
          return x = this.parent.children.indexOf(this), this.parent.children[x - 1] || null;
        }
      }), Object.defineProperty(y.prototype, "nextSibling", {
        get: function() {
          var x;
          return x = this.parent.children.indexOf(this), this.parent.children[x + 1] || null;
        }
      }), Object.defineProperty(y.prototype, "ownerDocument", {
        get: function() {
          return this.document() || null;
        }
      }), Object.defineProperty(y.prototype, "textContent", {
        get: function() {
          var x, b, w, S, T;
          if (this.nodeType === e.Element || this.nodeType === e.DocumentFragment) {
            for (T = "", S = this.children, b = 0, w = S.length; b < w; b++)
              x = S[b], x.textContent && (T += x.textContent);
            return T;
          } else
            return null;
        },
        set: function(x) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      }), y;
    }.call(this);
  }.call(ve)), oh.exports;
}
var Oh = { exports: {} }, iE;
function H$() {
  return iE || (iE = 1, function() {
    var t = {}.hasOwnProperty;
    Oh.exports = function() {
      class e {
        // Initializes a new instance of `XMLStringifier`
        // `options.version` The version number string of the XML spec to validate against, e.g. 1.0
        // `options.noDoubleEncoding` whether existing html entities are encoded: true or false
        // `options.stringify` a set of functions to use for converting values to strings
        // `options.noValidation` whether values will be validated and escaped or returned as is
        // `options.invalidCharReplacement` a character to replace invalid characters and disable character validation
        constructor(n) {
          var i, a, s;
          this.assertLegalChar = this.assertLegalChar.bind(this), this.assertLegalName = this.assertLegalName.bind(this), n || (n = {}), this.options = n, this.options.version || (this.options.version = "1.0"), a = n.stringify || {};
          for (i in a)
            t.call(a, i) && (s = a[i], this[i] = s);
        }
        // Defaults
        name(n) {
          return this.options.noValidation ? n : this.assertLegalName("" + n || "");
        }
        text(n) {
          return this.options.noValidation ? n : this.assertLegalChar(this.textEscape("" + n || ""));
        }
        cdata(n) {
          return this.options.noValidation ? n : (n = "" + n || "", n = n.replace("]]>", "]]]]><![CDATA[>"), this.assertLegalChar(n));
        }
        comment(n) {
          if (this.options.noValidation)
            return n;
          if (n = "" + n || "", n.match(/--/))
            throw new Error("Comment text cannot contain double-hypen: " + n);
          return this.assertLegalChar(n);
        }
        raw(n) {
          return this.options.noValidation ? n : "" + n || "";
        }
        attValue(n) {
          return this.options.noValidation ? n : this.assertLegalChar(this.attEscape(n = "" + n || ""));
        }
        insTarget(n) {
          return this.options.noValidation ? n : this.assertLegalChar("" + n || "");
        }
        insValue(n) {
          if (this.options.noValidation)
            return n;
          if (n = "" + n || "", n.match(/\?>/))
            throw new Error("Invalid processing instruction value: " + n);
          return this.assertLegalChar(n);
        }
        xmlVersion(n) {
          if (this.options.noValidation)
            return n;
          if (n = "" + n || "", !n.match(/1\.[0-9]+/))
            throw new Error("Invalid version number: " + n);
          return n;
        }
        xmlEncoding(n) {
          if (this.options.noValidation)
            return n;
          if (n = "" + n || "", !n.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/))
            throw new Error("Invalid encoding: " + n);
          return this.assertLegalChar(n);
        }
        xmlStandalone(n) {
          return this.options.noValidation ? n : n ? "yes" : "no";
        }
        dtdPubID(n) {
          return this.options.noValidation ? n : this.assertLegalChar("" + n || "");
        }
        dtdSysID(n) {
          return this.options.noValidation ? n : this.assertLegalChar("" + n || "");
        }
        dtdElementValue(n) {
          return this.options.noValidation ? n : this.assertLegalChar("" + n || "");
        }
        dtdAttType(n) {
          return this.options.noValidation ? n : this.assertLegalChar("" + n || "");
        }
        dtdAttDefault(n) {
          return this.options.noValidation ? n : this.assertLegalChar("" + n || "");
        }
        dtdEntityValue(n) {
          return this.options.noValidation ? n : this.assertLegalChar("" + n || "");
        }
        dtdNData(n) {
          return this.options.noValidation ? n : this.assertLegalChar("" + n || "");
        }
        assertLegalChar(n) {
          var i, a;
          if (this.options.noValidation)
            return n;
          if (this.options.version === "1.0") {
            if (i = /[\0-\x08\x0B\f\x0E-\x1F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/g, this.options.invalidCharReplacement !== void 0)
              n = n.replace(i, this.options.invalidCharReplacement);
            else if (a = n.match(i))
              throw new Error(`Invalid character in string: ${n} at index ${a.index}`);
          } else if (this.options.version === "1.1") {
            if (i = /[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/g, this.options.invalidCharReplacement !== void 0)
              n = n.replace(i, this.options.invalidCharReplacement);
            else if (a = n.match(i))
              throw new Error(`Invalid character in string: ${n} at index ${a.index}`);
          }
          return n;
        }
        assertLegalName(n) {
          var i;
          if (this.options.noValidation)
            return n;
          if (n = this.assertLegalChar(n), i = /^([:A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])([\x2D\.0-:A-Z_a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*$/, !n.match(i))
            throw new Error(`Invalid character in name: ${n}`);
          return n;
        }
        // Escapes special characters in text
        // See http://www.w3.org/TR/2000/WD-xml-c14n-20000119.html#charescaping
        // `str` the string to escape
        textEscape(n) {
          var i;
          return this.options.noValidation ? n : (i = this.options.noDoubleEncoding ? /(?!&(lt|gt|amp|apos|quot);)&/g : /&/g, n.replace(i, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#xD;"));
        }
        // Escapes special characters in attribute values
        // See http://www.w3.org/TR/2000/WD-xml-c14n-20000119.html#charescaping
        // `str` the string to escape
        attEscape(n) {
          var i;
          return this.options.noValidation ? n : (i = this.options.noDoubleEncoding ? /(?!&(lt|gt|amp|apos|quot);)&/g : /&/g, n.replace(i, "&amp;").replace(/</g, "&lt;").replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;"));
        }
      }
      return e.prototype.convertAttKey = "@", e.prototype.convertPIKey = "?", e.prototype.convertTextKey = "#text", e.prototype.convertCDataKey = "#cdata", e.prototype.convertCommentKey = "#comment", e.prototype.convertRawKey = "#raw", e;
    }.call(this);
  }.call(ve)), Oh.exports;
}
var Ah = { exports: {} }, $h = { exports: {} }, Ih = { exports: {} }, aE;
function Nu() {
  return aE || (aE = 1, function() {
    Ih.exports = {
      None: 0,
      OpenTag: 1,
      InsideTag: 2,
      CloseTag: 3
    };
  }.call(ve)), Ih.exports;
}
var sE;
function W$() {
  return sE || (sE = 1, function() {
    var t, e, r, n = {}.hasOwnProperty;
    ({ assign: r } = Ur()), t = ot(), fy(), vy(), ly(), py(), uy(), yy(), by(), wy(), z$(), hy(), my(), dy(), gy(), e = Nu(), $h.exports = class {
      // Initializes a new instance of `XMLWriterBase`
      // `options.pretty` pretty prints the result
      // `options.indent` indentation string
      // `options.newline` newline sequence
      // `options.offset` a fixed number of indentations to add to every line
      // `options.width` maximum column width
      // `options.allowEmpty` do not self close empty element tags
      // 'options.dontPrettyTextNodes' if any text is present in node, don't indent or LF
      // `options.spaceBeforeSlash` add a space before the closing slash of empty elements
      constructor(a) {
        var s, o, c;
        a || (a = {}), this.options = a, o = a.writer || {};
        for (s in o)
          n.call(o, s) && (c = o[s], this["_" + s] = this[s], this[s] = c);
      }
      // Filters writer options and provides defaults
      // `options` writer options
      filterOptions(a) {
        var s, o, c, f, u, l, p, m, h;
        return a || (a = {}), a = r({}, this.options, a), s = {
          writer: this
        }, s.pretty = a.pretty || !1, s.allowEmpty = a.allowEmpty || !1, s.indent = (o = a.indent) != null ? o : "  ", s.newline = (c = a.newline) != null ? c : `
`, s.offset = (f = a.offset) != null ? f : 0, s.width = (u = a.width) != null ? u : 0, s.dontPrettyTextNodes = (l = (p = a.dontPrettyTextNodes) != null ? p : a.dontprettytextnodes) != null ? l : 0, s.spaceBeforeSlash = (m = (h = a.spaceBeforeSlash) != null ? h : a.spacebeforeslash) != null ? m : "", s.spaceBeforeSlash === !0 && (s.spaceBeforeSlash = " "), s.suppressPrettyCount = 0, s.user = {}, s.state = e.None, s;
      }
      // Returns the indentation string for the current level
      // `node` current node
      // `options` writer options
      // `level` current indentation level
      indent(a, s, o) {
        var c;
        return !s.pretty || s.suppressPrettyCount ? "" : s.pretty && (c = (o || 0) + s.offset + 1, c > 0) ? new Array(c).join(s.indent) : "";
      }
      // Returns the newline string
      // `node` current node
      // `options` writer options
      // `level` current indentation level
      endline(a, s, o) {
        return !s.pretty || s.suppressPrettyCount ? "" : s.newline;
      }
      attribute(a, s, o) {
        var c;
        return this.openAttribute(a, s, o), s.pretty && s.width > 0 ? c = a.name + '="' + a.value + '"' : c = " " + a.name + '="' + a.value + '"', this.closeAttribute(a, s, o), c;
      }
      cdata(a, s, o) {
        var c;
        return this.openNode(a, s, o), s.state = e.OpenTag, c = this.indent(a, s, o) + "<![CDATA[", s.state = e.InsideTag, c += a.value, s.state = e.CloseTag, c += "]]>" + this.endline(a, s, o), s.state = e.None, this.closeNode(a, s, o), c;
      }
      comment(a, s, o) {
        var c;
        return this.openNode(a, s, o), s.state = e.OpenTag, c = this.indent(a, s, o) + "<!-- ", s.state = e.InsideTag, c += a.value, s.state = e.CloseTag, c += " -->" + this.endline(a, s, o), s.state = e.None, this.closeNode(a, s, o), c;
      }
      declaration(a, s, o) {
        var c;
        return this.openNode(a, s, o), s.state = e.OpenTag, c = this.indent(a, s, o) + "<?xml", s.state = e.InsideTag, c += ' version="' + a.version + '"', a.encoding != null && (c += ' encoding="' + a.encoding + '"'), a.standalone != null && (c += ' standalone="' + a.standalone + '"'), s.state = e.CloseTag, c += s.spaceBeforeSlash + "?>", c += this.endline(a, s, o), s.state = e.None, this.closeNode(a, s, o), c;
      }
      docType(a, s, o) {
        var c, f, u, l, p;
        if (o || (o = 0), this.openNode(a, s, o), s.state = e.OpenTag, l = this.indent(a, s, o), l += "<!DOCTYPE " + a.root().name, a.pubID && a.sysID ? l += ' PUBLIC "' + a.pubID + '" "' + a.sysID + '"' : a.sysID && (l += ' SYSTEM "' + a.sysID + '"'), a.children.length > 0) {
          for (l += " [", l += this.endline(a, s, o), s.state = e.InsideTag, p = a.children, f = 0, u = p.length; f < u; f++)
            c = p[f], l += this.writeChildNode(c, s, o + 1);
          s.state = e.CloseTag, l += "]";
        }
        return s.state = e.CloseTag, l += s.spaceBeforeSlash + ">", l += this.endline(a, s, o), s.state = e.None, this.closeNode(a, s, o), l;
      }
      element(a, s, o) {
        var c, f, u, l, p, m, h, g, v, d, y, x, b, w, S, T, E, C, A;
        if (o || (o = 0), x = !1, this.openNode(a, s, o), s.state = e.OpenTag, b = this.indent(a, s, o) + "<" + a.name, s.pretty && s.width > 0) {
          g = b.length, S = a.attribs;
          for (y in S)
            n.call(S, y) && (c = S[y], w = this.attribute(c, s, o), f = w.length, g + f > s.width ? (A = this.indent(a, s, o + 1) + w, b += this.endline(a, s, o) + A, g = A.length) : (A = " " + w, b += A, g += A.length));
        } else {
          T = a.attribs;
          for (y in T)
            n.call(T, y) && (c = T[y], b += this.attribute(c, s, o));
        }
        if (l = a.children.length, p = l === 0 ? null : a.children[0], l === 0 || a.children.every(function(R) {
          return (R.type === t.Text || R.type === t.Raw || R.type === t.CData) && R.value === "";
        }))
          s.allowEmpty ? (b += ">", s.state = e.CloseTag, b += "</" + a.name + ">" + this.endline(a, s, o)) : (s.state = e.CloseTag, b += s.spaceBeforeSlash + "/>" + this.endline(a, s, o));
        else if (s.pretty && l === 1 && (p.type === t.Text || p.type === t.Raw || p.type === t.CData) && p.value != null)
          b += ">", s.state = e.InsideTag, s.suppressPrettyCount++, x = !0, b += this.writeChildNode(p, s, o + 1), s.suppressPrettyCount--, x = !1, s.state = e.CloseTag, b += "</" + a.name + ">" + this.endline(a, s, o);
        else {
          if (s.dontPrettyTextNodes) {
            for (E = a.children, m = 0, v = E.length; m < v; m++)
              if (u = E[m], (u.type === t.Text || u.type === t.Raw || u.type === t.CData) && u.value != null) {
                s.suppressPrettyCount++, x = !0;
                break;
              }
          }
          for (b += ">" + this.endline(a, s, o), s.state = e.InsideTag, C = a.children, h = 0, d = C.length; h < d; h++)
            u = C[h], b += this.writeChildNode(u, s, o + 1);
          s.state = e.CloseTag, b += this.indent(a, s, o) + "</" + a.name + ">", x && s.suppressPrettyCount--, b += this.endline(a, s, o), s.state = e.None;
        }
        return this.closeNode(a, s, o), b;
      }
      writeChildNode(a, s, o) {
        switch (a.type) {
          case t.CData:
            return this.cdata(a, s, o);
          case t.Comment:
            return this.comment(a, s, o);
          case t.Element:
            return this.element(a, s, o);
          case t.Raw:
            return this.raw(a, s, o);
          case t.Text:
            return this.text(a, s, o);
          case t.ProcessingInstruction:
            return this.processingInstruction(a, s, o);
          case t.Dummy:
            return "";
          case t.Declaration:
            return this.declaration(a, s, o);
          case t.DocType:
            return this.docType(a, s, o);
          case t.AttributeDeclaration:
            return this.dtdAttList(a, s, o);
          case t.ElementDeclaration:
            return this.dtdElement(a, s, o);
          case t.EntityDeclaration:
            return this.dtdEntity(a, s, o);
          case t.NotationDeclaration:
            return this.dtdNotation(a, s, o);
          default:
            throw new Error("Unknown XML node type: " + a.constructor.name);
        }
      }
      processingInstruction(a, s, o) {
        var c;
        return this.openNode(a, s, o), s.state = e.OpenTag, c = this.indent(a, s, o) + "<?", s.state = e.InsideTag, c += a.target, a.value && (c += " " + a.value), s.state = e.CloseTag, c += s.spaceBeforeSlash + "?>", c += this.endline(a, s, o), s.state = e.None, this.closeNode(a, s, o), c;
      }
      raw(a, s, o) {
        var c;
        return this.openNode(a, s, o), s.state = e.OpenTag, c = this.indent(a, s, o), s.state = e.InsideTag, c += a.value, s.state = e.CloseTag, c += this.endline(a, s, o), s.state = e.None, this.closeNode(a, s, o), c;
      }
      text(a, s, o) {
        var c;
        return this.openNode(a, s, o), s.state = e.OpenTag, c = this.indent(a, s, o), s.state = e.InsideTag, c += a.value, s.state = e.CloseTag, c += this.endline(a, s, o), s.state = e.None, this.closeNode(a, s, o), c;
      }
      dtdAttList(a, s, o) {
        var c;
        return this.openNode(a, s, o), s.state = e.OpenTag, c = this.indent(a, s, o) + "<!ATTLIST", s.state = e.InsideTag, c += " " + a.elementName + " " + a.attributeName + " " + a.attributeType, a.defaultValueType !== "#DEFAULT" && (c += " " + a.defaultValueType), a.defaultValue && (c += ' "' + a.defaultValue + '"'), s.state = e.CloseTag, c += s.spaceBeforeSlash + ">" + this.endline(a, s, o), s.state = e.None, this.closeNode(a, s, o), c;
      }
      dtdElement(a, s, o) {
        var c;
        return this.openNode(a, s, o), s.state = e.OpenTag, c = this.indent(a, s, o) + "<!ELEMENT", s.state = e.InsideTag, c += " " + a.name + " " + a.value, s.state = e.CloseTag, c += s.spaceBeforeSlash + ">" + this.endline(a, s, o), s.state = e.None, this.closeNode(a, s, o), c;
      }
      dtdEntity(a, s, o) {
        var c;
        return this.openNode(a, s, o), s.state = e.OpenTag, c = this.indent(a, s, o) + "<!ENTITY", s.state = e.InsideTag, a.pe && (c += " %"), c += " " + a.name, a.value ? c += ' "' + a.value + '"' : (a.pubID && a.sysID ? c += ' PUBLIC "' + a.pubID + '" "' + a.sysID + '"' : a.sysID && (c += ' SYSTEM "' + a.sysID + '"'), a.nData && (c += " NDATA " + a.nData)), s.state = e.CloseTag, c += s.spaceBeforeSlash + ">" + this.endline(a, s, o), s.state = e.None, this.closeNode(a, s, o), c;
      }
      dtdNotation(a, s, o) {
        var c;
        return this.openNode(a, s, o), s.state = e.OpenTag, c = this.indent(a, s, o) + "<!NOTATION", s.state = e.InsideTag, c += " " + a.name, a.pubID && a.sysID ? c += ' PUBLIC "' + a.pubID + '" "' + a.sysID + '"' : a.pubID ? c += ' PUBLIC "' + a.pubID + '"' : a.sysID && (c += ' SYSTEM "' + a.sysID + '"'), s.state = e.CloseTag, c += s.spaceBeforeSlash + ">" + this.endline(a, s, o), s.state = e.None, this.closeNode(a, s, o), c;
      }
      openNode(a, s, o) {
      }
      closeNode(a, s, o) {
      }
      openAttribute(a, s, o) {
      }
      closeAttribute(a, s, o) {
      }
    };
  }.call(ve)), $h.exports;
}
var oE;
function xy() {
  return oE || (oE = 1, function() {
    var t;
    t = W$(), Ah.exports = class extends t {
      // Initializes a new instance of `XMLStringWriter`
      // `options.pretty` pretty prints the result
      // `options.indent` indentation string
      // `options.newline` newline sequence
      // `options.offset` a fixed number of indentations to add to every line
      // `options.allowEmpty` do not self close empty element tags
      // 'options.dontPrettyTextNodes' if any text is present in node, don't indent or LF
      // `options.spaceBeforeSlash` add a space before the closing slash of empty elements
      constructor(r) {
        super(r);
      }
      document(r, n) {
        var i, a, s, o, c;
        for (n = this.filterOptions(n), o = "", c = r.children, a = 0, s = c.length; a < s; a++)
          i = c[a], o += this.writeChildNode(i, n, 0);
        return n.pretty && o.slice(-n.newline.length) === n.newline && (o = o.slice(0, -n.newline.length)), o;
      }
    };
  }.call(ve)), Ah.exports;
}
var cE;
function G$() {
  return cE || (cE = 1, function() {
    var t, e, r, n, i, a, s;
    ({ isPlainObject: s } = Ur()), r = B$(), e = Mpe(), n = Gt(), t = ot(), a = H$(), i = xy(), nh.exports = function() {
      class o extends n {
        // Initializes a new instance of `XMLDocument`
        // `options.keepNullNodes` whether nodes with null values will be kept
        //     or ignored: true or false
        // `options.keepNullAttributes` whether attributes with null values will be
        //     kept or ignored: true or false
        // `options.ignoreDecorators` whether decorator strings will be ignored when
        //     converting JS objects: true or false
        // `options.separateArrayItems` whether array items are created as separate
        //     nodes when passed as an object value: true or false
        // `options.noDoubleEncoding` whether existing html entities are encoded:
        //     true or false
        // `options.stringify` a set of functions to use for converting values to
        //     strings
        // `options.writer` the default XML writer to use for converting nodes to
        //     string. If the default writer is not set, the built-in XMLStringWriter
        //     will be used instead.
        constructor(f) {
          super(null), this.name = "#document", this.type = t.Document, this.documentURI = null, this.domConfig = new e(), f || (f = {}), f.writer || (f.writer = new i()), this.options = f, this.stringify = new a(f);
        }
        // Ends the document and passes it to the given XML writer
        // `writer` is either an XML writer or a plain object to pass to the
        // constructor of the default XML writer. The default writer is assigned when
        // creating the XML document. Following flags are recognized by the
        // built-in XMLStringWriter:
        //   `writer.pretty` pretty prints the result
        //   `writer.indent` indentation for pretty print
        //   `writer.offset` how many indentations to add to every line for pretty print
        //   `writer.newline` newline sequence for pretty print
        end(f) {
          var u;
          return u = {}, f ? s(f) && (u = f, f = this.options.writer) : f = this.options.writer, f.document(this, f.filterOptions(u));
        }
        // Converts the XML document to string
        // `options.pretty` pretty prints the result
        // `options.indent` indentation for pretty print
        // `options.offset` how many indentations to add to every line for pretty print
        // `options.newline` newline sequence for pretty print
        toString(f) {
          return this.options.writer.document(this, this.options.writer.filterOptions(f));
        }
        // DOM level 1 functions to be implemented later
        createElement(f) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        createDocumentFragment() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        createTextNode(f) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        createComment(f) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        createCDATASection(f) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        createProcessingInstruction(f, u) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        createAttribute(f) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        createEntityReference(f) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        getElementsByTagName(f) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        // DOM level 2 functions to be implemented later
        importNode(f, u) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        createElementNS(f, u) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        createAttributeNS(f, u) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        getElementsByTagNameNS(f, u) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        getElementById(f) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        // DOM level 3 functions to be implemented later
        adoptNode(f) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        normalizeDocument() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        renameNode(f, u, l) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        // DOM level 4 functions to be implemented later
        getElementsByClassName(f) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        createEvent(f) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        createRange() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        createNodeIterator(f, u, l) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
        createTreeWalker(f, u, l) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      }
      return Object.defineProperty(o.prototype, "implementation", {
        value: new r()
      }), Object.defineProperty(o.prototype, "doctype", {
        get: function() {
          var c, f, u, l;
          for (l = this.children, f = 0, u = l.length; f < u; f++)
            if (c = l[f], c.type === t.DocType)
              return c;
          return null;
        }
      }), Object.defineProperty(o.prototype, "documentElement", {
        get: function() {
          return this.rootObject || null;
        }
      }), Object.defineProperty(o.prototype, "inputEncoding", {
        get: function() {
          return null;
        }
      }), Object.defineProperty(o.prototype, "strictErrorChecking", {
        get: function() {
          return !1;
        }
      }), Object.defineProperty(o.prototype, "xmlEncoding", {
        get: function() {
          return this.children.length !== 0 && this.children[0].type === t.Declaration ? this.children[0].encoding : null;
        }
      }), Object.defineProperty(o.prototype, "xmlStandalone", {
        get: function() {
          return this.children.length !== 0 && this.children[0].type === t.Declaration ? this.children[0].standalone === "yes" : !1;
        }
      }), Object.defineProperty(o.prototype, "xmlVersion", {
        get: function() {
          return this.children.length !== 0 && this.children[0].type === t.Declaration ? this.children[0].version : "1.0";
        }
      }), Object.defineProperty(o.prototype, "URL", {
        get: function() {
          return this.documentURI;
        }
      }), Object.defineProperty(o.prototype, "origin", {
        get: function() {
          return null;
        }
      }), Object.defineProperty(o.prototype, "compatMode", {
        get: function() {
          return null;
        }
      }), Object.defineProperty(o.prototype, "characterSet", {
        get: function() {
          return null;
        }
      }), Object.defineProperty(o.prototype, "contentType", {
        get: function() {
          return null;
        }
      }), o;
    }.call(this);
  }.call(ve)), nh.exports;
}
var kh = { exports: {} }, uE;
function Fpe() {
  return uE || (uE = 1, function() {
    var t, e, r, n, i, a, s, o, c, f, u, l, p, m, h, g, v, d, y, x, b, w, S = {}.hasOwnProperty;
    ({ isObject: b, isFunction: x, isPlainObject: w, getValue: y } = Ur()), t = ot(), l = G$(), p = uy(), n = ly(), i = py(), h = yy(), d = by(), m = wy(), f = fy(), u = vy(), a = hy(), o = dy(), s = my(), c = gy(), r = U$(), v = H$(), g = xy(), e = Nu(), kh.exports = class {
      // Initializes a new instance of `XMLDocumentCB`
      // `options.keepNullNodes` whether nodes with null values will be kept
      //     or ignored: true or false
      // `options.keepNullAttributes` whether attributes with null values will be
      //     kept or ignored: true or false
      // `options.ignoreDecorators` whether decorator strings will be ignored when
      //     converting JS objects: true or false
      // `options.separateArrayItems` whether array items are created as separate
      //     nodes when passed as an object value: true or false
      // `options.noDoubleEncoding` whether existing html entities are encoded:
      //     true or false
      // `options.stringify` a set of functions to use for converting values to
      //     strings
      // `options.writer` the default XML writer to use for converting nodes to
      //     string. If the default writer is not set, the built-in XMLStringWriter
      //     will be used instead.
      // `onData` the function to be called when a new chunk of XML is output. The
      //          string containing the XML chunk is passed to `onData` as its first
      //          argument, and the current indentation level as its second argument.
      // `onEnd`  the function to be called when the XML document is completed with
      //          `end`. `onEnd` does not receive any arguments.
      constructor(E, C, A) {
        var R;
        this.name = "?xml", this.type = t.Document, E || (E = {}), R = {}, E.writer ? w(E.writer) && (R = E.writer, E.writer = new g()) : E.writer = new g(), this.options = E, this.writer = E.writer, this.writerOptions = this.writer.filterOptions(R), this.stringify = new v(E), this.onDataCallback = C || function() {
        }, this.onEndCallback = A || function() {
        }, this.currentNode = null, this.currentLevel = -1, this.openTags = {}, this.documentStarted = !1, this.documentCompleted = !1, this.root = null;
      }
      // Creates a child element node from the given XMLNode
      // `node` the child node
      createChildNode(E) {
        var C, A, R, D, F, K, V, ne;
        switch (E.type) {
          case t.CData:
            this.cdata(E.value);
            break;
          case t.Comment:
            this.comment(E.value);
            break;
          case t.Element:
            R = {}, V = E.attribs;
            for (A in V)
              S.call(V, A) && (C = V[A], R[A] = C.value);
            this.node(E.name, R);
            break;
          case t.Dummy:
            this.dummy();
            break;
          case t.Raw:
            this.raw(E.value);
            break;
          case t.Text:
            this.text(E.value);
            break;
          case t.ProcessingInstruction:
            this.instruction(E.target, E.value);
            break;
          default:
            throw new Error("This XML node type is not supported in a JS object: " + E.constructor.name);
        }
        for (ne = E.children, F = 0, K = ne.length; F < K; F++)
          D = ne[F], this.createChildNode(D), D.type === t.Element && this.up();
        return this;
      }
      // Creates a dummy node
      dummy() {
        return this;
      }
      // Creates a node
      // `name` name of the node
      // `attributes` an object containing name/value pairs of attributes
      // `text` element text
      node(E, C, A) {
        if (E == null)
          throw new Error("Missing node name.");
        if (this.root && this.currentLevel === -1)
          throw new Error("Document can only have one root node. " + this.debugInfo(E));
        return this.openCurrent(), E = y(E), C == null && (C = {}), C = y(C), b(C) || ([A, C] = [C, A]), this.currentNode = new p(this, E, C), this.currentNode.children = !1, this.currentLevel++, this.openTags[this.currentLevel] = this.currentNode, A != null && this.text(A), this;
      }
      // Creates a child element node or an element type declaration when called
      // inside the DTD
      // `name` name of the node
      // `attributes` an object containing name/value pairs of attributes
      // `text` element text
      element(E, C, A) {
        var R, D, F, K, V, ne;
        if (this.currentNode && this.currentNode.type === t.DocType)
          this.dtdElement(...arguments);
        else if (Array.isArray(E) || b(E) || x(E))
          for (K = this.options.noValidation, this.options.noValidation = !0, ne = new l(this.options).element("TEMP_ROOT"), ne.element(E), this.options.noValidation = K, V = ne.children, D = 0, F = V.length; D < F; D++)
            R = V[D], this.createChildNode(R), R.type === t.Element && this.up();
        else
          this.node(E, C, A);
        return this;
      }
      // Adds or modifies an attribute
      // `name` attribute name
      // `value` attribute value
      attribute(E, C) {
        var A, R;
        if (!this.currentNode || this.currentNode.children)
          throw new Error("att() can only be used immediately after an ele() call in callback mode. " + this.debugInfo(E));
        if (E != null && (E = y(E)), b(E))
          for (A in E)
            S.call(E, A) && (R = E[A], this.attribute(A, R));
        else
          x(C) && (C = C.apply()), this.options.keepNullAttributes && C == null ? this.currentNode.attribs[E] = new r(this, E, "") : C != null && (this.currentNode.attribs[E] = new r(this, E, C));
        return this;
      }
      // Creates a text node
      // `value` element text
      text(E) {
        var C;
        return this.openCurrent(), C = new d(this, E), this.onData(this.writer.text(C, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
      }
      // Creates a CDATA node
      // `value` element text without CDATA delimiters
      cdata(E) {
        var C;
        return this.openCurrent(), C = new n(this, E), this.onData(this.writer.cdata(C, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
      }
      // Creates a comment node
      // `value` comment text
      comment(E) {
        var C;
        return this.openCurrent(), C = new i(this, E), this.onData(this.writer.comment(C, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
      }
      // Adds unescaped raw text
      // `value` text
      raw(E) {
        var C;
        return this.openCurrent(), C = new h(this, E), this.onData(this.writer.raw(C, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
      }
      // Adds a processing instruction
      // `target` instruction target
      // `value` instruction value
      instruction(E, C) {
        var A, R, D, F, K;
        if (this.openCurrent(), E != null && (E = y(E)), C != null && (C = y(C)), Array.isArray(E))
          for (A = 0, F = E.length; A < F; A++)
            R = E[A], this.instruction(R);
        else if (b(E))
          for (R in E)
            S.call(E, R) && (D = E[R], this.instruction(R, D));
        else
          x(C) && (C = C.apply()), K = new m(this, E, C), this.onData(this.writer.processingInstruction(K, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      }
      // Creates the xml declaration
      // `version` A version number string, e.g. 1.0
      // `encoding` Encoding declaration, e.g. UTF-8
      // `standalone` standalone document declaration: true or false
      declaration(E, C, A) {
        var R;
        if (this.openCurrent(), this.documentStarted)
          throw new Error("declaration() must be the first node.");
        return R = new f(this, E, C, A), this.onData(this.writer.declaration(R, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
      }
      // Creates the document type declaration
      // `root`  the name of the root node
      // `pubID` the public identifier of the external subset
      // `sysID` the system identifier of the external subset
      doctype(E, C, A) {
        if (this.openCurrent(), E == null)
          throw new Error("Missing root node name.");
        if (this.root)
          throw new Error("dtd() must come before the root node.");
        return this.currentNode = new u(this, C, A), this.currentNode.rootNodeName = E, this.currentNode.children = !1, this.currentLevel++, this.openTags[this.currentLevel] = this.currentNode, this;
      }
      // Creates an element type declaration
      // `name` element name
      // `value` element content (defaults to #PCDATA)
      dtdElement(E, C) {
        var A;
        return this.openCurrent(), A = new s(this, E, C), this.onData(this.writer.dtdElement(A, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
      }
      // Creates an attribute declaration
      // `elementName` the name of the element containing this attribute
      // `attributeName` attribute name
      // `attributeType` type of the attribute (defaults to CDATA)
      // `defaultValueType` default value type (either #REQUIRED, #IMPLIED, #FIXED or
      //                    #DEFAULT) (defaults to #IMPLIED)
      // `defaultValue` default value of the attribute
      //                (only used for #FIXED or #DEFAULT)
      attList(E, C, A, R, D) {
        var F;
        return this.openCurrent(), F = new a(this, E, C, A, R, D), this.onData(this.writer.dtdAttList(F, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
      }
      // Creates a general entity declaration
      // `name` the name of the entity
      // `value` internal entity value or an object with external entity details
      // `value.pubID` public identifier
      // `value.sysID` system identifier
      // `value.nData` notation declaration
      entity(E, C) {
        var A;
        return this.openCurrent(), A = new o(this, !1, E, C), this.onData(this.writer.dtdEntity(A, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
      }
      // Creates a parameter entity declaration
      // `name` the name of the entity
      // `value` internal entity value or an object with external entity details
      // `value.pubID` public identifier
      // `value.sysID` system identifier
      pEntity(E, C) {
        var A;
        return this.openCurrent(), A = new o(this, !0, E, C), this.onData(this.writer.dtdEntity(A, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
      }
      // Creates a NOTATION declaration
      // `name` the name of the notation
      // `value` an object with external entity details
      // `value.pubID` public identifier
      // `value.sysID` system identifier
      notation(E, C) {
        var A;
        return this.openCurrent(), A = new c(this, E, C), this.onData(this.writer.dtdNotation(A, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
      }
      // Gets the parent node
      up() {
        if (this.currentLevel < 0)
          throw new Error("The document node has no parent.");
        return this.currentNode ? (this.currentNode.children ? this.closeNode(this.currentNode) : this.openNode(this.currentNode), this.currentNode = null) : this.closeNode(this.openTags[this.currentLevel]), delete this.openTags[this.currentLevel], this.currentLevel--, this;
      }
      // Ends the document
      end() {
        for (; this.currentLevel >= 0; )
          this.up();
        return this.onEnd();
      }
      // Opens the current parent node
      openCurrent() {
        if (this.currentNode)
          return this.currentNode.children = !0, this.openNode(this.currentNode);
      }
      // Writes the opening tag of the current node or the entire node if it has
      // no child nodes
      openNode(E) {
        var C, A, R, D;
        if (!E.isOpen) {
          if (!this.root && this.currentLevel === 0 && E.type === t.Element && (this.root = E), A = "", E.type === t.Element) {
            this.writerOptions.state = e.OpenTag, A = this.writer.indent(E, this.writerOptions, this.currentLevel) + "<" + E.name, D = E.attribs;
            for (R in D)
              S.call(D, R) && (C = D[R], A += this.writer.attribute(C, this.writerOptions, this.currentLevel));
            A += (E.children ? ">" : "/>") + this.writer.endline(E, this.writerOptions, this.currentLevel), this.writerOptions.state = e.InsideTag;
          } else
            this.writerOptions.state = e.OpenTag, A = this.writer.indent(E, this.writerOptions, this.currentLevel) + "<!DOCTYPE " + E.rootNodeName, E.pubID && E.sysID ? A += ' PUBLIC "' + E.pubID + '" "' + E.sysID + '"' : E.sysID && (A += ' SYSTEM "' + E.sysID + '"'), E.children ? (A += " [", this.writerOptions.state = e.InsideTag) : (this.writerOptions.state = e.CloseTag, A += ">"), A += this.writer.endline(E, this.writerOptions, this.currentLevel);
          return this.onData(A, this.currentLevel), E.isOpen = !0;
        }
      }
      // Writes the closing tag of the current node
      closeNode(E) {
        var C;
        if (!E.isClosed)
          return C = "", this.writerOptions.state = e.CloseTag, E.type === t.Element ? C = this.writer.indent(E, this.writerOptions, this.currentLevel) + "</" + E.name + ">" + this.writer.endline(E, this.writerOptions, this.currentLevel) : C = this.writer.indent(E, this.writerOptions, this.currentLevel) + "]>" + this.writer.endline(E, this.writerOptions, this.currentLevel), this.writerOptions.state = e.None, this.onData(C, this.currentLevel), E.isClosed = !0;
      }
      // Called when a new chunk of XML is output
      // `chunk` a string containing the XML chunk
      // `level` current indentation level
      onData(E, C) {
        return this.documentStarted = !0, this.onDataCallback(E, C + 1);
      }
      // Called when the XML document is completed
      onEnd() {
        return this.documentCompleted = !0, this.onEndCallback();
      }
      // Returns debug string
      debugInfo(E) {
        return E == null ? "" : "node: <" + E + ">";
      }
      // Node aliases
      ele() {
        return this.element(...arguments);
      }
      nod(E, C, A) {
        return this.node(E, C, A);
      }
      txt(E) {
        return this.text(E);
      }
      dat(E) {
        return this.cdata(E);
      }
      com(E) {
        return this.comment(E);
      }
      ins(E, C) {
        return this.instruction(E, C);
      }
      dec(E, C, A) {
        return this.declaration(E, C, A);
      }
      dtd(E, C, A) {
        return this.doctype(E, C, A);
      }
      e(E, C, A) {
        return this.element(E, C, A);
      }
      n(E, C, A) {
        return this.node(E, C, A);
      }
      t(E) {
        return this.text(E);
      }
      d(E) {
        return this.cdata(E);
      }
      c(E) {
        return this.comment(E);
      }
      r(E) {
        return this.raw(E);
      }
      i(E, C) {
        return this.instruction(E, C);
      }
      // Attribute aliases
      att() {
        return this.currentNode && this.currentNode.type === t.DocType ? this.attList(...arguments) : this.attribute(...arguments);
      }
      a() {
        return this.currentNode && this.currentNode.type === t.DocType ? this.attList(...arguments) : this.attribute(...arguments);
      }
      // DTD aliases
      // att() and ele() are defined above
      ent(E, C) {
        return this.entity(E, C);
      }
      pent(E, C) {
        return this.pEntity(E, C);
      }
      not(E, C) {
        return this.notation(E, C);
      }
    };
  }.call(ve)), kh.exports;
}
var Rh = { exports: {} }, lE;
function Bpe() {
  return lE || (lE = 1, function() {
    var t, e, r, n = {}.hasOwnProperty;
    t = ot(), r = W$(), e = Nu(), Rh.exports = class extends r {
      // Initializes a new instance of `XMLStreamWriter`
      // `stream` output stream
      // `options.pretty` pretty prints the result
      // `options.indent` indentation string
      // `options.newline` newline sequence
      // `options.offset` a fixed number of indentations to add to every line
      // `options.allowEmpty` do not self close empty element tags
      // 'options.dontPrettyTextNodes' if any text is present in node, don't indent or LF
      // `options.spaceBeforeSlash` add a space before the closing slash of empty elements
      constructor(a, s) {
        super(s), this.stream = a;
      }
      endline(a, s, o) {
        return a.isLastRootNode && s.state === e.CloseTag ? "" : super.endline(a, s, o);
      }
      document(a, s) {
        var o, c, f, u, l, p, m, h, g;
        for (m = a.children, c = f = 0, l = m.length; f < l; c = ++f)
          o = m[c], o.isLastRootNode = c === a.children.length - 1;
        for (s = this.filterOptions(s), h = a.children, g = [], u = 0, p = h.length; u < p; u++)
          o = h[u], g.push(this.writeChildNode(o, s, 0));
        return g;
      }
      cdata(a, s, o) {
        return this.stream.write(super.cdata(a, s, o));
      }
      comment(a, s, o) {
        return this.stream.write(super.comment(a, s, o));
      }
      declaration(a, s, o) {
        return this.stream.write(super.declaration(a, s, o));
      }
      docType(a, s, o) {
        var c, f, u, l;
        if (o || (o = 0), this.openNode(a, s, o), s.state = e.OpenTag, this.stream.write(this.indent(a, s, o)), this.stream.write("<!DOCTYPE " + a.root().name), a.pubID && a.sysID ? this.stream.write(' PUBLIC "' + a.pubID + '" "' + a.sysID + '"') : a.sysID && this.stream.write(' SYSTEM "' + a.sysID + '"'), a.children.length > 0) {
          for (this.stream.write(" ["), this.stream.write(this.endline(a, s, o)), s.state = e.InsideTag, l = a.children, f = 0, u = l.length; f < u; f++)
            c = l[f], this.writeChildNode(c, s, o + 1);
          s.state = e.CloseTag, this.stream.write("]");
        }
        return s.state = e.CloseTag, this.stream.write(s.spaceBeforeSlash + ">"), this.stream.write(this.endline(a, s, o)), s.state = e.None, this.closeNode(a, s, o);
      }
      element(a, s, o) {
        var c, f, u, l, p, m, h, g, v, d, y, x, b, w, S;
        if (o || (o = 0), this.openNode(a, s, o), s.state = e.OpenTag, d = this.indent(a, s, o) + "<" + a.name, s.pretty && s.width > 0) {
          h = d.length, x = a.attribs;
          for (v in x)
            n.call(x, v) && (c = x[v], y = this.attribute(c, s, o), f = y.length, h + f > s.width ? (S = this.indent(a, s, o + 1) + y, d += this.endline(a, s, o) + S, h = S.length) : (S = " " + y, d += S, h += S.length));
        } else {
          b = a.attribs;
          for (v in b)
            n.call(b, v) && (c = b[v], d += this.attribute(c, s, o));
        }
        if (this.stream.write(d), l = a.children.length, p = l === 0 ? null : a.children[0], l === 0 || a.children.every(function(T) {
          return (T.type === t.Text || T.type === t.Raw || T.type === t.CData) && T.value === "";
        }))
          s.allowEmpty ? (this.stream.write(">"), s.state = e.CloseTag, this.stream.write("</" + a.name + ">")) : (s.state = e.CloseTag, this.stream.write(s.spaceBeforeSlash + "/>"));
        else if (s.pretty && l === 1 && (p.type === t.Text || p.type === t.Raw || p.type === t.CData) && p.value != null)
          this.stream.write(">"), s.state = e.InsideTag, s.suppressPrettyCount++, this.writeChildNode(p, s, o + 1), s.suppressPrettyCount--, s.state = e.CloseTag, this.stream.write("</" + a.name + ">");
        else {
          for (this.stream.write(">" + this.endline(a, s, o)), s.state = e.InsideTag, w = a.children, m = 0, g = w.length; m < g; m++)
            u = w[m], this.writeChildNode(u, s, o + 1);
          s.state = e.CloseTag, this.stream.write(this.indent(a, s, o) + "</" + a.name + ">");
        }
        return this.stream.write(this.endline(a, s, o)), s.state = e.None, this.closeNode(a, s, o);
      }
      processingInstruction(a, s, o) {
        return this.stream.write(super.processingInstruction(a, s, o));
      }
      raw(a, s, o) {
        return this.stream.write(super.raw(a, s, o));
      }
      text(a, s, o) {
        return this.stream.write(super.text(a, s, o));
      }
      dtdAttList(a, s, o) {
        return this.stream.write(super.dtdAttList(a, s, o));
      }
      dtdElement(a, s, o) {
        return this.stream.write(super.dtdElement(a, s, o));
      }
      dtdEntity(a, s, o) {
        return this.stream.write(super.dtdEntity(a, s, o));
      }
      dtdNotation(a, s, o) {
        return this.stream.write(super.dtdNotation(a, s, o));
      }
    };
  }.call(ve)), Rh.exports;
}
(function() {
  var t, e, r, n, i, a, s, o, c;
  ({ assign: o, isFunction: c } = Ur()), r = B$(), n = G$(), i = Fpe(), s = xy(), a = Bpe(), t = ot(), e = Nu(), Rr.create = function(f, u, l, p) {
    var m, h;
    if (f == null)
      throw new Error("Root element needs a name.");
    return p = o({}, u, l, p), m = new n(p), h = m.element(f), p.headless || (m.declaration(p), (p.pubID != null || p.sysID != null) && m.dtd(p)), h;
  }, Rr.begin = function(f, u, l) {
    return c(f) && ([u, l] = [f, u], f = {}), u ? new i(f, u, l) : new n(f);
  }, Rr.stringWriter = function(f) {
    return new s(f);
  }, Rr.streamWriter = function(f, u) {
    return new a(f, u);
  }, Rr.implementation = new r(), Rr.nodeType = t, Rr.writerState = e;
}).call(ve);
var Upe = se, zpe = Rr, pE = F$, Hpe = function(t) {
  var e = pE.config(t);
  return zpe.create("lom", {
    version: "1.0",
    encoding: "utf-8"
  }).ele(pE.metadata(e)).end({
    pretty: !0,
    newline: Upe.EOL
  });
}, Wpe = Hpe, Gpe = se, Qpe = Rr, Vpe = se, fE = F$, Kpe = D$, Jpe = function(t, e) {
  var r = fE.config(e), n = Kpe(Vpe.normalize(e.source), "excludeManifestFiles");
  return r.files = n.map(function(i) {
    var a = {};
    return a["@href"] = i, a;
  }), Qpe.create("manifest", {
    version: "1.0",
    encoding: "utf-8",
    standalone: !1
  }).ele(fE[t](r)).end({
    pretty: !0,
    newline: Gpe.EOL
  });
}, Xpe = Jpe, Nh, hE;
function Zpe() {
  return hE || (hE = 1, Nh = typeof process == "object" && process && process.platform === "win32" ? { sep: "\\" } : { sep: "/" }), Nh;
}
var Lh, dE;
function Q$() {
  if (dE)
    return Lh;
  dE = 1, Lh = t;
  function t(n, i, a) {
    n instanceof RegExp && (n = e(n, a)), i instanceof RegExp && (i = e(i, a));
    var s = r(n, i, a);
    return s && {
      start: s[0],
      end: s[1],
      pre: a.slice(0, s[0]),
      body: a.slice(s[0] + n.length, s[1]),
      post: a.slice(s[1] + i.length)
    };
  }
  function e(n, i) {
    var a = i.match(n);
    return a ? a[0] : null;
  }
  t.range = r;
  function r(n, i, a) {
    var s, o, c, f, u, l = a.indexOf(n), p = a.indexOf(i, l + 1), m = l;
    if (l >= 0 && p > 0) {
      if (n === i)
        return [l, p];
      for (s = [], c = a.length; m >= 0 && !u; )
        m == l ? (s.push(m), l = a.indexOf(n, m + 1)) : s.length == 1 ? u = [s.pop(), p] : (o = s.pop(), o < c && (c = o, f = p), p = a.indexOf(i, m + 1)), m = l < p && l >= 0 ? l : p;
      s.length && (u = [c, f]);
    }
    return u;
  }
  return Lh;
}
var Ph, mE;
function Ype() {
  if (mE)
    return Ph;
  mE = 1;
  var t = Q$();
  Ph = u;
  var e = "\0SLASH" + Math.random() + "\0", r = "\0OPEN" + Math.random() + "\0", n = "\0CLOSE" + Math.random() + "\0", i = "\0COMMA" + Math.random() + "\0", a = "\0PERIOD" + Math.random() + "\0";
  function s(v) {
    return parseInt(v, 10) == v ? parseInt(v, 10) : v.charCodeAt(0);
  }
  function o(v) {
    return v.split("\\\\").join(e).split("\\{").join(r).split("\\}").join(n).split("\\,").join(i).split("\\.").join(a);
  }
  function c(v) {
    return v.split(e).join("\\").split(r).join("{").split(n).join("}").split(i).join(",").split(a).join(".");
  }
  function f(v) {
    if (!v)
      return [""];
    var d = [], y = t("{", "}", v);
    if (!y)
      return v.split(",");
    var x = y.pre, b = y.body, w = y.post, S = x.split(",");
    S[S.length - 1] += "{" + b + "}";
    var T = f(w);
    return w.length && (S[S.length - 1] += T.shift(), S.push.apply(S, T)), d.push.apply(d, S), d;
  }
  function u(v) {
    return v ? (v.substr(0, 2) === "{}" && (v = "\\{\\}" + v.substr(2)), g(o(v), !0).map(c)) : [];
  }
  function l(v) {
    return "{" + v + "}";
  }
  function p(v) {
    return /^-?0\d/.test(v);
  }
  function m(v, d) {
    return v <= d;
  }
  function h(v, d) {
    return v >= d;
  }
  function g(v, d) {
    var y = [], x = t("{", "}", v);
    if (!x)
      return [v];
    var b = x.pre, w = x.post.length ? g(x.post, !1) : [""];
    if (/\$$/.test(x.pre))
      for (var S = 0; S < w.length; S++) {
        var T = b + "{" + x.body + "}" + w[S];
        y.push(T);
      }
    else {
      var E = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(x.body), C = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(x.body), A = E || C, R = x.body.indexOf(",") >= 0;
      if (!A && !R)
        return x.post.match(/,.*\}/) ? (v = x.pre + "{" + x.body + n + x.post, g(v)) : [v];
      var D;
      if (A)
        D = x.body.split(/\.\./);
      else if (D = f(x.body), D.length === 1 && (D = g(D[0], !1).map(l), D.length === 1))
        return w.map(function(J) {
          return x.pre + D[0] + J;
        });
      var F;
      if (A) {
        var K = s(D[0]), V = s(D[1]), ne = Math.max(D[0].length, D[1].length), $ = D.length == 3 ? Math.abs(s(D[2])) : 1, L = m, P = V < K;
        P && ($ *= -1, L = h);
        var H = D.some(p);
        F = [];
        for (var Q = K; L(Q, V); Q += $) {
          var Y;
          if (C)
            Y = String.fromCharCode(Q), Y === "\\" && (Y = "");
          else if (Y = String(Q), H) {
            var ce = ne - Y.length;
            if (ce > 0) {
              var ue = new Array(ce + 1).join("0");
              Q < 0 ? Y = "-" + ue + Y.slice(1) : Y = ue + Y;
            }
          }
          F.push(Y);
        }
      } else {
        F = [];
        for (var me = 0; me < D.length; me++)
          F.push.apply(F, g(D[me], !1));
      }
      for (var me = 0; me < F.length; me++)
        for (var S = 0; S < w.length; S++) {
          var T = b + F[me] + w[S];
          (!d || A || T) && y.push(T);
        }
    }
    return y;
  }
  return Ph;
}
var ao, gE;
function efe() {
  if (gE)
    return ao;
  gE = 1;
  const t = ao = (T, E, C = {}) => (v(E), !C.nocomment && E.charAt(0) === "#" ? !1 : new S(E, C).match(T));
  ao = t;
  const e = Zpe();
  t.sep = e.sep;
  const r = Symbol("globstar **");
  t.GLOBSTAR = r;
  const n = Ype(), i = {
    "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
    "?": { open: "(?:", close: ")?" },
    "+": { open: "(?:", close: ")+" },
    "*": { open: "(?:", close: ")*" },
    "@": { open: "(?:", close: ")" }
  }, a = "[^/]", s = a + "*?", o = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?", c = "(?:(?!(?:\\/|^)\\.).)*?", f = (T) => T.split("").reduce((E, C) => (E[C] = !0, E), {}), u = f("().*{}+?[]^$\\!"), l = f("[.("), p = /\/+/;
  t.filter = (T, E = {}) => (C, A, R) => t(C, T, E);
  const m = (T, E = {}) => {
    const C = {};
    return Object.keys(T).forEach((A) => C[A] = T[A]), Object.keys(E).forEach((A) => C[A] = E[A]), C;
  };
  t.defaults = (T) => {
    if (!T || typeof T != "object" || !Object.keys(T).length)
      return t;
    const E = t, C = (A, R, D) => E(A, R, m(T, D));
    return C.Minimatch = class extends E.Minimatch {
      constructor(R, D) {
        super(R, m(T, D));
      }
    }, C.Minimatch.defaults = (A) => E.defaults(m(T, A)).Minimatch, C.filter = (A, R) => E.filter(A, m(T, R)), C.defaults = (A) => E.defaults(m(T, A)), C.makeRe = (A, R) => E.makeRe(A, m(T, R)), C.braceExpand = (A, R) => E.braceExpand(A, m(T, R)), C.match = (A, R, D) => E.match(A, R, m(T, D)), C;
  }, t.braceExpand = (T, E) => h(T, E);
  const h = (T, E = {}) => (v(T), E.nobrace || !/\{(?:(?!\{).)*\}/.test(T) ? [T] : n(T)), g = 1024 * 64, v = (T) => {
    if (typeof T != "string")
      throw new TypeError("invalid pattern");
    if (T.length > g)
      throw new TypeError("pattern is too long");
  }, d = Symbol("subparse");
  t.makeRe = (T, E) => new S(T, E || {}).makeRe(), t.match = (T, E, C = {}) => {
    const A = new S(E, C);
    return T = T.filter((R) => A.match(R)), A.options.nonull && !T.length && T.push(E), T;
  };
  const y = (T) => T.replace(/\\(.)/g, "$1"), x = (T) => T.replace(/\\([^-\]])/g, "$1"), b = (T) => T.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), w = (T) => T.replace(/[[\]\\]/g, "\\$&");
  class S {
    constructor(E, C) {
      v(E), C || (C = {}), this.options = C, this.set = [], this.pattern = E, this.windowsPathsNoEscape = !!C.windowsPathsNoEscape || C.allowWindowsEscape === !1, this.windowsPathsNoEscape && (this.pattern = this.pattern.replace(/\\/g, "/")), this.regexp = null, this.negate = !1, this.comment = !1, this.empty = !1, this.partial = !!C.partial, this.make();
    }
    debug() {
    }
    make() {
      const E = this.pattern, C = this.options;
      if (!C.nocomment && E.charAt(0) === "#") {
        this.comment = !0;
        return;
      }
      if (!E) {
        this.empty = !0;
        return;
      }
      this.parseNegate();
      let A = this.globSet = this.braceExpand();
      C.debug && (this.debug = (...R) => console.error(...R)), this.debug(this.pattern, A), A = this.globParts = A.map((R) => R.split(p)), this.debug(this.pattern, A), A = A.map((R, D, F) => R.map(this.parse, this)), this.debug(this.pattern, A), A = A.filter((R) => R.indexOf(!1) === -1), this.debug(this.pattern, A), this.set = A;
    }
    parseNegate() {
      if (this.options.nonegate)
        return;
      const E = this.pattern;
      let C = !1, A = 0;
      for (let R = 0; R < E.length && E.charAt(R) === "!"; R++)
        C = !C, A++;
      A && (this.pattern = E.slice(A)), this.negate = C;
    }
    // set partial to true to test if, for example,
    // "/a/b" matches the start of "/*/b/*/d"
    // Partial means, if you run out of file before you run
    // out of pattern, then that's fine, as long as all
    // the parts match.
    matchOne(E, C, A) {
      var R = this.options;
      this.debug(
        "matchOne",
        { this: this, file: E, pattern: C }
      ), this.debug("matchOne", E.length, C.length);
      for (var D = 0, F = 0, K = E.length, V = C.length; D < K && F < V; D++, F++) {
        this.debug("matchOne loop");
        var ne = C[F], $ = E[D];
        if (this.debug(C, ne, $), ne === !1)
          return !1;
        if (ne === r) {
          this.debug("GLOBSTAR", [C, ne, $]);
          var L = D, P = F + 1;
          if (P === V) {
            for (this.debug("** at the end"); D < K; D++)
              if (E[D] === "." || E[D] === ".." || !R.dot && E[D].charAt(0) === ".")
                return !1;
            return !0;
          }
          for (; L < K; ) {
            var H = E[L];
            if (this.debug(`
globstar while`, E, L, C, P, H), this.matchOne(E.slice(L), C.slice(P), A))
              return this.debug("globstar found match!", L, K, H), !0;
            if (H === "." || H === ".." || !R.dot && H.charAt(0) === ".") {
              this.debug("dot detected!", E, L, C, P);
              break;
            }
            this.debug("globstar swallow a segment, and continue"), L++;
          }
          return !!(A && (this.debug(`
>>> no match, partial?`, E, L, C, P), L === K));
        }
        var Q;
        if (typeof ne == "string" ? (Q = $ === ne, this.debug("string match", ne, $, Q)) : (Q = $.match(ne), this.debug("pattern match", ne, $, Q)), !Q)
          return !1;
      }
      if (D === K && F === V)
        return !0;
      if (D === K)
        return A;
      if (F === V)
        return D === K - 1 && E[D] === "";
      throw new Error("wtf?");
    }
    braceExpand() {
      return h(this.pattern, this.options);
    }
    parse(E, C) {
      v(E);
      const A = this.options;
      if (E === "**")
        if (A.noglobstar)
          E = "*";
        else
          return r;
      if (E === "")
        return "";
      let R = "", D = !1, F = !1;
      const K = [], V = [];
      let ne, $ = !1, L = -1, P = -1, H, Q, Y, ce = E.charAt(0) === ".", ue = A.dot || ce;
      const me = () => ce ? "" : ue ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)", J = (G) => G.charAt(0) === "." ? "" : A.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)", O = () => {
        if (ne) {
          switch (ne) {
            case "*":
              R += s, D = !0;
              break;
            case "?":
              R += a, D = !0;
              break;
            default:
              R += "\\" + ne;
              break;
          }
          this.debug("clearStateChar %j %j", ne, R), ne = !1;
        }
      };
      for (let G = 0, q; G < E.length && (q = E.charAt(G)); G++) {
        if (this.debug("%s	%s %s %j", E, G, R, q), F) {
          if (q === "/")
            return !1;
          u[q] && (R += "\\"), R += q, F = !1;
          continue;
        }
        switch (q) {
          case "/":
            return !1;
          case "\\":
            if ($ && E.charAt(G + 1) === "-") {
              R += q;
              continue;
            }
            O(), F = !0;
            continue;
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            if (this.debug("%s	%s %s %j <-- stateChar", E, G, R, q), $) {
              this.debug("  in class"), q === "!" && G === P + 1 && (q = "^"), R += q;
              continue;
            }
            this.debug("call clearStateChar %j", ne), O(), ne = q, A.noext && O();
            continue;
          case "(": {
            if ($) {
              R += "(";
              continue;
            }
            if (!ne) {
              R += "\\(";
              continue;
            }
            const M = {
              type: ne,
              start: G - 1,
              reStart: R.length,
              open: i[ne].open,
              close: i[ne].close
            };
            this.debug(this.pattern, "	", M), K.push(M), R += M.open, M.start === 0 && M.type !== "!" && (ce = !0, R += J(E.slice(G + 1))), this.debug("plType %j %j", ne, R), ne = !1;
            continue;
          }
          case ")": {
            const M = K[K.length - 1];
            if ($ || !M) {
              R += "\\)";
              continue;
            }
            K.pop(), O(), D = !0, Q = M, R += Q.close, Q.type === "!" && V.push(Object.assign(Q, { reEnd: R.length }));
            continue;
          }
          case "|": {
            const M = K[K.length - 1];
            if ($ || !M) {
              R += "\\|";
              continue;
            }
            O(), R += "|", M.start === 0 && M.type !== "!" && (ce = !0, R += J(E.slice(G + 1)));
            continue;
          }
          case "[":
            if (O(), $) {
              R += "\\" + q;
              continue;
            }
            $ = !0, P = G, L = R.length, R += q;
            continue;
          case "]":
            if (G === P + 1 || !$) {
              R += "\\" + q;
              continue;
            }
            H = E.substring(P + 1, G);
            try {
              RegExp("[" + w(x(H)) + "]"), R += q;
            } catch {
              R = R.substring(0, L) + "(?:$.)";
            }
            D = !0, $ = !1;
            continue;
          default:
            O(), u[q] && !(q === "^" && $) && (R += "\\"), R += q;
            break;
        }
      }
      for ($ && (H = E.slice(P + 1), Y = this.parse(H, d), R = R.substring(0, L) + "\\[" + Y[0], D = D || Y[1]), Q = K.pop(); Q; Q = K.pop()) {
        let G;
        G = R.slice(Q.reStart + Q.open.length), this.debug("setting tail", R, Q), G = G.replace(/((?:\\{2}){0,64})(\\?)\|/g, (M, Z, B) => (B || (B = "\\"), Z + Z + B + "|")), this.debug(`tail=%j
   %s`, G, G, Q, R);
        const q = Q.type === "*" ? s : Q.type === "?" ? a : "\\" + Q.type;
        D = !0, R = R.slice(0, Q.reStart) + q + "\\(" + G;
      }
      O(), F && (R += "\\\\");
      const I = l[R.charAt(0)];
      for (let G = V.length - 1; G > -1; G--) {
        const q = V[G], M = R.slice(0, q.reStart), Z = R.slice(q.reStart, q.reEnd - 8);
        let B = R.slice(q.reEnd);
        const re = R.slice(q.reEnd - 8, q.reEnd) + B, j = M.split(")").length, k = M.split("(").length - j;
        let N = B;
        for (let ee = 0; ee < k; ee++)
          N = N.replace(/\)[+*?]?/, "");
        B = N;
        const U = B === "" && C !== d ? "(?:$|\\/)" : "";
        R = M + Z + B + U + re;
      }
      if (R !== "" && D && (R = "(?=.)" + R), I && (R = me() + R), C === d)
        return [R, D];
      if (A.nocase && !D && (D = E.toUpperCase() !== E.toLowerCase()), !D)
        return y(E);
      const z = A.nocase ? "i" : "";
      try {
        return Object.assign(new RegExp("^" + R + "$", z), {
          _glob: E,
          _src: R
        });
      } catch {
        return new RegExp("$.");
      }
    }
    makeRe() {
      if (this.regexp || this.regexp === !1)
        return this.regexp;
      const E = this.set;
      if (!E.length)
        return this.regexp = !1, this.regexp;
      const C = this.options, A = C.noglobstar ? s : C.dot ? o : c, R = C.nocase ? "i" : "";
      let D = E.map((F) => (F = F.map(
        (K) => typeof K == "string" ? b(K) : K === r ? r : K._src
      ).reduce((K, V) => (K[K.length - 1] === r && V === r || K.push(V), K), []), F.forEach((K, V) => {
        K !== r || F[V - 1] === r || (V === 0 ? F.length > 1 ? F[V + 1] = "(?:\\/|" + A + "\\/)?" + F[V + 1] : F[V] = A : V === F.length - 1 ? F[V - 1] += "(?:\\/|" + A + ")?" : (F[V - 1] += "(?:\\/|\\/" + A + "\\/)" + F[V + 1], F[V + 1] = r));
      }), F.filter((K) => K !== r).join("/"))).join("|");
      D = "^(?:" + D + ")$", this.negate && (D = "^(?!" + D + ").*$");
      try {
        this.regexp = new RegExp(D, R);
      } catch {
        this.regexp = !1;
      }
      return this.regexp;
    }
    match(E, C = this.partial) {
      if (this.debug("match", E, this.pattern), this.comment)
        return !1;
      if (this.empty)
        return E === "";
      if (E === "/" && C)
        return !0;
      const A = this.options;
      e.sep !== "/" && (E = E.split(e.sep).join("/")), E = E.split(p), this.debug(this.pattern, "split", E);
      const R = this.set;
      this.debug(this.pattern, "set", R);
      let D;
      for (let F = E.length - 1; F >= 0 && (D = E[F], !D); F--)
        ;
      for (let F = 0; F < R.length; F++) {
        const K = R[F];
        let V = E;
        if (A.matchBase && K.length === 1 && (V = [D]), this.matchOne(V, K, C))
          return A.flipNegate ? !0 : !this.negate;
      }
      return A.flipNegate ? !1 : this.negate;
    }
    static defaults(E) {
      return t.defaults(E).Minimatch;
    }
  }
  return t.Minimatch = S, ao;
}
var Dh, vE;
function tfe() {
  if (vE)
    return Dh;
  vE = 1, Dh = u;
  const t = se, { EventEmitter: e } = bt, { Minimatch: r } = efe(), { resolve: n } = se;
  function i(l, p) {
    return new Promise((m, h) => {
      t.readdir(l, { withFileTypes: !0 }, (g, v) => {
        if (g)
          switch (g.code) {
            case "ENOTDIR":
              p ? h(g) : m([]);
              break;
            case "ENOTSUP":
            case "ENOENT":
            case "ENAMETOOLONG":
            case "UNKNOWN":
              m([]);
              break;
            case "ELOOP":
            default:
              h(g);
              break;
          }
        else
          m(v);
      });
    });
  }
  function a(l, p) {
    return new Promise((m, h) => {
      (p ? t.stat : t.lstat)(l, (v, d) => {
        if (v)
          switch (v.code) {
            case "ENOENT":
              m(p ? a(l, !1) : null);
              break;
            default:
              m(null);
              break;
          }
        else
          m(d);
      });
    });
  }
  async function* s(l, p, m, h, g, v) {
    let d = await i(p + l, v);
    for (const y of d) {
      let x = y.name;
      x === void 0 && (x = y, h = !0);
      const b = l + "/" + x, w = b.slice(1), S = p + "/" + w;
      let T = null;
      (h || m) && (T = await a(S, m)), !T && y.name !== void 0 && (T = y), T === null && (T = { isDirectory: () => !1 }), T.isDirectory() ? g(w) || (yield { relative: w, absolute: S, stats: T }, yield* s(b, p, m, h, g, !1)) : yield { relative: w, absolute: S, stats: T };
    }
  }
  async function* o(l, p, m, h) {
    yield* s("", l, p, m, h, !0);
  }
  function c(l) {
    return {
      pattern: l.pattern,
      dot: !!l.dot,
      noglobstar: !!l.noglobstar,
      matchBase: !!l.matchBase,
      nocase: !!l.nocase,
      ignore: l.ignore,
      skip: l.skip,
      follow: !!l.follow,
      stat: !!l.stat,
      nodir: !!l.nodir,
      mark: !!l.mark,
      silent: !!l.silent,
      absolute: !!l.absolute
    };
  }
  class f extends e {
    constructor(p, m, h) {
      if (super(), typeof m == "function" && (h = m, m = null), this.options = c(m || {}), this.matchers = [], this.options.pattern) {
        const g = Array.isArray(this.options.pattern) ? this.options.pattern : [this.options.pattern];
        this.matchers = g.map(
          (v) => new r(v, {
            dot: this.options.dot,
            noglobstar: this.options.noglobstar,
            matchBase: this.options.matchBase,
            nocase: this.options.nocase
          })
        );
      }
      if (this.ignoreMatchers = [], this.options.ignore) {
        const g = Array.isArray(this.options.ignore) ? this.options.ignore : [this.options.ignore];
        this.ignoreMatchers = g.map(
          (v) => new r(v, { dot: !0 })
        );
      }
      if (this.skipMatchers = [], this.options.skip) {
        const g = Array.isArray(this.options.skip) ? this.options.skip : [this.options.skip];
        this.skipMatchers = g.map(
          (v) => new r(v, { dot: !0 })
        );
      }
      this.iterator = o(n(p || "."), this.options.follow, this.options.stat, this._shouldSkipDirectory.bind(this)), this.paused = !1, this.inactive = !1, this.aborted = !1, h && (this._matches = [], this.on("match", (g) => this._matches.push(this.options.absolute ? g.absolute : g.relative)), this.on("error", (g) => h(g)), this.on("end", () => h(null, this._matches))), setTimeout(() => this._next(), 0);
    }
    _shouldSkipDirectory(p) {
      return this.skipMatchers.some((m) => m.match(p));
    }
    _fileMatches(p, m) {
      const h = p + (m ? "/" : "");
      return (this.matchers.length === 0 || this.matchers.some((g) => g.match(h))) && !this.ignoreMatchers.some((g) => g.match(h)) && (!this.options.nodir || !m);
    }
    _next() {
      !this.paused && !this.aborted ? this.iterator.next().then((p) => {
        if (p.done)
          this.emit("end");
        else {
          const m = p.value.stats.isDirectory();
          if (this._fileMatches(p.value.relative, m)) {
            let h = p.value.relative, g = p.value.absolute;
            this.options.mark && m && (h += "/", g += "/"), this.options.stat ? this.emit("match", { relative: h, absolute: g, stat: p.value.stats }) : this.emit("match", { relative: h, absolute: g });
          }
          this._next(this.iterator);
        }
      }).catch((p) => {
        this.abort(), this.emit("error", p), !p.code && !this.options.silent && console.error(p);
      }) : this.inactive = !0;
    }
    abort() {
      this.aborted = !0;
    }
    pause() {
      this.paused = !0;
    }
    resume() {
      this.paused = !1, this.inactive && (this.inactive = !1, this._next());
    }
  }
  function u(l, p, m) {
    return new f(l, p, m);
  }
  return u.ReaddirGlob = f, Dh;
}
var Mh = { exports: {} }, so = { exports: {} }, oo = { exports: {} }, yE;
function mn() {
  if (yE)
    return oo.exports;
  yE = 1, typeof process > "u" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0 ? oo.exports = { nextTick: t } : oo.exports = process;
  function t(e, r, n, i) {
    if (typeof e != "function")
      throw new TypeError('"callback" argument must be a function');
    var a = arguments.length, s, o;
    switch (a) {
      case 0:
      case 1:
        return process.nextTick(e);
      case 2:
        return process.nextTick(function() {
          e.call(null, r);
        });
      case 3:
        return process.nextTick(function() {
          e.call(null, r, n);
        });
      case 4:
        return process.nextTick(function() {
          e.call(null, r, n, i);
        });
      default:
        for (s = new Array(a - 1), o = 0; o < s.length; )
          s[o++] = arguments[o];
        return process.nextTick(function() {
          e.apply(null, s);
        });
    }
  }
  return oo.exports;
}
var qh, bE;
function rfe() {
  if (bE)
    return qh;
  bE = 1;
  var t = {}.toString;
  return qh = Array.isArray || function(e) {
    return t.call(e) == "[object Array]";
  }, qh;
}
var jh, wE;
function V$() {
  return wE || (wE = 1, jh = bt.EventEmitter), jh;
}
var co = { exports: {} }, xE;
function Lu() {
  return xE || (xE = 1, function(t, e) {
    var r = rr, n = r.Buffer;
    function i(s, o) {
      for (var c in s)
        o[c] = s[c];
    }
    n.from && n.alloc && n.allocUnsafe && n.allocUnsafeSlow ? t.exports = r : (i(r, e), e.Buffer = a);
    function a(s, o, c) {
      return n(s, o, c);
    }
    i(n, a), a.from = function(s, o, c) {
      if (typeof s == "number")
        throw new TypeError("Argument must not be a number");
      return n(s, o, c);
    }, a.alloc = function(s, o, c) {
      if (typeof s != "number")
        throw new TypeError("Argument must be a number");
      var f = n(s);
      return o !== void 0 ? typeof c == "string" ? f.fill(o, c) : f.fill(o) : f.fill(0), f;
    }, a.allocUnsafe = function(s) {
      if (typeof s != "number")
        throw new TypeError("Argument must be a number");
      return n(s);
    }, a.allocUnsafeSlow = function(s) {
      if (typeof s != "number")
        throw new TypeError("Argument must be a number");
      return r.SlowBuffer(s);
    };
  }(co, co.exports)), co.exports;
}
var mt = {}, _E;
function Sr() {
  if (_E)
    return mt;
  _E = 1;
  function t(g) {
    return Array.isArray ? Array.isArray(g) : h(g) === "[object Array]";
  }
  mt.isArray = t;
  function e(g) {
    return typeof g == "boolean";
  }
  mt.isBoolean = e;
  function r(g) {
    return g === null;
  }
  mt.isNull = r;
  function n(g) {
    return g == null;
  }
  mt.isNullOrUndefined = n;
  function i(g) {
    return typeof g == "number";
  }
  mt.isNumber = i;
  function a(g) {
    return typeof g == "string";
  }
  mt.isString = a;
  function s(g) {
    return typeof g == "symbol";
  }
  mt.isSymbol = s;
  function o(g) {
    return g === void 0;
  }
  mt.isUndefined = o;
  function c(g) {
    return h(g) === "[object RegExp]";
  }
  mt.isRegExp = c;
  function f(g) {
    return typeof g == "object" && g !== null;
  }
  mt.isObject = f;
  function u(g) {
    return h(g) === "[object Date]";
  }
  mt.isDate = u;
  function l(g) {
    return h(g) === "[object Error]" || g instanceof Error;
  }
  mt.isError = l;
  function p(g) {
    return typeof g == "function";
  }
  mt.isFunction = p;
  function m(g) {
    return g === null || typeof g == "boolean" || typeof g == "number" || typeof g == "string" || typeof g == "symbol" || // ES6 symbol
    typeof g > "u";
  }
  mt.isPrimitive = m, mt.isBuffer = rr.Buffer.isBuffer;
  function h(g) {
    return Object.prototype.toString.call(g);
  }
  return mt;
}
var Fh = { exports: {} }, EE;
function nfe() {
  return EE || (EE = 1, function(t) {
    function e(a, s) {
      if (!(a instanceof s))
        throw new TypeError("Cannot call a class as a function");
    }
    var r = Lu().Buffer, n = se;
    function i(a, s, o) {
      a.copy(s, o);
    }
    t.exports = function() {
      function a() {
        e(this, a), this.head = null, this.tail = null, this.length = 0;
      }
      return a.prototype.push = function(o) {
        var c = { data: o, next: null };
        this.length > 0 ? this.tail.next = c : this.head = c, this.tail = c, ++this.length;
      }, a.prototype.unshift = function(o) {
        var c = { data: o, next: this.head };
        this.length === 0 && (this.tail = c), this.head = c, ++this.length;
      }, a.prototype.shift = function() {
        if (this.length !== 0) {
          var o = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, o;
        }
      }, a.prototype.clear = function() {
        this.head = this.tail = null, this.length = 0;
      }, a.prototype.join = function(o) {
        if (this.length === 0)
          return "";
        for (var c = this.head, f = "" + c.data; c = c.next; )
          f += o + c.data;
        return f;
      }, a.prototype.concat = function(o) {
        if (this.length === 0)
          return r.alloc(0);
        for (var c = r.allocUnsafe(o >>> 0), f = this.head, u = 0; f; )
          i(f.data, c, u), u += f.data.length, f = f.next;
        return c;
      }, a;
    }(), n && n.inspect && n.inspect.custom && (t.exports.prototype[n.inspect.custom] = function() {
      var a = n.inspect({ length: this.length });
      return this.constructor.name + " " + a;
    });
  }(Fh)), Fh.exports;
}
var Bh, SE;
function K$() {
  if (SE)
    return Bh;
  SE = 1;
  var t = mn();
  function e(i, a) {
    var s = this, o = this._readableState && this._readableState.destroyed, c = this._writableState && this._writableState.destroyed;
    return o || c ? (a ? a(i) : i && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, t.nextTick(n, this, i)) : t.nextTick(n, this, i)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(i || null, function(f) {
      !a && f ? s._writableState ? s._writableState.errorEmitted || (s._writableState.errorEmitted = !0, t.nextTick(n, s, f)) : t.nextTick(n, s, f) : a && a(f);
    }), this);
  }
  function r() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function n(i, a) {
    i.emit("error", a);
  }
  return Bh = {
    destroy: e,
    undestroy: r
  }, Bh;
}
var Uh, CE;
function _y() {
  if (CE)
    return Uh;
  CE = 1, Uh = t;
  function t(r, n) {
    if (e("noDeprecation"))
      return r;
    var i = !1;
    function a() {
      if (!i) {
        if (e("throwDeprecation"))
          throw new Error(n);
        e("traceDeprecation") ? console.trace(n) : console.warn(n), i = !0;
      }
      return r.apply(this, arguments);
    }
    return a;
  }
  function e(r) {
    try {
      if (!ve.localStorage)
        return !1;
    } catch {
      return !1;
    }
    var n = ve.localStorage[r];
    return n == null ? !1 : String(n).toLowerCase() === "true";
  }
  return Uh;
}
var zh, TE;
function J$() {
  if (TE)
    return zh;
  TE = 1;
  var t = mn();
  zh = g;
  function e($) {
    var L = this;
    this.next = null, this.entry = null, this.finish = function() {
      ne(L, $);
    };
  }
  var r = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : t.nextTick, n;
  g.WritableState = m;
  var i = Object.create(Sr());
  i.inherits = ct();
  var a = {
    deprecate: _y()
  }, s = V$(), o = Lu().Buffer, c = (typeof ve < "u" ? ve : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function f($) {
    return o.from($);
  }
  function u($) {
    return o.isBuffer($) || $ instanceof c;
  }
  var l = K$();
  i.inherits(g, s);
  function p() {
  }
  function m($, L) {
    n = n || Si(), $ = $ || {};
    var P = L instanceof n;
    this.objectMode = !!$.objectMode, P && (this.objectMode = this.objectMode || !!$.writableObjectMode);
    var H = $.highWaterMark, Q = $.writableHighWaterMark, Y = this.objectMode ? 16 : 16 * 1024;
    H || H === 0 ? this.highWaterMark = H : P && (Q || Q === 0) ? this.highWaterMark = Q : this.highWaterMark = Y, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var ce = $.decodeStrings === !1;
    this.decodeStrings = !ce, this.defaultEncoding = $.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(ue) {
      T(L, ue);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new e(this);
  }
  m.prototype.getBuffer = function() {
    for (var L = this.bufferedRequest, P = []; L; )
      P.push(L), L = L.next;
    return P;
  }, function() {
    try {
      Object.defineProperty(m.prototype, "buffer", {
        get: a.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var h;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (h = Function.prototype[Symbol.hasInstance], Object.defineProperty(g, Symbol.hasInstance, {
    value: function($) {
      return h.call(this, $) ? !0 : this !== g ? !1 : $ && $._writableState instanceof m;
    }
  })) : h = function($) {
    return $ instanceof this;
  };
  function g($) {
    if (n = n || Si(), !h.call(g, this) && !(this instanceof n))
      return new g($);
    this._writableState = new m($, this), this.writable = !0, $ && (typeof $.write == "function" && (this._write = $.write), typeof $.writev == "function" && (this._writev = $.writev), typeof $.destroy == "function" && (this._destroy = $.destroy), typeof $.final == "function" && (this._final = $.final)), s.call(this);
  }
  g.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function v($, L) {
    var P = new Error("write after end");
    $.emit("error", P), t.nextTick(L, P);
  }
  function d($, L, P, H) {
    var Q = !0, Y = !1;
    return P === null ? Y = new TypeError("May not write null values to stream") : typeof P != "string" && P !== void 0 && !L.objectMode && (Y = new TypeError("Invalid non-string/buffer chunk")), Y && ($.emit("error", Y), t.nextTick(H, Y), Q = !1), Q;
  }
  g.prototype.write = function($, L, P) {
    var H = this._writableState, Q = !1, Y = !H.objectMode && u($);
    return Y && !o.isBuffer($) && ($ = f($)), typeof L == "function" && (P = L, L = null), Y ? L = "buffer" : L || (L = H.defaultEncoding), typeof P != "function" && (P = p), H.ended ? v(this, P) : (Y || d(this, H, $, P)) && (H.pendingcb++, Q = x(this, H, Y, $, L, P)), Q;
  }, g.prototype.cork = function() {
    var $ = this._writableState;
    $.corked++;
  }, g.prototype.uncork = function() {
    var $ = this._writableState;
    $.corked && ($.corked--, !$.writing && !$.corked && !$.bufferProcessing && $.bufferedRequest && A(this, $));
  }, g.prototype.setDefaultEncoding = function(L) {
    if (typeof L == "string" && (L = L.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((L + "").toLowerCase()) > -1))
      throw new TypeError("Unknown encoding: " + L);
    return this._writableState.defaultEncoding = L, this;
  };
  function y($, L, P) {
    return !$.objectMode && $.decodeStrings !== !1 && typeof L == "string" && (L = o.from(L, P)), L;
  }
  Object.defineProperty(g.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function x($, L, P, H, Q, Y) {
    if (!P) {
      var ce = y(L, H, Q);
      H !== ce && (P = !0, Q = "buffer", H = ce);
    }
    var ue = L.objectMode ? 1 : H.length;
    L.length += ue;
    var me = L.length < L.highWaterMark;
    if (me || (L.needDrain = !0), L.writing || L.corked) {
      var J = L.lastBufferedRequest;
      L.lastBufferedRequest = {
        chunk: H,
        encoding: Q,
        isBuf: P,
        callback: Y,
        next: null
      }, J ? J.next = L.lastBufferedRequest : L.bufferedRequest = L.lastBufferedRequest, L.bufferedRequestCount += 1;
    } else
      b($, L, !1, ue, H, Q, Y);
    return me;
  }
  function b($, L, P, H, Q, Y, ce) {
    L.writelen = H, L.writecb = ce, L.writing = !0, L.sync = !0, P ? $._writev(Q, L.onwrite) : $._write(Q, Y, L.onwrite), L.sync = !1;
  }
  function w($, L, P, H, Q) {
    --L.pendingcb, P ? (t.nextTick(Q, H), t.nextTick(K, $, L), $._writableState.errorEmitted = !0, $.emit("error", H)) : (Q(H), $._writableState.errorEmitted = !0, $.emit("error", H), K($, L));
  }
  function S($) {
    $.writing = !1, $.writecb = null, $.length -= $.writelen, $.writelen = 0;
  }
  function T($, L) {
    var P = $._writableState, H = P.sync, Q = P.writecb;
    if (S(P), L)
      w($, P, H, L, Q);
    else {
      var Y = R(P);
      !Y && !P.corked && !P.bufferProcessing && P.bufferedRequest && A($, P), H ? r(E, $, P, Y, Q) : E($, P, Y, Q);
    }
  }
  function E($, L, P, H) {
    P || C($, L), L.pendingcb--, H(), K($, L);
  }
  function C($, L) {
    L.length === 0 && L.needDrain && (L.needDrain = !1, $.emit("drain"));
  }
  function A($, L) {
    L.bufferProcessing = !0;
    var P = L.bufferedRequest;
    if ($._writev && P && P.next) {
      var H = L.bufferedRequestCount, Q = new Array(H), Y = L.corkedRequestsFree;
      Y.entry = P;
      for (var ce = 0, ue = !0; P; )
        Q[ce] = P, P.isBuf || (ue = !1), P = P.next, ce += 1;
      Q.allBuffers = ue, b($, L, !0, L.length, Q, "", Y.finish), L.pendingcb++, L.lastBufferedRequest = null, Y.next ? (L.corkedRequestsFree = Y.next, Y.next = null) : L.corkedRequestsFree = new e(L), L.bufferedRequestCount = 0;
    } else {
      for (; P; ) {
        var me = P.chunk, J = P.encoding, O = P.callback, I = L.objectMode ? 1 : me.length;
        if (b($, L, !1, I, me, J, O), P = P.next, L.bufferedRequestCount--, L.writing)
          break;
      }
      P === null && (L.lastBufferedRequest = null);
    }
    L.bufferedRequest = P, L.bufferProcessing = !1;
  }
  g.prototype._write = function($, L, P) {
    P(new Error("_write() is not implemented"));
  }, g.prototype._writev = null, g.prototype.end = function($, L, P) {
    var H = this._writableState;
    typeof $ == "function" ? (P = $, $ = null, L = null) : typeof L == "function" && (P = L, L = null), $ != null && this.write($, L), H.corked && (H.corked = 1, this.uncork()), H.ending || V(this, H, P);
  };
  function R($) {
    return $.ending && $.length === 0 && $.bufferedRequest === null && !$.finished && !$.writing;
  }
  function D($, L) {
    $._final(function(P) {
      L.pendingcb--, P && $.emit("error", P), L.prefinished = !0, $.emit("prefinish"), K($, L);
    });
  }
  function F($, L) {
    !L.prefinished && !L.finalCalled && (typeof $._final == "function" ? (L.pendingcb++, L.finalCalled = !0, t.nextTick(D, $, L)) : (L.prefinished = !0, $.emit("prefinish")));
  }
  function K($, L) {
    var P = R(L);
    return P && (F($, L), L.pendingcb === 0 && (L.finished = !0, $.emit("finish"))), P;
  }
  function V($, L, P) {
    L.ending = !0, K($, L), P && (L.finished ? t.nextTick(P) : $.once("finish", P)), L.ended = !0, $.writable = !1;
  }
  function ne($, L, P) {
    var H = $.entry;
    for ($.entry = null; H; ) {
      var Q = H.callback;
      L.pendingcb--, Q(P), H = H.next;
    }
    L.corkedRequestsFree.next = $;
  }
  return Object.defineProperty(g.prototype, "destroyed", {
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function($) {
      this._writableState && (this._writableState.destroyed = $);
    }
  }), g.prototype.destroy = l.destroy, g.prototype._undestroy = l.undestroy, g.prototype._destroy = function($, L) {
    this.end(), L($);
  }, zh;
}
var Hh, OE;
function Si() {
  if (OE)
    return Hh;
  OE = 1;
  var t = mn(), e = Object.keys || function(l) {
    var p = [];
    for (var m in l)
      p.push(m);
    return p;
  };
  Hh = c;
  var r = Object.create(Sr());
  r.inherits = ct();
  var n = X$(), i = J$();
  r.inherits(c, n);
  for (var a = e(i.prototype), s = 0; s < a.length; s++) {
    var o = a[s];
    c.prototype[o] || (c.prototype[o] = i.prototype[o]);
  }
  function c(l) {
    if (!(this instanceof c))
      return new c(l);
    n.call(this, l), i.call(this, l), l && l.readable === !1 && (this.readable = !1), l && l.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, l && l.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", f);
  }
  Object.defineProperty(c.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function f() {
    this.allowHalfOpen || this._writableState.ended || t.nextTick(u, this);
  }
  function u(l) {
    l.end();
  }
  return Object.defineProperty(c.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(l) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = l, this._writableState.destroyed = l);
    }
  }), c.prototype._destroy = function(l, p) {
    this.push(null), this.end(), t.nextTick(p, l);
  }, Hh;
}
var Wh = {}, AE;
function $E() {
  if (AE)
    return Wh;
  AE = 1;
  var t = Lu().Buffer, e = t.isEncoding || function(d) {
    switch (d = "" + d, d && d.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function r(d) {
    if (!d)
      return "utf8";
    for (var y; ; )
      switch (d) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return d;
        default:
          if (y)
            return;
          d = ("" + d).toLowerCase(), y = !0;
      }
  }
  function n(d) {
    var y = r(d);
    if (typeof y != "string" && (t.isEncoding === e || !e(d)))
      throw new Error("Unknown encoding: " + d);
    return y || d;
  }
  Wh.StringDecoder = i;
  function i(d) {
    this.encoding = n(d);
    var y;
    switch (this.encoding) {
      case "utf16le":
        this.text = l, this.end = p, y = 4;
        break;
      case "utf8":
        this.fillLast = c, y = 4;
        break;
      case "base64":
        this.text = m, this.end = h, y = 3;
        break;
      default:
        this.write = g, this.end = v;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = t.allocUnsafe(y);
  }
  i.prototype.write = function(d) {
    if (d.length === 0)
      return "";
    var y, x;
    if (this.lastNeed) {
      if (y = this.fillLast(d), y === void 0)
        return "";
      x = this.lastNeed, this.lastNeed = 0;
    } else
      x = 0;
    return x < d.length ? y ? y + this.text(d, x) : this.text(d, x) : y || "";
  }, i.prototype.end = u, i.prototype.text = f, i.prototype.fillLast = function(d) {
    if (this.lastNeed <= d.length)
      return d.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    d.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, d.length), this.lastNeed -= d.length;
  };
  function a(d) {
    return d <= 127 ? 0 : d >> 5 === 6 ? 2 : d >> 4 === 14 ? 3 : d >> 3 === 30 ? 4 : d >> 6 === 2 ? -1 : -2;
  }
  function s(d, y, x) {
    var b = y.length - 1;
    if (b < x)
      return 0;
    var w = a(y[b]);
    return w >= 0 ? (w > 0 && (d.lastNeed = w - 1), w) : --b < x || w === -2 ? 0 : (w = a(y[b]), w >= 0 ? (w > 0 && (d.lastNeed = w - 2), w) : --b < x || w === -2 ? 0 : (w = a(y[b]), w >= 0 ? (w > 0 && (w === 2 ? w = 0 : d.lastNeed = w - 3), w) : 0));
  }
  function o(d, y, x) {
    if ((y[0] & 192) !== 128)
      return d.lastNeed = 0, "";
    if (d.lastNeed > 1 && y.length > 1) {
      if ((y[1] & 192) !== 128)
        return d.lastNeed = 1, "";
      if (d.lastNeed > 2 && y.length > 2 && (y[2] & 192) !== 128)
        return d.lastNeed = 2, "";
    }
  }
  function c(d) {
    var y = this.lastTotal - this.lastNeed, x = o(this, d);
    if (x !== void 0)
      return x;
    if (this.lastNeed <= d.length)
      return d.copy(this.lastChar, y, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    d.copy(this.lastChar, y, 0, d.length), this.lastNeed -= d.length;
  }
  function f(d, y) {
    var x = s(this, d, y);
    if (!this.lastNeed)
      return d.toString("utf8", y);
    this.lastTotal = x;
    var b = d.length - (x - this.lastNeed);
    return d.copy(this.lastChar, 0, b), d.toString("utf8", y, b);
  }
  function u(d) {
    var y = d && d.length ? this.write(d) : "";
    return this.lastNeed ? y + "" : y;
  }
  function l(d, y) {
    if ((d.length - y) % 2 === 0) {
      var x = d.toString("utf16le", y);
      if (x) {
        var b = x.charCodeAt(x.length - 1);
        if (b >= 55296 && b <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = d[d.length - 2], this.lastChar[1] = d[d.length - 1], x.slice(0, -1);
      }
      return x;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = d[d.length - 1], d.toString("utf16le", y, d.length - 1);
  }
  function p(d) {
    var y = d && d.length ? this.write(d) : "";
    if (this.lastNeed) {
      var x = this.lastTotal - this.lastNeed;
      return y + this.lastChar.toString("utf16le", 0, x);
    }
    return y;
  }
  function m(d, y) {
    var x = (d.length - y) % 3;
    return x === 0 ? d.toString("base64", y) : (this.lastNeed = 3 - x, this.lastTotal = 3, x === 1 ? this.lastChar[0] = d[d.length - 1] : (this.lastChar[0] = d[d.length - 2], this.lastChar[1] = d[d.length - 1]), d.toString("base64", y, d.length - x));
  }
  function h(d) {
    var y = d && d.length ? this.write(d) : "";
    return this.lastNeed ? y + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : y;
  }
  function g(d) {
    return d.toString(this.encoding);
  }
  function v(d) {
    return d && d.length ? this.write(d) : "";
  }
  return Wh;
}
var Gh, IE;
function X$() {
  if (IE)
    return Gh;
  IE = 1;
  var t = mn();
  Gh = y;
  var e = rfe(), r;
  y.ReadableState = d, bt.EventEmitter;
  var n = function(O, I) {
    return O.listeners(I).length;
  }, i = V$(), a = Lu().Buffer, s = (typeof ve < "u" ? ve : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function o(O) {
    return a.from(O);
  }
  function c(O) {
    return a.isBuffer(O) || O instanceof s;
  }
  var f = Object.create(Sr());
  f.inherits = ct();
  var u = se, l = void 0;
  u && u.debuglog ? l = u.debuglog("stream") : l = function() {
  };
  var p = nfe(), m = K$(), h;
  f.inherits(y, i);
  var g = ["error", "close", "destroy", "pause", "resume"];
  function v(O, I, z) {
    if (typeof O.prependListener == "function")
      return O.prependListener(I, z);
    !O._events || !O._events[I] ? O.on(I, z) : e(O._events[I]) ? O._events[I].unshift(z) : O._events[I] = [z, O._events[I]];
  }
  function d(O, I) {
    r = r || Si(), O = O || {};
    var z = I instanceof r;
    this.objectMode = !!O.objectMode, z && (this.objectMode = this.objectMode || !!O.readableObjectMode);
    var G = O.highWaterMark, q = O.readableHighWaterMark, M = this.objectMode ? 16 : 16 * 1024;
    G || G === 0 ? this.highWaterMark = G : z && (q || q === 0) ? this.highWaterMark = q : this.highWaterMark = M, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new p(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = O.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, O.encoding && (h || (h = $E().StringDecoder), this.decoder = new h(O.encoding), this.encoding = O.encoding);
  }
  function y(O) {
    if (r = r || Si(), !(this instanceof y))
      return new y(O);
    this._readableState = new d(O, this), this.readable = !0, O && (typeof O.read == "function" && (this._read = O.read), typeof O.destroy == "function" && (this._destroy = O.destroy)), i.call(this);
  }
  Object.defineProperty(y.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(O) {
      this._readableState && (this._readableState.destroyed = O);
    }
  }), y.prototype.destroy = m.destroy, y.prototype._undestroy = m.undestroy, y.prototype._destroy = function(O, I) {
    this.push(null), I(O);
  }, y.prototype.push = function(O, I) {
    var z = this._readableState, G;
    return z.objectMode ? G = !0 : typeof O == "string" && (I = I || z.defaultEncoding, I !== z.encoding && (O = a.from(O, I), I = ""), G = !0), x(this, O, I, !1, G);
  }, y.prototype.unshift = function(O) {
    return x(this, O, null, !0, !1);
  };
  function x(O, I, z, G, q) {
    var M = O._readableState;
    if (I === null)
      M.reading = !1, A(O, M);
    else {
      var Z;
      q || (Z = w(M, I)), Z ? O.emit("error", Z) : M.objectMode || I && I.length > 0 ? (typeof I != "string" && !M.objectMode && Object.getPrototypeOf(I) !== a.prototype && (I = o(I)), G ? M.endEmitted ? O.emit("error", new Error("stream.unshift() after end event")) : b(O, M, I, !0) : M.ended ? O.emit("error", new Error("stream.push() after EOF")) : (M.reading = !1, M.decoder && !z ? (I = M.decoder.write(I), M.objectMode || I.length !== 0 ? b(O, M, I, !1) : F(O, M)) : b(O, M, I, !1))) : G || (M.reading = !1);
    }
    return S(M);
  }
  function b(O, I, z, G) {
    I.flowing && I.length === 0 && !I.sync ? (O.emit("data", z), O.read(0)) : (I.length += I.objectMode ? 1 : z.length, G ? I.buffer.unshift(z) : I.buffer.push(z), I.needReadable && R(O)), F(O, I);
  }
  function w(O, I) {
    var z;
    return !c(I) && typeof I != "string" && I !== void 0 && !O.objectMode && (z = new TypeError("Invalid non-string/buffer chunk")), z;
  }
  function S(O) {
    return !O.ended && (O.needReadable || O.length < O.highWaterMark || O.length === 0);
  }
  y.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, y.prototype.setEncoding = function(O) {
    return h || (h = $E().StringDecoder), this._readableState.decoder = new h(O), this._readableState.encoding = O, this;
  };
  var T = 8388608;
  function E(O) {
    return O >= T ? O = T : (O--, O |= O >>> 1, O |= O >>> 2, O |= O >>> 4, O |= O >>> 8, O |= O >>> 16, O++), O;
  }
  function C(O, I) {
    return O <= 0 || I.length === 0 && I.ended ? 0 : I.objectMode ? 1 : O !== O ? I.flowing && I.length ? I.buffer.head.data.length : I.length : (O > I.highWaterMark && (I.highWaterMark = E(O)), O <= I.length ? O : I.ended ? I.length : (I.needReadable = !0, 0));
  }
  y.prototype.read = function(O) {
    l("read", O), O = parseInt(O, 10);
    var I = this._readableState, z = O;
    if (O !== 0 && (I.emittedReadable = !1), O === 0 && I.needReadable && (I.length >= I.highWaterMark || I.ended))
      return l("read: emitReadable", I.length, I.ended), I.length === 0 && I.ended ? ue(this) : R(this), null;
    if (O = C(O, I), O === 0 && I.ended)
      return I.length === 0 && ue(this), null;
    var G = I.needReadable;
    l("need readable", G), (I.length === 0 || I.length - O < I.highWaterMark) && (G = !0, l("length less than watermark", G)), I.ended || I.reading ? (G = !1, l("reading or ended", G)) : G && (l("do read"), I.reading = !0, I.sync = !0, I.length === 0 && (I.needReadable = !0), this._read(I.highWaterMark), I.sync = !1, I.reading || (O = C(z, I)));
    var q;
    return O > 0 ? q = H(O, I) : q = null, q === null ? (I.needReadable = !0, O = 0) : I.length -= O, I.length === 0 && (I.ended || (I.needReadable = !0), z !== O && I.ended && ue(this)), q !== null && this.emit("data", q), q;
  };
  function A(O, I) {
    if (!I.ended) {
      if (I.decoder) {
        var z = I.decoder.end();
        z && z.length && (I.buffer.push(z), I.length += I.objectMode ? 1 : z.length);
      }
      I.ended = !0, R(O);
    }
  }
  function R(O) {
    var I = O._readableState;
    I.needReadable = !1, I.emittedReadable || (l("emitReadable", I.flowing), I.emittedReadable = !0, I.sync ? t.nextTick(D, O) : D(O));
  }
  function D(O) {
    l("emit readable"), O.emit("readable"), P(O);
  }
  function F(O, I) {
    I.readingMore || (I.readingMore = !0, t.nextTick(K, O, I));
  }
  function K(O, I) {
    for (var z = I.length; !I.reading && !I.flowing && !I.ended && I.length < I.highWaterMark && (l("maybeReadMore read 0"), O.read(0), z !== I.length); )
      z = I.length;
    I.readingMore = !1;
  }
  y.prototype._read = function(O) {
    this.emit("error", new Error("_read() is not implemented"));
  }, y.prototype.pipe = function(O, I) {
    var z = this, G = this._readableState;
    switch (G.pipesCount) {
      case 0:
        G.pipes = O;
        break;
      case 1:
        G.pipes = [G.pipes, O];
        break;
      default:
        G.pipes.push(O);
        break;
    }
    G.pipesCount += 1, l("pipe count=%d opts=%j", G.pipesCount, I);
    var q = (!I || I.end !== !1) && O !== process.stdout && O !== process.stderr, M = q ? B : be;
    G.endEmitted ? t.nextTick(M) : z.once("end", M), O.on("unpipe", Z);
    function Z(ye, Ee) {
      l("onunpipe"), ye === z && Ee && Ee.hasUnpiped === !1 && (Ee.hasUnpiped = !0, k());
    }
    function B() {
      l("onend"), O.end();
    }
    var re = V(z);
    O.on("drain", re);
    var j = !1;
    function k() {
      l("cleanup"), O.removeListener("close", pe), O.removeListener("finish", he), O.removeListener("drain", re), O.removeListener("error", ee), O.removeListener("unpipe", Z), z.removeListener("end", B), z.removeListener("end", be), z.removeListener("data", U), j = !0, G.awaitDrain && (!O._writableState || O._writableState.needDrain) && re();
    }
    var N = !1;
    z.on("data", U);
    function U(ye) {
      l("ondata"), N = !1;
      var Ee = O.write(ye);
      Ee === !1 && !N && ((G.pipesCount === 1 && G.pipes === O || G.pipesCount > 1 && J(G.pipes, O) !== -1) && !j && (l("false write response, pause", G.awaitDrain), G.awaitDrain++, N = !0), z.pause());
    }
    function ee(ye) {
      l("onerror", ye), be(), O.removeListener("error", ee), n(O, "error") === 0 && O.emit("error", ye);
    }
    v(O, "error", ee);
    function pe() {
      O.removeListener("finish", he), be();
    }
    O.once("close", pe);
    function he() {
      l("onfinish"), O.removeListener("close", pe), be();
    }
    O.once("finish", he);
    function be() {
      l("unpipe"), z.unpipe(O);
    }
    return O.emit("pipe", z), G.flowing || (l("pipe resume"), z.resume()), O;
  };
  function V(O) {
    return function() {
      var I = O._readableState;
      l("pipeOnDrain", I.awaitDrain), I.awaitDrain && I.awaitDrain--, I.awaitDrain === 0 && n(O, "data") && (I.flowing = !0, P(O));
    };
  }
  y.prototype.unpipe = function(O) {
    var I = this._readableState, z = { hasUnpiped: !1 };
    if (I.pipesCount === 0)
      return this;
    if (I.pipesCount === 1)
      return O && O !== I.pipes ? this : (O || (O = I.pipes), I.pipes = null, I.pipesCount = 0, I.flowing = !1, O && O.emit("unpipe", this, z), this);
    if (!O) {
      var G = I.pipes, q = I.pipesCount;
      I.pipes = null, I.pipesCount = 0, I.flowing = !1;
      for (var M = 0; M < q; M++)
        G[M].emit("unpipe", this, { hasUnpiped: !1 });
      return this;
    }
    var Z = J(I.pipes, O);
    return Z === -1 ? this : (I.pipes.splice(Z, 1), I.pipesCount -= 1, I.pipesCount === 1 && (I.pipes = I.pipes[0]), O.emit("unpipe", this, z), this);
  }, y.prototype.on = function(O, I) {
    var z = i.prototype.on.call(this, O, I);
    if (O === "data")
      this._readableState.flowing !== !1 && this.resume();
    else if (O === "readable") {
      var G = this._readableState;
      !G.endEmitted && !G.readableListening && (G.readableListening = G.needReadable = !0, G.emittedReadable = !1, G.reading ? G.length && R(this) : t.nextTick(ne, this));
    }
    return z;
  }, y.prototype.addListener = y.prototype.on;
  function ne(O) {
    l("readable nexttick read 0"), O.read(0);
  }
  y.prototype.resume = function() {
    var O = this._readableState;
    return O.flowing || (l("resume"), O.flowing = !0, $(this, O)), this;
  };
  function $(O, I) {
    I.resumeScheduled || (I.resumeScheduled = !0, t.nextTick(L, O, I));
  }
  function L(O, I) {
    I.reading || (l("resume read 0"), O.read(0)), I.resumeScheduled = !1, I.awaitDrain = 0, O.emit("resume"), P(O), I.flowing && !I.reading && O.read(0);
  }
  y.prototype.pause = function() {
    return l("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (l("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
  };
  function P(O) {
    var I = O._readableState;
    for (l("flow", I.flowing); I.flowing && O.read() !== null; )
      ;
  }
  y.prototype.wrap = function(O) {
    var I = this, z = this._readableState, G = !1;
    O.on("end", function() {
      if (l("wrapped end"), z.decoder && !z.ended) {
        var Z = z.decoder.end();
        Z && Z.length && I.push(Z);
      }
      I.push(null);
    }), O.on("data", function(Z) {
      if (l("wrapped data"), z.decoder && (Z = z.decoder.write(Z)), !(z.objectMode && Z == null) && !(!z.objectMode && (!Z || !Z.length))) {
        var B = I.push(Z);
        B || (G = !0, O.pause());
      }
    });
    for (var q in O)
      this[q] === void 0 && typeof O[q] == "function" && (this[q] = function(Z) {
        return function() {
          return O[Z].apply(O, arguments);
        };
      }(q));
    for (var M = 0; M < g.length; M++)
      O.on(g[M], this.emit.bind(this, g[M]));
    return this._read = function(Z) {
      l("wrapped _read", Z), G && (G = !1, O.resume());
    }, this;
  }, Object.defineProperty(y.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), y._fromList = H;
  function H(O, I) {
    if (I.length === 0)
      return null;
    var z;
    return I.objectMode ? z = I.buffer.shift() : !O || O >= I.length ? (I.decoder ? z = I.buffer.join("") : I.buffer.length === 1 ? z = I.buffer.head.data : z = I.buffer.concat(I.length), I.buffer.clear()) : z = Q(O, I.buffer, I.decoder), z;
  }
  function Q(O, I, z) {
    var G;
    return O < I.head.data.length ? (G = I.head.data.slice(0, O), I.head.data = I.head.data.slice(O)) : O === I.head.data.length ? G = I.shift() : G = z ? Y(O, I) : ce(O, I), G;
  }
  function Y(O, I) {
    var z = I.head, G = 1, q = z.data;
    for (O -= q.length; z = z.next; ) {
      var M = z.data, Z = O > M.length ? M.length : O;
      if (Z === M.length ? q += M : q += M.slice(0, O), O -= Z, O === 0) {
        Z === M.length ? (++G, z.next ? I.head = z.next : I.head = I.tail = null) : (I.head = z, z.data = M.slice(Z));
        break;
      }
      ++G;
    }
    return I.length -= G, q;
  }
  function ce(O, I) {
    var z = a.allocUnsafe(O), G = I.head, q = 1;
    for (G.data.copy(z), O -= G.data.length; G = G.next; ) {
      var M = G.data, Z = O > M.length ? M.length : O;
      if (M.copy(z, z.length - O, 0, Z), O -= Z, O === 0) {
        Z === M.length ? (++q, G.next ? I.head = G.next : I.head = I.tail = null) : (I.head = G, G.data = M.slice(Z));
        break;
      }
      ++q;
    }
    return I.length -= q, z;
  }
  function ue(O) {
    var I = O._readableState;
    if (I.length > 0)
      throw new Error('"endReadable()" called on non-empty stream');
    I.endEmitted || (I.ended = !0, t.nextTick(me, I, O));
  }
  function me(O, I) {
    !O.endEmitted && O.length === 0 && (O.endEmitted = !0, I.readable = !1, I.emit("end"));
  }
  function J(O, I) {
    for (var z = 0, G = O.length; z < G; z++)
      if (O[z] === I)
        return z;
    return -1;
  }
  return Gh;
}
var Qh, kE;
function Z$() {
  if (kE)
    return Qh;
  kE = 1, Qh = n;
  var t = Si(), e = Object.create(Sr());
  e.inherits = ct(), e.inherits(n, t);
  function r(s, o) {
    var c = this._transformState;
    c.transforming = !1;
    var f = c.writecb;
    if (!f)
      return this.emit("error", new Error("write callback called multiple times"));
    c.writechunk = null, c.writecb = null, o != null && this.push(o), f(s);
    var u = this._readableState;
    u.reading = !1, (u.needReadable || u.length < u.highWaterMark) && this._read(u.highWaterMark);
  }
  function n(s) {
    if (!(this instanceof n))
      return new n(s);
    t.call(this, s), this._transformState = {
      afterTransform: r.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, s && (typeof s.transform == "function" && (this._transform = s.transform), typeof s.flush == "function" && (this._flush = s.flush)), this.on("prefinish", i);
  }
  function i() {
    var s = this;
    typeof this._flush == "function" ? this._flush(function(o, c) {
      a(s, o, c);
    }) : a(this, null, null);
  }
  n.prototype.push = function(s, o) {
    return this._transformState.needTransform = !1, t.prototype.push.call(this, s, o);
  }, n.prototype._transform = function(s, o, c) {
    throw new Error("_transform() is not implemented");
  }, n.prototype._write = function(s, o, c) {
    var f = this._transformState;
    if (f.writecb = c, f.writechunk = s, f.writeencoding = o, !f.transforming) {
      var u = this._readableState;
      (f.needTransform || u.needReadable || u.length < u.highWaterMark) && this._read(u.highWaterMark);
    }
  }, n.prototype._read = function(s) {
    var o = this._transformState;
    o.writechunk !== null && o.writecb && !o.transforming ? (o.transforming = !0, this._transform(o.writechunk, o.writeencoding, o.afterTransform)) : o.needTransform = !0;
  }, n.prototype._destroy = function(s, o) {
    var c = this;
    t.prototype._destroy.call(this, s, function(f) {
      o(f), c.emit("close");
    });
  };
  function a(s, o, c) {
    if (o)
      return s.emit("error", o);
    if (c != null && s.push(c), s._writableState.length)
      throw new Error("Calling transform done when ws.length != 0");
    if (s._transformState.transforming)
      throw new Error("Calling transform done when still transforming");
    return s.push(null);
  }
  return Qh;
}
var Vh, RE;
function ife() {
  if (RE)
    return Vh;
  RE = 1, Vh = r;
  var t = Z$(), e = Object.create(Sr());
  e.inherits = ct(), e.inherits(r, t);
  function r(n) {
    if (!(this instanceof r))
      return new r(n);
    t.call(this, n);
  }
  return r.prototype._transform = function(n, i, a) {
    a(null, n);
  }, Vh;
}
var NE;
function afe() {
  return NE || (NE = 1, function(t, e) {
    e = t.exports = X$(), e.Stream = e, e.Readable = e, e.Writable = J$(), e.Duplex = Si(), e.Transform = Z$(), e.PassThrough = ife();
  }(so, so.exports)), so.exports;
}
var Kh, LE;
function sfe() {
  return LE || (LE = 1, Kh = afe().PassThrough), Kh;
}
var Jh, PE;
function ofe() {
  if (PE)
    return Jh;
  PE = 1;
  var t = nt, e = sfe();
  Jh = {
    Readable: n,
    Writable: i
  }, t.inherits(n, e), t.inherits(i, e);
  function r(a, s, o) {
    a[s] = function() {
      return delete a[s], o.apply(this, arguments), this[s].apply(this, arguments);
    };
  }
  function n(a, s) {
    if (!(this instanceof n))
      return new n(a, s);
    e.call(this, s), r(this, "_read", function() {
      var o = a.call(this, s), c = this.emit.bind(this, "error");
      o.on("error", c), o.pipe(this);
    }), this.emit("readable");
  }
  function i(a, s) {
    if (!(this instanceof i))
      return new i(a, s);
    e.call(this, s), r(this, "_write", function() {
      var o = a.call(this, s), c = this.emit.bind(this, "error");
      o.on("error", c), this.pipe(o);
    }), this.emit("writable");
  }
  return Jh;
}
/*!
 * normalize-path <https://github.com/jonschlinkert/normalize-path>
 *
 * Copyright (c) 2014-2018, Jon Schlinkert.
 * Released under the MIT License.
 */
var Xh, DE;
function Y$() {
  return DE || (DE = 1, Xh = function(t, e) {
    if (typeof t != "string")
      throw new TypeError("expected path to be a string");
    if (t === "\\" || t === "/")
      return "/";
    var r = t.length;
    if (r <= 1)
      return t;
    var n = "";
    if (r > 4 && t[3] === "\\") {
      var i = t[2];
      (i === "?" || i === ".") && t.slice(0, 2) === "\\\\" && (t = t.slice(2), n = "//");
    }
    var a = t.split(/[/\\]+/);
    return e !== !1 && a[a.length - 1] === "" && a.pop(), n + a.join("/");
  }), Xh;
}
var Zh, ME;
function cfe() {
  if (ME)
    return Zh;
  ME = 1;
  var t = 9007199254740991, e = "[object Arguments]", r = "[object Function]", n = "[object GeneratorFunction]", i = /^(?:0|[1-9]\d*)$/;
  function a(P, H, Q) {
    switch (Q.length) {
      case 0:
        return P.call(H);
      case 1:
        return P.call(H, Q[0]);
      case 2:
        return P.call(H, Q[0], Q[1]);
      case 3:
        return P.call(H, Q[0], Q[1], Q[2]);
    }
    return P.apply(H, Q);
  }
  function s(P, H) {
    for (var Q = -1, Y = Array(P); ++Q < P; )
      Y[Q] = H(Q);
    return Y;
  }
  var o = Object.prototype, c = o.hasOwnProperty, f = o.toString, u = o.propertyIsEnumerable, l = Math.max;
  function p(P, H) {
    var Q = C(P) || E(P) ? s(P.length, String) : [], Y = Q.length, ce = !!Y;
    for (var ue in P)
      (H || c.call(P, ue)) && !(ce && (ue == "length" || x(ue, Y))) && Q.push(ue);
    return Q;
  }
  function m(P, H, Q, Y) {
    return P === void 0 || T(P, o[Q]) && !c.call(Y, Q) ? H : P;
  }
  function h(P, H, Q) {
    var Y = P[H];
    (!(c.call(P, H) && T(Y, Q)) || Q === void 0 && !(H in P)) && (P[H] = Q);
  }
  function g(P) {
    if (!K(P))
      return S(P);
    var H = w(P), Q = [];
    for (var Y in P)
      Y == "constructor" && (H || !c.call(P, Y)) || Q.push(Y);
    return Q;
  }
  function v(P, H) {
    return H = l(H === void 0 ? P.length - 1 : H, 0), function() {
      for (var Q = arguments, Y = -1, ce = l(Q.length - H, 0), ue = Array(ce); ++Y < ce; )
        ue[Y] = Q[H + Y];
      Y = -1;
      for (var me = Array(H + 1); ++Y < H; )
        me[Y] = Q[Y];
      return me[H] = ue, a(P, this, me);
    };
  }
  function d(P, H, Q, Y) {
    Q || (Q = {});
    for (var ce = -1, ue = H.length; ++ce < ue; ) {
      var me = H[ce], J = Y ? Y(Q[me], P[me], me, Q, P) : void 0;
      h(Q, me, J === void 0 ? P[me] : J);
    }
    return Q;
  }
  function y(P) {
    return v(function(H, Q) {
      var Y = -1, ce = Q.length, ue = ce > 1 ? Q[ce - 1] : void 0, me = ce > 2 ? Q[2] : void 0;
      for (ue = P.length > 3 && typeof ue == "function" ? (ce--, ue) : void 0, me && b(Q[0], Q[1], me) && (ue = ce < 3 ? void 0 : ue, ce = 1), H = Object(H); ++Y < ce; ) {
        var J = Q[Y];
        J && P(H, J, Y, ue);
      }
      return H;
    });
  }
  function x(P, H) {
    return H = H ?? t, !!H && (typeof P == "number" || i.test(P)) && P > -1 && P % 1 == 0 && P < H;
  }
  function b(P, H, Q) {
    if (!K(Q))
      return !1;
    var Y = typeof H;
    return (Y == "number" ? A(Q) && x(H, Q.length) : Y == "string" && H in Q) ? T(Q[H], P) : !1;
  }
  function w(P) {
    var H = P && P.constructor, Q = typeof H == "function" && H.prototype || o;
    return P === Q;
  }
  function S(P) {
    var H = [];
    if (P != null)
      for (var Q in Object(P))
        H.push(Q);
    return H;
  }
  function T(P, H) {
    return P === H || P !== P && H !== H;
  }
  function E(P) {
    return R(P) && c.call(P, "callee") && (!u.call(P, "callee") || f.call(P) == e);
  }
  var C = Array.isArray;
  function A(P) {
    return P != null && F(P.length) && !D(P);
  }
  function R(P) {
    return V(P) && A(P);
  }
  function D(P) {
    var H = K(P) ? f.call(P) : "";
    return H == r || H == n;
  }
  function F(P) {
    return typeof P == "number" && P > -1 && P % 1 == 0 && P <= t;
  }
  function K(P) {
    var H = typeof P;
    return !!P && (H == "object" || H == "function");
  }
  function V(P) {
    return !!P && typeof P == "object";
  }
  var ne = y(function(P, H, Q, Y) {
    d(H, L(H), P, Y);
  }), $ = v(function(P) {
    return P.push(void 0, m), a(ne, void 0, P);
  });
  function L(P) {
    return A(P) ? p(P, !0) : g(P);
  }
  return Zh = $, Zh;
}
var uo = { exports: {} }, Yh, qE;
function ufe() {
  if (qE)
    return Yh;
  qE = 1;
  var t = {}.toString;
  return Yh = Array.isArray || function(e) {
    return t.call(e) == "[object Array]";
  }, Yh;
}
var ed, jE;
function e8() {
  return jE || (jE = 1, ed = bt.EventEmitter), ed;
}
var lo = { exports: {} }, FE;
function Pu() {
  return FE || (FE = 1, function(t, e) {
    var r = rr, n = r.Buffer;
    function i(s, o) {
      for (var c in s)
        o[c] = s[c];
    }
    n.from && n.alloc && n.allocUnsafe && n.allocUnsafeSlow ? t.exports = r : (i(r, e), e.Buffer = a);
    function a(s, o, c) {
      return n(s, o, c);
    }
    i(n, a), a.from = function(s, o, c) {
      if (typeof s == "number")
        throw new TypeError("Argument must not be a number");
      return n(s, o, c);
    }, a.alloc = function(s, o, c) {
      if (typeof s != "number")
        throw new TypeError("Argument must be a number");
      var f = n(s);
      return o !== void 0 ? typeof c == "string" ? f.fill(o, c) : f.fill(o) : f.fill(0), f;
    }, a.allocUnsafe = function(s) {
      if (typeof s != "number")
        throw new TypeError("Argument must be a number");
      return n(s);
    }, a.allocUnsafeSlow = function(s) {
      if (typeof s != "number")
        throw new TypeError("Argument must be a number");
      return r.SlowBuffer(s);
    };
  }(lo, lo.exports)), lo.exports;
}
var td = { exports: {} }, BE;
function lfe() {
  return BE || (BE = 1, function(t) {
    function e(a, s) {
      if (!(a instanceof s))
        throw new TypeError("Cannot call a class as a function");
    }
    var r = Pu().Buffer, n = se;
    function i(a, s, o) {
      a.copy(s, o);
    }
    t.exports = function() {
      function a() {
        e(this, a), this.head = null, this.tail = null, this.length = 0;
      }
      return a.prototype.push = function(o) {
        var c = { data: o, next: null };
        this.length > 0 ? this.tail.next = c : this.head = c, this.tail = c, ++this.length;
      }, a.prototype.unshift = function(o) {
        var c = { data: o, next: this.head };
        this.length === 0 && (this.tail = c), this.head = c, ++this.length;
      }, a.prototype.shift = function() {
        if (this.length !== 0) {
          var o = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, o;
        }
      }, a.prototype.clear = function() {
        this.head = this.tail = null, this.length = 0;
      }, a.prototype.join = function(o) {
        if (this.length === 0)
          return "";
        for (var c = this.head, f = "" + c.data; c = c.next; )
          f += o + c.data;
        return f;
      }, a.prototype.concat = function(o) {
        if (this.length === 0)
          return r.alloc(0);
        for (var c = r.allocUnsafe(o >>> 0), f = this.head, u = 0; f; )
          i(f.data, c, u), u += f.data.length, f = f.next;
        return c;
      }, a;
    }(), n && n.inspect && n.inspect.custom && (t.exports.prototype[n.inspect.custom] = function() {
      var a = n.inspect({ length: this.length });
      return this.constructor.name + " " + a;
    });
  }(td)), td.exports;
}
var rd, UE;
function t8() {
  if (UE)
    return rd;
  UE = 1;
  var t = mn();
  function e(i, a) {
    var s = this, o = this._readableState && this._readableState.destroyed, c = this._writableState && this._writableState.destroyed;
    return o || c ? (a ? a(i) : i && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, t.nextTick(n, this, i)) : t.nextTick(n, this, i)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(i || null, function(f) {
      !a && f ? s._writableState ? s._writableState.errorEmitted || (s._writableState.errorEmitted = !0, t.nextTick(n, s, f)) : t.nextTick(n, s, f) : a && a(f);
    }), this);
  }
  function r() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function n(i, a) {
    i.emit("error", a);
  }
  return rd = {
    destroy: e,
    undestroy: r
  }, rd;
}
var nd, zE;
function r8() {
  if (zE)
    return nd;
  zE = 1;
  var t = mn();
  nd = g;
  function e($) {
    var L = this;
    this.next = null, this.entry = null, this.finish = function() {
      ne(L, $);
    };
  }
  var r = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : t.nextTick, n;
  g.WritableState = m;
  var i = Object.create(Sr());
  i.inherits = ct();
  var a = {
    deprecate: _y()
  }, s = e8(), o = Pu().Buffer, c = (typeof ve < "u" ? ve : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function f($) {
    return o.from($);
  }
  function u($) {
    return o.isBuffer($) || $ instanceof c;
  }
  var l = t8();
  i.inherits(g, s);
  function p() {
  }
  function m($, L) {
    n = n || Ci(), $ = $ || {};
    var P = L instanceof n;
    this.objectMode = !!$.objectMode, P && (this.objectMode = this.objectMode || !!$.writableObjectMode);
    var H = $.highWaterMark, Q = $.writableHighWaterMark, Y = this.objectMode ? 16 : 16 * 1024;
    H || H === 0 ? this.highWaterMark = H : P && (Q || Q === 0) ? this.highWaterMark = Q : this.highWaterMark = Y, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var ce = $.decodeStrings === !1;
    this.decodeStrings = !ce, this.defaultEncoding = $.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(ue) {
      T(L, ue);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new e(this);
  }
  m.prototype.getBuffer = function() {
    for (var L = this.bufferedRequest, P = []; L; )
      P.push(L), L = L.next;
    return P;
  }, function() {
    try {
      Object.defineProperty(m.prototype, "buffer", {
        get: a.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var h;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (h = Function.prototype[Symbol.hasInstance], Object.defineProperty(g, Symbol.hasInstance, {
    value: function($) {
      return h.call(this, $) ? !0 : this !== g ? !1 : $ && $._writableState instanceof m;
    }
  })) : h = function($) {
    return $ instanceof this;
  };
  function g($) {
    if (n = n || Ci(), !h.call(g, this) && !(this instanceof n))
      return new g($);
    this._writableState = new m($, this), this.writable = !0, $ && (typeof $.write == "function" && (this._write = $.write), typeof $.writev == "function" && (this._writev = $.writev), typeof $.destroy == "function" && (this._destroy = $.destroy), typeof $.final == "function" && (this._final = $.final)), s.call(this);
  }
  g.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function v($, L) {
    var P = new Error("write after end");
    $.emit("error", P), t.nextTick(L, P);
  }
  function d($, L, P, H) {
    var Q = !0, Y = !1;
    return P === null ? Y = new TypeError("May not write null values to stream") : typeof P != "string" && P !== void 0 && !L.objectMode && (Y = new TypeError("Invalid non-string/buffer chunk")), Y && ($.emit("error", Y), t.nextTick(H, Y), Q = !1), Q;
  }
  g.prototype.write = function($, L, P) {
    var H = this._writableState, Q = !1, Y = !H.objectMode && u($);
    return Y && !o.isBuffer($) && ($ = f($)), typeof L == "function" && (P = L, L = null), Y ? L = "buffer" : L || (L = H.defaultEncoding), typeof P != "function" && (P = p), H.ended ? v(this, P) : (Y || d(this, H, $, P)) && (H.pendingcb++, Q = x(this, H, Y, $, L, P)), Q;
  }, g.prototype.cork = function() {
    var $ = this._writableState;
    $.corked++;
  }, g.prototype.uncork = function() {
    var $ = this._writableState;
    $.corked && ($.corked--, !$.writing && !$.corked && !$.bufferProcessing && $.bufferedRequest && A(this, $));
  }, g.prototype.setDefaultEncoding = function(L) {
    if (typeof L == "string" && (L = L.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((L + "").toLowerCase()) > -1))
      throw new TypeError("Unknown encoding: " + L);
    return this._writableState.defaultEncoding = L, this;
  };
  function y($, L, P) {
    return !$.objectMode && $.decodeStrings !== !1 && typeof L == "string" && (L = o.from(L, P)), L;
  }
  Object.defineProperty(g.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function x($, L, P, H, Q, Y) {
    if (!P) {
      var ce = y(L, H, Q);
      H !== ce && (P = !0, Q = "buffer", H = ce);
    }
    var ue = L.objectMode ? 1 : H.length;
    L.length += ue;
    var me = L.length < L.highWaterMark;
    if (me || (L.needDrain = !0), L.writing || L.corked) {
      var J = L.lastBufferedRequest;
      L.lastBufferedRequest = {
        chunk: H,
        encoding: Q,
        isBuf: P,
        callback: Y,
        next: null
      }, J ? J.next = L.lastBufferedRequest : L.bufferedRequest = L.lastBufferedRequest, L.bufferedRequestCount += 1;
    } else
      b($, L, !1, ue, H, Q, Y);
    return me;
  }
  function b($, L, P, H, Q, Y, ce) {
    L.writelen = H, L.writecb = ce, L.writing = !0, L.sync = !0, P ? $._writev(Q, L.onwrite) : $._write(Q, Y, L.onwrite), L.sync = !1;
  }
  function w($, L, P, H, Q) {
    --L.pendingcb, P ? (t.nextTick(Q, H), t.nextTick(K, $, L), $._writableState.errorEmitted = !0, $.emit("error", H)) : (Q(H), $._writableState.errorEmitted = !0, $.emit("error", H), K($, L));
  }
  function S($) {
    $.writing = !1, $.writecb = null, $.length -= $.writelen, $.writelen = 0;
  }
  function T($, L) {
    var P = $._writableState, H = P.sync, Q = P.writecb;
    if (S(P), L)
      w($, P, H, L, Q);
    else {
      var Y = R(P);
      !Y && !P.corked && !P.bufferProcessing && P.bufferedRequest && A($, P), H ? r(E, $, P, Y, Q) : E($, P, Y, Q);
    }
  }
  function E($, L, P, H) {
    P || C($, L), L.pendingcb--, H(), K($, L);
  }
  function C($, L) {
    L.length === 0 && L.needDrain && (L.needDrain = !1, $.emit("drain"));
  }
  function A($, L) {
    L.bufferProcessing = !0;
    var P = L.bufferedRequest;
    if ($._writev && P && P.next) {
      var H = L.bufferedRequestCount, Q = new Array(H), Y = L.corkedRequestsFree;
      Y.entry = P;
      for (var ce = 0, ue = !0; P; )
        Q[ce] = P, P.isBuf || (ue = !1), P = P.next, ce += 1;
      Q.allBuffers = ue, b($, L, !0, L.length, Q, "", Y.finish), L.pendingcb++, L.lastBufferedRequest = null, Y.next ? (L.corkedRequestsFree = Y.next, Y.next = null) : L.corkedRequestsFree = new e(L), L.bufferedRequestCount = 0;
    } else {
      for (; P; ) {
        var me = P.chunk, J = P.encoding, O = P.callback, I = L.objectMode ? 1 : me.length;
        if (b($, L, !1, I, me, J, O), P = P.next, L.bufferedRequestCount--, L.writing)
          break;
      }
      P === null && (L.lastBufferedRequest = null);
    }
    L.bufferedRequest = P, L.bufferProcessing = !1;
  }
  g.prototype._write = function($, L, P) {
    P(new Error("_write() is not implemented"));
  }, g.prototype._writev = null, g.prototype.end = function($, L, P) {
    var H = this._writableState;
    typeof $ == "function" ? (P = $, $ = null, L = null) : typeof L == "function" && (P = L, L = null), $ != null && this.write($, L), H.corked && (H.corked = 1, this.uncork()), H.ending || V(this, H, P);
  };
  function R($) {
    return $.ending && $.length === 0 && $.bufferedRequest === null && !$.finished && !$.writing;
  }
  function D($, L) {
    $._final(function(P) {
      L.pendingcb--, P && $.emit("error", P), L.prefinished = !0, $.emit("prefinish"), K($, L);
    });
  }
  function F($, L) {
    !L.prefinished && !L.finalCalled && (typeof $._final == "function" ? (L.pendingcb++, L.finalCalled = !0, t.nextTick(D, $, L)) : (L.prefinished = !0, $.emit("prefinish")));
  }
  function K($, L) {
    var P = R(L);
    return P && (F($, L), L.pendingcb === 0 && (L.finished = !0, $.emit("finish"))), P;
  }
  function V($, L, P) {
    L.ending = !0, K($, L), P && (L.finished ? t.nextTick(P) : $.once("finish", P)), L.ended = !0, $.writable = !1;
  }
  function ne($, L, P) {
    var H = $.entry;
    for ($.entry = null; H; ) {
      var Q = H.callback;
      L.pendingcb--, Q(P), H = H.next;
    }
    L.corkedRequestsFree.next = $;
  }
  return Object.defineProperty(g.prototype, "destroyed", {
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function($) {
      this._writableState && (this._writableState.destroyed = $);
    }
  }), g.prototype.destroy = l.destroy, g.prototype._undestroy = l.undestroy, g.prototype._destroy = function($, L) {
    this.end(), L($);
  }, nd;
}
var id, HE;
function Ci() {
  if (HE)
    return id;
  HE = 1;
  var t = mn(), e = Object.keys || function(l) {
    var p = [];
    for (var m in l)
      p.push(m);
    return p;
  };
  id = c;
  var r = Object.create(Sr());
  r.inherits = ct();
  var n = n8(), i = r8();
  r.inherits(c, n);
  for (var a = e(i.prototype), s = 0; s < a.length; s++) {
    var o = a[s];
    c.prototype[o] || (c.prototype[o] = i.prototype[o]);
  }
  function c(l) {
    if (!(this instanceof c))
      return new c(l);
    n.call(this, l), i.call(this, l), l && l.readable === !1 && (this.readable = !1), l && l.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, l && l.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", f);
  }
  Object.defineProperty(c.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function f() {
    this.allowHalfOpen || this._writableState.ended || t.nextTick(u, this);
  }
  function u(l) {
    l.end();
  }
  return Object.defineProperty(c.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(l) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = l, this._writableState.destroyed = l);
    }
  }), c.prototype._destroy = function(l, p) {
    this.push(null), this.end(), t.nextTick(p, l);
  }, id;
}
var ad = {}, WE;
function GE() {
  if (WE)
    return ad;
  WE = 1;
  var t = Pu().Buffer, e = t.isEncoding || function(d) {
    switch (d = "" + d, d && d.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function r(d) {
    if (!d)
      return "utf8";
    for (var y; ; )
      switch (d) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return d;
        default:
          if (y)
            return;
          d = ("" + d).toLowerCase(), y = !0;
      }
  }
  function n(d) {
    var y = r(d);
    if (typeof y != "string" && (t.isEncoding === e || !e(d)))
      throw new Error("Unknown encoding: " + d);
    return y || d;
  }
  ad.StringDecoder = i;
  function i(d) {
    this.encoding = n(d);
    var y;
    switch (this.encoding) {
      case "utf16le":
        this.text = l, this.end = p, y = 4;
        break;
      case "utf8":
        this.fillLast = c, y = 4;
        break;
      case "base64":
        this.text = m, this.end = h, y = 3;
        break;
      default:
        this.write = g, this.end = v;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = t.allocUnsafe(y);
  }
  i.prototype.write = function(d) {
    if (d.length === 0)
      return "";
    var y, x;
    if (this.lastNeed) {
      if (y = this.fillLast(d), y === void 0)
        return "";
      x = this.lastNeed, this.lastNeed = 0;
    } else
      x = 0;
    return x < d.length ? y ? y + this.text(d, x) : this.text(d, x) : y || "";
  }, i.prototype.end = u, i.prototype.text = f, i.prototype.fillLast = function(d) {
    if (this.lastNeed <= d.length)
      return d.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    d.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, d.length), this.lastNeed -= d.length;
  };
  function a(d) {
    return d <= 127 ? 0 : d >> 5 === 6 ? 2 : d >> 4 === 14 ? 3 : d >> 3 === 30 ? 4 : d >> 6 === 2 ? -1 : -2;
  }
  function s(d, y, x) {
    var b = y.length - 1;
    if (b < x)
      return 0;
    var w = a(y[b]);
    return w >= 0 ? (w > 0 && (d.lastNeed = w - 1), w) : --b < x || w === -2 ? 0 : (w = a(y[b]), w >= 0 ? (w > 0 && (d.lastNeed = w - 2), w) : --b < x || w === -2 ? 0 : (w = a(y[b]), w >= 0 ? (w > 0 && (w === 2 ? w = 0 : d.lastNeed = w - 3), w) : 0));
  }
  function o(d, y, x) {
    if ((y[0] & 192) !== 128)
      return d.lastNeed = 0, "";
    if (d.lastNeed > 1 && y.length > 1) {
      if ((y[1] & 192) !== 128)
        return d.lastNeed = 1, "";
      if (d.lastNeed > 2 && y.length > 2 && (y[2] & 192) !== 128)
        return d.lastNeed = 2, "";
    }
  }
  function c(d) {
    var y = this.lastTotal - this.lastNeed, x = o(this, d);
    if (x !== void 0)
      return x;
    if (this.lastNeed <= d.length)
      return d.copy(this.lastChar, y, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    d.copy(this.lastChar, y, 0, d.length), this.lastNeed -= d.length;
  }
  function f(d, y) {
    var x = s(this, d, y);
    if (!this.lastNeed)
      return d.toString("utf8", y);
    this.lastTotal = x;
    var b = d.length - (x - this.lastNeed);
    return d.copy(this.lastChar, 0, b), d.toString("utf8", y, b);
  }
  function u(d) {
    var y = d && d.length ? this.write(d) : "";
    return this.lastNeed ? y + "" : y;
  }
  function l(d, y) {
    if ((d.length - y) % 2 === 0) {
      var x = d.toString("utf16le", y);
      if (x) {
        var b = x.charCodeAt(x.length - 1);
        if (b >= 55296 && b <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = d[d.length - 2], this.lastChar[1] = d[d.length - 1], x.slice(0, -1);
      }
      return x;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = d[d.length - 1], d.toString("utf16le", y, d.length - 1);
  }
  function p(d) {
    var y = d && d.length ? this.write(d) : "";
    if (this.lastNeed) {
      var x = this.lastTotal - this.lastNeed;
      return y + this.lastChar.toString("utf16le", 0, x);
    }
    return y;
  }
  function m(d, y) {
    var x = (d.length - y) % 3;
    return x === 0 ? d.toString("base64", y) : (this.lastNeed = 3 - x, this.lastTotal = 3, x === 1 ? this.lastChar[0] = d[d.length - 1] : (this.lastChar[0] = d[d.length - 2], this.lastChar[1] = d[d.length - 1]), d.toString("base64", y, d.length - x));
  }
  function h(d) {
    var y = d && d.length ? this.write(d) : "";
    return this.lastNeed ? y + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : y;
  }
  function g(d) {
    return d.toString(this.encoding);
  }
  function v(d) {
    return d && d.length ? this.write(d) : "";
  }
  return ad;
}
var sd, QE;
function n8() {
  if (QE)
    return sd;
  QE = 1;
  var t = mn();
  sd = y;
  var e = ufe(), r;
  y.ReadableState = d, bt.EventEmitter;
  var n = function(O, I) {
    return O.listeners(I).length;
  }, i = e8(), a = Pu().Buffer, s = (typeof ve < "u" ? ve : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function o(O) {
    return a.from(O);
  }
  function c(O) {
    return a.isBuffer(O) || O instanceof s;
  }
  var f = Object.create(Sr());
  f.inherits = ct();
  var u = se, l = void 0;
  u && u.debuglog ? l = u.debuglog("stream") : l = function() {
  };
  var p = lfe(), m = t8(), h;
  f.inherits(y, i);
  var g = ["error", "close", "destroy", "pause", "resume"];
  function v(O, I, z) {
    if (typeof O.prependListener == "function")
      return O.prependListener(I, z);
    !O._events || !O._events[I] ? O.on(I, z) : e(O._events[I]) ? O._events[I].unshift(z) : O._events[I] = [z, O._events[I]];
  }
  function d(O, I) {
    r = r || Ci(), O = O || {};
    var z = I instanceof r;
    this.objectMode = !!O.objectMode, z && (this.objectMode = this.objectMode || !!O.readableObjectMode);
    var G = O.highWaterMark, q = O.readableHighWaterMark, M = this.objectMode ? 16 : 16 * 1024;
    G || G === 0 ? this.highWaterMark = G : z && (q || q === 0) ? this.highWaterMark = q : this.highWaterMark = M, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new p(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = O.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, O.encoding && (h || (h = GE().StringDecoder), this.decoder = new h(O.encoding), this.encoding = O.encoding);
  }
  function y(O) {
    if (r = r || Ci(), !(this instanceof y))
      return new y(O);
    this._readableState = new d(O, this), this.readable = !0, O && (typeof O.read == "function" && (this._read = O.read), typeof O.destroy == "function" && (this._destroy = O.destroy)), i.call(this);
  }
  Object.defineProperty(y.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(O) {
      this._readableState && (this._readableState.destroyed = O);
    }
  }), y.prototype.destroy = m.destroy, y.prototype._undestroy = m.undestroy, y.prototype._destroy = function(O, I) {
    this.push(null), I(O);
  }, y.prototype.push = function(O, I) {
    var z = this._readableState, G;
    return z.objectMode ? G = !0 : typeof O == "string" && (I = I || z.defaultEncoding, I !== z.encoding && (O = a.from(O, I), I = ""), G = !0), x(this, O, I, !1, G);
  }, y.prototype.unshift = function(O) {
    return x(this, O, null, !0, !1);
  };
  function x(O, I, z, G, q) {
    var M = O._readableState;
    if (I === null)
      M.reading = !1, A(O, M);
    else {
      var Z;
      q || (Z = w(M, I)), Z ? O.emit("error", Z) : M.objectMode || I && I.length > 0 ? (typeof I != "string" && !M.objectMode && Object.getPrototypeOf(I) !== a.prototype && (I = o(I)), G ? M.endEmitted ? O.emit("error", new Error("stream.unshift() after end event")) : b(O, M, I, !0) : M.ended ? O.emit("error", new Error("stream.push() after EOF")) : (M.reading = !1, M.decoder && !z ? (I = M.decoder.write(I), M.objectMode || I.length !== 0 ? b(O, M, I, !1) : F(O, M)) : b(O, M, I, !1))) : G || (M.reading = !1);
    }
    return S(M);
  }
  function b(O, I, z, G) {
    I.flowing && I.length === 0 && !I.sync ? (O.emit("data", z), O.read(0)) : (I.length += I.objectMode ? 1 : z.length, G ? I.buffer.unshift(z) : I.buffer.push(z), I.needReadable && R(O)), F(O, I);
  }
  function w(O, I) {
    var z;
    return !c(I) && typeof I != "string" && I !== void 0 && !O.objectMode && (z = new TypeError("Invalid non-string/buffer chunk")), z;
  }
  function S(O) {
    return !O.ended && (O.needReadable || O.length < O.highWaterMark || O.length === 0);
  }
  y.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, y.prototype.setEncoding = function(O) {
    return h || (h = GE().StringDecoder), this._readableState.decoder = new h(O), this._readableState.encoding = O, this;
  };
  var T = 8388608;
  function E(O) {
    return O >= T ? O = T : (O--, O |= O >>> 1, O |= O >>> 2, O |= O >>> 4, O |= O >>> 8, O |= O >>> 16, O++), O;
  }
  function C(O, I) {
    return O <= 0 || I.length === 0 && I.ended ? 0 : I.objectMode ? 1 : O !== O ? I.flowing && I.length ? I.buffer.head.data.length : I.length : (O > I.highWaterMark && (I.highWaterMark = E(O)), O <= I.length ? O : I.ended ? I.length : (I.needReadable = !0, 0));
  }
  y.prototype.read = function(O) {
    l("read", O), O = parseInt(O, 10);
    var I = this._readableState, z = O;
    if (O !== 0 && (I.emittedReadable = !1), O === 0 && I.needReadable && (I.length >= I.highWaterMark || I.ended))
      return l("read: emitReadable", I.length, I.ended), I.length === 0 && I.ended ? ue(this) : R(this), null;
    if (O = C(O, I), O === 0 && I.ended)
      return I.length === 0 && ue(this), null;
    var G = I.needReadable;
    l("need readable", G), (I.length === 0 || I.length - O < I.highWaterMark) && (G = !0, l("length less than watermark", G)), I.ended || I.reading ? (G = !1, l("reading or ended", G)) : G && (l("do read"), I.reading = !0, I.sync = !0, I.length === 0 && (I.needReadable = !0), this._read(I.highWaterMark), I.sync = !1, I.reading || (O = C(z, I)));
    var q;
    return O > 0 ? q = H(O, I) : q = null, q === null ? (I.needReadable = !0, O = 0) : I.length -= O, I.length === 0 && (I.ended || (I.needReadable = !0), z !== O && I.ended && ue(this)), q !== null && this.emit("data", q), q;
  };
  function A(O, I) {
    if (!I.ended) {
      if (I.decoder) {
        var z = I.decoder.end();
        z && z.length && (I.buffer.push(z), I.length += I.objectMode ? 1 : z.length);
      }
      I.ended = !0, R(O);
    }
  }
  function R(O) {
    var I = O._readableState;
    I.needReadable = !1, I.emittedReadable || (l("emitReadable", I.flowing), I.emittedReadable = !0, I.sync ? t.nextTick(D, O) : D(O));
  }
  function D(O) {
    l("emit readable"), O.emit("readable"), P(O);
  }
  function F(O, I) {
    I.readingMore || (I.readingMore = !0, t.nextTick(K, O, I));
  }
  function K(O, I) {
    for (var z = I.length; !I.reading && !I.flowing && !I.ended && I.length < I.highWaterMark && (l("maybeReadMore read 0"), O.read(0), z !== I.length); )
      z = I.length;
    I.readingMore = !1;
  }
  y.prototype._read = function(O) {
    this.emit("error", new Error("_read() is not implemented"));
  }, y.prototype.pipe = function(O, I) {
    var z = this, G = this._readableState;
    switch (G.pipesCount) {
      case 0:
        G.pipes = O;
        break;
      case 1:
        G.pipes = [G.pipes, O];
        break;
      default:
        G.pipes.push(O);
        break;
    }
    G.pipesCount += 1, l("pipe count=%d opts=%j", G.pipesCount, I);
    var q = (!I || I.end !== !1) && O !== process.stdout && O !== process.stderr, M = q ? B : be;
    G.endEmitted ? t.nextTick(M) : z.once("end", M), O.on("unpipe", Z);
    function Z(ye, Ee) {
      l("onunpipe"), ye === z && Ee && Ee.hasUnpiped === !1 && (Ee.hasUnpiped = !0, k());
    }
    function B() {
      l("onend"), O.end();
    }
    var re = V(z);
    O.on("drain", re);
    var j = !1;
    function k() {
      l("cleanup"), O.removeListener("close", pe), O.removeListener("finish", he), O.removeListener("drain", re), O.removeListener("error", ee), O.removeListener("unpipe", Z), z.removeListener("end", B), z.removeListener("end", be), z.removeListener("data", U), j = !0, G.awaitDrain && (!O._writableState || O._writableState.needDrain) && re();
    }
    var N = !1;
    z.on("data", U);
    function U(ye) {
      l("ondata"), N = !1;
      var Ee = O.write(ye);
      Ee === !1 && !N && ((G.pipesCount === 1 && G.pipes === O || G.pipesCount > 1 && J(G.pipes, O) !== -1) && !j && (l("false write response, pause", G.awaitDrain), G.awaitDrain++, N = !0), z.pause());
    }
    function ee(ye) {
      l("onerror", ye), be(), O.removeListener("error", ee), n(O, "error") === 0 && O.emit("error", ye);
    }
    v(O, "error", ee);
    function pe() {
      O.removeListener("finish", he), be();
    }
    O.once("close", pe);
    function he() {
      l("onfinish"), O.removeListener("close", pe), be();
    }
    O.once("finish", he);
    function be() {
      l("unpipe"), z.unpipe(O);
    }
    return O.emit("pipe", z), G.flowing || (l("pipe resume"), z.resume()), O;
  };
  function V(O) {
    return function() {
      var I = O._readableState;
      l("pipeOnDrain", I.awaitDrain), I.awaitDrain && I.awaitDrain--, I.awaitDrain === 0 && n(O, "data") && (I.flowing = !0, P(O));
    };
  }
  y.prototype.unpipe = function(O) {
    var I = this._readableState, z = { hasUnpiped: !1 };
    if (I.pipesCount === 0)
      return this;
    if (I.pipesCount === 1)
      return O && O !== I.pipes ? this : (O || (O = I.pipes), I.pipes = null, I.pipesCount = 0, I.flowing = !1, O && O.emit("unpipe", this, z), this);
    if (!O) {
      var G = I.pipes, q = I.pipesCount;
      I.pipes = null, I.pipesCount = 0, I.flowing = !1;
      for (var M = 0; M < q; M++)
        G[M].emit("unpipe", this, { hasUnpiped: !1 });
      return this;
    }
    var Z = J(I.pipes, O);
    return Z === -1 ? this : (I.pipes.splice(Z, 1), I.pipesCount -= 1, I.pipesCount === 1 && (I.pipes = I.pipes[0]), O.emit("unpipe", this, z), this);
  }, y.prototype.on = function(O, I) {
    var z = i.prototype.on.call(this, O, I);
    if (O === "data")
      this._readableState.flowing !== !1 && this.resume();
    else if (O === "readable") {
      var G = this._readableState;
      !G.endEmitted && !G.readableListening && (G.readableListening = G.needReadable = !0, G.emittedReadable = !1, G.reading ? G.length && R(this) : t.nextTick(ne, this));
    }
    return z;
  }, y.prototype.addListener = y.prototype.on;
  function ne(O) {
    l("readable nexttick read 0"), O.read(0);
  }
  y.prototype.resume = function() {
    var O = this._readableState;
    return O.flowing || (l("resume"), O.flowing = !0, $(this, O)), this;
  };
  function $(O, I) {
    I.resumeScheduled || (I.resumeScheduled = !0, t.nextTick(L, O, I));
  }
  function L(O, I) {
    I.reading || (l("resume read 0"), O.read(0)), I.resumeScheduled = !1, I.awaitDrain = 0, O.emit("resume"), P(O), I.flowing && !I.reading && O.read(0);
  }
  y.prototype.pause = function() {
    return l("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (l("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
  };
  function P(O) {
    var I = O._readableState;
    for (l("flow", I.flowing); I.flowing && O.read() !== null; )
      ;
  }
  y.prototype.wrap = function(O) {
    var I = this, z = this._readableState, G = !1;
    O.on("end", function() {
      if (l("wrapped end"), z.decoder && !z.ended) {
        var Z = z.decoder.end();
        Z && Z.length && I.push(Z);
      }
      I.push(null);
    }), O.on("data", function(Z) {
      if (l("wrapped data"), z.decoder && (Z = z.decoder.write(Z)), !(z.objectMode && Z == null) && !(!z.objectMode && (!Z || !Z.length))) {
        var B = I.push(Z);
        B || (G = !0, O.pause());
      }
    });
    for (var q in O)
      this[q] === void 0 && typeof O[q] == "function" && (this[q] = function(Z) {
        return function() {
          return O[Z].apply(O, arguments);
        };
      }(q));
    for (var M = 0; M < g.length; M++)
      O.on(g[M], this.emit.bind(this, g[M]));
    return this._read = function(Z) {
      l("wrapped _read", Z), G && (G = !1, O.resume());
    }, this;
  }, Object.defineProperty(y.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), y._fromList = H;
  function H(O, I) {
    if (I.length === 0)
      return null;
    var z;
    return I.objectMode ? z = I.buffer.shift() : !O || O >= I.length ? (I.decoder ? z = I.buffer.join("") : I.buffer.length === 1 ? z = I.buffer.head.data : z = I.buffer.concat(I.length), I.buffer.clear()) : z = Q(O, I.buffer, I.decoder), z;
  }
  function Q(O, I, z) {
    var G;
    return O < I.head.data.length ? (G = I.head.data.slice(0, O), I.head.data = I.head.data.slice(O)) : O === I.head.data.length ? G = I.shift() : G = z ? Y(O, I) : ce(O, I), G;
  }
  function Y(O, I) {
    var z = I.head, G = 1, q = z.data;
    for (O -= q.length; z = z.next; ) {
      var M = z.data, Z = O > M.length ? M.length : O;
      if (Z === M.length ? q += M : q += M.slice(0, O), O -= Z, O === 0) {
        Z === M.length ? (++G, z.next ? I.head = z.next : I.head = I.tail = null) : (I.head = z, z.data = M.slice(Z));
        break;
      }
      ++G;
    }
    return I.length -= G, q;
  }
  function ce(O, I) {
    var z = a.allocUnsafe(O), G = I.head, q = 1;
    for (G.data.copy(z), O -= G.data.length; G = G.next; ) {
      var M = G.data, Z = O > M.length ? M.length : O;
      if (M.copy(z, z.length - O, 0, Z), O -= Z, O === 0) {
        Z === M.length ? (++q, G.next ? I.head = G.next : I.head = I.tail = null) : (I.head = G, G.data = M.slice(Z));
        break;
      }
      ++q;
    }
    return I.length -= q, z;
  }
  function ue(O) {
    var I = O._readableState;
    if (I.length > 0)
      throw new Error('"endReadable()" called on non-empty stream');
    I.endEmitted || (I.ended = !0, t.nextTick(me, I, O));
  }
  function me(O, I) {
    !O.endEmitted && O.length === 0 && (O.endEmitted = !0, I.readable = !1, I.emit("end"));
  }
  function J(O, I) {
    for (var z = 0, G = O.length; z < G; z++)
      if (O[z] === I)
        return z;
    return -1;
  }
  return sd;
}
var od, VE;
function i8() {
  if (VE)
    return od;
  VE = 1, od = n;
  var t = Ci(), e = Object.create(Sr());
  e.inherits = ct(), e.inherits(n, t);
  function r(s, o) {
    var c = this._transformState;
    c.transforming = !1;
    var f = c.writecb;
    if (!f)
      return this.emit("error", new Error("write callback called multiple times"));
    c.writechunk = null, c.writecb = null, o != null && this.push(o), f(s);
    var u = this._readableState;
    u.reading = !1, (u.needReadable || u.length < u.highWaterMark) && this._read(u.highWaterMark);
  }
  function n(s) {
    if (!(this instanceof n))
      return new n(s);
    t.call(this, s), this._transformState = {
      afterTransform: r.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, s && (typeof s.transform == "function" && (this._transform = s.transform), typeof s.flush == "function" && (this._flush = s.flush)), this.on("prefinish", i);
  }
  function i() {
    var s = this;
    typeof this._flush == "function" ? this._flush(function(o, c) {
      a(s, o, c);
    }) : a(this, null, null);
  }
  n.prototype.push = function(s, o) {
    return this._transformState.needTransform = !1, t.prototype.push.call(this, s, o);
  }, n.prototype._transform = function(s, o, c) {
    throw new Error("_transform() is not implemented");
  }, n.prototype._write = function(s, o, c) {
    var f = this._transformState;
    if (f.writecb = c, f.writechunk = s, f.writeencoding = o, !f.transforming) {
      var u = this._readableState;
      (f.needTransform || u.needReadable || u.length < u.highWaterMark) && this._read(u.highWaterMark);
    }
  }, n.prototype._read = function(s) {
    var o = this._transformState;
    o.writechunk !== null && o.writecb && !o.transforming ? (o.transforming = !0, this._transform(o.writechunk, o.writeencoding, o.afterTransform)) : o.needTransform = !0;
  }, n.prototype._destroy = function(s, o) {
    var c = this;
    t.prototype._destroy.call(this, s, function(f) {
      o(f), c.emit("close");
    });
  };
  function a(s, o, c) {
    if (o)
      return s.emit("error", o);
    if (c != null && s.push(c), s._writableState.length)
      throw new Error("Calling transform done when ws.length != 0");
    if (s._transformState.transforming)
      throw new Error("Calling transform done when still transforming");
    return s.push(null);
  }
  return od;
}
var cd, KE;
function pfe() {
  if (KE)
    return cd;
  KE = 1, cd = r;
  var t = i8(), e = Object.create(Sr());
  e.inherits = ct(), e.inherits(r, t);
  function r(n) {
    if (!(this instanceof r))
      return new r(n);
    t.call(this, n);
  }
  return r.prototype._transform = function(n, i, a) {
    a(null, n);
  }, cd;
}
var JE;
function ffe() {
  return JE || (JE = 1, function(t, e) {
    e = t.exports = n8(), e.Stream = e, e.Readable = e, e.Writable = r8(), e.Duplex = Ci(), e.Transform = i8(), e.PassThrough = pfe();
  }(uo, uo.exports)), uo.exports;
}
var ud = { exports: {} }, ld, XE;
function hfe() {
  if (XE)
    return ld;
  XE = 1;
  var t = 9007199254740991, e = "[object Arguments]", r = "[object Function]", n = "[object GeneratorFunction]", i = typeof ve == "object" && ve && ve.Object === Object && ve, a = typeof self == "object" && self && self.Object === Object && self, s = i || a || Function("return this")();
  function o(C, A) {
    for (var R = -1, D = A.length, F = C.length; ++R < D; )
      C[F + R] = A[R];
    return C;
  }
  var c = Object.prototype, f = c.hasOwnProperty, u = c.toString, l = s.Symbol, p = c.propertyIsEnumerable, m = l ? l.isConcatSpreadable : void 0;
  function h(C, A, R, D, F) {
    var K = -1, V = C.length;
    for (R || (R = g), F || (F = []); ++K < V; ) {
      var ne = C[K];
      A > 0 && R(ne) ? A > 1 ? h(ne, A - 1, R, D, F) : o(F, ne) : D || (F[F.length] = ne);
    }
    return F;
  }
  function g(C) {
    return y(C) || d(C) || !!(m && C && C[m]);
  }
  function v(C) {
    var A = C ? C.length : 0;
    return A ? h(C, 1) : [];
  }
  function d(C) {
    return b(C) && f.call(C, "callee") && (!p.call(C, "callee") || u.call(C) == e);
  }
  var y = Array.isArray;
  function x(C) {
    return C != null && S(C.length) && !w(C);
  }
  function b(C) {
    return E(C) && x(C);
  }
  function w(C) {
    var A = T(C) ? u.call(C) : "";
    return A == r || A == n;
  }
  function S(C) {
    return typeof C == "number" && C > -1 && C % 1 == 0 && C <= t;
  }
  function T(C) {
    var A = typeof C;
    return !!C && (A == "object" || A == "function");
  }
  function E(C) {
    return !!C && typeof C == "object";
  }
  return ld = v, ld;
}
var pd, ZE;
function dfe() {
  if (ZE)
    return pd;
  ZE = 1;
  var t = 200, e = "__lodash_hash_undefined__", r = 9007199254740991, n = "[object Arguments]", i = "[object Function]", a = "[object GeneratorFunction]", s = /[\\^$.*+?()[\]{}|]/g, o = /^\[object .+?Constructor\]$/, c = typeof ve == "object" && ve && ve.Object === Object && ve, f = typeof self == "object" && self && self.Object === Object && self, u = c || f || Function("return this")();
  function l(te, fe, ge) {
    switch (ge.length) {
      case 0:
        return te.call(fe);
      case 1:
        return te.call(fe, ge[0]);
      case 2:
        return te.call(fe, ge[0], ge[1]);
      case 3:
        return te.call(fe, ge[0], ge[1], ge[2]);
    }
    return te.apply(fe, ge);
  }
  function p(te, fe) {
    var ge = te ? te.length : 0;
    return !!ge && d(te, fe, 0) > -1;
  }
  function m(te, fe, ge) {
    for (var X = -1, oe = te ? te.length : 0; ++X < oe; )
      if (ge(fe, te[X]))
        return !0;
    return !1;
  }
  function h(te, fe) {
    for (var ge = -1, X = te ? te.length : 0, oe = Array(X); ++ge < X; )
      oe[ge] = fe(te[ge], ge, te);
    return oe;
  }
  function g(te, fe) {
    for (var ge = -1, X = fe.length, oe = te.length; ++ge < X; )
      te[oe + ge] = fe[ge];
    return te;
  }
  function v(te, fe, ge, X) {
    for (var oe = te.length, de = ge + (X ? 1 : -1); X ? de-- : ++de < oe; )
      if (fe(te[de], de, te))
        return de;
    return -1;
  }
  function d(te, fe, ge) {
    if (fe !== fe)
      return v(te, y, ge);
    for (var X = ge - 1, oe = te.length; ++X < oe; )
      if (te[X] === fe)
        return X;
    return -1;
  }
  function y(te) {
    return te !== te;
  }
  function x(te) {
    return function(fe) {
      return te(fe);
    };
  }
  function b(te, fe) {
    return te.has(fe);
  }
  function w(te, fe) {
    return te == null ? void 0 : te[fe];
  }
  function S(te) {
    var fe = !1;
    if (te != null && typeof te.toString != "function")
      try {
        fe = !!(te + "");
      } catch {
      }
    return fe;
  }
  var T = Array.prototype, E = Function.prototype, C = Object.prototype, A = u["__core-js_shared__"], R = function() {
    var te = /[^.]+$/.exec(A && A.keys && A.keys.IE_PROTO || "");
    return te ? "Symbol(src)_1." + te : "";
  }(), D = E.toString, F = C.hasOwnProperty, K = C.toString, V = RegExp(
    "^" + D.call(F).replace(s, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), ne = u.Symbol, $ = C.propertyIsEnumerable, L = T.splice, P = ne ? ne.isConcatSpreadable : void 0, H = Math.max, Q = Se(u, "Map"), Y = Se(Object, "create");
  function ce(te) {
    var fe = -1, ge = te ? te.length : 0;
    for (this.clear(); ++fe < ge; ) {
      var X = te[fe];
      this.set(X[0], X[1]);
    }
  }
  function ue() {
    this.__data__ = Y ? Y(null) : {};
  }
  function me(te) {
    return this.has(te) && delete this.__data__[te];
  }
  function J(te) {
    var fe = this.__data__;
    if (Y) {
      var ge = fe[te];
      return ge === e ? void 0 : ge;
    }
    return F.call(fe, te) ? fe[te] : void 0;
  }
  function O(te) {
    var fe = this.__data__;
    return Y ? fe[te] !== void 0 : F.call(fe, te);
  }
  function I(te, fe) {
    var ge = this.__data__;
    return ge[te] = Y && fe === void 0 ? e : fe, this;
  }
  ce.prototype.clear = ue, ce.prototype.delete = me, ce.prototype.get = J, ce.prototype.has = O, ce.prototype.set = I;
  function z(te) {
    var fe = -1, ge = te ? te.length : 0;
    for (this.clear(); ++fe < ge; ) {
      var X = te[fe];
      this.set(X[0], X[1]);
    }
  }
  function G() {
    this.__data__ = [];
  }
  function q(te) {
    var fe = this.__data__, ge = ye(fe, te);
    if (ge < 0)
      return !1;
    var X = fe.length - 1;
    return ge == X ? fe.pop() : L.call(fe, ge, 1), !0;
  }
  function M(te) {
    var fe = this.__data__, ge = ye(fe, te);
    return ge < 0 ? void 0 : fe[ge][1];
  }
  function Z(te) {
    return ye(this.__data__, te) > -1;
  }
  function B(te, fe) {
    var ge = this.__data__, X = ye(ge, te);
    return X < 0 ? ge.push([te, fe]) : ge[X][1] = fe, this;
  }
  z.prototype.clear = G, z.prototype.delete = q, z.prototype.get = M, z.prototype.has = Z, z.prototype.set = B;
  function re(te) {
    var fe = -1, ge = te ? te.length : 0;
    for (this.clear(); ++fe < ge; ) {
      var X = te[fe];
      this.set(X[0], X[1]);
    }
  }
  function j() {
    this.__data__ = {
      hash: new ce(),
      map: new (Q || z)(),
      string: new ce()
    };
  }
  function k(te) {
    return W(this, te).delete(te);
  }
  function N(te) {
    return W(this, te).get(te);
  }
  function U(te) {
    return W(this, te).has(te);
  }
  function ee(te, fe) {
    return W(this, te).set(te, fe), this;
  }
  re.prototype.clear = j, re.prototype.delete = k, re.prototype.get = N, re.prototype.has = U, re.prototype.set = ee;
  function pe(te) {
    var fe = -1, ge = te ? te.length : 0;
    for (this.__data__ = new re(); ++fe < ge; )
      this.add(te[fe]);
  }
  function he(te) {
    return this.__data__.set(te, e), this;
  }
  function be(te) {
    return this.__data__.has(te);
  }
  pe.prototype.add = pe.prototype.push = he, pe.prototype.has = be;
  function ye(te, fe) {
    for (var ge = te.length; ge--; )
      if (Pe(te[ge][0], fe))
        return ge;
    return -1;
  }
  function Ee(te, fe, ge, X) {
    var oe = -1, de = p, _e = !0, Le = te.length, Xe = [], It = fe.length;
    if (!Le)
      return Xe;
    ge && (fe = h(fe, x(ge))), X ? (de = m, _e = !1) : fe.length >= t && (de = b, _e = !1, fe = new pe(fe));
    e:
      for (; ++oe < Le; ) {
        var tt = te[oe], dt = ge ? ge(tt) : tt;
        if (tt = X || tt !== 0 ? tt : 0, _e && dt === dt) {
          for (var zr = It; zr--; )
            if (fe[zr] === dt)
              continue e;
          Xe.push(tt);
        } else
          de(fe, dt, X) || Xe.push(tt);
      }
    return Xe;
  }
  function $e(te, fe, ge, X, oe) {
    var de = -1, _e = te.length;
    for (ge || (ge = cr), oe || (oe = []); ++de < _e; ) {
      var Le = te[de];
      fe > 0 && ge(Le) ? fe > 1 ? $e(Le, fe - 1, ge, X, oe) : g(oe, Le) : X || (oe[oe.length] = Le);
    }
    return oe;
  }
  function Ce(te) {
    if (!Cr(te) || ie(te))
      return !1;
    var fe = ut(te) || S(te) ? V : o;
    return fe.test(ae(te));
  }
  function le(te, fe) {
    return fe = H(fe === void 0 ? te.length - 1 : fe, 0), function() {
      for (var ge = arguments, X = -1, oe = H(ge.length - fe, 0), de = Array(oe); ++X < oe; )
        de[X] = ge[fe + X];
      X = -1;
      for (var _e = Array(fe + 1); ++X < fe; )
        _e[X] = ge[X];
      return _e[fe] = de, l(te, this, _e);
    };
  }
  function W(te, fe) {
    var ge = te.__data__;
    return ur(fe) ? ge[typeof fe == "string" ? "string" : "hash"] : ge.map;
  }
  function Se(te, fe) {
    var ge = w(te, fe);
    return Ce(ge) ? ge : void 0;
  }
  function cr(te) {
    return Oe(te) || Qe(te) || !!(P && te && te[P]);
  }
  function ur(te) {
    var fe = typeof te;
    return fe == "string" || fe == "number" || fe == "symbol" || fe == "boolean" ? te !== "__proto__" : te === null;
  }
  function ie(te) {
    return !!R && R in te;
  }
  function ae(te) {
    if (te != null) {
      try {
        return D.call(te);
      } catch {
      }
      try {
        return te + "";
      } catch {
      }
    }
    return "";
  }
  var Ne = le(function(te, fe) {
    return Nt(te) ? Ee(te, $e(fe, 1, Nt, !0)) : [];
  });
  function Pe(te, fe) {
    return te === fe || te !== te && fe !== fe;
  }
  function Qe(te) {
    return Nt(te) && F.call(te, "callee") && (!$.call(te, "callee") || K.call(te) == n);
  }
  var Oe = Array.isArray;
  function qt(te) {
    return te != null && Lt(te.length) && !ut(te);
  }
  function Nt(te) {
    return lr(te) && qt(te);
  }
  function ut(te) {
    var fe = Cr(te) ? K.call(te) : "";
    return fe == i || fe == a;
  }
  function Lt(te) {
    return typeof te == "number" && te > -1 && te % 1 == 0 && te <= r;
  }
  function Cr(te) {
    var fe = typeof te;
    return !!te && (fe == "object" || fe == "function");
  }
  function lr(te) {
    return !!te && typeof te == "object";
  }
  return pd = Ne, pd;
}
var fd, YE;
function mfe() {
  if (YE)
    return fd;
  YE = 1;
  var t = 200, e = "__lodash_hash_undefined__", r = 1 / 0, n = 9007199254740991, i = "[object Arguments]", a = "[object Function]", s = "[object GeneratorFunction]", o = /[\\^$.*+?()[\]{}|]/g, c = /^\[object .+?Constructor\]$/, f = typeof ve == "object" && ve && ve.Object === Object && ve, u = typeof self == "object" && self && self.Object === Object && self, l = f || u || Function("return this")();
  function p(X, oe, de) {
    switch (de.length) {
      case 0:
        return X.call(oe);
      case 1:
        return X.call(oe, de[0]);
      case 2:
        return X.call(oe, de[0], de[1]);
      case 3:
        return X.call(oe, de[0], de[1], de[2]);
    }
    return X.apply(oe, de);
  }
  function m(X, oe) {
    var de = X ? X.length : 0;
    return !!de && d(X, oe, 0) > -1;
  }
  function h(X, oe, de) {
    for (var _e = -1, Le = X ? X.length : 0; ++_e < Le; )
      if (de(oe, X[_e]))
        return !0;
    return !1;
  }
  function g(X, oe) {
    for (var de = -1, _e = oe.length, Le = X.length; ++de < _e; )
      X[Le + de] = oe[de];
    return X;
  }
  function v(X, oe, de, _e) {
    for (var Le = X.length, Xe = de + (_e ? 1 : -1); _e ? Xe-- : ++Xe < Le; )
      if (oe(X[Xe], Xe, X))
        return Xe;
    return -1;
  }
  function d(X, oe, de) {
    if (oe !== oe)
      return v(X, y, de);
    for (var _e = de - 1, Le = X.length; ++_e < Le; )
      if (X[_e] === oe)
        return _e;
    return -1;
  }
  function y(X) {
    return X !== X;
  }
  function x(X, oe) {
    return X.has(oe);
  }
  function b(X, oe) {
    return X == null ? void 0 : X[oe];
  }
  function w(X) {
    var oe = !1;
    if (X != null && typeof X.toString != "function")
      try {
        oe = !!(X + "");
      } catch {
      }
    return oe;
  }
  function S(X) {
    var oe = -1, de = Array(X.size);
    return X.forEach(function(_e) {
      de[++oe] = _e;
    }), de;
  }
  var T = Array.prototype, E = Function.prototype, C = Object.prototype, A = l["__core-js_shared__"], R = function() {
    var X = /[^.]+$/.exec(A && A.keys && A.keys.IE_PROTO || "");
    return X ? "Symbol(src)_1." + X : "";
  }(), D = E.toString, F = C.hasOwnProperty, K = C.toString, V = RegExp(
    "^" + D.call(F).replace(o, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), ne = l.Symbol, $ = C.propertyIsEnumerable, L = T.splice, P = ne ? ne.isConcatSpreadable : void 0, H = Math.max, Q = ur(l, "Map"), Y = ur(l, "Set"), ce = ur(Object, "create");
  function ue(X) {
    var oe = -1, de = X ? X.length : 0;
    for (this.clear(); ++oe < de; ) {
      var _e = X[oe];
      this.set(_e[0], _e[1]);
    }
  }
  function me() {
    this.__data__ = ce ? ce(null) : {};
  }
  function J(X) {
    return this.has(X) && delete this.__data__[X];
  }
  function O(X) {
    var oe = this.__data__;
    if (ce) {
      var de = oe[X];
      return de === e ? void 0 : de;
    }
    return F.call(oe, X) ? oe[X] : void 0;
  }
  function I(X) {
    var oe = this.__data__;
    return ce ? oe[X] !== void 0 : F.call(oe, X);
  }
  function z(X, oe) {
    var de = this.__data__;
    return de[X] = ce && oe === void 0 ? e : oe, this;
  }
  ue.prototype.clear = me, ue.prototype.delete = J, ue.prototype.get = O, ue.prototype.has = I, ue.prototype.set = z;
  function G(X) {
    var oe = -1, de = X ? X.length : 0;
    for (this.clear(); ++oe < de; ) {
      var _e = X[oe];
      this.set(_e[0], _e[1]);
    }
  }
  function q() {
    this.__data__ = [];
  }
  function M(X) {
    var oe = this.__data__, de = Ee(oe, X);
    if (de < 0)
      return !1;
    var _e = oe.length - 1;
    return de == _e ? oe.pop() : L.call(oe, de, 1), !0;
  }
  function Z(X) {
    var oe = this.__data__, de = Ee(oe, X);
    return de < 0 ? void 0 : oe[de][1];
  }
  function B(X) {
    return Ee(this.__data__, X) > -1;
  }
  function re(X, oe) {
    var de = this.__data__, _e = Ee(de, X);
    return _e < 0 ? de.push([X, oe]) : de[_e][1] = oe, this;
  }
  G.prototype.clear = q, G.prototype.delete = M, G.prototype.get = Z, G.prototype.has = B, G.prototype.set = re;
  function j(X) {
    var oe = -1, de = X ? X.length : 0;
    for (this.clear(); ++oe < de; ) {
      var _e = X[oe];
      this.set(_e[0], _e[1]);
    }
  }
  function k() {
    this.__data__ = {
      hash: new ue(),
      map: new (Q || G)(),
      string: new ue()
    };
  }
  function N(X) {
    return cr(this, X).delete(X);
  }
  function U(X) {
    return cr(this, X).get(X);
  }
  function ee(X) {
    return cr(this, X).has(X);
  }
  function pe(X, oe) {
    return cr(this, X).set(X, oe), this;
  }
  j.prototype.clear = k, j.prototype.delete = N, j.prototype.get = U, j.prototype.has = ee, j.prototype.set = pe;
  function he(X) {
    var oe = -1, de = X ? X.length : 0;
    for (this.__data__ = new j(); ++oe < de; )
      this.add(X[oe]);
  }
  function be(X) {
    return this.__data__.set(X, e), this;
  }
  function ye(X) {
    return this.__data__.has(X);
  }
  he.prototype.add = he.prototype.push = be, he.prototype.has = ye;
  function Ee(X, oe) {
    for (var de = X.length; de--; )
      if (Oe(X[de][0], oe))
        return de;
    return -1;
  }
  function $e(X, oe, de, _e, Le) {
    var Xe = -1, It = X.length;
    for (de || (de = ie), Le || (Le = []); ++Xe < It; ) {
      var tt = X[Xe];
      oe > 0 && de(tt) ? oe > 1 ? $e(tt, oe - 1, de, _e, Le) : g(Le, tt) : _e || (Le[Le.length] = tt);
    }
    return Le;
  }
  function Ce(X) {
    if (!te(X) || Ne(X))
      return !1;
    var oe = Cr(X) || w(X) ? V : c;
    return oe.test(Pe(X));
  }
  function le(X, oe) {
    return oe = H(oe === void 0 ? X.length - 1 : oe, 0), function() {
      for (var de = arguments, _e = -1, Le = H(de.length - oe, 0), Xe = Array(Le); ++_e < Le; )
        Xe[_e] = de[oe + _e];
      _e = -1;
      for (var It = Array(oe + 1); ++_e < oe; )
        It[_e] = de[_e];
      return It[oe] = Xe, p(X, this, It);
    };
  }
  function W(X, oe, de) {
    var _e = -1, Le = m, Xe = X.length, It = !0, tt = [], dt = tt;
    if (de)
      It = !1, Le = h;
    else if (Xe >= t) {
      var zr = oe ? null : Se(X);
      if (zr)
        return S(zr);
      It = !1, Le = x, dt = new he();
    } else
      dt = oe ? [] : tt;
    e:
      for (; ++_e < Xe; ) {
        var Qt = X[_e], Tr = oe ? oe(Qt) : Qt;
        if (Qt = de || Qt !== 0 ? Qt : 0, It && Tr === Tr) {
          for (var Os = dt.length; Os--; )
            if (dt[Os] === Tr)
              continue e;
          oe && dt.push(Tr), tt.push(Qt);
        } else
          Le(dt, Tr, de) || (dt !== tt && dt.push(Tr), tt.push(Qt));
      }
    return tt;
  }
  var Se = Y && 1 / S(new Y([, -0]))[1] == r ? function(X) {
    return new Y(X);
  } : ge;
  function cr(X, oe) {
    var de = X.__data__;
    return ae(oe) ? de[typeof oe == "string" ? "string" : "hash"] : de.map;
  }
  function ur(X, oe) {
    var de = b(X, oe);
    return Ce(de) ? de : void 0;
  }
  function ie(X) {
    return Nt(X) || qt(X) || !!(P && X && X[P]);
  }
  function ae(X) {
    var oe = typeof X;
    return oe == "string" || oe == "number" || oe == "symbol" || oe == "boolean" ? X !== "__proto__" : X === null;
  }
  function Ne(X) {
    return !!R && R in X;
  }
  function Pe(X) {
    if (X != null) {
      try {
        return D.call(X);
      } catch {
      }
      try {
        return X + "";
      } catch {
      }
    }
    return "";
  }
  var Qe = le(function(X) {
    return W($e(X, 1, Lt, !0));
  });
  function Oe(X, oe) {
    return X === oe || X !== X && oe !== oe;
  }
  function qt(X) {
    return Lt(X) && F.call(X, "callee") && (!$.call(X, "callee") || K.call(X) == i);
  }
  var Nt = Array.isArray;
  function ut(X) {
    return X != null && lr(X.length) && !Cr(X);
  }
  function Lt(X) {
    return fe(X) && ut(X);
  }
  function Cr(X) {
    var oe = te(X) ? K.call(X) : "";
    return oe == a || oe == s;
  }
  function lr(X) {
    return typeof X == "number" && X > -1 && X % 1 == 0 && X <= n;
  }
  function te(X) {
    var oe = typeof X;
    return !!X && (oe == "object" || oe == "function");
  }
  function fe(X) {
    return !!X && typeof X == "object";
  }
  function ge() {
  }
  return fd = Qe, fd;
}
var hd, eS;
function gfe() {
  if (eS)
    return hd;
  eS = 1;
  var t = "[object Object]";
  function e(p) {
    var m = !1;
    if (p != null && typeof p.toString != "function")
      try {
        m = !!(p + "");
      } catch {
      }
    return m;
  }
  function r(p, m) {
    return function(h) {
      return p(m(h));
    };
  }
  var n = Function.prototype, i = Object.prototype, a = n.toString, s = i.hasOwnProperty, o = a.call(Object), c = i.toString, f = r(Object.getPrototypeOf, Object);
  function u(p) {
    return !!p && typeof p == "object";
  }
  function l(p) {
    if (!u(p) || c.call(p) != t || e(p))
      return !1;
    var m = f(p);
    if (m === null)
      return !0;
    var h = s.call(m, "constructor") && m.constructor;
    return typeof h == "function" && h instanceof h && a.call(h) == o;
  }
  return hd = l, hd;
}
var po = {}, tS;
function vfe() {
  if (tS)
    return po;
  tS = 1;
  var t = se, e = process.platform === "win32", r = se, n = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
  function i() {
    var c;
    if (n) {
      var f = new Error();
      c = u;
    } else
      c = l;
    return c;
    function u(p) {
      p && (f.message = p.message, p = f, l(p));
    }
    function l(p) {
      if (p) {
        if (process.throwDeprecation)
          throw p;
        if (!process.noDeprecation) {
          var m = "fs: missing callback " + (p.stack || p.message);
          process.traceDeprecation ? console.trace(m) : console.error(m);
        }
      }
    }
  }
  function a(c) {
    return typeof c == "function" ? c : i();
  }
  if (t.normalize, e)
    var s = /(.*?)(?:[\/\\]+|$)/g;
  else
    var s = /(.*?)(?:[\/]+|$)/g;
  if (e)
    var o = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
  else
    var o = /^[\/]*/;
  return po.realpathSync = function(f, u) {
    if (f = t.resolve(f), u && Object.prototype.hasOwnProperty.call(u, f))
      return u[f];
    var l = f, p = {}, m = {}, h, g, v, d;
    y();
    function y() {
      var E = o.exec(f);
      h = E[0].length, g = E[0], v = E[0], d = "", e && !m[v] && (r.lstatSync(v), m[v] = !0);
    }
    for (; h < f.length; ) {
      s.lastIndex = h;
      var x = s.exec(f);
      if (d = g, g += x[0], v = d + x[1], h = s.lastIndex, !(m[v] || u && u[v] === v)) {
        var b;
        if (u && Object.prototype.hasOwnProperty.call(u, v))
          b = u[v];
        else {
          var w = r.lstatSync(v);
          if (!w.isSymbolicLink()) {
            m[v] = !0, u && (u[v] = v);
            continue;
          }
          var S = null;
          if (!e) {
            var T = w.dev.toString(32) + ":" + w.ino.toString(32);
            p.hasOwnProperty(T) && (S = p[T]);
          }
          S === null && (r.statSync(v), S = r.readlinkSync(v)), b = t.resolve(d, S), u && (u[v] = b), e || (p[T] = S);
        }
        f = t.resolve(b, f.slice(h)), y();
      }
    }
    return u && (u[l] = f), f;
  }, po.realpath = function(f, u, l) {
    if (typeof l != "function" && (l = a(u), u = null), f = t.resolve(f), u && Object.prototype.hasOwnProperty.call(u, f))
      return process.nextTick(l.bind(null, null, u[f]));
    var p = f, m = {}, h = {}, g, v, d, y;
    x();
    function x() {
      var E = o.exec(f);
      g = E[0].length, v = E[0], d = E[0], y = "", e && !h[d] ? r.lstat(d, function(C) {
        if (C)
          return l(C);
        h[d] = !0, b();
      }) : process.nextTick(b);
    }
    function b() {
      if (g >= f.length)
        return u && (u[p] = f), l(null, f);
      s.lastIndex = g;
      var E = s.exec(f);
      return y = v, v += E[0], d = y + E[1], g = s.lastIndex, h[d] || u && u[d] === d ? process.nextTick(b) : u && Object.prototype.hasOwnProperty.call(u, d) ? T(u[d]) : r.lstat(d, w);
    }
    function w(E, C) {
      if (E)
        return l(E);
      if (!C.isSymbolicLink())
        return h[d] = !0, u && (u[d] = d), process.nextTick(b);
      if (!e) {
        var A = C.dev.toString(32) + ":" + C.ino.toString(32);
        if (m.hasOwnProperty(A))
          return S(null, m[A], d);
      }
      r.stat(d, function(R) {
        if (R)
          return l(R);
        r.readlink(d, function(D, F) {
          e || (m[A] = F), S(D, F);
        });
      });
    }
    function S(E, C, A) {
      if (E)
        return l(E);
      var R = t.resolve(y, C);
      u && (u[A] = R), T(R);
    }
    function T(E) {
      f = t.resolve(E, f.slice(g)), x();
    }
  }, po;
}
var dd, rS;
function a8() {
  if (rS)
    return dd;
  rS = 1, dd = o, o.realpath = o, o.sync = c, o.realpathSync = c, o.monkeypatch = f, o.unmonkeypatch = u;
  var t = se, e = t.realpath, r = t.realpathSync, n = process.version, i = /^v[0-5]\./.test(n), a = vfe();
  function s(l) {
    return l && l.syscall === "realpath" && (l.code === "ELOOP" || l.code === "ENOMEM" || l.code === "ENAMETOOLONG");
  }
  function o(l, p, m) {
    if (i)
      return e(l, p, m);
    typeof p == "function" && (m = p, p = null), e(l, p, function(h, g) {
      s(h) ? a.realpath(l, p, m) : m(h, g);
    });
  }
  function c(l, p) {
    if (i)
      return r(l, p);
    try {
      return r(l, p);
    } catch (m) {
      if (s(m))
        return a.realpathSync(l, p);
      throw m;
    }
  }
  function f() {
    t.realpath = o, t.realpathSync = c;
  }
  function u() {
    t.realpath = e, t.realpathSync = r;
  }
  return dd;
}
var md, nS;
function yfe() {
  if (nS)
    return md;
  nS = 1, md = function(e, r) {
    for (var n = [], i = 0; i < e.length; i++) {
      var a = r(e[i], i);
      t(a) ? n.push.apply(n, a) : n.push(a);
    }
    return n;
  };
  var t = Array.isArray || function(e) {
    return Object.prototype.toString.call(e) === "[object Array]";
  };
  return md;
}
var gd, iS;
function bfe() {
  if (iS)
    return gd;
  iS = 1;
  var t = yfe(), e = Q$();
  gd = l;
  var r = "\0SLASH" + Math.random() + "\0", n = "\0OPEN" + Math.random() + "\0", i = "\0CLOSE" + Math.random() + "\0", a = "\0COMMA" + Math.random() + "\0", s = "\0PERIOD" + Math.random() + "\0";
  function o(d) {
    return parseInt(d, 10) == d ? parseInt(d, 10) : d.charCodeAt(0);
  }
  function c(d) {
    return d.split("\\\\").join(r).split("\\{").join(n).split("\\}").join(i).split("\\,").join(a).split("\\.").join(s);
  }
  function f(d) {
    return d.split(r).join("\\").split(n).join("{").split(i).join("}").split(a).join(",").split(s).join(".");
  }
  function u(d) {
    if (!d)
      return [""];
    var y = [], x = e("{", "}", d);
    if (!x)
      return d.split(",");
    var b = x.pre, w = x.body, S = x.post, T = b.split(",");
    T[T.length - 1] += "{" + w + "}";
    var E = u(S);
    return S.length && (T[T.length - 1] += E.shift(), T.push.apply(T, E)), y.push.apply(y, T), y;
  }
  function l(d) {
    return d ? (d.substr(0, 2) === "{}" && (d = "\\{\\}" + d.substr(2)), v(c(d), !0).map(f)) : [];
  }
  function p(d) {
    return "{" + d + "}";
  }
  function m(d) {
    return /^-?0\d/.test(d);
  }
  function h(d, y) {
    return d <= y;
  }
  function g(d, y) {
    return d >= y;
  }
  function v(d, y) {
    var x = [], b = e("{", "}", d);
    if (!b || /\$$/.test(b.pre))
      return [d];
    var w = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(b.body), S = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(b.body), T = w || S, E = b.body.indexOf(",") >= 0;
    if (!T && !E)
      return b.post.match(/,.*\}/) ? (d = b.pre + "{" + b.body + i + b.post, v(d)) : [d];
    var C;
    if (T)
      C = b.body.split(/\.\./);
    else if (C = u(b.body), C.length === 1 && (C = v(C[0], !1).map(p), C.length === 1)) {
      var R = b.post.length ? v(b.post, !1) : [""];
      return R.map(function(I) {
        return b.pre + C[0] + I;
      });
    }
    var A = b.pre, R = b.post.length ? v(b.post, !1) : [""], D;
    if (T) {
      var F = o(C[0]), K = o(C[1]), V = Math.max(C[0].length, C[1].length), ne = C.length == 3 ? Math.abs(o(C[2])) : 1, $ = h, L = K < F;
      L && (ne *= -1, $ = g);
      var P = C.some(m);
      D = [];
      for (var H = F; $(H, K); H += ne) {
        var Q;
        if (S)
          Q = String.fromCharCode(H), Q === "\\" && (Q = "");
        else if (Q = String(H), P) {
          var Y = V - Q.length;
          if (Y > 0) {
            var ce = new Array(Y + 1).join("0");
            H < 0 ? Q = "-" + ce + Q.slice(1) : Q = ce + Q;
          }
        }
        D.push(Q);
      }
    } else
      D = t(C, function(O) {
        return v(O, !1);
      });
    for (var ue = 0; ue < D.length; ue++)
      for (var me = 0; me < R.length; me++) {
        var J = A + D[ue] + R[me];
        (!y || T || J) && x.push(J);
      }
    return x;
  }
  return gd;
}
var vd, aS;
function Ey() {
  if (aS)
    return vd;
  aS = 1, vd = m, m.Minimatch = h;
  var t = function() {
    try {
      return se;
    } catch {
    }
  }() || {
    sep: "/"
  };
  m.sep = t.sep;
  var e = m.GLOBSTAR = h.GLOBSTAR = {}, r = bfe(), n = {
    "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
    "?": { open: "(?:", close: ")?" },
    "+": { open: "(?:", close: ")+" },
    "*": { open: "(?:", close: ")*" },
    "@": { open: "(?:", close: ")" }
  }, i = "[^/]", a = i + "*?", s = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?", o = "(?:(?!(?:\\/|^)\\.).)*?", c = f("().*{}+?[]^$\\!");
  function f(C) {
    return C.split("").reduce(function(A, R) {
      return A[R] = !0, A;
    }, {});
  }
  var u = /\/+/;
  m.filter = l;
  function l(C, A) {
    return A = A || {}, function(R, D, F) {
      return m(R, C, A);
    };
  }
  function p(C, A) {
    A = A || {};
    var R = {};
    return Object.keys(C).forEach(function(D) {
      R[D] = C[D];
    }), Object.keys(A).forEach(function(D) {
      R[D] = A[D];
    }), R;
  }
  m.defaults = function(C) {
    if (!C || typeof C != "object" || !Object.keys(C).length)
      return m;
    var A = m, R = function(F, K, V) {
      return A(F, K, p(C, V));
    };
    return R.Minimatch = function(F, K) {
      return new A.Minimatch(F, p(C, K));
    }, R.Minimatch.defaults = function(F) {
      return A.defaults(p(C, F)).Minimatch;
    }, R.filter = function(F, K) {
      return A.filter(F, p(C, K));
    }, R.defaults = function(F) {
      return A.defaults(p(C, F));
    }, R.makeRe = function(F, K) {
      return A.makeRe(F, p(C, K));
    }, R.braceExpand = function(F, K) {
      return A.braceExpand(F, p(C, K));
    }, R.match = function(D, F, K) {
      return A.match(D, F, p(C, K));
    }, R;
  }, h.defaults = function(C) {
    return m.defaults(C).Minimatch;
  };
  function m(C, A, R) {
    return x(A), R || (R = {}), !R.nocomment && A.charAt(0) === "#" ? !1 : new h(A, R).match(C);
  }
  function h(C, A) {
    if (!(this instanceof h))
      return new h(C, A);
    x(C), A || (A = {}), C = C.trim(), !A.allowWindowsEscape && t.sep !== "/" && (C = C.split(t.sep).join("/")), this.options = A, this.set = [], this.pattern = C, this.regexp = null, this.negate = !1, this.comment = !1, this.empty = !1, this.partial = !!A.partial, this.make();
  }
  h.prototype.debug = function() {
  }, h.prototype.make = g;
  function g() {
    var C = this.pattern, A = this.options;
    if (!A.nocomment && C.charAt(0) === "#") {
      this.comment = !0;
      return;
    }
    if (!C) {
      this.empty = !0;
      return;
    }
    this.parseNegate();
    var R = this.globSet = this.braceExpand();
    A.debug && (this.debug = function() {
      console.error.apply(console, arguments);
    }), this.debug(this.pattern, R), R = this.globParts = R.map(function(D) {
      return D.split(u);
    }), this.debug(this.pattern, R), R = R.map(function(D, F, K) {
      return D.map(this.parse, this);
    }, this), this.debug(this.pattern, R), R = R.filter(function(D) {
      return D.indexOf(!1) === -1;
    }), this.debug(this.pattern, R), this.set = R;
  }
  h.prototype.parseNegate = v;
  function v() {
    var C = this.pattern, A = !1, R = this.options, D = 0;
    if (!R.nonegate) {
      for (var F = 0, K = C.length; F < K && C.charAt(F) === "!"; F++)
        A = !A, D++;
      D && (this.pattern = C.substr(D)), this.negate = A;
    }
  }
  m.braceExpand = function(C, A) {
    return d(C, A);
  }, h.prototype.braceExpand = d;
  function d(C, A) {
    return A || (this instanceof h ? A = this.options : A = {}), C = typeof C > "u" ? this.pattern : C, x(C), A.nobrace || !/\{(?:(?!\{).)*\}/.test(C) ? [C] : r(C);
  }
  var y = 1024 * 64, x = function(C) {
    if (typeof C != "string")
      throw new TypeError("invalid pattern");
    if (C.length > y)
      throw new TypeError("pattern is too long");
  };
  h.prototype.parse = w;
  var b = {};
  function w(C, A) {
    x(C);
    var R = this.options;
    if (C === "**")
      if (R.noglobstar)
        C = "*";
      else
        return e;
    if (C === "")
      return "";
    var D = "", F = !!R.nocase, K = !1, V = [], ne = [], $, L = !1, P = -1, H = -1, Q = C.charAt(0) === "." ? "" : R.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)", Y = this;
    function ce() {
      if ($) {
        switch ($) {
          case "*":
            D += a, F = !0;
            break;
          case "?":
            D += i, F = !0;
            break;
          default:
            D += "\\" + $;
            break;
        }
        Y.debug("clearStateChar %j %j", $, D), $ = !1;
      }
    }
    for (var ue = 0, me = C.length, J; ue < me && (J = C.charAt(ue)); ue++) {
      if (this.debug("%s	%s %s %j", C, ue, D, J), K && c[J]) {
        D += "\\" + J, K = !1;
        continue;
      }
      switch (J) {
        case "/":
          return !1;
        case "\\":
          ce(), K = !0;
          continue;
        case "?":
        case "*":
        case "+":
        case "@":
        case "!":
          if (this.debug("%s	%s %s %j <-- stateChar", C, ue, D, J), L) {
            this.debug("  in class"), J === "!" && ue === H + 1 && (J = "^"), D += J;
            continue;
          }
          Y.debug("call clearStateChar %j", $), ce(), $ = J, R.noext && ce();
          continue;
        case "(":
          if (L) {
            D += "(";
            continue;
          }
          if (!$) {
            D += "\\(";
            continue;
          }
          V.push({
            type: $,
            start: ue - 1,
            reStart: D.length,
            open: n[$].open,
            close: n[$].close
          }), D += $ === "!" ? "(?:(?!(?:" : "(?:", this.debug("plType %j %j", $, D), $ = !1;
          continue;
        case ")":
          if (L || !V.length) {
            D += "\\)";
            continue;
          }
          ce(), F = !0;
          var O = V.pop();
          D += O.close, O.type === "!" && ne.push(O), O.reEnd = D.length;
          continue;
        case "|":
          if (L || !V.length || K) {
            D += "\\|", K = !1;
            continue;
          }
          ce(), D += "|";
          continue;
        case "[":
          if (ce(), L) {
            D += "\\" + J;
            continue;
          }
          L = !0, H = ue, P = D.length, D += J;
          continue;
        case "]":
          if (ue === H + 1 || !L) {
            D += "\\" + J, K = !1;
            continue;
          }
          var I = C.substring(H + 1, ue);
          try {
            RegExp("[" + I + "]");
          } catch {
            var z = this.parse(I, b);
            D = D.substr(0, P) + "\\[" + z[0] + "\\]", F = F || z[1], L = !1;
            continue;
          }
          F = !0, L = !1, D += J;
          continue;
        default:
          ce(), K ? K = !1 : c[J] && !(J === "^" && L) && (D += "\\"), D += J;
      }
    }
    for (L && (I = C.substr(H + 1), z = this.parse(I, b), D = D.substr(0, P) + "\\[" + z[0], F = F || z[1]), O = V.pop(); O; O = V.pop()) {
      var G = D.slice(O.reStart + O.open.length);
      this.debug("setting tail", D, O), G = G.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(Ee, $e, Ce) {
        return Ce || (Ce = "\\"), $e + $e + Ce + "|";
      }), this.debug(`tail=%j
   %s`, G, G, O, D);
      var q = O.type === "*" ? a : O.type === "?" ? i : "\\" + O.type;
      F = !0, D = D.slice(0, O.reStart) + q + "\\(" + G;
    }
    ce(), K && (D += "\\\\");
    var M = !1;
    switch (D.charAt(0)) {
      case "[":
      case ".":
      case "(":
        M = !0;
    }
    for (var Z = ne.length - 1; Z > -1; Z--) {
      var B = ne[Z], re = D.slice(0, B.reStart), j = D.slice(B.reStart, B.reEnd - 8), k = D.slice(B.reEnd - 8, B.reEnd), N = D.slice(B.reEnd);
      k += N;
      var U = re.split("(").length - 1, ee = N;
      for (ue = 0; ue < U; ue++)
        ee = ee.replace(/\)[+*?]?/, "");
      N = ee;
      var pe = "";
      N === "" && A !== b && (pe = "$");
      var he = re + j + N + pe + k;
      D = he;
    }
    if (D !== "" && F && (D = "(?=.)" + D), M && (D = Q + D), A === b)
      return [D, F];
    if (!F)
      return T(C);
    var be = R.nocase ? "i" : "";
    try {
      var ye = new RegExp("^" + D + "$", be);
    } catch {
      return new RegExp("$.");
    }
    return ye._glob = C, ye._src = D, ye;
  }
  m.makeRe = function(C, A) {
    return new h(C, A || {}).makeRe();
  }, h.prototype.makeRe = S;
  function S() {
    if (this.regexp || this.regexp === !1)
      return this.regexp;
    var C = this.set;
    if (!C.length)
      return this.regexp = !1, this.regexp;
    var A = this.options, R = A.noglobstar ? a : A.dot ? s : o, D = A.nocase ? "i" : "", F = C.map(function(K) {
      return K.map(function(V) {
        return V === e ? R : typeof V == "string" ? E(V) : V._src;
      }).join("\\/");
    }).join("|");
    F = "^(?:" + F + ")$", this.negate && (F = "^(?!" + F + ").*$");
    try {
      this.regexp = new RegExp(F, D);
    } catch {
      this.regexp = !1;
    }
    return this.regexp;
  }
  m.match = function(C, A, R) {
    R = R || {};
    var D = new h(A, R);
    return C = C.filter(function(F) {
      return D.match(F);
    }), D.options.nonull && !C.length && C.push(A), C;
  }, h.prototype.match = function(A, R) {
    if (typeof R > "u" && (R = this.partial), this.debug("match", A, this.pattern), this.comment)
      return !1;
    if (this.empty)
      return A === "";
    if (A === "/" && R)
      return !0;
    var D = this.options;
    t.sep !== "/" && (A = A.split(t.sep).join("/")), A = A.split(u), this.debug(this.pattern, "split", A);
    var F = this.set;
    this.debug(this.pattern, "set", F);
    var K, V;
    for (V = A.length - 1; V >= 0 && (K = A[V], !K); V--)
      ;
    for (V = 0; V < F.length; V++) {
      var ne = F[V], $ = A;
      D.matchBase && ne.length === 1 && ($ = [K]);
      var L = this.matchOne($, ne, R);
      if (L)
        return D.flipNegate ? !0 : !this.negate;
    }
    return D.flipNegate ? !1 : this.negate;
  }, h.prototype.matchOne = function(C, A, R) {
    var D = this.options;
    this.debug(
      "matchOne",
      { this: this, file: C, pattern: A }
    ), this.debug("matchOne", C.length, A.length);
    for (var F = 0, K = 0, V = C.length, ne = A.length; F < V && K < ne; F++, K++) {
      this.debug("matchOne loop");
      var $ = A[K], L = C[F];
      if (this.debug(A, $, L), $ === !1)
        return !1;
      if ($ === e) {
        this.debug("GLOBSTAR", [A, $, L]);
        var P = F, H = K + 1;
        if (H === ne) {
          for (this.debug("** at the end"); F < V; F++)
            if (C[F] === "." || C[F] === ".." || !D.dot && C[F].charAt(0) === ".")
              return !1;
          return !0;
        }
        for (; P < V; ) {
          var Q = C[P];
          if (this.debug(`
globstar while`, C, P, A, H, Q), this.matchOne(C.slice(P), A.slice(H), R))
            return this.debug("globstar found match!", P, V, Q), !0;
          if (Q === "." || Q === ".." || !D.dot && Q.charAt(0) === ".") {
            this.debug("dot detected!", C, P, A, H);
            break;
          }
          this.debug("globstar swallow a segment, and continue"), P++;
        }
        return !!(R && (this.debug(`
>>> no match, partial?`, C, P, A, H), P === V));
      }
      var Y;
      if (typeof $ == "string" ? (Y = L === $, this.debug("string match", $, L, Y)) : (Y = L.match($), this.debug("pattern match", $, L, Y)), !Y)
        return !1;
    }
    if (F === V && K === ne)
      return !0;
    if (F === V)
      return R;
    if (K === ne)
      return F === V - 1 && C[F] === "";
    throw new Error("wtf?");
  };
  function T(C) {
    return C.replace(/\\(.)/g, "$1");
  }
  function E(C) {
    return C.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  }
  return vd;
}
var ca = { exports: {} }, sS;
function Sy() {
  if (sS)
    return ca.exports;
  sS = 1;
  function t(r) {
    return r.charAt(0) === "/";
  }
  function e(r) {
    var n = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/, i = n.exec(r), a = i[1] || "", s = !!(a && a.charAt(1) !== ":");
    return !!(i[2] || s);
  }
  return ca.exports = process.platform === "win32" ? e : t, ca.exports.posix = t, ca.exports.win32 = e, ca.exports;
}
var kr = {}, oS;
function s8() {
  if (oS)
    return kr;
  oS = 1, kr.setopts = f, kr.ownProp = t, kr.makeAbs = p, kr.finish = u, kr.mark = l, kr.isIgnored = m, kr.childrenIgnored = h;
  function t(g, v) {
    return Object.prototype.hasOwnProperty.call(g, v);
  }
  var e = se, r = se, n = Ey(), i = Sy(), a = n.Minimatch;
  function s(g, v) {
    return g.localeCompare(v, "en");
  }
  function o(g, v) {
    g.ignore = v.ignore || [], Array.isArray(g.ignore) || (g.ignore = [g.ignore]), g.ignore.length && (g.ignore = g.ignore.map(c));
  }
  function c(g) {
    var v = null;
    if (g.slice(-3) === "/**") {
      var d = g.replace(/(\/\*\*)+$/, "");
      v = new a(d, { dot: !0 });
    }
    return {
      matcher: new a(g, { dot: !0 }),
      gmatcher: v
    };
  }
  function f(g, v, d) {
    if (d || (d = {}), d.matchBase && v.indexOf("/") === -1) {
      if (d.noglobstar)
        throw new Error("base matching requires globstar");
      v = "**/" + v;
    }
    g.silent = !!d.silent, g.pattern = v, g.strict = d.strict !== !1, g.realpath = !!d.realpath, g.realpathCache = d.realpathCache || /* @__PURE__ */ Object.create(null), g.follow = !!d.follow, g.dot = !!d.dot, g.mark = !!d.mark, g.nodir = !!d.nodir, g.nodir && (g.mark = !0), g.sync = !!d.sync, g.nounique = !!d.nounique, g.nonull = !!d.nonull, g.nosort = !!d.nosort, g.nocase = !!d.nocase, g.stat = !!d.stat, g.noprocess = !!d.noprocess, g.absolute = !!d.absolute, g.fs = d.fs || e, g.maxLength = d.maxLength || 1 / 0, g.cache = d.cache || /* @__PURE__ */ Object.create(null), g.statCache = d.statCache || /* @__PURE__ */ Object.create(null), g.symlinks = d.symlinks || /* @__PURE__ */ Object.create(null), o(g, d), g.changedCwd = !1;
    var y = process.cwd();
    t(d, "cwd") ? (g.cwd = r.resolve(d.cwd), g.changedCwd = g.cwd !== y) : g.cwd = y, g.root = d.root || r.resolve(g.cwd, "/"), g.root = r.resolve(g.root), process.platform === "win32" && (g.root = g.root.replace(/\\/g, "/")), g.cwdAbs = i(g.cwd) ? g.cwd : p(g, g.cwd), process.platform === "win32" && (g.cwdAbs = g.cwdAbs.replace(/\\/g, "/")), g.nomount = !!d.nomount, d.nonegate = !0, d.nocomment = !0, d.allowWindowsEscape = !1, g.minimatch = new a(v, d), g.options = g.minimatch.options;
  }
  function u(g) {
    for (var v = g.nounique, d = v ? [] : /* @__PURE__ */ Object.create(null), y = 0, x = g.matches.length; y < x; y++) {
      var b = g.matches[y];
      if (!b || Object.keys(b).length === 0) {
        if (g.nonull) {
          var w = g.minimatch.globSet[y];
          v ? d.push(w) : d[w] = !0;
        }
      } else {
        var S = Object.keys(b);
        v ? d.push.apply(d, S) : S.forEach(function(T) {
          d[T] = !0;
        });
      }
    }
    if (v || (d = Object.keys(d)), g.nosort || (d = d.sort(s)), g.mark) {
      for (var y = 0; y < d.length; y++)
        d[y] = g._mark(d[y]);
      g.nodir && (d = d.filter(function(T) {
        var E = !/\/$/.test(T), C = g.cache[T] || g.cache[p(g, T)];
        return E && C && (E = C !== "DIR" && !Array.isArray(C)), E;
      }));
    }
    g.ignore.length && (d = d.filter(function(T) {
      return !m(g, T);
    })), g.found = d;
  }
  function l(g, v) {
    var d = p(g, v), y = g.cache[d], x = v;
    if (y) {
      var b = y === "DIR" || Array.isArray(y), w = v.slice(-1) === "/";
      if (b && !w ? x += "/" : !b && w && (x = x.slice(0, -1)), x !== v) {
        var S = p(g, x);
        g.statCache[S] = g.statCache[d], g.cache[S] = g.cache[d];
      }
    }
    return x;
  }
  function p(g, v) {
    var d = v;
    return v.charAt(0) === "/" ? d = r.join(g.root, v) : i(v) || v === "" ? d = v : g.changedCwd ? d = r.resolve(g.cwd, v) : d = r.resolve(v), process.platform === "win32" && (d = d.replace(/\\/g, "/")), d;
  }
  function m(g, v) {
    return g.ignore.length ? g.ignore.some(function(d) {
      return d.matcher.match(v) || !!(d.gmatcher && d.gmatcher.match(v));
    }) : !1;
  }
  function h(g, v) {
    return g.ignore.length ? g.ignore.some(function(d) {
      return !!(d.gmatcher && d.gmatcher.match(v));
    }) : !1;
  }
  return kr;
}
var yd, cS;
function wfe() {
  if (cS)
    return yd;
  cS = 1, yd = u, u.GlobSync = l;
  var t = a8(), e = Ey();
  e.Minimatch, c8().Glob;
  var r = se, n = se, i = Sy(), a = s8(), s = a.setopts, o = a.ownProp, c = a.childrenIgnored, f = a.isIgnored;
  function u(p, m) {
    if (typeof m == "function" || arguments.length === 3)
      throw new TypeError(`callback provided to sync glob
See: https://github.com/isaacs/node-glob/issues/167`);
    return new l(p, m).found;
  }
  function l(p, m) {
    if (!p)
      throw new Error("must provide pattern");
    if (typeof m == "function" || arguments.length === 3)
      throw new TypeError(`callback provided to sync glob
See: https://github.com/isaacs/node-glob/issues/167`);
    if (!(this instanceof l))
      return new l(p, m);
    if (s(this, p, m), this.noprocess)
      return this;
    var h = this.minimatch.set.length;
    this.matches = new Array(h);
    for (var g = 0; g < h; g++)
      this._process(this.minimatch.set[g], g, !1);
    this._finish();
  }
  return l.prototype._finish = function() {
    if (n.ok(this instanceof l), this.realpath) {
      var p = this;
      this.matches.forEach(function(m, h) {
        var g = p.matches[h] = /* @__PURE__ */ Object.create(null);
        for (var v in m)
          try {
            v = p._makeAbs(v);
            var d = t.realpathSync(v, p.realpathCache);
            g[d] = !0;
          } catch (y) {
            if (y.syscall === "stat")
              g[p._makeAbs(v)] = !0;
            else
              throw y;
          }
      });
    }
    a.finish(this);
  }, l.prototype._process = function(p, m, h) {
    n.ok(this instanceof l);
    for (var g = 0; typeof p[g] == "string"; )
      g++;
    var v;
    switch (g) {
      case p.length:
        this._processSimple(p.join("/"), m);
        return;
      case 0:
        v = null;
        break;
      default:
        v = p.slice(0, g).join("/");
        break;
    }
    var d = p.slice(g), y;
    v === null ? y = "." : ((i(v) || i(p.map(function(w) {
      return typeof w == "string" ? w : "[*]";
    }).join("/"))) && (!v || !i(v)) && (v = "/" + v), y = v);
    var x = this._makeAbs(y);
    if (!c(this, y)) {
      var b = d[0] === e.GLOBSTAR;
      b ? this._processGlobStar(v, y, x, d, m, h) : this._processReaddir(v, y, x, d, m, h);
    }
  }, l.prototype._processReaddir = function(p, m, h, g, v, d) {
    var y = this._readdir(h, d);
    if (y) {
      for (var x = g[0], b = !!this.minimatch.negate, w = x._glob, S = this.dot || w.charAt(0) === ".", T = [], E = 0; E < y.length; E++) {
        var C = y[E];
        if (C.charAt(0) !== "." || S) {
          var A;
          b && !p ? A = !C.match(x) : A = C.match(x), A && T.push(C);
        }
      }
      var R = T.length;
      if (R !== 0) {
        if (g.length === 1 && !this.mark && !this.stat) {
          this.matches[v] || (this.matches[v] = /* @__PURE__ */ Object.create(null));
          for (var E = 0; E < R; E++) {
            var C = T[E];
            p && (p.slice(-1) !== "/" ? C = p + "/" + C : C = p + C), C.charAt(0) === "/" && !this.nomount && (C = r.join(this.root, C)), this._emitMatch(v, C);
          }
          return;
        }
        g.shift();
        for (var E = 0; E < R; E++) {
          var C = T[E], D;
          p ? D = [p, C] : D = [C], this._process(D.concat(g), v, d);
        }
      }
    }
  }, l.prototype._emitMatch = function(p, m) {
    if (!f(this, m)) {
      var h = this._makeAbs(m);
      if (this.mark && (m = this._mark(m)), this.absolute && (m = h), !this.matches[p][m]) {
        if (this.nodir) {
          var g = this.cache[h];
          if (g === "DIR" || Array.isArray(g))
            return;
        }
        this.matches[p][m] = !0, this.stat && this._stat(m);
      }
    }
  }, l.prototype._readdirInGlobStar = function(p) {
    if (this.follow)
      return this._readdir(p, !1);
    var m, h;
    try {
      h = this.fs.lstatSync(p);
    } catch (v) {
      if (v.code === "ENOENT")
        return null;
    }
    var g = h && h.isSymbolicLink();
    return this.symlinks[p] = g, !g && h && !h.isDirectory() ? this.cache[p] = "FILE" : m = this._readdir(p, !1), m;
  }, l.prototype._readdir = function(p, m) {
    if (m && !o(this.symlinks, p))
      return this._readdirInGlobStar(p);
    if (o(this.cache, p)) {
      var h = this.cache[p];
      if (!h || h === "FILE")
        return null;
      if (Array.isArray(h))
        return h;
    }
    try {
      return this._readdirEntries(p, this.fs.readdirSync(p));
    } catch (g) {
      return this._readdirError(p, g), null;
    }
  }, l.prototype._readdirEntries = function(p, m) {
    if (!this.mark && !this.stat)
      for (var h = 0; h < m.length; h++) {
        var g = m[h];
        p === "/" ? g = p + g : g = p + "/" + g, this.cache[g] = !0;
      }
    return this.cache[p] = m, m;
  }, l.prototype._readdirError = function(p, m) {
    switch (m.code) {
      case "ENOTSUP":
      case "ENOTDIR":
        var h = this._makeAbs(p);
        if (this.cache[h] = "FILE", h === this.cwdAbs) {
          var g = new Error(m.code + " invalid cwd " + this.cwd);
          throw g.path = this.cwd, g.code = m.code, g;
        }
        break;
      case "ENOENT":
      case "ELOOP":
      case "ENAMETOOLONG":
      case "UNKNOWN":
        this.cache[this._makeAbs(p)] = !1;
        break;
      default:
        if (this.cache[this._makeAbs(p)] = !1, this.strict)
          throw m;
        this.silent || console.error("glob error", m);
        break;
    }
  }, l.prototype._processGlobStar = function(p, m, h, g, v, d) {
    var y = this._readdir(h, d);
    if (y) {
      var x = g.slice(1), b = p ? [p] : [], w = b.concat(x);
      this._process(w, v, !1);
      var S = y.length, T = this.symlinks[h];
      if (!(T && d))
        for (var E = 0; E < S; E++) {
          var C = y[E];
          if (!(C.charAt(0) === "." && !this.dot)) {
            var A = b.concat(y[E], x);
            this._process(A, v, !0);
            var R = b.concat(y[E], g);
            this._process(R, v, !0);
          }
        }
    }
  }, l.prototype._processSimple = function(p, m) {
    var h = this._stat(p);
    if (this.matches[m] || (this.matches[m] = /* @__PURE__ */ Object.create(null)), !!h) {
      if (p && i(p) && !this.nomount) {
        var g = /[\/\\]$/.test(p);
        p.charAt(0) === "/" ? p = r.join(this.root, p) : (p = r.resolve(this.root, p), g && (p += "/"));
      }
      process.platform === "win32" && (p = p.replace(/\\/g, "/")), this._emitMatch(m, p);
    }
  }, l.prototype._stat = function(p) {
    var m = this._makeAbs(p), h = p.slice(-1) === "/";
    if (p.length > this.maxLength)
      return !1;
    if (!this.stat && o(this.cache, m)) {
      var d = this.cache[m];
      if (Array.isArray(d) && (d = "DIR"), !h || d === "DIR")
        return d;
      if (h && d === "FILE")
        return !1;
    }
    var g = this.statCache[m];
    if (!g) {
      var v;
      try {
        v = this.fs.lstatSync(m);
      } catch (y) {
        if (y && (y.code === "ENOENT" || y.code === "ENOTDIR"))
          return this.statCache[m] = !1, !1;
      }
      if (v && v.isSymbolicLink())
        try {
          g = this.fs.statSync(m);
        } catch {
          g = v;
        }
      else
        g = v;
    }
    this.statCache[m] = g;
    var d = !0;
    return g && (d = g.isDirectory() ? "DIR" : "FILE"), this.cache[m] = this.cache[m] || d, h && d === "FILE" ? !1 : d;
  }, l.prototype._mark = function(p) {
    return a.mark(this, p);
  }, l.prototype._makeAbs = function(p) {
    return a.makeAbs(this, p);
  }, yd;
}
var bd, uS;
function o8() {
  if (uS)
    return bd;
  uS = 1, bd = t;
  function t(e, r) {
    if (e && r)
      return t(e)(r);
    if (typeof e != "function")
      throw new TypeError("need wrapper function");
    return Object.keys(e).forEach(function(i) {
      n[i] = e[i];
    }), n;
    function n() {
      for (var i = new Array(arguments.length), a = 0; a < i.length; a++)
        i[a] = arguments[a];
      var s = e.apply(this, i), o = i[i.length - 1];
      return typeof s == "function" && s !== o && Object.keys(o).forEach(function(c) {
        s[c] = o[c];
      }), s;
    }
  }
  return bd;
}
var fo = { exports: {} }, lS;
function Cy() {
  if (lS)
    return fo.exports;
  lS = 1;
  var t = o8();
  fo.exports = t(e), fo.exports.strict = t(r), e.proto = e(function() {
    Object.defineProperty(Function.prototype, "once", {
      value: function() {
        return e(this);
      },
      configurable: !0
    }), Object.defineProperty(Function.prototype, "onceStrict", {
      value: function() {
        return r(this);
      },
      configurable: !0
    });
  });
  function e(n) {
    var i = function() {
      return i.called ? i.value : (i.called = !0, i.value = n.apply(this, arguments));
    };
    return i.called = !1, i;
  }
  function r(n) {
    var i = function() {
      if (i.called)
        throw new Error(i.onceError);
      return i.called = !0, i.value = n.apply(this, arguments);
    }, a = n.name || "Function wrapped with `once`";
    return i.onceError = a + " shouldn't be called more than once", i.called = !1, i;
  }
  return fo.exports;
}
var wd, pS;
function xfe() {
  if (pS)
    return wd;
  pS = 1;
  var t = o8(), e = /* @__PURE__ */ Object.create(null), r = Cy();
  wd = t(n);
  function n(s, o) {
    return e[s] ? (e[s].push(o), null) : (e[s] = [o], i(s));
  }
  function i(s) {
    return r(function o() {
      var c = e[s], f = c.length, u = a(arguments);
      try {
        for (var l = 0; l < f; l++)
          c[l].apply(null, u);
      } finally {
        c.length > f ? (c.splice(0, f), process.nextTick(function() {
          o.apply(null, u);
        })) : delete e[s];
      }
    });
  }
  function a(s) {
    for (var o = s.length, c = [], f = 0; f < o; f++)
      c[f] = s[f];
    return c;
  }
  return wd;
}
var xd, fS;
function c8() {
  if (fS)
    return xd;
  fS = 1, xd = g;
  var t = a8(), e = Ey();
  e.Minimatch;
  var r = ct(), n = bt.EventEmitter, i = se, a = se, s = Sy(), o = wfe(), c = s8(), f = c.setopts, u = c.ownProp, l = xfe(), p = c.childrenIgnored, m = c.isIgnored, h = Cy();
  function g(b, w, S) {
    if (typeof w == "function" && (S = w, w = {}), w || (w = {}), w.sync) {
      if (S)
        throw new TypeError("callback provided to sync glob");
      return o(b, w);
    }
    return new y(b, w, S);
  }
  g.sync = o;
  var v = g.GlobSync = o.GlobSync;
  g.glob = g;
  function d(b, w) {
    if (w === null || typeof w != "object")
      return b;
    for (var S = Object.keys(w), T = S.length; T--; )
      b[S[T]] = w[S[T]];
    return b;
  }
  g.hasMagic = function(b, w) {
    var S = d({}, w);
    S.noprocess = !0;
    var T = new y(b, S), E = T.minimatch.set;
    if (!b)
      return !1;
    if (E.length > 1)
      return !0;
    for (var C = 0; C < E[0].length; C++)
      if (typeof E[0][C] != "string")
        return !0;
    return !1;
  }, g.Glob = y, r(y, n);
  function y(b, w, S) {
    if (typeof w == "function" && (S = w, w = null), w && w.sync) {
      if (S)
        throw new TypeError("callback provided to sync glob");
      return new v(b, w);
    }
    if (!(this instanceof y))
      return new y(b, w, S);
    f(this, b, w), this._didRealPath = !1;
    var T = this.minimatch.set.length;
    this.matches = new Array(T), typeof S == "function" && (S = h(S), this.on("error", S), this.on("end", function(D) {
      S(null, D);
    }));
    var E = this;
    if (this._processing = 0, this._emitQueue = [], this._processQueue = [], this.paused = !1, this.noprocess)
      return this;
    if (T === 0)
      return R();
    for (var C = !0, A = 0; A < T; A++)
      this._process(this.minimatch.set[A], A, !1, R);
    C = !1;
    function R() {
      --E._processing, E._processing <= 0 && (C ? process.nextTick(function() {
        E._finish();
      }) : E._finish());
    }
  }
  y.prototype._finish = function() {
    if (a(this instanceof y), !this.aborted) {
      if (this.realpath && !this._didRealpath)
        return this._realpath();
      c.finish(this), this.emit("end", this.found);
    }
  }, y.prototype._realpath = function() {
    if (this._didRealpath)
      return;
    this._didRealpath = !0;
    var b = this.matches.length;
    if (b === 0)
      return this._finish();
    for (var w = this, S = 0; S < this.matches.length; S++)
      this._realpathSet(S, T);
    function T() {
      --b === 0 && w._finish();
    }
  }, y.prototype._realpathSet = function(b, w) {
    var S = this.matches[b];
    if (!S)
      return w();
    var T = Object.keys(S), E = this, C = T.length;
    if (C === 0)
      return w();
    var A = this.matches[b] = /* @__PURE__ */ Object.create(null);
    T.forEach(function(R, D) {
      R = E._makeAbs(R), t.realpath(R, E.realpathCache, function(F, K) {
        F ? F.syscall === "stat" ? A[R] = !0 : E.emit("error", F) : A[K] = !0, --C === 0 && (E.matches[b] = A, w());
      });
    });
  }, y.prototype._mark = function(b) {
    return c.mark(this, b);
  }, y.prototype._makeAbs = function(b) {
    return c.makeAbs(this, b);
  }, y.prototype.abort = function() {
    this.aborted = !0, this.emit("abort");
  }, y.prototype.pause = function() {
    this.paused || (this.paused = !0, this.emit("pause"));
  }, y.prototype.resume = function() {
    if (this.paused) {
      if (this.emit("resume"), this.paused = !1, this._emitQueue.length) {
        var b = this._emitQueue.slice(0);
        this._emitQueue.length = 0;
        for (var w = 0; w < b.length; w++) {
          var S = b[w];
          this._emitMatch(S[0], S[1]);
        }
      }
      if (this._processQueue.length) {
        var T = this._processQueue.slice(0);
        this._processQueue.length = 0;
        for (var w = 0; w < T.length; w++) {
          var E = T[w];
          this._processing--, this._process(E[0], E[1], E[2], E[3]);
        }
      }
    }
  }, y.prototype._process = function(b, w, S, T) {
    if (a(this instanceof y), a(typeof T == "function"), !this.aborted) {
      if (this._processing++, this.paused) {
        this._processQueue.push([b, w, S, T]);
        return;
      }
      for (var E = 0; typeof b[E] == "string"; )
        E++;
      var C;
      switch (E) {
        case b.length:
          this._processSimple(b.join("/"), w, T);
          return;
        case 0:
          C = null;
          break;
        default:
          C = b.slice(0, E).join("/");
          break;
      }
      var A = b.slice(E), R;
      C === null ? R = "." : ((s(C) || s(b.map(function(K) {
        return typeof K == "string" ? K : "[*]";
      }).join("/"))) && (!C || !s(C)) && (C = "/" + C), R = C);
      var D = this._makeAbs(R);
      if (p(this, R))
        return T();
      var F = A[0] === e.GLOBSTAR;
      F ? this._processGlobStar(C, R, D, A, w, S, T) : this._processReaddir(C, R, D, A, w, S, T);
    }
  }, y.prototype._processReaddir = function(b, w, S, T, E, C, A) {
    var R = this;
    this._readdir(S, C, function(D, F) {
      return R._processReaddir2(b, w, S, T, E, C, F, A);
    });
  }, y.prototype._processReaddir2 = function(b, w, S, T, E, C, A, R) {
    if (!A)
      return R();
    for (var D = T[0], F = !!this.minimatch.negate, K = D._glob, V = this.dot || K.charAt(0) === ".", ne = [], $ = 0; $ < A.length; $++) {
      var L = A[$];
      if (L.charAt(0) !== "." || V) {
        var P;
        F && !b ? P = !L.match(D) : P = L.match(D), P && ne.push(L);
      }
    }
    var H = ne.length;
    if (H === 0)
      return R();
    if (T.length === 1 && !this.mark && !this.stat) {
      this.matches[E] || (this.matches[E] = /* @__PURE__ */ Object.create(null));
      for (var $ = 0; $ < H; $++) {
        var L = ne[$];
        b && (b !== "/" ? L = b + "/" + L : L = b + L), L.charAt(0) === "/" && !this.nomount && (L = i.join(this.root, L)), this._emitMatch(E, L);
      }
      return R();
    }
    T.shift();
    for (var $ = 0; $ < H; $++) {
      var L = ne[$];
      b && (b !== "/" ? L = b + "/" + L : L = b + L), this._process([L].concat(T), E, C, R);
    }
    R();
  }, y.prototype._emitMatch = function(b, w) {
    if (!this.aborted && !m(this, w)) {
      if (this.paused) {
        this._emitQueue.push([b, w]);
        return;
      }
      var S = s(w) ? w : this._makeAbs(w);
      if (this.mark && (w = this._mark(w)), this.absolute && (w = S), !this.matches[b][w]) {
        if (this.nodir) {
          var T = this.cache[S];
          if (T === "DIR" || Array.isArray(T))
            return;
        }
        this.matches[b][w] = !0;
        var E = this.statCache[S];
        E && this.emit("stat", w, E), this.emit("match", w);
      }
    }
  }, y.prototype._readdirInGlobStar = function(b, w) {
    if (this.aborted)
      return;
    if (this.follow)
      return this._readdir(b, !1, w);
    var S = "lstat\0" + b, T = this, E = l(S, C);
    E && T.fs.lstat(b, E);
    function C(A, R) {
      if (A && A.code === "ENOENT")
        return w();
      var D = R && R.isSymbolicLink();
      T.symlinks[b] = D, !D && R && !R.isDirectory() ? (T.cache[b] = "FILE", w()) : T._readdir(b, !1, w);
    }
  }, y.prototype._readdir = function(b, w, S) {
    if (!this.aborted && (S = l("readdir\0" + b + "\0" + w, S), !!S)) {
      if (w && !u(this.symlinks, b))
        return this._readdirInGlobStar(b, S);
      if (u(this.cache, b)) {
        var T = this.cache[b];
        if (!T || T === "FILE")
          return S();
        if (Array.isArray(T))
          return S(null, T);
      }
      var E = this;
      E.fs.readdir(b, x(this, b, S));
    }
  };
  function x(b, w, S) {
    return function(T, E) {
      T ? b._readdirError(w, T, S) : b._readdirEntries(w, E, S);
    };
  }
  return y.prototype._readdirEntries = function(b, w, S) {
    if (!this.aborted) {
      if (!this.mark && !this.stat)
        for (var T = 0; T < w.length; T++) {
          var E = w[T];
          b === "/" ? E = b + E : E = b + "/" + E, this.cache[E] = !0;
        }
      return this.cache[b] = w, S(null, w);
    }
  }, y.prototype._readdirError = function(b, w, S) {
    if (!this.aborted) {
      switch (w.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var T = this._makeAbs(b);
          if (this.cache[T] = "FILE", T === this.cwdAbs) {
            var E = new Error(w.code + " invalid cwd " + this.cwd);
            E.path = this.cwd, E.code = w.code, this.emit("error", E), this.abort();
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(b)] = !1;
          break;
        default:
          this.cache[this._makeAbs(b)] = !1, this.strict && (this.emit("error", w), this.abort()), this.silent || console.error("glob error", w);
          break;
      }
      return S();
    }
  }, y.prototype._processGlobStar = function(b, w, S, T, E, C, A) {
    var R = this;
    this._readdir(S, C, function(D, F) {
      R._processGlobStar2(b, w, S, T, E, C, F, A);
    });
  }, y.prototype._processGlobStar2 = function(b, w, S, T, E, C, A, R) {
    if (!A)
      return R();
    var D = T.slice(1), F = b ? [b] : [], K = F.concat(D);
    this._process(K, E, !1, R);
    var V = this.symlinks[S], ne = A.length;
    if (V && C)
      return R();
    for (var $ = 0; $ < ne; $++) {
      var L = A[$];
      if (!(L.charAt(0) === "." && !this.dot)) {
        var P = F.concat(A[$], D);
        this._process(P, E, !0, R);
        var H = F.concat(A[$], T);
        this._process(H, E, !0, R);
      }
    }
    R();
  }, y.prototype._processSimple = function(b, w, S) {
    var T = this;
    this._stat(b, function(E, C) {
      T._processSimple2(b, w, E, C, S);
    });
  }, y.prototype._processSimple2 = function(b, w, S, T, E) {
    if (this.matches[w] || (this.matches[w] = /* @__PURE__ */ Object.create(null)), !T)
      return E();
    if (b && s(b) && !this.nomount) {
      var C = /[\/\\]$/.test(b);
      b.charAt(0) === "/" ? b = i.join(this.root, b) : (b = i.resolve(this.root, b), C && (b += "/"));
    }
    process.platform === "win32" && (b = b.replace(/\\/g, "/")), this._emitMatch(w, b), E();
  }, y.prototype._stat = function(b, w) {
    var S = this._makeAbs(b), T = b.slice(-1) === "/";
    if (b.length > this.maxLength)
      return w();
    if (!this.stat && u(this.cache, S)) {
      var E = this.cache[S];
      if (Array.isArray(E) && (E = "DIR"), !T || E === "DIR")
        return w(null, E);
      if (T && E === "FILE")
        return w();
    }
    var C = this.statCache[S];
    if (C !== void 0) {
      if (C === !1)
        return w(null, C);
      var A = C.isDirectory() ? "DIR" : "FILE";
      return T && A === "FILE" ? w() : w(null, A, C);
    }
    var R = this, D = l("stat\0" + S, F);
    D && R.fs.lstat(S, D);
    function F(K, V) {
      if (V && V.isSymbolicLink())
        return R.fs.stat(S, function(ne, $) {
          ne ? R._stat2(b, S, null, V, w) : R._stat2(b, S, ne, $, w);
        });
      R._stat2(b, S, K, V, w);
    }
  }, y.prototype._stat2 = function(b, w, S, T, E) {
    if (S && (S.code === "ENOENT" || S.code === "ENOTDIR"))
      return this.statCache[w] = !1, E();
    var C = b.slice(-1) === "/";
    if (this.statCache[w] = T, w.slice(-1) === "/" && T && !T.isDirectory())
      return E(null, !1, T);
    var A = !0;
    return T && (A = T.isDirectory() ? "DIR" : "FILE"), this.cache[w] = this.cache[w] || A, C && A === "FILE" ? E() : E(null, A, T);
  }, xd;
}
var hS;
function _fe() {
  if (hS)
    return ud.exports;
  hS = 1;
  var t = Me, e = se, r = hfe(), n = dfe(), i = mfe(), a = gfe(), s = c8(), o = ud.exports = {}, c = /[\/\\]/g, f = function(u, l) {
    var p = [];
    return r(u).forEach(function(m) {
      var h = m.indexOf("!") === 0;
      h && (m = m.slice(1));
      var g = l(m);
      h ? p = n(p, g) : p = i(p, g);
    }), p;
  };
  return o.exists = function() {
    var u = e.join.apply(e, arguments);
    return t.existsSync(u);
  }, o.expand = function(...u) {
    var l = a(u[0]) ? u.shift() : {}, p = Array.isArray(u[0]) ? u[0] : u;
    if (p.length === 0)
      return [];
    var m = f(p, function(h) {
      return s.sync(h, l);
    });
    return l.filter && (m = m.filter(function(h) {
      h = e.join(l.cwd || "", h);
      try {
        return typeof l.filter == "function" ? l.filter(h) : t.statSync(h)[l.filter]();
      } catch {
        return !1;
      }
    })), m;
  }, o.expandMapping = function(u, l, p) {
    p = Object.assign({
      rename: function(g, v) {
        return e.join(g || "", v);
      }
    }, p);
    var m = [], h = {};
    return o.expand(p, u).forEach(function(g) {
      var v = g;
      p.flatten && (v = e.basename(v)), p.ext && (v = v.replace(/(\.[^\/]*)?$/, p.ext));
      var d = p.rename(l, v, p);
      p.cwd && (g = e.join(p.cwd, g)), d = d.replace(c, "/"), g = g.replace(c, "/"), h[d] ? h[d].src.push(g) : (m.push({
        src: [g],
        dest: d
      }), h[d] = m[m.length - 1]);
    }), m;
  }, o.normalizeFilesArray = function(u) {
    var l = [];
    return u.forEach(function(p) {
      ("src" in p || "dest" in p) && l.push(p);
    }), l.length === 0 ? [] : (l = _(l).chain().forEach(function(p) {
      !("src" in p) || !p.src || (Array.isArray(p.src) ? p.src = r(p.src) : p.src = [p.src]);
    }).map(function(p) {
      var m = Object.assign({}, p);
      if (delete m.src, delete m.dest, p.expand)
        return o.expandMapping(p.src, p.dest, m).map(function(g) {
          var v = Object.assign({}, p);
          return v.orig = Object.assign({}, p), v.src = g.src, v.dest = g.dest, ["expand", "cwd", "flatten", "rename", "ext"].forEach(function(d) {
            delete v[d];
          }), v;
        });
      var h = Object.assign({}, p);
      return h.orig = Object.assign({}, p), "src" in h && Object.defineProperty(h, "src", {
        enumerable: !0,
        get: function g() {
          var v;
          return "result" in g || (v = p.src, v = Array.isArray(v) ? r(v) : [v], g.result = o.expand(m, v)), g.result;
        }
      }), "dest" in h && (h.dest = p.dest), h;
    }).flatten().value(), l);
  }, ud.exports;
}
var dS;
function Ts() {
  if (dS)
    return Mh.exports;
  dS = 1;
  var t = Me, e = se, r = ofe(), n = Y$(), i = cfe(), a = se.Stream, s = ffe().PassThrough, o = Mh.exports = {};
  return o.file = _fe(), o.collectStream = function(c, f) {
    var u = [], l = 0;
    c.on("error", f), c.on("data", function(p) {
      u.push(p), l += p.length;
    }), c.on("end", function() {
      var p = new Buffer(l), m = 0;
      u.forEach(function(h) {
        h.copy(p, m), m += h.length;
      }), f(null, p);
    });
  }, o.dateify = function(c) {
    return c = c || /* @__PURE__ */ new Date(), c instanceof Date ? c = c : typeof c == "string" ? c = new Date(c) : c = /* @__PURE__ */ new Date(), c;
  }, o.defaults = function(c, f, u) {
    var l = arguments;
    return l[0] = l[0] || {}, i(...l);
  }, o.isStream = function(c) {
    return c instanceof a;
  }, o.lazyReadStream = function(c) {
    return new r.Readable(function() {
      return t.createReadStream(c);
    });
  }, o.normalizeInputSource = function(c) {
    if (c === null)
      return new Buffer(0);
    if (typeof c == "string")
      return new Buffer(c);
    if (o.isStream(c) && !c._readableState) {
      var f = new s();
      return c.pipe(f), f;
    }
    return c;
  }, o.sanitizePath = function(c) {
    return n(c, !1).replace(/^\w+:/, "").replace(/^(\.\.\/|\/)+/, "");
  }, o.trailingSlashIt = function(c) {
    return c.slice(-1) !== "/" ? c + "/" : c;
  }, o.unixifyPath = function(c) {
    return n(c, !1).replace(/^\w+:/, "");
  }, o.walkdir = function(c, f, u) {
    var l = [];
    typeof f == "function" && (u = f, f = c), t.readdir(c, function(p, m) {
      var h = 0, g, v;
      if (p)
        return u(p);
      (function d() {
        if (g = m[h++], !g)
          return u(null, l);
        v = e.join(c, g), t.stat(v, function(y, x) {
          l.push({
            path: v,
            relative: e.relative(f, v).replace(/\\/g, "/"),
            stats: x
          }), x && x.isDirectory() ? o.walkdir(v, f, function(b, w) {
            w.forEach(function(S) {
              l.push(S);
            }), d();
          }) : d();
        });
      })();
    });
  }, Mh.exports;
}
var _d = { exports: {} };
/**
 * Archiver Core
 *
 * @ignore
 * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
 * @copyright (c) 2012-2014 Chris Talkington, contributors.
 */
var mS;
function Efe() {
  return mS || (mS = 1, function(t, e) {
    var r = nt;
    const n = {
      ABORTED: "archive was aborted",
      DIRECTORYDIRPATHREQUIRED: "diretory dirpath argument must be a non-empty string value",
      DIRECTORYFUNCTIONINVALIDDATA: "invalid data returned by directory custom data function",
      ENTRYNAMEREQUIRED: "entry name must be a non-empty string value",
      FILEFILEPATHREQUIRED: "file filepath argument must be a non-empty string value",
      FINALIZING: "archive already finalizing",
      QUEUECLOSED: "queue closed",
      NOENDMETHOD: "no suitable finalize/end method defined by module",
      DIRECTORYNOTSUPPORTED: "support for directory entries not defined by module",
      FORMATSET: "archive format already set",
      INPUTSTEAMBUFFERREQUIRED: "input source must be valid Stream or Buffer instance",
      MODULESET: "module already set",
      SYMLINKNOTSUPPORTED: "support for symlink entries not defined by module",
      SYMLINKFILEPATHREQUIRED: "symlink filepath argument must be a non-empty string value",
      SYMLINKTARGETREQUIRED: "symlink target argument must be a non-empty string value",
      ENTRYNOTSUPPORTED: "entry not supported"
    };
    function i(a, s) {
      Error.captureStackTrace(this, this.constructor), this.message = n[a] || a, this.code = a, this.data = s;
    }
    r.inherits(i, Error), t.exports = i;
  }(_d)), _d.exports;
}
var ho = { exports: {} }, Ed, gS;
function u8() {
  return gS || (gS = 1, Ed = bt.EventEmitter), Ed;
}
var Sd, vS;
function Sfe() {
  if (vS)
    return Sd;
  vS = 1;
  function t(h, g) {
    var v = Object.keys(h);
    if (Object.getOwnPropertySymbols) {
      var d = Object.getOwnPropertySymbols(h);
      g && (d = d.filter(function(y) {
        return Object.getOwnPropertyDescriptor(h, y).enumerable;
      })), v.push.apply(v, d);
    }
    return v;
  }
  function e(h) {
    for (var g = 1; g < arguments.length; g++) {
      var v = arguments[g] != null ? arguments[g] : {};
      g % 2 ? t(Object(v), !0).forEach(function(d) {
        r(h, d, v[d]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(h, Object.getOwnPropertyDescriptors(v)) : t(Object(v)).forEach(function(d) {
        Object.defineProperty(h, d, Object.getOwnPropertyDescriptor(v, d));
      });
    }
    return h;
  }
  function r(h, g, v) {
    return g = s(g), g in h ? Object.defineProperty(h, g, { value: v, enumerable: !0, configurable: !0, writable: !0 }) : h[g] = v, h;
  }
  function n(h, g) {
    if (!(h instanceof g))
      throw new TypeError("Cannot call a class as a function");
  }
  function i(h, g) {
    for (var v = 0; v < g.length; v++) {
      var d = g[v];
      d.enumerable = d.enumerable || !1, d.configurable = !0, "value" in d && (d.writable = !0), Object.defineProperty(h, s(d.key), d);
    }
  }
  function a(h, g, v) {
    return g && i(h.prototype, g), v && i(h, v), Object.defineProperty(h, "prototype", { writable: !1 }), h;
  }
  function s(h) {
    var g = o(h, "string");
    return typeof g == "symbol" ? g : String(g);
  }
  function o(h, g) {
    if (typeof h != "object" || h === null)
      return h;
    var v = h[Symbol.toPrimitive];
    if (v !== void 0) {
      var d = v.call(h, g || "default");
      if (typeof d != "object")
        return d;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (g === "string" ? String : Number)(h);
  }
  var c = rr, f = c.Buffer, u = se, l = u.inspect, p = l && l.custom || "inspect";
  function m(h, g, v) {
    f.prototype.copy.call(h, g, v);
  }
  return Sd = /* @__PURE__ */ function() {
    function h() {
      n(this, h), this.head = null, this.tail = null, this.length = 0;
    }
    return a(h, [{
      key: "push",
      value: function(v) {
        var d = {
          data: v,
          next: null
        };
        this.length > 0 ? this.tail.next = d : this.head = d, this.tail = d, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(v) {
        var d = {
          data: v,
          next: this.head
        };
        this.length === 0 && (this.tail = d), this.head = d, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var v = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, v;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(v) {
        if (this.length === 0)
          return "";
        for (var d = this.head, y = "" + d.data; d = d.next; )
          y += v + d.data;
        return y;
      }
    }, {
      key: "concat",
      value: function(v) {
        if (this.length === 0)
          return f.alloc(0);
        for (var d = f.allocUnsafe(v >>> 0), y = this.head, x = 0; y; )
          m(y.data, d, x), x += y.data.length, y = y.next;
        return d;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(v, d) {
        var y;
        return v < this.head.data.length ? (y = this.head.data.slice(0, v), this.head.data = this.head.data.slice(v)) : v === this.head.data.length ? y = this.shift() : y = d ? this._getString(v) : this._getBuffer(v), y;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(v) {
        var d = this.head, y = 1, x = d.data;
        for (v -= x.length; d = d.next; ) {
          var b = d.data, w = v > b.length ? b.length : v;
          if (w === b.length ? x += b : x += b.slice(0, v), v -= w, v === 0) {
            w === b.length ? (++y, d.next ? this.head = d.next : this.head = this.tail = null) : (this.head = d, d.data = b.slice(w));
            break;
          }
          ++y;
        }
        return this.length -= y, x;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(v) {
        var d = f.allocUnsafe(v), y = this.head, x = 1;
        for (y.data.copy(d), v -= y.data.length; y = y.next; ) {
          var b = y.data, w = v > b.length ? b.length : v;
          if (b.copy(d, d.length - v, 0, w), v -= w, v === 0) {
            w === b.length ? (++x, y.next ? this.head = y.next : this.head = this.tail = null) : (this.head = y, y.data = b.slice(w));
            break;
          }
          ++x;
        }
        return this.length -= x, d;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: p,
      value: function(v, d) {
        return l(this, e(e({}, d), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), h;
  }(), Sd;
}
var Cd, yS;
function l8() {
  if (yS)
    return Cd;
  yS = 1;
  function t(s, o) {
    var c = this, f = this._readableState && this._readableState.destroyed, u = this._writableState && this._writableState.destroyed;
    return f || u ? (o ? o(s) : s && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process.nextTick(i, this, s)) : process.nextTick(i, this, s)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(s || null, function(l) {
      !o && l ? c._writableState ? c._writableState.errorEmitted ? process.nextTick(r, c) : (c._writableState.errorEmitted = !0, process.nextTick(e, c, l)) : process.nextTick(e, c, l) : o ? (process.nextTick(r, c), o(l)) : process.nextTick(r, c);
    }), this);
  }
  function e(s, o) {
    i(s, o), r(s);
  }
  function r(s) {
    s._writableState && !s._writableState.emitClose || s._readableState && !s._readableState.emitClose || s.emit("close");
  }
  function n() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function i(s, o) {
    s.emit("error", o);
  }
  function a(s, o) {
    var c = s._readableState, f = s._writableState;
    c && c.autoDestroy || f && f.autoDestroy ? s.destroy(o) : s.emit("error", o);
  }
  return Cd = {
    destroy: t,
    undestroy: n,
    errorOrDestroy: a
  }, Cd;
}
var Td = {}, bS;
function Ji() {
  if (bS)
    return Td;
  bS = 1;
  function t(o, c) {
    o.prototype = Object.create(c.prototype), o.prototype.constructor = o, o.__proto__ = c;
  }
  var e = {};
  function r(o, c, f) {
    f || (f = Error);
    function u(p, m, h) {
      return typeof c == "string" ? c : c(p, m, h);
    }
    var l = /* @__PURE__ */ function(p) {
      t(m, p);
      function m(h, g, v) {
        return p.call(this, u(h, g, v)) || this;
      }
      return m;
    }(f);
    l.prototype.name = f.name, l.prototype.code = o, e[o] = l;
  }
  function n(o, c) {
    if (Array.isArray(o)) {
      var f = o.length;
      return o = o.map(function(u) {
        return String(u);
      }), f > 2 ? "one of ".concat(c, " ").concat(o.slice(0, f - 1).join(", "), ", or ") + o[f - 1] : f === 2 ? "one of ".concat(c, " ").concat(o[0], " or ").concat(o[1]) : "of ".concat(c, " ").concat(o[0]);
    } else
      return "of ".concat(c, " ").concat(String(o));
  }
  function i(o, c, f) {
    return o.substr(!f || f < 0 ? 0 : +f, c.length) === c;
  }
  function a(o, c, f) {
    return (f === void 0 || f > o.length) && (f = o.length), o.substring(f - c.length, f) === c;
  }
  function s(o, c, f) {
    return typeof f != "number" && (f = 0), f + c.length > o.length ? !1 : o.indexOf(c, f) !== -1;
  }
  return r("ERR_INVALID_OPT_VALUE", function(o, c) {
    return 'The value "' + c + '" is invalid for option "' + o + '"';
  }, TypeError), r("ERR_INVALID_ARG_TYPE", function(o, c, f) {
    var u;
    typeof c == "string" && i(c, "not ") ? (u = "must not be", c = c.replace(/^not /, "")) : u = "must be";
    var l;
    if (a(o, " argument"))
      l = "The ".concat(o, " ").concat(u, " ").concat(n(c, "type"));
    else {
      var p = s(o, ".") ? "property" : "argument";
      l = 'The "'.concat(o, '" ').concat(p, " ").concat(u, " ").concat(n(c, "type"));
    }
    return l += ". Received type ".concat(typeof f), l;
  }, TypeError), r("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), r("ERR_METHOD_NOT_IMPLEMENTED", function(o) {
    return "The " + o + " method is not implemented";
  }), r("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), r("ERR_STREAM_DESTROYED", function(o) {
    return "Cannot call " + o + " after a stream was destroyed";
  }), r("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), r("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), r("ERR_STREAM_WRITE_AFTER_END", "write after end"), r("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), r("ERR_UNKNOWN_ENCODING", function(o) {
    return "Unknown encoding: " + o;
  }, TypeError), r("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), Td.codes = e, Td;
}
var Od, wS;
function p8() {
  if (wS)
    return Od;
  wS = 1;
  var t = Ji().codes.ERR_INVALID_OPT_VALUE;
  function e(n, i, a) {
    return n.highWaterMark != null ? n.highWaterMark : i ? n[a] : null;
  }
  function r(n, i, a, s) {
    var o = e(i, s, a);
    if (o != null) {
      if (!(isFinite(o) && Math.floor(o) === o) || o < 0) {
        var c = s ? a : "highWaterMark";
        throw new t(c, o);
      }
      return Math.floor(o);
    }
    return n.objectMode ? 16 : 16 * 1024;
  }
  return Od = {
    getHighWaterMark: r
  }, Od;
}
var Ad, xS;
function f8() {
  if (xS)
    return Ad;
  xS = 1, Ad = E;
  function t(J) {
    var O = this;
    this.next = null, this.entry = null, this.finish = function() {
      me(O, J);
    };
  }
  var e;
  E.WritableState = S;
  var r = {
    deprecate: _y()
  }, n = u8(), i = rr.Buffer, a = (typeof ve < "u" ? ve : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function s(J) {
    return i.from(J);
  }
  function o(J) {
    return i.isBuffer(J) || J instanceof a;
  }
  var c = l8(), f = p8(), u = f.getHighWaterMark, l = Ji().codes, p = l.ERR_INVALID_ARG_TYPE, m = l.ERR_METHOD_NOT_IMPLEMENTED, h = l.ERR_MULTIPLE_CALLBACK, g = l.ERR_STREAM_CANNOT_PIPE, v = l.ERR_STREAM_DESTROYED, d = l.ERR_STREAM_NULL_VALUES, y = l.ERR_STREAM_WRITE_AFTER_END, x = l.ERR_UNKNOWN_ENCODING, b = c.errorOrDestroy;
  ct()(E, n);
  function w() {
  }
  function S(J, O, I) {
    e = e || Ti(), J = J || {}, typeof I != "boolean" && (I = O instanceof e), this.objectMode = !!J.objectMode, I && (this.objectMode = this.objectMode || !!J.writableObjectMode), this.highWaterMark = u(this, J, "writableHighWaterMark", I), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var z = J.decodeStrings === !1;
    this.decodeStrings = !z, this.defaultEncoding = J.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(G) {
      ne(O, G);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = J.emitClose !== !1, this.autoDestroy = !!J.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new t(this);
  }
  S.prototype.getBuffer = function() {
    for (var O = this.bufferedRequest, I = []; O; )
      I.push(O), O = O.next;
    return I;
  }, function() {
    try {
      Object.defineProperty(S.prototype, "buffer", {
        get: r.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var T;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (T = Function.prototype[Symbol.hasInstance], Object.defineProperty(E, Symbol.hasInstance, {
    value: function(O) {
      return T.call(this, O) ? !0 : this !== E ? !1 : O && O._writableState instanceof S;
    }
  })) : T = function(O) {
    return O instanceof this;
  };
  function E(J) {
    e = e || Ti();
    var O = this instanceof e;
    if (!O && !T.call(E, this))
      return new E(J);
    this._writableState = new S(J, this, O), this.writable = !0, J && (typeof J.write == "function" && (this._write = J.write), typeof J.writev == "function" && (this._writev = J.writev), typeof J.destroy == "function" && (this._destroy = J.destroy), typeof J.final == "function" && (this._final = J.final)), n.call(this);
  }
  E.prototype.pipe = function() {
    b(this, new g());
  };
  function C(J, O) {
    var I = new y();
    b(J, I), process.nextTick(O, I);
  }
  function A(J, O, I, z) {
    var G;
    return I === null ? G = new d() : typeof I != "string" && !O.objectMode && (G = new p("chunk", ["string", "Buffer"], I)), G ? (b(J, G), process.nextTick(z, G), !1) : !0;
  }
  E.prototype.write = function(J, O, I) {
    var z = this._writableState, G = !1, q = !z.objectMode && o(J);
    return q && !i.isBuffer(J) && (J = s(J)), typeof O == "function" && (I = O, O = null), q ? O = "buffer" : O || (O = z.defaultEncoding), typeof I != "function" && (I = w), z.ending ? C(this, I) : (q || A(this, z, J, I)) && (z.pendingcb++, G = D(this, z, q, J, O, I)), G;
  }, E.prototype.cork = function() {
    this._writableState.corked++;
  }, E.prototype.uncork = function() {
    var J = this._writableState;
    J.corked && (J.corked--, !J.writing && !J.corked && !J.bufferProcessing && J.bufferedRequest && P(this, J));
  }, E.prototype.setDefaultEncoding = function(O) {
    if (typeof O == "string" && (O = O.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((O + "").toLowerCase()) > -1))
      throw new x(O);
    return this._writableState.defaultEncoding = O, this;
  }, Object.defineProperty(E.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function R(J, O, I) {
    return !J.objectMode && J.decodeStrings !== !1 && typeof O == "string" && (O = i.from(O, I)), O;
  }
  Object.defineProperty(E.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function D(J, O, I, z, G, q) {
    if (!I) {
      var M = R(O, z, G);
      z !== M && (I = !0, G = "buffer", z = M);
    }
    var Z = O.objectMode ? 1 : z.length;
    O.length += Z;
    var B = O.length < O.highWaterMark;
    if (B || (O.needDrain = !0), O.writing || O.corked) {
      var re = O.lastBufferedRequest;
      O.lastBufferedRequest = {
        chunk: z,
        encoding: G,
        isBuf: I,
        callback: q,
        next: null
      }, re ? re.next = O.lastBufferedRequest : O.bufferedRequest = O.lastBufferedRequest, O.bufferedRequestCount += 1;
    } else
      F(J, O, !1, Z, z, G, q);
    return B;
  }
  function F(J, O, I, z, G, q, M) {
    O.writelen = z, O.writecb = M, O.writing = !0, O.sync = !0, O.destroyed ? O.onwrite(new v("write")) : I ? J._writev(G, O.onwrite) : J._write(G, q, O.onwrite), O.sync = !1;
  }
  function K(J, O, I, z, G) {
    --O.pendingcb, I ? (process.nextTick(G, z), process.nextTick(ce, J, O), J._writableState.errorEmitted = !0, b(J, z)) : (G(z), J._writableState.errorEmitted = !0, b(J, z), ce(J, O));
  }
  function V(J) {
    J.writing = !1, J.writecb = null, J.length -= J.writelen, J.writelen = 0;
  }
  function ne(J, O) {
    var I = J._writableState, z = I.sync, G = I.writecb;
    if (typeof G != "function")
      throw new h();
    if (V(I), O)
      K(J, I, z, O, G);
    else {
      var q = H(I) || J.destroyed;
      !q && !I.corked && !I.bufferProcessing && I.bufferedRequest && P(J, I), z ? process.nextTick($, J, I, q, G) : $(J, I, q, G);
    }
  }
  function $(J, O, I, z) {
    I || L(J, O), O.pendingcb--, z(), ce(J, O);
  }
  function L(J, O) {
    O.length === 0 && O.needDrain && (O.needDrain = !1, J.emit("drain"));
  }
  function P(J, O) {
    O.bufferProcessing = !0;
    var I = O.bufferedRequest;
    if (J._writev && I && I.next) {
      var z = O.bufferedRequestCount, G = new Array(z), q = O.corkedRequestsFree;
      q.entry = I;
      for (var M = 0, Z = !0; I; )
        G[M] = I, I.isBuf || (Z = !1), I = I.next, M += 1;
      G.allBuffers = Z, F(J, O, !0, O.length, G, "", q.finish), O.pendingcb++, O.lastBufferedRequest = null, q.next ? (O.corkedRequestsFree = q.next, q.next = null) : O.corkedRequestsFree = new t(O), O.bufferedRequestCount = 0;
    } else {
      for (; I; ) {
        var B = I.chunk, re = I.encoding, j = I.callback, k = O.objectMode ? 1 : B.length;
        if (F(J, O, !1, k, B, re, j), I = I.next, O.bufferedRequestCount--, O.writing)
          break;
      }
      I === null && (O.lastBufferedRequest = null);
    }
    O.bufferedRequest = I, O.bufferProcessing = !1;
  }
  E.prototype._write = function(J, O, I) {
    I(new m("_write()"));
  }, E.prototype._writev = null, E.prototype.end = function(J, O, I) {
    var z = this._writableState;
    return typeof J == "function" ? (I = J, J = null, O = null) : typeof O == "function" && (I = O, O = null), J != null && this.write(J, O), z.corked && (z.corked = 1, this.uncork()), z.ending || ue(this, z, I), this;
  }, Object.defineProperty(E.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function H(J) {
    return J.ending && J.length === 0 && J.bufferedRequest === null && !J.finished && !J.writing;
  }
  function Q(J, O) {
    J._final(function(I) {
      O.pendingcb--, I && b(J, I), O.prefinished = !0, J.emit("prefinish"), ce(J, O);
    });
  }
  function Y(J, O) {
    !O.prefinished && !O.finalCalled && (typeof J._final == "function" && !O.destroyed ? (O.pendingcb++, O.finalCalled = !0, process.nextTick(Q, J, O)) : (O.prefinished = !0, J.emit("prefinish")));
  }
  function ce(J, O) {
    var I = H(O);
    if (I && (Y(J, O), O.pendingcb === 0 && (O.finished = !0, J.emit("finish"), O.autoDestroy))) {
      var z = J._readableState;
      (!z || z.autoDestroy && z.endEmitted) && J.destroy();
    }
    return I;
  }
  function ue(J, O, I) {
    O.ending = !0, ce(J, O), I && (O.finished ? process.nextTick(I) : J.once("finish", I)), O.ended = !0, J.writable = !1;
  }
  function me(J, O, I) {
    var z = J.entry;
    for (J.entry = null; z; ) {
      var G = z.callback;
      O.pendingcb--, G(I), z = z.next;
    }
    O.corkedRequestsFree.next = J;
  }
  return Object.defineProperty(E.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(O) {
      this._writableState && (this._writableState.destroyed = O);
    }
  }), E.prototype.destroy = c.destroy, E.prototype._undestroy = c.undestroy, E.prototype._destroy = function(J, O) {
    O(J);
  }, Ad;
}
var $d, _S;
function Ti() {
  if (_S)
    return $d;
  _S = 1;
  var t = Object.keys || function(f) {
    var u = [];
    for (var l in f)
      u.push(l);
    return u;
  };
  $d = s;
  var e = h8(), r = f8();
  ct()(s, e);
  for (var n = t(r.prototype), i = 0; i < n.length; i++) {
    var a = n[i];
    s.prototype[a] || (s.prototype[a] = r.prototype[a]);
  }
  function s(f) {
    if (!(this instanceof s))
      return new s(f);
    e.call(this, f), r.call(this, f), this.allowHalfOpen = !0, f && (f.readable === !1 && (this.readable = !1), f.writable === !1 && (this.writable = !1), f.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", o)));
  }
  Object.defineProperty(s.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(s.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(s.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function o() {
    this._writableState.ended || process.nextTick(c, this);
  }
  function c(f) {
    f.end();
  }
  return Object.defineProperty(s.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(u) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = u, this._writableState.destroyed = u);
    }
  }), $d;
}
var Id, ES;
function Ty() {
  if (ES)
    return Id;
  ES = 1;
  var t = Ji().codes.ERR_STREAM_PREMATURE_CLOSE;
  function e(a) {
    var s = !1;
    return function() {
      if (!s) {
        s = !0;
        for (var o = arguments.length, c = new Array(o), f = 0; f < o; f++)
          c[f] = arguments[f];
        a.apply(this, c);
      }
    };
  }
  function r() {
  }
  function n(a) {
    return a.setHeader && typeof a.abort == "function";
  }
  function i(a, s, o) {
    if (typeof s == "function")
      return i(a, null, s);
    s || (s = {}), o = e(o || r);
    var c = s.readable || s.readable !== !1 && a.readable, f = s.writable || s.writable !== !1 && a.writable, u = function() {
      a.writable || p();
    }, l = a._writableState && a._writableState.finished, p = function() {
      f = !1, l = !0, c || o.call(a);
    }, m = a._readableState && a._readableState.endEmitted, h = function() {
      c = !1, m = !0, f || o.call(a);
    }, g = function(x) {
      o.call(a, x);
    }, v = function() {
      var x;
      if (c && !m)
        return (!a._readableState || !a._readableState.ended) && (x = new t()), o.call(a, x);
      if (f && !l)
        return (!a._writableState || !a._writableState.ended) && (x = new t()), o.call(a, x);
    }, d = function() {
      a.req.on("finish", p);
    };
    return n(a) ? (a.on("complete", p), a.on("abort", v), a.req ? d() : a.on("request", d)) : f && !a._writableState && (a.on("end", u), a.on("close", u)), a.on("end", h), a.on("finish", p), s.error !== !1 && a.on("error", g), a.on("close", v), function() {
      a.removeListener("complete", p), a.removeListener("abort", v), a.removeListener("request", d), a.req && a.req.removeListener("finish", p), a.removeListener("end", u), a.removeListener("close", u), a.removeListener("finish", p), a.removeListener("end", h), a.removeListener("error", g), a.removeListener("close", v);
    };
  }
  return Id = i, Id;
}
var kd, SS;
function Cfe() {
  if (SS)
    return kd;
  SS = 1;
  var t;
  function e(x, b, w) {
    return b = r(b), b in x ? Object.defineProperty(x, b, { value: w, enumerable: !0, configurable: !0, writable: !0 }) : x[b] = w, x;
  }
  function r(x) {
    var b = n(x, "string");
    return typeof b == "symbol" ? b : String(b);
  }
  function n(x, b) {
    if (typeof x != "object" || x === null)
      return x;
    var w = x[Symbol.toPrimitive];
    if (w !== void 0) {
      var S = w.call(x, b || "default");
      if (typeof S != "object")
        return S;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (b === "string" ? String : Number)(x);
  }
  var i = Ty(), a = Symbol("lastResolve"), s = Symbol("lastReject"), o = Symbol("error"), c = Symbol("ended"), f = Symbol("lastPromise"), u = Symbol("handlePromise"), l = Symbol("stream");
  function p(x, b) {
    return {
      value: x,
      done: b
    };
  }
  function m(x) {
    var b = x[a];
    if (b !== null) {
      var w = x[l].read();
      w !== null && (x[f] = null, x[a] = null, x[s] = null, b(p(w, !1)));
    }
  }
  function h(x) {
    process.nextTick(m, x);
  }
  function g(x, b) {
    return function(w, S) {
      x.then(function() {
        if (b[c]) {
          w(p(void 0, !0));
          return;
        }
        b[u](w, S);
      }, S);
    };
  }
  var v = Object.getPrototypeOf(function() {
  }), d = Object.setPrototypeOf((t = {
    get stream() {
      return this[l];
    },
    next: function() {
      var b = this, w = this[o];
      if (w !== null)
        return Promise.reject(w);
      if (this[c])
        return Promise.resolve(p(void 0, !0));
      if (this[l].destroyed)
        return new Promise(function(C, A) {
          process.nextTick(function() {
            b[o] ? A(b[o]) : C(p(void 0, !0));
          });
        });
      var S = this[f], T;
      if (S)
        T = new Promise(g(S, this));
      else {
        var E = this[l].read();
        if (E !== null)
          return Promise.resolve(p(E, !1));
        T = new Promise(this[u]);
      }
      return this[f] = T, T;
    }
  }, e(t, Symbol.asyncIterator, function() {
    return this;
  }), e(t, "return", function() {
    var b = this;
    return new Promise(function(w, S) {
      b[l].destroy(null, function(T) {
        if (T) {
          S(T);
          return;
        }
        w(p(void 0, !0));
      });
    });
  }), t), v), y = function(b) {
    var w, S = Object.create(d, (w = {}, e(w, l, {
      value: b,
      writable: !0
    }), e(w, a, {
      value: null,
      writable: !0
    }), e(w, s, {
      value: null,
      writable: !0
    }), e(w, o, {
      value: null,
      writable: !0
    }), e(w, c, {
      value: b._readableState.endEmitted,
      writable: !0
    }), e(w, u, {
      value: function(E, C) {
        var A = S[l].read();
        A ? (S[f] = null, S[a] = null, S[s] = null, E(p(A, !1))) : (S[a] = E, S[s] = C);
      },
      writable: !0
    }), w));
    return S[f] = null, i(b, function(T) {
      if (T && T.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var E = S[s];
        E !== null && (S[f] = null, S[a] = null, S[s] = null, E(T)), S[o] = T;
        return;
      }
      var C = S[a];
      C !== null && (S[f] = null, S[a] = null, S[s] = null, C(p(void 0, !0))), S[c] = !0;
    }), b.on("readable", h.bind(null, S)), S;
  };
  return kd = y, kd;
}
var Rd, CS;
function Tfe() {
  return CS || (CS = 1, Rd = function() {
    throw new Error("Readable.from is not available in the browser");
  }), Rd;
}
var Nd, TS;
function h8() {
  if (TS)
    return Nd;
  TS = 1, Nd = C;
  var t;
  C.ReadableState = E, bt.EventEmitter;
  var e = function(M, Z) {
    return M.listeners(Z).length;
  }, r = u8(), n = rr.Buffer, i = (typeof ve < "u" ? ve : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function a(q) {
    return n.from(q);
  }
  function s(q) {
    return n.isBuffer(q) || q instanceof i;
  }
  var o = se, c;
  o && o.debuglog ? c = o.debuglog("stream") : c = function() {
  };
  var f = Sfe(), u = l8(), l = p8(), p = l.getHighWaterMark, m = Ji().codes, h = m.ERR_INVALID_ARG_TYPE, g = m.ERR_STREAM_PUSH_AFTER_EOF, v = m.ERR_METHOD_NOT_IMPLEMENTED, d = m.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, y, x, b;
  ct()(C, r);
  var w = u.errorOrDestroy, S = ["error", "close", "destroy", "pause", "resume"];
  function T(q, M, Z) {
    if (typeof q.prependListener == "function")
      return q.prependListener(M, Z);
    !q._events || !q._events[M] ? q.on(M, Z) : Array.isArray(q._events[M]) ? q._events[M].unshift(Z) : q._events[M] = [Z, q._events[M]];
  }
  function E(q, M, Z) {
    t = t || Ti(), q = q || {}, typeof Z != "boolean" && (Z = M instanceof t), this.objectMode = !!q.objectMode, Z && (this.objectMode = this.objectMode || !!q.readableObjectMode), this.highWaterMark = p(this, q, "readableHighWaterMark", Z), this.buffer = new f(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = q.emitClose !== !1, this.autoDestroy = !!q.autoDestroy, this.destroyed = !1, this.defaultEncoding = q.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, q.encoding && (y || (y = No().StringDecoder), this.decoder = new y(q.encoding), this.encoding = q.encoding);
  }
  function C(q) {
    if (t = t || Ti(), !(this instanceof C))
      return new C(q);
    var M = this instanceof t;
    this._readableState = new E(q, this, M), this.readable = !0, q && (typeof q.read == "function" && (this._read = q.read), typeof q.destroy == "function" && (this._destroy = q.destroy)), r.call(this);
  }
  Object.defineProperty(C.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(M) {
      this._readableState && (this._readableState.destroyed = M);
    }
  }), C.prototype.destroy = u.destroy, C.prototype._undestroy = u.undestroy, C.prototype._destroy = function(q, M) {
    M(q);
  }, C.prototype.push = function(q, M) {
    var Z = this._readableState, B;
    return Z.objectMode ? B = !0 : typeof q == "string" && (M = M || Z.defaultEncoding, M !== Z.encoding && (q = n.from(q, M), M = ""), B = !0), A(this, q, M, !1, B);
  }, C.prototype.unshift = function(q) {
    return A(this, q, null, !0, !1);
  };
  function A(q, M, Z, B, re) {
    c("readableAddChunk", M);
    var j = q._readableState;
    if (M === null)
      j.reading = !1, ne(q, j);
    else {
      var k;
      if (re || (k = D(j, M)), k)
        w(q, k);
      else if (j.objectMode || M && M.length > 0)
        if (typeof M != "string" && !j.objectMode && Object.getPrototypeOf(M) !== n.prototype && (M = a(M)), B)
          j.endEmitted ? w(q, new d()) : R(q, j, M, !0);
        else if (j.ended)
          w(q, new g());
        else {
          if (j.destroyed)
            return !1;
          j.reading = !1, j.decoder && !Z ? (M = j.decoder.write(M), j.objectMode || M.length !== 0 ? R(q, j, M, !1) : P(q, j)) : R(q, j, M, !1);
        }
      else
        B || (j.reading = !1, P(q, j));
    }
    return !j.ended && (j.length < j.highWaterMark || j.length === 0);
  }
  function R(q, M, Z, B) {
    M.flowing && M.length === 0 && !M.sync ? (M.awaitDrain = 0, q.emit("data", Z)) : (M.length += M.objectMode ? 1 : Z.length, B ? M.buffer.unshift(Z) : M.buffer.push(Z), M.needReadable && $(q)), P(q, M);
  }
  function D(q, M) {
    var Z;
    return !s(M) && typeof M != "string" && M !== void 0 && !q.objectMode && (Z = new h("chunk", ["string", "Buffer", "Uint8Array"], M)), Z;
  }
  C.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, C.prototype.setEncoding = function(q) {
    y || (y = No().StringDecoder);
    var M = new y(q);
    this._readableState.decoder = M, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var Z = this._readableState.buffer.head, B = ""; Z !== null; )
      B += M.write(Z.data), Z = Z.next;
    return this._readableState.buffer.clear(), B !== "" && this._readableState.buffer.push(B), this._readableState.length = B.length, this;
  };
  var F = 1073741824;
  function K(q) {
    return q >= F ? q = F : (q--, q |= q >>> 1, q |= q >>> 2, q |= q >>> 4, q |= q >>> 8, q |= q >>> 16, q++), q;
  }
  function V(q, M) {
    return q <= 0 || M.length === 0 && M.ended ? 0 : M.objectMode ? 1 : q !== q ? M.flowing && M.length ? M.buffer.head.data.length : M.length : (q > M.highWaterMark && (M.highWaterMark = K(q)), q <= M.length ? q : M.ended ? M.length : (M.needReadable = !0, 0));
  }
  C.prototype.read = function(q) {
    c("read", q), q = parseInt(q, 10);
    var M = this._readableState, Z = q;
    if (q !== 0 && (M.emittedReadable = !1), q === 0 && M.needReadable && ((M.highWaterMark !== 0 ? M.length >= M.highWaterMark : M.length > 0) || M.ended))
      return c("read: emitReadable", M.length, M.ended), M.length === 0 && M.ended ? I(this) : $(this), null;
    if (q = V(q, M), q === 0 && M.ended)
      return M.length === 0 && I(this), null;
    var B = M.needReadable;
    c("need readable", B), (M.length === 0 || M.length - q < M.highWaterMark) && (B = !0, c("length less than watermark", B)), M.ended || M.reading ? (B = !1, c("reading or ended", B)) : B && (c("do read"), M.reading = !0, M.sync = !0, M.length === 0 && (M.needReadable = !0), this._read(M.highWaterMark), M.sync = !1, M.reading || (q = V(Z, M)));
    var re;
    return q > 0 ? re = O(q, M) : re = null, re === null ? (M.needReadable = M.length <= M.highWaterMark, q = 0) : (M.length -= q, M.awaitDrain = 0), M.length === 0 && (M.ended || (M.needReadable = !0), Z !== q && M.ended && I(this)), re !== null && this.emit("data", re), re;
  };
  function ne(q, M) {
    if (c("onEofChunk"), !M.ended) {
      if (M.decoder) {
        var Z = M.decoder.end();
        Z && Z.length && (M.buffer.push(Z), M.length += M.objectMode ? 1 : Z.length);
      }
      M.ended = !0, M.sync ? $(q) : (M.needReadable = !1, M.emittedReadable || (M.emittedReadable = !0, L(q)));
    }
  }
  function $(q) {
    var M = q._readableState;
    c("emitReadable", M.needReadable, M.emittedReadable), M.needReadable = !1, M.emittedReadable || (c("emitReadable", M.flowing), M.emittedReadable = !0, process.nextTick(L, q));
  }
  function L(q) {
    var M = q._readableState;
    c("emitReadable_", M.destroyed, M.length, M.ended), !M.destroyed && (M.length || M.ended) && (q.emit("readable"), M.emittedReadable = !1), M.needReadable = !M.flowing && !M.ended && M.length <= M.highWaterMark, J(q);
  }
  function P(q, M) {
    M.readingMore || (M.readingMore = !0, process.nextTick(H, q, M));
  }
  function H(q, M) {
    for (; !M.reading && !M.ended && (M.length < M.highWaterMark || M.flowing && M.length === 0); ) {
      var Z = M.length;
      if (c("maybeReadMore read 0"), q.read(0), Z === M.length)
        break;
    }
    M.readingMore = !1;
  }
  C.prototype._read = function(q) {
    w(this, new v("_read()"));
  }, C.prototype.pipe = function(q, M) {
    var Z = this, B = this._readableState;
    switch (B.pipesCount) {
      case 0:
        B.pipes = q;
        break;
      case 1:
        B.pipes = [B.pipes, q];
        break;
      default:
        B.pipes.push(q);
        break;
    }
    B.pipesCount += 1, c("pipe count=%d opts=%j", B.pipesCount, M);
    var re = (!M || M.end !== !1) && q !== process.stdout && q !== process.stderr, j = re ? N : $e;
    B.endEmitted ? process.nextTick(j) : Z.once("end", j), q.on("unpipe", k);
    function k(Ce, le) {
      c("onunpipe"), Ce === Z && le && le.hasUnpiped === !1 && (le.hasUnpiped = !0, pe());
    }
    function N() {
      c("onend"), q.end();
    }
    var U = Q(Z);
    q.on("drain", U);
    var ee = !1;
    function pe() {
      c("cleanup"), q.removeListener("close", ye), q.removeListener("finish", Ee), q.removeListener("drain", U), q.removeListener("error", be), q.removeListener("unpipe", k), Z.removeListener("end", N), Z.removeListener("end", $e), Z.removeListener("data", he), ee = !0, B.awaitDrain && (!q._writableState || q._writableState.needDrain) && U();
    }
    Z.on("data", he);
    function he(Ce) {
      c("ondata");
      var le = q.write(Ce);
      c("dest.write", le), le === !1 && ((B.pipesCount === 1 && B.pipes === q || B.pipesCount > 1 && G(B.pipes, q) !== -1) && !ee && (c("false write response, pause", B.awaitDrain), B.awaitDrain++), Z.pause());
    }
    function be(Ce) {
      c("onerror", Ce), $e(), q.removeListener("error", be), e(q, "error") === 0 && w(q, Ce);
    }
    T(q, "error", be);
    function ye() {
      q.removeListener("finish", Ee), $e();
    }
    q.once("close", ye);
    function Ee() {
      c("onfinish"), q.removeListener("close", ye), $e();
    }
    q.once("finish", Ee);
    function $e() {
      c("unpipe"), Z.unpipe(q);
    }
    return q.emit("pipe", Z), B.flowing || (c("pipe resume"), Z.resume()), q;
  };
  function Q(q) {
    return function() {
      var Z = q._readableState;
      c("pipeOnDrain", Z.awaitDrain), Z.awaitDrain && Z.awaitDrain--, Z.awaitDrain === 0 && e(q, "data") && (Z.flowing = !0, J(q));
    };
  }
  C.prototype.unpipe = function(q) {
    var M = this._readableState, Z = {
      hasUnpiped: !1
    };
    if (M.pipesCount === 0)
      return this;
    if (M.pipesCount === 1)
      return q && q !== M.pipes ? this : (q || (q = M.pipes), M.pipes = null, M.pipesCount = 0, M.flowing = !1, q && q.emit("unpipe", this, Z), this);
    if (!q) {
      var B = M.pipes, re = M.pipesCount;
      M.pipes = null, M.pipesCount = 0, M.flowing = !1;
      for (var j = 0; j < re; j++)
        B[j].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    var k = G(M.pipes, q);
    return k === -1 ? this : (M.pipes.splice(k, 1), M.pipesCount -= 1, M.pipesCount === 1 && (M.pipes = M.pipes[0]), q.emit("unpipe", this, Z), this);
  }, C.prototype.on = function(q, M) {
    var Z = r.prototype.on.call(this, q, M), B = this._readableState;
    return q === "data" ? (B.readableListening = this.listenerCount("readable") > 0, B.flowing !== !1 && this.resume()) : q === "readable" && !B.endEmitted && !B.readableListening && (B.readableListening = B.needReadable = !0, B.flowing = !1, B.emittedReadable = !1, c("on readable", B.length, B.reading), B.length ? $(this) : B.reading || process.nextTick(ce, this)), Z;
  }, C.prototype.addListener = C.prototype.on, C.prototype.removeListener = function(q, M) {
    var Z = r.prototype.removeListener.call(this, q, M);
    return q === "readable" && process.nextTick(Y, this), Z;
  }, C.prototype.removeAllListeners = function(q) {
    var M = r.prototype.removeAllListeners.apply(this, arguments);
    return (q === "readable" || q === void 0) && process.nextTick(Y, this), M;
  };
  function Y(q) {
    var M = q._readableState;
    M.readableListening = q.listenerCount("readable") > 0, M.resumeScheduled && !M.paused ? M.flowing = !0 : q.listenerCount("data") > 0 && q.resume();
  }
  function ce(q) {
    c("readable nexttick read 0"), q.read(0);
  }
  C.prototype.resume = function() {
    var q = this._readableState;
    return q.flowing || (c("resume"), q.flowing = !q.readableListening, ue(this, q)), q.paused = !1, this;
  };
  function ue(q, M) {
    M.resumeScheduled || (M.resumeScheduled = !0, process.nextTick(me, q, M));
  }
  function me(q, M) {
    c("resume", M.reading), M.reading || q.read(0), M.resumeScheduled = !1, q.emit("resume"), J(q), M.flowing && !M.reading && q.read(0);
  }
  C.prototype.pause = function() {
    return c("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (c("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function J(q) {
    var M = q._readableState;
    for (c("flow", M.flowing); M.flowing && q.read() !== null; )
      ;
  }
  C.prototype.wrap = function(q) {
    var M = this, Z = this._readableState, B = !1;
    q.on("end", function() {
      if (c("wrapped end"), Z.decoder && !Z.ended) {
        var k = Z.decoder.end();
        k && k.length && M.push(k);
      }
      M.push(null);
    }), q.on("data", function(k) {
      if (c("wrapped data"), Z.decoder && (k = Z.decoder.write(k)), !(Z.objectMode && k == null) && !(!Z.objectMode && (!k || !k.length))) {
        var N = M.push(k);
        N || (B = !0, q.pause());
      }
    });
    for (var re in q)
      this[re] === void 0 && typeof q[re] == "function" && (this[re] = function(N) {
        return function() {
          return q[N].apply(q, arguments);
        };
      }(re));
    for (var j = 0; j < S.length; j++)
      q.on(S[j], this.emit.bind(this, S[j]));
    return this._read = function(k) {
      c("wrapped _read", k), B && (B = !1, q.resume());
    }, this;
  }, typeof Symbol == "function" && (C.prototype[Symbol.asyncIterator] = function() {
    return x === void 0 && (x = Cfe()), x(this);
  }), Object.defineProperty(C.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(C.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(C.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(M) {
      this._readableState && (this._readableState.flowing = M);
    }
  }), C._fromList = O, Object.defineProperty(C.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function O(q, M) {
    if (M.length === 0)
      return null;
    var Z;
    return M.objectMode ? Z = M.buffer.shift() : !q || q >= M.length ? (M.decoder ? Z = M.buffer.join("") : M.buffer.length === 1 ? Z = M.buffer.first() : Z = M.buffer.concat(M.length), M.buffer.clear()) : Z = M.buffer.consume(q, M.decoder), Z;
  }
  function I(q) {
    var M = q._readableState;
    c("endReadable", M.endEmitted), M.endEmitted || (M.ended = !0, process.nextTick(z, M, q));
  }
  function z(q, M) {
    if (c("endReadableNT", q.endEmitted, q.length), !q.endEmitted && q.length === 0 && (q.endEmitted = !0, M.readable = !1, M.emit("end"), q.autoDestroy)) {
      var Z = M._writableState;
      (!Z || Z.autoDestroy && Z.finished) && M.destroy();
    }
  }
  typeof Symbol == "function" && (C.from = function(q, M) {
    return b === void 0 && (b = Tfe()), b(C, q, M);
  });
  function G(q, M) {
    for (var Z = 0, B = q.length; Z < B; Z++)
      if (q[Z] === M)
        return Z;
    return -1;
  }
  return Nd;
}
var Ld, OS;
function d8() {
  if (OS)
    return Ld;
  OS = 1, Ld = o;
  var t = Ji().codes, e = t.ERR_METHOD_NOT_IMPLEMENTED, r = t.ERR_MULTIPLE_CALLBACK, n = t.ERR_TRANSFORM_ALREADY_TRANSFORMING, i = t.ERR_TRANSFORM_WITH_LENGTH_0, a = Ti();
  ct()(o, a);
  function s(u, l) {
    var p = this._transformState;
    p.transforming = !1;
    var m = p.writecb;
    if (m === null)
      return this.emit("error", new r());
    p.writechunk = null, p.writecb = null, l != null && this.push(l), m(u);
    var h = this._readableState;
    h.reading = !1, (h.needReadable || h.length < h.highWaterMark) && this._read(h.highWaterMark);
  }
  function o(u) {
    if (!(this instanceof o))
      return new o(u);
    a.call(this, u), this._transformState = {
      afterTransform: s.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, u && (typeof u.transform == "function" && (this._transform = u.transform), typeof u.flush == "function" && (this._flush = u.flush)), this.on("prefinish", c);
  }
  function c() {
    var u = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(l, p) {
      f(u, l, p);
    }) : f(this, null, null);
  }
  o.prototype.push = function(u, l) {
    return this._transformState.needTransform = !1, a.prototype.push.call(this, u, l);
  }, o.prototype._transform = function(u, l, p) {
    p(new e("_transform()"));
  }, o.prototype._write = function(u, l, p) {
    var m = this._transformState;
    if (m.writecb = p, m.writechunk = u, m.writeencoding = l, !m.transforming) {
      var h = this._readableState;
      (m.needTransform || h.needReadable || h.length < h.highWaterMark) && this._read(h.highWaterMark);
    }
  }, o.prototype._read = function(u) {
    var l = this._transformState;
    l.writechunk !== null && !l.transforming ? (l.transforming = !0, this._transform(l.writechunk, l.writeencoding, l.afterTransform)) : l.needTransform = !0;
  }, o.prototype._destroy = function(u, l) {
    a.prototype._destroy.call(this, u, function(p) {
      l(p);
    });
  };
  function f(u, l, p) {
    if (l)
      return u.emit("error", l);
    if (p != null && u.push(p), u._writableState.length)
      throw new i();
    if (u._transformState.transforming)
      throw new n();
    return u.push(null);
  }
  return Ld;
}
var Pd, AS;
function Ofe() {
  if (AS)
    return Pd;
  AS = 1, Pd = e;
  var t = d8();
  ct()(e, t);
  function e(r) {
    if (!(this instanceof e))
      return new e(r);
    t.call(this, r);
  }
  return e.prototype._transform = function(r, n, i) {
    i(null, r);
  }, Pd;
}
var Dd, $S;
function Afe() {
  if ($S)
    return Dd;
  $S = 1;
  var t;
  function e(p) {
    var m = !1;
    return function() {
      m || (m = !0, p.apply(void 0, arguments));
    };
  }
  var r = Ji().codes, n = r.ERR_MISSING_ARGS, i = r.ERR_STREAM_DESTROYED;
  function a(p) {
    if (p)
      throw p;
  }
  function s(p) {
    return p.setHeader && typeof p.abort == "function";
  }
  function o(p, m, h, g) {
    g = e(g);
    var v = !1;
    p.on("close", function() {
      v = !0;
    }), t === void 0 && (t = Ty()), t(p, {
      readable: m,
      writable: h
    }, function(y) {
      if (y)
        return g(y);
      v = !0, g();
    });
    var d = !1;
    return function(y) {
      if (!v && !d) {
        if (d = !0, s(p))
          return p.abort();
        if (typeof p.destroy == "function")
          return p.destroy();
        g(y || new i("pipe"));
      }
    };
  }
  function c(p) {
    p();
  }
  function f(p, m) {
    return p.pipe(m);
  }
  function u(p) {
    return !p.length || typeof p[p.length - 1] != "function" ? a : p.pop();
  }
  function l() {
    for (var p = arguments.length, m = new Array(p), h = 0; h < p; h++)
      m[h] = arguments[h];
    var g = u(m);
    if (Array.isArray(m[0]) && (m = m[0]), m.length < 2)
      throw new n("streams");
    var v, d = m.map(function(y, x) {
      var b = x < m.length - 1, w = x > 0;
      return o(y, b, w, function(S) {
        v || (v = S), S && d.forEach(c), !b && (d.forEach(c), g(v));
      });
    });
    return m.reduce(f);
  }
  return Dd = l, Dd;
}
var IS;
function gr() {
  return IS || (IS = 1, function(t, e) {
    e = t.exports = h8(), e.Stream = e, e.Readable = e, e.Writable = f8(), e.Duplex = Ti(), e.Transform = d8(), e.PassThrough = Ofe(), e.finished = Ty(), e.pipeline = Afe();
  }(ho, ho.exports)), ho.exports;
}
/**
 * Archiver Core
 *
 * @ignore
 * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
 * @copyright (c) 2012-2014 Chris Talkington, contributors.
 */
var Md, kS;
function $fe() {
  if (kS)
    return Md;
  kS = 1;
  var t = se, e = tfe(), r = N$, n = se, i = Ts(), a = nt.inherits, s = Efe(), o = gr().Transform, c = process.platform === "win32", f = function(u, l) {
    if (!(this instanceof f))
      return new f(u, l);
    typeof u != "string" && (l = u, u = "zip"), l = this.options = i.defaults(l, {
      highWaterMark: 1024 * 1024,
      statConcurrency: 4
    }), o.call(this, l), this._format = !1, this._module = !1, this._pending = 0, this._pointer = 0, this._entriesCount = 0, this._entriesProcessedCount = 0, this._fsEntriesTotalBytes = 0, this._fsEntriesProcessedBytes = 0, this._queue = r.queue(this._onQueueTask.bind(this), 1), this._queue.drain(this._onQueueDrain.bind(this)), this._statQueue = r.queue(this._onStatQueueTask.bind(this), l.statConcurrency), this._statQueue.drain(this._onQueueDrain.bind(this)), this._state = {
      aborted: !1,
      finalize: !1,
      finalizing: !1,
      finalized: !1,
      modulePiped: !1
    }, this._streams = [];
  };
  return a(f, o), f.prototype._abort = function() {
    this._state.aborted = !0, this._queue.kill(), this._statQueue.kill(), this._queue.idle() && this._shutdown();
  }, f.prototype._append = function(u, l) {
    l = l || {};
    var p = {
      source: null,
      filepath: u
    };
    l.name || (l.name = u), l.sourcePath = u, p.data = l, this._entriesCount++, l.stats && l.stats instanceof t.Stats ? (p = this._updateQueueTaskWithStats(p, l.stats), p && (l.stats.size && (this._fsEntriesTotalBytes += l.stats.size), this._queue.push(p))) : this._statQueue.push(p);
  }, f.prototype._finalize = function() {
    this._state.finalizing || this._state.finalized || this._state.aborted || (this._state.finalizing = !0, this._moduleFinalize(), this._state.finalizing = !1, this._state.finalized = !0);
  }, f.prototype._maybeFinalize = function() {
    return this._state.finalizing || this._state.finalized || this._state.aborted ? !1 : this._state.finalize && this._pending === 0 && this._queue.idle() && this._statQueue.idle() ? (this._finalize(), !0) : !1;
  }, f.prototype._moduleAppend = function(u, l, p) {
    if (this._state.aborted) {
      p();
      return;
    }
    this._module.append(u, l, function(m) {
      if (this._task = null, this._state.aborted) {
        this._shutdown();
        return;
      }
      if (m) {
        this.emit("error", m), setImmediate(p);
        return;
      }
      this.emit("entry", l), this._entriesProcessedCount++, l.stats && l.stats.size && (this._fsEntriesProcessedBytes += l.stats.size), this.emit("progress", {
        entries: {
          total: this._entriesCount,
          processed: this._entriesProcessedCount
        },
        fs: {
          totalBytes: this._fsEntriesTotalBytes,
          processedBytes: this._fsEntriesProcessedBytes
        }
      }), setImmediate(p);
    }.bind(this));
  }, f.prototype._moduleFinalize = function() {
    typeof this._module.finalize == "function" ? this._module.finalize() : typeof this._module.end == "function" ? this._module.end() : this.emit("error", new s("NOENDMETHOD"));
  }, f.prototype._modulePipe = function() {
    this._module.on("error", this._onModuleError.bind(this)), this._module.pipe(this), this._state.modulePiped = !0;
  }, f.prototype._moduleSupports = function(u) {
    return !this._module.supports || !this._module.supports[u] ? !1 : this._module.supports[u];
  }, f.prototype._moduleUnpipe = function() {
    this._module.unpipe(this), this._state.modulePiped = !1;
  }, f.prototype._normalizeEntryData = function(u, l) {
    u = i.defaults(u, {
      type: "file",
      name: null,
      date: null,
      mode: null,
      prefix: null,
      sourcePath: null,
      stats: !1
    }), l && u.stats === !1 && (u.stats = l);
    var p = u.type === "directory";
    return u.name && (typeof u.prefix == "string" && u.prefix !== "" && (u.name = u.prefix + "/" + u.name, u.prefix = null), u.name = i.sanitizePath(u.name), u.type !== "symlink" && u.name.slice(-1) === "/" ? (p = !0, u.type = "directory") : p && (u.name += "/")), typeof u.mode == "number" ? c ? u.mode &= 511 : u.mode &= 4095 : u.stats && u.mode === null ? (c ? u.mode = u.stats.mode & 511 : u.mode = u.stats.mode & 4095, c && p && (u.mode = 493)) : u.mode === null && (u.mode = p ? 493 : 420), u.stats && u.date === null ? u.date = u.stats.mtime : u.date = i.dateify(u.date), u;
  }, f.prototype._onModuleError = function(u) {
    this.emit("error", u);
  }, f.prototype._onQueueDrain = function() {
    this._state.finalizing || this._state.finalized || this._state.aborted || this._state.finalize && this._pending === 0 && this._queue.idle() && this._statQueue.idle() && this._finalize();
  }, f.prototype._onQueueTask = function(u, l) {
    var p = () => {
      u.data.callback && u.data.callback(), l();
    };
    if (this._state.finalizing || this._state.finalized || this._state.aborted) {
      p();
      return;
    }
    this._task = u, this._moduleAppend(u.source, u.data, p);
  }, f.prototype._onStatQueueTask = function(u, l) {
    if (this._state.finalizing || this._state.finalized || this._state.aborted) {
      l();
      return;
    }
    t.lstat(u.filepath, function(p, m) {
      if (this._state.aborted) {
        setImmediate(l);
        return;
      }
      if (p) {
        this._entriesCount--, this.emit("warning", p), setImmediate(l);
        return;
      }
      u = this._updateQueueTaskWithStats(u, m), u && (m.size && (this._fsEntriesTotalBytes += m.size), this._queue.push(u)), setImmediate(l);
    }.bind(this));
  }, f.prototype._shutdown = function() {
    this._moduleUnpipe(), this.end();
  }, f.prototype._transform = function(u, l, p) {
    u && (this._pointer += u.length), p(null, u);
  }, f.prototype._updateQueueTaskWithStats = function(u, l) {
    if (l.isFile())
      u.data.type = "file", u.data.sourceType = "stream", u.source = i.lazyReadStream(u.filepath);
    else if (l.isDirectory() && this._moduleSupports("directory"))
      u.data.name = i.trailingSlashIt(u.data.name), u.data.type = "directory", u.data.sourcePath = i.trailingSlashIt(u.filepath), u.data.sourceType = "buffer", u.source = Buffer.concat([]);
    else if (l.isSymbolicLink() && this._moduleSupports("symlink")) {
      var p = t.readlinkSync(u.filepath), m = n.dirname(u.filepath);
      u.data.type = "symlink", u.data.linkname = n.relative(m, n.resolve(m, p)), u.data.sourceType = "buffer", u.source = Buffer.concat([]);
    } else
      return l.isDirectory() ? this.emit("warning", new s("DIRECTORYNOTSUPPORTED", u.data)) : l.isSymbolicLink() ? this.emit("warning", new s("SYMLINKNOTSUPPORTED", u.data)) : this.emit("warning", new s("ENTRYNOTSUPPORTED", u.data)), null;
    return u.data = this._normalizeEntryData(u.data, l), u;
  }, f.prototype.abort = function() {
    return this._state.aborted || this._state.finalized ? this : (this._abort(), this);
  }, f.prototype.append = function(u, l) {
    if (this._state.finalize || this._state.aborted)
      return this.emit("error", new s("QUEUECLOSED")), this;
    if (l = this._normalizeEntryData(l), typeof l.name != "string" || l.name.length === 0)
      return this.emit("error", new s("ENTRYNAMEREQUIRED")), this;
    if (l.type === "directory" && !this._moduleSupports("directory"))
      return this.emit("error", new s("DIRECTORYNOTSUPPORTED", { name: l.name })), this;
    if (u = i.normalizeInputSource(u), Buffer.isBuffer(u))
      l.sourceType = "buffer";
    else if (i.isStream(u))
      l.sourceType = "stream";
    else
      return this.emit("error", new s("INPUTSTEAMBUFFERREQUIRED", { name: l.name })), this;
    return this._entriesCount++, this._queue.push({
      data: l,
      source: u
    }), this;
  }, f.prototype.directory = function(u, l, p) {
    if (this._state.finalize || this._state.aborted)
      return this.emit("error", new s("QUEUECLOSED")), this;
    if (typeof u != "string" || u.length === 0)
      return this.emit("error", new s("DIRECTORYDIRPATHREQUIRED")), this;
    this._pending++, l === !1 ? l = "" : typeof l != "string" && (l = u);
    var m = !1;
    typeof p == "function" ? (m = p, p = {}) : typeof p != "object" && (p = {});
    var h = {
      stat: !0,
      dot: !0
    };
    function g() {
      this._pending--, this._maybeFinalize();
    }
    function v(x) {
      this.emit("error", x);
    }
    function d(x) {
      y.pause();
      var b = !1, w = Object.assign({}, p);
      w.name = x.relative, w.prefix = l, w.stats = x.stat, w.callback = y.resume.bind(y);
      try {
        if (m) {
          if (w = m(w), w === !1)
            b = !0;
          else if (typeof w != "object")
            throw new s("DIRECTORYFUNCTIONINVALIDDATA", { dirpath: u });
        }
      } catch (S) {
        this.emit("error", S);
        return;
      }
      if (b) {
        y.resume();
        return;
      }
      this._append(x.absolute, w);
    }
    var y = e(u, h);
    return y.on("error", v.bind(this)), y.on("match", d.bind(this)), y.on("end", g.bind(this)), this;
  }, f.prototype.file = function(u, l) {
    return this._state.finalize || this._state.aborted ? (this.emit("error", new s("QUEUECLOSED")), this) : typeof u != "string" || u.length === 0 ? (this.emit("error", new s("FILEFILEPATHREQUIRED")), this) : (this._append(u, l), this);
  }, f.prototype.glob = function(u, l, p) {
    this._pending++, l = i.defaults(l, {
      stat: !0,
      pattern: u
    });
    function m() {
      this._pending--, this._maybeFinalize();
    }
    function h(d) {
      this.emit("error", d);
    }
    function g(d) {
      v.pause();
      var y = Object.assign({}, p);
      y.callback = v.resume.bind(v), y.stats = d.stat, y.name = d.relative, this._append(d.absolute, y);
    }
    var v = e(l.cwd || ".", l);
    return v.on("error", h.bind(this)), v.on("match", g.bind(this)), v.on("end", m.bind(this)), this;
  }, f.prototype.finalize = function() {
    if (this._state.aborted) {
      var u = new s("ABORTED");
      return this.emit("error", u), Promise.reject(u);
    }
    if (this._state.finalize) {
      var l = new s("FINALIZING");
      return this.emit("error", l), Promise.reject(l);
    }
    this._state.finalize = !0, this._pending === 0 && this._queue.idle() && this._statQueue.idle() && this._finalize();
    var p = this;
    return new Promise(function(m, h) {
      var g;
      p._module.on("end", function() {
        g || m();
      }), p._module.on("error", function(v) {
        g = !0, h(v);
      });
    });
  }, f.prototype.setFormat = function(u) {
    return this._format ? (this.emit("error", new s("FORMATSET")), this) : (this._format = u, this);
  }, f.prototype.setModule = function(u) {
    return this._state.aborted ? (this.emit("error", new s("ABORTED")), this) : this._state.module ? (this.emit("error", new s("MODULESET")), this) : (this._module = u, this._modulePipe(), this);
  }, f.prototype.symlink = function(u, l, p) {
    if (this._state.finalize || this._state.aborted)
      return this.emit("error", new s("QUEUECLOSED")), this;
    if (typeof u != "string" || u.length === 0)
      return this.emit("error", new s("SYMLINKFILEPATHREQUIRED")), this;
    if (typeof l != "string" || l.length === 0)
      return this.emit("error", new s("SYMLINKTARGETREQUIRED", { filepath: u })), this;
    if (!this._moduleSupports("symlink"))
      return this.emit("error", new s("SYMLINKNOTSUPPORTED", { filepath: u })), this;
    var m = {};
    return m.type = "symlink", m.name = u.replace(/\\/g, "/"), m.linkname = l.replace(/\\/g, "/"), m.sourceType = "buffer", typeof p == "number" && (m.mode = p), this._entriesCount++, this._queue.push({
      data: m,
      source: Buffer.concat([])
    }), this;
  }, f.prototype.pointer = function() {
    return this._pointer;
  }, f.prototype.use = function(u) {
    return this._streams.push(u), this;
  }, Md = f, Md;
}
var qd = { exports: {} }, jd = { exports: {} }, RS;
function Oy() {
  if (RS)
    return jd.exports;
  RS = 1;
  var t = jd.exports = function() {
  };
  return t.prototype.getName = function() {
  }, t.prototype.getSize = function() {
  }, t.prototype.getLastModifiedDate = function() {
  }, t.prototype.isDirectory = function() {
  }, jd.exports;
}
var Fd = { exports: {} }, Bd = { exports: {} }, Ud = { exports: {} }, NS;
function Ay() {
  if (NS)
    return Ud.exports;
  NS = 1;
  var t = Ud.exports = {};
  return t.dateToDos = function(e, r) {
    r = r || !1;
    var n = r ? e.getFullYear() : e.getUTCFullYear();
    if (n < 1980)
      return 2162688;
    if (n >= 2044)
      return 2141175677;
    var i = {
      year: n,
      month: r ? e.getMonth() : e.getUTCMonth(),
      date: r ? e.getDate() : e.getUTCDate(),
      hours: r ? e.getHours() : e.getUTCHours(),
      minutes: r ? e.getMinutes() : e.getUTCMinutes(),
      seconds: r ? e.getSeconds() : e.getUTCSeconds()
    };
    return i.year - 1980 << 25 | i.month + 1 << 21 | i.date << 16 | i.hours << 11 | i.minutes << 5 | i.seconds / 2;
  }, t.dosToDate = function(e) {
    return new Date((e >> 25 & 127) + 1980, (e >> 21 & 15) - 1, e >> 16 & 31, e >> 11 & 31, e >> 5 & 63, (e & 31) << 1);
  }, t.fromDosTime = function(e) {
    return t.dosToDate(e.readUInt32LE(0));
  }, t.getEightBytes = function(e) {
    var r = Buffer.alloc(8);
    return r.writeUInt32LE(e % 4294967296, 0), r.writeUInt32LE(e / 4294967296 | 0, 4), r;
  }, t.getShortBytes = function(e) {
    var r = Buffer.alloc(2);
    return r.writeUInt16LE((e & 65535) >>> 0, 0), r;
  }, t.getShortBytesValue = function(e, r) {
    return e.readUInt16LE(r);
  }, t.getLongBytes = function(e) {
    var r = Buffer.alloc(4);
    return r.writeUInt32LE((e & 4294967295) >>> 0, 0), r;
  }, t.getLongBytesValue = function(e, r) {
    return e.readUInt32LE(r);
  }, t.toDosTime = function(e) {
    return t.getLongBytes(t.dateToDos(e));
  }, Ud.exports;
}
var LS;
function m8() {
  if (LS)
    return Bd.exports;
  LS = 1;
  var t = Ay(), e = 8, r = 1, n = 4, i = 2, a = 64, s = 2048, o = Bd.exports = function() {
    return this instanceof o ? (this.descriptor = !1, this.encryption = !1, this.utf8 = !1, this.numberOfShannonFanoTrees = 0, this.strongEncryption = !1, this.slidingDictionarySize = 0, this) : new o();
  };
  return o.prototype.encode = function() {
    return t.getShortBytes(
      (this.descriptor ? e : 0) | (this.utf8 ? s : 0) | (this.encryption ? r : 0) | (this.strongEncryption ? a : 0)
    );
  }, o.prototype.parse = function(c, f) {
    var u = t.getShortBytesValue(c, f), l = new o();
    return l.useDataDescriptor((u & e) !== 0), l.useUTF8ForNames((u & s) !== 0), l.useStrongEncryption((u & a) !== 0), l.useEncryption((u & r) !== 0), l.setSlidingDictionarySize(u & i ? 8192 : 4096), l.setNumberOfShannonFanoTrees(u & n ? 3 : 2), l;
  }, o.prototype.setNumberOfShannonFanoTrees = function(c) {
    this.numberOfShannonFanoTrees = c;
  }, o.prototype.getNumberOfShannonFanoTrees = function() {
    return this.numberOfShannonFanoTrees;
  }, o.prototype.setSlidingDictionarySize = function(c) {
    this.slidingDictionarySize = c;
  }, o.prototype.getSlidingDictionarySize = function() {
    return this.slidingDictionarySize;
  }, o.prototype.useDataDescriptor = function(c) {
    this.descriptor = c;
  }, o.prototype.usesDataDescriptor = function() {
    return this.descriptor;
  }, o.prototype.useEncryption = function(c) {
    this.encryption = c;
  }, o.prototype.usesEncryption = function() {
    return this.encryption;
  }, o.prototype.useStrongEncryption = function(c) {
    this.strongEncryption = c;
  }, o.prototype.usesStrongEncryption = function() {
    return this.strongEncryption;
  }, o.prototype.useUTF8ForNames = function(c) {
    this.utf8 = c;
  }, o.prototype.usesUTF8ForNames = function() {
    return this.utf8;
  }, Bd.exports;
}
var zd, PS;
function Ife() {
  return PS || (PS = 1, zd = {
    /**
     * Bits used for permissions (and sticky bit)
     */
    PERM_MASK: 4095,
    // 07777
    /**
     * Bits used to indicate the filesystem object type.
     */
    FILE_TYPE_FLAG: 61440,
    // 0170000
    /**
     * Indicates symbolic links.
     */
    LINK_FLAG: 40960,
    // 0120000
    /**
     * Indicates plain files.
     */
    FILE_FLAG: 32768,
    // 0100000
    /**
     * Indicates directories.
     */
    DIR_FLAG: 16384,
    // 040000
    // ----------------------------------------------------------
    // somewhat arbitrary choices that are quite common for shared
    // installations
    // -----------------------------------------------------------
    /**
     * Default permissions for symbolic links.
     */
    DEFAULT_LINK_PERM: 511,
    // 0777
    /**
     * Default permissions for directories.
     */
    DEFAULT_DIR_PERM: 493,
    // 0755
    /**
     * Default permissions for plain files.
     */
    DEFAULT_FILE_PERM: 420
    // 0644
  }), zd;
}
var Hd, DS;
function g8() {
  return DS || (DS = 1, Hd = {
    WORD: 4,
    DWORD: 8,
    EMPTY: Buffer.alloc(0),
    SHORT: 2,
    SHORT_MASK: 65535,
    SHORT_SHIFT: 16,
    SHORT_ZERO: Buffer.from(Array(2)),
    LONG: 4,
    LONG_ZERO: Buffer.from(Array(4)),
    MIN_VERSION_INITIAL: 10,
    MIN_VERSION_DATA_DESCRIPTOR: 20,
    MIN_VERSION_ZIP64: 45,
    VERSION_MADEBY: 45,
    METHOD_STORED: 0,
    METHOD_DEFLATED: 8,
    PLATFORM_UNIX: 3,
    PLATFORM_FAT: 0,
    SIG_LFH: 67324752,
    SIG_DD: 134695760,
    SIG_CFH: 33639248,
    SIG_EOCD: 101010256,
    SIG_ZIP64_EOCD: 101075792,
    SIG_ZIP64_EOCD_LOC: 117853008,
    ZIP64_MAGIC_SHORT: 65535,
    ZIP64_MAGIC: 4294967295,
    ZIP64_EXTRA_ID: 1,
    ZLIB_NO_COMPRESSION: 0,
    ZLIB_BEST_SPEED: 1,
    ZLIB_BEST_COMPRESSION: 9,
    ZLIB_DEFAULT_COMPRESSION: -1,
    MODE_MASK: 4095,
    DEFAULT_FILE_MODE: 33188,
    // 010644 = -rw-r--r-- = S_IFREG | S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH
    DEFAULT_DIR_MODE: 16877,
    // 040755 = drwxr-xr-x = S_IFDIR | S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH
    EXT_FILE_ATTR_DIR: 1106051088,
    // 010173200020 = drwxr-xr-x = (((S_IFDIR | 0755) << 16) | S_DOS_D)
    EXT_FILE_ATTR_FILE: 2175008800,
    // 020151000040 = -rw-r--r-- = (((S_IFREG | 0644) << 16) | S_DOS_A) >>> 0
    // Unix file types
    S_IFMT: 61440,
    // 0170000 type of file mask
    S_IFIFO: 4096,
    // 010000 named pipe (fifo)
    S_IFCHR: 8192,
    // 020000 character special
    S_IFDIR: 16384,
    // 040000 directory
    S_IFBLK: 24576,
    // 060000 block special
    S_IFREG: 32768,
    // 0100000 regular
    S_IFLNK: 40960,
    // 0120000 symbolic link
    S_IFSOCK: 49152,
    // 0140000 socket
    // DOS file type flags
    S_DOS_A: 32,
    // 040 Archive
    S_DOS_D: 16,
    // 020 Directory
    S_DOS_V: 8,
    // 010 Volume
    S_DOS_S: 4,
    // 04 System
    S_DOS_H: 2,
    // 02 Hidden
    S_DOS_R: 1
    // 01 Read Only
  }), Hd;
}
var MS;
function v8() {
  if (MS)
    return Fd.exports;
  MS = 1;
  var t = nt.inherits, e = Y$(), r = Oy(), n = m8(), i = Ife(), a = g8(), s = Ay(), o = Fd.exports = function(c) {
    if (!(this instanceof o))
      return new o(c);
    r.call(this), this.platform = a.PLATFORM_FAT, this.method = -1, this.name = null, this.size = 0, this.csize = 0, this.gpb = new n(), this.crc = 0, this.time = -1, this.minver = a.MIN_VERSION_INITIAL, this.mode = -1, this.extra = null, this.exattr = 0, this.inattr = 0, this.comment = null, c && this.setName(c);
  };
  return t(o, r), o.prototype.getCentralDirectoryExtra = function() {
    return this.getExtra();
  }, o.prototype.getComment = function() {
    return this.comment !== null ? this.comment : "";
  }, o.prototype.getCompressedSize = function() {
    return this.csize;
  }, o.prototype.getCrc = function() {
    return this.crc;
  }, o.prototype.getExternalAttributes = function() {
    return this.exattr;
  }, o.prototype.getExtra = function() {
    return this.extra !== null ? this.extra : a.EMPTY;
  }, o.prototype.getGeneralPurposeBit = function() {
    return this.gpb;
  }, o.prototype.getInternalAttributes = function() {
    return this.inattr;
  }, o.prototype.getLastModifiedDate = function() {
    return this.getTime();
  }, o.prototype.getLocalFileDataExtra = function() {
    return this.getExtra();
  }, o.prototype.getMethod = function() {
    return this.method;
  }, o.prototype.getName = function() {
    return this.name;
  }, o.prototype.getPlatform = function() {
    return this.platform;
  }, o.prototype.getSize = function() {
    return this.size;
  }, o.prototype.getTime = function() {
    return this.time !== -1 ? s.dosToDate(this.time) : -1;
  }, o.prototype.getTimeDos = function() {
    return this.time !== -1 ? this.time : 0;
  }, o.prototype.getUnixMode = function() {
    return this.platform !== a.PLATFORM_UNIX ? 0 : this.getExternalAttributes() >> a.SHORT_SHIFT & a.SHORT_MASK;
  }, o.prototype.getVersionNeededToExtract = function() {
    return this.minver;
  }, o.prototype.setComment = function(c) {
    Buffer.byteLength(c) !== c.length && this.getGeneralPurposeBit().useUTF8ForNames(!0), this.comment = c;
  }, o.prototype.setCompressedSize = function(c) {
    if (c < 0)
      throw new Error("invalid entry compressed size");
    this.csize = c;
  }, o.prototype.setCrc = function(c) {
    if (c < 0)
      throw new Error("invalid entry crc32");
    this.crc = c;
  }, o.prototype.setExternalAttributes = function(c) {
    this.exattr = c >>> 0;
  }, o.prototype.setExtra = function(c) {
    this.extra = c;
  }, o.prototype.setGeneralPurposeBit = function(c) {
    if (!(c instanceof n))
      throw new Error("invalid entry GeneralPurposeBit");
    this.gpb = c;
  }, o.prototype.setInternalAttributes = function(c) {
    this.inattr = c;
  }, o.prototype.setMethod = function(c) {
    if (c < 0)
      throw new Error("invalid entry compression method");
    this.method = c;
  }, o.prototype.setName = function(c, f = !1) {
    c = e(c, !1).replace(/^\w+:/, "").replace(/^(\.\.\/|\/)+/, ""), f && (c = `/${c}`), Buffer.byteLength(c) !== c.length && this.getGeneralPurposeBit().useUTF8ForNames(!0), this.name = c;
  }, o.prototype.setPlatform = function(c) {
    this.platform = c;
  }, o.prototype.setSize = function(c) {
    if (c < 0)
      throw new Error("invalid entry size");
    this.size = c;
  }, o.prototype.setTime = function(c, f) {
    if (!(c instanceof Date))
      throw new Error("invalid entry time");
    this.time = s.dateToDos(c, f);
  }, o.prototype.setUnixMode = function(c) {
    c |= this.isDirectory() ? a.S_IFDIR : a.S_IFREG;
    var f = 0;
    f |= c << a.SHORT_SHIFT | (this.isDirectory() ? a.S_DOS_D : a.S_DOS_A), this.setExternalAttributes(f), this.mode = c & a.MODE_MASK, this.platform = a.PLATFORM_UNIX;
  }, o.prototype.setVersionNeededToExtract = function(c) {
    this.minver = c;
  }, o.prototype.isDirectory = function() {
    return this.getName().slice(-1) === "/";
  }, o.prototype.isUnixSymlink = function() {
    return (this.getUnixMode() & i.FILE_TYPE_FLAG) === i.LINK_FLAG;
  }, o.prototype.isZip64 = function() {
    return this.csize > a.ZIP64_MAGIC || this.size > a.ZIP64_MAGIC;
  }, Fd.exports;
}
var Wd = { exports: {} }, Gd = { exports: {} }, qS;
function y8() {
  if (qS)
    return Gd.exports;
  qS = 1;
  var t = se.Stream, e = gr().PassThrough, r = Gd.exports = {};
  return r.isStream = function(n) {
    return n instanceof t;
  }, r.normalizeInputSource = function(n) {
    if (n === null)
      return Buffer.alloc(0);
    if (typeof n == "string")
      return Buffer.from(n);
    if (r.isStream(n) && !n._readableState) {
      var i = new e();
      return n.pipe(i), i;
    }
    return n;
  }, Gd.exports;
}
var jS;
function b8() {
  if (jS)
    return Wd.exports;
  jS = 1;
  var t = nt.inherits, e = gr().Transform, r = Oy(), n = y8(), i = Wd.exports = function(a) {
    if (!(this instanceof i))
      return new i(a);
    e.call(this, a), this.offset = 0, this._archive = {
      finish: !1,
      finished: !1,
      processing: !1
    };
  };
  return t(i, e), i.prototype._appendBuffer = function(a, s, o) {
  }, i.prototype._appendStream = function(a, s, o) {
  }, i.prototype._emitErrorCallback = function(a) {
    a && this.emit("error", a);
  }, i.prototype._finish = function(a) {
  }, i.prototype._normalizeEntry = function(a) {
  }, i.prototype._transform = function(a, s, o) {
    o(null, a);
  }, i.prototype.entry = function(a, s, o) {
    if (s = s || null, typeof o != "function" && (o = this._emitErrorCallback.bind(this)), !(a instanceof r)) {
      o(new Error("not a valid instance of ArchiveEntry"));
      return;
    }
    if (this._archive.finish || this._archive.finished) {
      o(new Error("unacceptable entry after finish"));
      return;
    }
    if (this._archive.processing) {
      o(new Error("already processing an entry"));
      return;
    }
    if (this._archive.processing = !0, this._normalizeEntry(a), this._entry = a, s = n.normalizeInputSource(s), Buffer.isBuffer(s))
      this._appendBuffer(a, s, o);
    else if (n.isStream(s))
      this._appendStream(a, s, o);
    else {
      this._archive.processing = !1, o(new Error("input source must be valid Stream or Buffer instance"));
      return;
    }
    return this;
  }, i.prototype.finish = function() {
    if (this._archive.processing) {
      this._archive.finish = !0;
      return;
    }
    this._finish();
  }, i.prototype.getBytesWritten = function() {
    return this.offset;
  }, i.prototype.write = function(a, s) {
    return a && (this.offset += a.length), e.prototype.write.call(this, a, s);
  }, Wd.exports;
}
var Qd = { exports: {} }, Vd, FS;
function w8() {
  if (FS)
    return Vd;
  FS = 1;
  var t = rr.Buffer, e = [
    0,
    1996959894,
    3993919788,
    2567524794,
    124634137,
    1886057615,
    3915621685,
    2657392035,
    249268274,
    2044508324,
    3772115230,
    2547177864,
    162941995,
    2125561021,
    3887607047,
    2428444049,
    498536548,
    1789927666,
    4089016648,
    2227061214,
    450548861,
    1843258603,
    4107580753,
    2211677639,
    325883990,
    1684777152,
    4251122042,
    2321926636,
    335633487,
    1661365465,
    4195302755,
    2366115317,
    997073096,
    1281953886,
    3579855332,
    2724688242,
    1006888145,
    1258607687,
    3524101629,
    2768942443,
    901097722,
    1119000684,
    3686517206,
    2898065728,
    853044451,
    1172266101,
    3705015759,
    2882616665,
    651767980,
    1373503546,
    3369554304,
    3218104598,
    565507253,
    1454621731,
    3485111705,
    3099436303,
    671266974,
    1594198024,
    3322730930,
    2970347812,
    795835527,
    1483230225,
    3244367275,
    3060149565,
    1994146192,
    31158534,
    2563907772,
    4023717930,
    1907459465,
    112637215,
    2680153253,
    3904427059,
    2013776290,
    251722036,
    2517215374,
    3775830040,
    2137656763,
    141376813,
    2439277719,
    3865271297,
    1802195444,
    476864866,
    2238001368,
    4066508878,
    1812370925,
    453092731,
    2181625025,
    4111451223,
    1706088902,
    314042704,
    2344532202,
    4240017532,
    1658658271,
    366619977,
    2362670323,
    4224994405,
    1303535960,
    984961486,
    2747007092,
    3569037538,
    1256170817,
    1037604311,
    2765210733,
    3554079995,
    1131014506,
    879679996,
    2909243462,
    3663771856,
    1141124467,
    855842277,
    2852801631,
    3708648649,
    1342533948,
    654459306,
    3188396048,
    3373015174,
    1466479909,
    544179635,
    3110523913,
    3462522015,
    1591671054,
    702138776,
    2966460450,
    3352799412,
    1504918807,
    783551873,
    3082640443,
    3233442989,
    3988292384,
    2596254646,
    62317068,
    1957810842,
    3939845945,
    2647816111,
    81470997,
    1943803523,
    3814918930,
    2489596804,
    225274430,
    2053790376,
    3826175755,
    2466906013,
    167816743,
    2097651377,
    4027552580,
    2265490386,
    503444072,
    1762050814,
    4150417245,
    2154129355,
    426522225,
    1852507879,
    4275313526,
    2312317920,
    282753626,
    1742555852,
    4189708143,
    2394877945,
    397917763,
    1622183637,
    3604390888,
    2714866558,
    953729732,
    1340076626,
    3518719985,
    2797360999,
    1068828381,
    1219638859,
    3624741850,
    2936675148,
    906185462,
    1090812512,
    3747672003,
    2825379669,
    829329135,
    1181335161,
    3412177804,
    3160834842,
    628085408,
    1382605366,
    3423369109,
    3138078467,
    570562233,
    1426400815,
    3317316542,
    2998733608,
    733239954,
    1555261956,
    3268935591,
    3050360625,
    752459403,
    1541320221,
    2607071920,
    3965973030,
    1969922972,
    40735498,
    2617837225,
    3943577151,
    1913087877,
    83908371,
    2512341634,
    3803740692,
    2075208622,
    213261112,
    2463272603,
    3855990285,
    2094854071,
    198958881,
    2262029012,
    4057260610,
    1759359992,
    534414190,
    2176718541,
    4139329115,
    1873836001,
    414664567,
    2282248934,
    4279200368,
    1711684554,
    285281116,
    2405801727,
    4167216745,
    1634467795,
    376229701,
    2685067896,
    3608007406,
    1308918612,
    956543938,
    2808555105,
    3495958263,
    1231636301,
    1047427035,
    2932959818,
    3654703836,
    1088359270,
    936918e3,
    2847714899,
    3736837829,
    1202900863,
    817233897,
    3183342108,
    3401237130,
    1404277552,
    615818150,
    3134207493,
    3453421203,
    1423857449,
    601450431,
    3009837614,
    3294710456,
    1567103746,
    711928724,
    3020668471,
    3272380065,
    1510334235,
    755167117
  ];
  typeof Int32Array < "u" && (e = new Int32Array(e));
  function r(s) {
    if (t.isBuffer(s))
      return s;
    var o = typeof t.alloc == "function" && typeof t.from == "function";
    if (typeof s == "number")
      return o ? t.alloc(s) : new t(s);
    if (typeof s == "string")
      return o ? t.from(s) : new t(s);
    throw new Error("input must be buffer, number, or string, received " + typeof s);
  }
  function n(s) {
    var o = r(4);
    return o.writeInt32BE(s, 0), o;
  }
  function i(s, o) {
    s = r(s), t.isBuffer(o) && (o = o.readUInt32BE(0));
    for (var c = ~~o ^ -1, f = 0; f < s.length; f++)
      c = e[(c ^ s[f]) & 255] ^ c >>> 8;
    return c ^ -1;
  }
  function a() {
    return n(i.apply(null, arguments));
  }
  return a.signed = function() {
    return i.apply(null, arguments);
  }, a.unsigned = function() {
    return i.apply(null, arguments) >>> 0;
  }, Vd = a, Vd;
}
var Kd = {};
/*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */
var BS;
function x8() {
  return BS || (BS = 1, function(t) {
    (function(e) {
      e(typeof DO_NOT_EXPORT_CRC > "u" ? t : {});
    })(function(e) {
      e.version = "1.2.2";
      function r() {
        for (var E = 0, C = new Array(256), A = 0; A != 256; ++A)
          E = A, E = E & 1 ? -306674912 ^ E >>> 1 : E >>> 1, E = E & 1 ? -306674912 ^ E >>> 1 : E >>> 1, E = E & 1 ? -306674912 ^ E >>> 1 : E >>> 1, E = E & 1 ? -306674912 ^ E >>> 1 : E >>> 1, E = E & 1 ? -306674912 ^ E >>> 1 : E >>> 1, E = E & 1 ? -306674912 ^ E >>> 1 : E >>> 1, E = E & 1 ? -306674912 ^ E >>> 1 : E >>> 1, E = E & 1 ? -306674912 ^ E >>> 1 : E >>> 1, C[A] = E;
        return typeof Int32Array < "u" ? new Int32Array(C) : C;
      }
      var n = r();
      function i(E) {
        var C = 0, A = 0, R = 0, D = typeof Int32Array < "u" ? new Int32Array(4096) : new Array(4096);
        for (R = 0; R != 256; ++R)
          D[R] = E[R];
        for (R = 0; R != 256; ++R)
          for (A = E[R], C = 256 + R; C < 4096; C += 256)
            A = D[C] = A >>> 8 ^ E[A & 255];
        var F = [];
        for (R = 1; R != 16; ++R)
          F[R - 1] = typeof Int32Array < "u" ? D.subarray(R * 256, R * 256 + 256) : D.slice(R * 256, R * 256 + 256);
        return F;
      }
      var a = i(n), s = a[0], o = a[1], c = a[2], f = a[3], u = a[4], l = a[5], p = a[6], m = a[7], h = a[8], g = a[9], v = a[10], d = a[11], y = a[12], x = a[13], b = a[14];
      function w(E, C) {
        for (var A = C ^ -1, R = 0, D = E.length; R < D; )
          A = A >>> 8 ^ n[(A ^ E.charCodeAt(R++)) & 255];
        return ~A;
      }
      function S(E, C) {
        for (var A = C ^ -1, R = E.length - 15, D = 0; D < R; )
          A = b[E[D++] ^ A & 255] ^ x[E[D++] ^ A >> 8 & 255] ^ y[E[D++] ^ A >> 16 & 255] ^ d[E[D++] ^ A >>> 24] ^ v[E[D++]] ^ g[E[D++]] ^ h[E[D++]] ^ m[E[D++]] ^ p[E[D++]] ^ l[E[D++]] ^ u[E[D++]] ^ f[E[D++]] ^ c[E[D++]] ^ o[E[D++]] ^ s[E[D++]] ^ n[E[D++]];
        for (R += 15; D < R; )
          A = A >>> 8 ^ n[(A ^ E[D++]) & 255];
        return ~A;
      }
      function T(E, C) {
        for (var A = C ^ -1, R = 0, D = E.length, F = 0, K = 0; R < D; )
          F = E.charCodeAt(R++), F < 128 ? A = A >>> 8 ^ n[(A ^ F) & 255] : F < 2048 ? (A = A >>> 8 ^ n[(A ^ (192 | F >> 6 & 31)) & 255], A = A >>> 8 ^ n[(A ^ (128 | F & 63)) & 255]) : F >= 55296 && F < 57344 ? (F = (F & 1023) + 64, K = E.charCodeAt(R++) & 1023, A = A >>> 8 ^ n[(A ^ (240 | F >> 8 & 7)) & 255], A = A >>> 8 ^ n[(A ^ (128 | F >> 2 & 63)) & 255], A = A >>> 8 ^ n[(A ^ (128 | K >> 6 & 15 | (F & 3) << 4)) & 255], A = A >>> 8 ^ n[(A ^ (128 | K & 63)) & 255]) : (A = A >>> 8 ^ n[(A ^ (224 | F >> 12 & 15)) & 255], A = A >>> 8 ^ n[(A ^ (128 | F >> 6 & 63)) & 255], A = A >>> 8 ^ n[(A ^ (128 | F & 63)) & 255]);
        return ~A;
      }
      e.table = n, e.bstr = w, e.buf = S, e.str = T;
    });
  }(Kd)), Kd;
}
var Jd, US;
function kfe() {
  if (US)
    return Jd;
  US = 1;
  const { Transform: t } = gr(), e = x8();
  class r extends t {
    constructor(i) {
      super(i), this.checksum = Buffer.allocUnsafe(4), this.checksum.writeInt32BE(0, 0), this.rawSize = 0;
    }
    _transform(i, a, s) {
      i && (this.checksum = e.buf(i, this.checksum) >>> 0, this.rawSize += i.length), s(null, i);
    }
    digest(i) {
      const a = Buffer.allocUnsafe(4);
      return a.writeUInt32BE(this.checksum >>> 0, 0), i ? a.toString(i) : a;
    }
    hex() {
      return this.digest("hex").toUpperCase();
    }
    size() {
      return this.rawSize;
    }
  }
  return Jd = r, Jd;
}
var Xd, zS;
function Rfe() {
  if (zS)
    return Xd;
  zS = 1;
  const { DeflateRaw: t } = se, e = x8();
  class r extends t {
    constructor(i) {
      super(i), this.checksum = Buffer.allocUnsafe(4), this.checksum.writeInt32BE(0, 0), this.rawSize = 0, this.compressedSize = 0;
    }
    push(i, a) {
      return i && (this.compressedSize += i.length), super.push(i, a);
    }
    _transform(i, a, s) {
      i && (this.checksum = e.buf(i, this.checksum) >>> 0, this.rawSize += i.length), super._transform(i, a, s);
    }
    digest(i) {
      const a = Buffer.allocUnsafe(4);
      return a.writeUInt32BE(this.checksum >>> 0, 0), i ? a.toString(i) : a;
    }
    hex() {
      return this.digest("hex").toUpperCase();
    }
    size(i = !1) {
      return i ? this.compressedSize : this.rawSize;
    }
  }
  return Xd = r, Xd;
}
var Zd, HS;
function WS() {
  return HS || (HS = 1, Zd = {
    CRC32Stream: kfe(),
    DeflateCRC32Stream: Rfe()
  }), Zd;
}
var GS;
function Nfe() {
  if (GS)
    return Qd.exports;
  GS = 1;
  var t = nt.inherits, e = w8(), { CRC32Stream: r } = WS(), { DeflateCRC32Stream: n } = WS(), i = b8();
  v8(), m8();
  var a = g8();
  y8();
  var s = Ay(), o = Qd.exports = function(c) {
    if (!(this instanceof o))
      return new o(c);
    c = this.options = this._defaults(c), i.call(this, c), this._entry = null, this._entries = [], this._archive = {
      centralLength: 0,
      centralOffset: 0,
      comment: "",
      finish: !1,
      finished: !1,
      processing: !1,
      forceZip64: c.forceZip64,
      forceLocalTime: c.forceLocalTime
    };
  };
  return t(o, i), o.prototype._afterAppend = function(c) {
    this._entries.push(c), c.getGeneralPurposeBit().usesDataDescriptor() && this._writeDataDescriptor(c), this._archive.processing = !1, this._entry = null, this._archive.finish && !this._archive.finished && this._finish();
  }, o.prototype._appendBuffer = function(c, f, u) {
    f.length === 0 && c.setMethod(a.METHOD_STORED);
    var l = c.getMethod();
    if (l === a.METHOD_STORED && (c.setSize(f.length), c.setCompressedSize(f.length), c.setCrc(e.unsigned(f))), this._writeLocalFileHeader(c), l === a.METHOD_STORED) {
      this.write(f), this._afterAppend(c), u(null, c);
      return;
    } else if (l === a.METHOD_DEFLATED) {
      this._smartStream(c, u).end(f);
      return;
    } else {
      u(new Error("compression method " + l + " not implemented"));
      return;
    }
  }, o.prototype._appendStream = function(c, f, u) {
    c.getGeneralPurposeBit().useDataDescriptor(!0), c.setVersionNeededToExtract(a.MIN_VERSION_DATA_DESCRIPTOR), this._writeLocalFileHeader(c);
    var l = this._smartStream(c, u);
    f.once("error", function(p) {
      l.emit("error", p), l.end();
    }), f.pipe(l);
  }, o.prototype._defaults = function(c) {
    return typeof c != "object" && (c = {}), typeof c.zlib != "object" && (c.zlib = {}), typeof c.zlib.level != "number" && (c.zlib.level = a.ZLIB_BEST_SPEED), c.forceZip64 = !!c.forceZip64, c.forceLocalTime = !!c.forceLocalTime, c;
  }, o.prototype._finish = function() {
    this._archive.centralOffset = this.offset, this._entries.forEach(function(c) {
      this._writeCentralFileHeader(c);
    }.bind(this)), this._archive.centralLength = this.offset - this._archive.centralOffset, this.isZip64() && this._writeCentralDirectoryZip64(), this._writeCentralDirectoryEnd(), this._archive.processing = !1, this._archive.finish = !0, this._archive.finished = !0, this.end();
  }, o.prototype._normalizeEntry = function(c) {
    c.getMethod() === -1 && c.setMethod(a.METHOD_DEFLATED), c.getMethod() === a.METHOD_DEFLATED && (c.getGeneralPurposeBit().useDataDescriptor(!0), c.setVersionNeededToExtract(a.MIN_VERSION_DATA_DESCRIPTOR)), c.getTime() === -1 && c.setTime(/* @__PURE__ */ new Date(), this._archive.forceLocalTime), c._offsets = {
      file: 0,
      data: 0,
      contents: 0
    };
  }, o.prototype._smartStream = function(c, f) {
    var u = c.getMethod() === a.METHOD_DEFLATED, l = u ? new n(this.options.zlib) : new r(), p = null;
    function m() {
      var h = l.digest().readUInt32BE(0);
      c.setCrc(h), c.setSize(l.size()), c.setCompressedSize(l.size(!0)), this._afterAppend(c), f(p, c);
    }
    return l.once("end", m.bind(this)), l.once("error", function(h) {
      p = h;
    }), l.pipe(this, { end: !1 }), l;
  }, o.prototype._writeCentralDirectoryEnd = function() {
    var c = this._entries.length, f = this._archive.centralLength, u = this._archive.centralOffset;
    this.isZip64() && (c = a.ZIP64_MAGIC_SHORT, f = a.ZIP64_MAGIC, u = a.ZIP64_MAGIC), this.write(s.getLongBytes(a.SIG_EOCD)), this.write(a.SHORT_ZERO), this.write(a.SHORT_ZERO), this.write(s.getShortBytes(c)), this.write(s.getShortBytes(c)), this.write(s.getLongBytes(f)), this.write(s.getLongBytes(u));
    var l = this.getComment(), p = Buffer.byteLength(l);
    this.write(s.getShortBytes(p)), this.write(l);
  }, o.prototype._writeCentralDirectoryZip64 = function() {
    this.write(s.getLongBytes(a.SIG_ZIP64_EOCD)), this.write(s.getEightBytes(44)), this.write(s.getShortBytes(a.MIN_VERSION_ZIP64)), this.write(s.getShortBytes(a.MIN_VERSION_ZIP64)), this.write(a.LONG_ZERO), this.write(a.LONG_ZERO), this.write(s.getEightBytes(this._entries.length)), this.write(s.getEightBytes(this._entries.length)), this.write(s.getEightBytes(this._archive.centralLength)), this.write(s.getEightBytes(this._archive.centralOffset)), this.write(s.getLongBytes(a.SIG_ZIP64_EOCD_LOC)), this.write(a.LONG_ZERO), this.write(s.getEightBytes(this._archive.centralOffset + this._archive.centralLength)), this.write(s.getLongBytes(1));
  }, o.prototype._writeCentralFileHeader = function(c) {
    var f = c.getGeneralPurposeBit(), u = c.getMethod(), l = c._offsets, p = c.getSize(), m = c.getCompressedSize();
    if (c.isZip64() || l.file > a.ZIP64_MAGIC) {
      p = a.ZIP64_MAGIC, m = a.ZIP64_MAGIC, c.setVersionNeededToExtract(a.MIN_VERSION_ZIP64);
      var h = Buffer.concat([
        s.getShortBytes(a.ZIP64_EXTRA_ID),
        s.getShortBytes(24),
        s.getEightBytes(c.getSize()),
        s.getEightBytes(c.getCompressedSize()),
        s.getEightBytes(l.file)
      ], 28);
      c.setExtra(h);
    }
    this.write(s.getLongBytes(a.SIG_CFH)), this.write(s.getShortBytes(c.getPlatform() << 8 | a.VERSION_MADEBY)), this.write(s.getShortBytes(c.getVersionNeededToExtract())), this.write(f.encode()), this.write(s.getShortBytes(u)), this.write(s.getLongBytes(c.getTimeDos())), this.write(s.getLongBytes(c.getCrc())), this.write(s.getLongBytes(m)), this.write(s.getLongBytes(p));
    var g = c.getName(), v = c.getComment(), d = c.getCentralDirectoryExtra();
    f.usesUTF8ForNames() && (g = Buffer.from(g), v = Buffer.from(v)), this.write(s.getShortBytes(g.length)), this.write(s.getShortBytes(d.length)), this.write(s.getShortBytes(v.length)), this.write(a.SHORT_ZERO), this.write(s.getShortBytes(c.getInternalAttributes())), this.write(s.getLongBytes(c.getExternalAttributes())), l.file > a.ZIP64_MAGIC ? this.write(s.getLongBytes(a.ZIP64_MAGIC)) : this.write(s.getLongBytes(l.file)), this.write(g), this.write(d), this.write(v);
  }, o.prototype._writeDataDescriptor = function(c) {
    this.write(s.getLongBytes(a.SIG_DD)), this.write(s.getLongBytes(c.getCrc())), c.isZip64() ? (this.write(s.getEightBytes(c.getCompressedSize())), this.write(s.getEightBytes(c.getSize()))) : (this.write(s.getLongBytes(c.getCompressedSize())), this.write(s.getLongBytes(c.getSize())));
  }, o.prototype._writeLocalFileHeader = function(c) {
    var f = c.getGeneralPurposeBit(), u = c.getMethod(), l = c.getName(), p = c.getLocalFileDataExtra();
    c.isZip64() && (f.useDataDescriptor(!0), c.setVersionNeededToExtract(a.MIN_VERSION_ZIP64)), f.usesUTF8ForNames() && (l = Buffer.from(l)), c._offsets.file = this.offset, this.write(s.getLongBytes(a.SIG_LFH)), this.write(s.getShortBytes(c.getVersionNeededToExtract())), this.write(f.encode()), this.write(s.getShortBytes(u)), this.write(s.getLongBytes(c.getTimeDos())), c._offsets.data = this.offset, f.usesDataDescriptor() ? (this.write(a.LONG_ZERO), this.write(a.LONG_ZERO), this.write(a.LONG_ZERO)) : (this.write(s.getLongBytes(c.getCrc())), this.write(s.getLongBytes(c.getCompressedSize())), this.write(s.getLongBytes(c.getSize()))), this.write(s.getShortBytes(l.length)), this.write(s.getShortBytes(p.length)), this.write(l), this.write(p), c._offsets.contents = this.offset;
  }, o.prototype.getComment = function(c) {
    return this._archive.comment !== null ? this._archive.comment : "";
  }, o.prototype.isZip64 = function() {
    return this._archive.forceZip64 || this._entries.length > a.ZIP64_MAGIC_SHORT || this._archive.centralLength > a.ZIP64_MAGIC || this._archive.centralOffset > a.ZIP64_MAGIC;
  }, o.prototype.setComment = function(c) {
    this._archive.comment = c;
  }, Qd.exports;
}
var Yd, QS;
function VS() {
  return QS || (QS = 1, Yd = {
    ArchiveEntry: Oy(),
    ZipArchiveEntry: v8(),
    ArchiveOutputStream: b8(),
    ZipArchiveOutputStream: Nfe()
  }), Yd;
}
/**
 * ZipStream
 *
 * @ignore
 * @license [MIT]{@link https://github.com/archiverjs/node-zip-stream/blob/master/LICENSE}
 * @copyright (c) 2014 Chris Talkington, contributors.
 */
var KS;
function Lfe() {
  if (KS)
    return qd.exports;
  KS = 1;
  var t = nt.inherits, e = VS().ZipArchiveOutputStream, r = VS().ZipArchiveEntry, n = Ts(), i = qd.exports = function(a) {
    if (!(this instanceof i))
      return new i(a);
    a = this.options = a || {}, a.zlib = a.zlib || {}, e.call(this, a), typeof a.level == "number" && a.level >= 0 && (a.zlib.level = a.level, delete a.level), !a.forceZip64 && typeof a.zlib.level == "number" && a.zlib.level === 0 && (a.store = !0), a.namePrependSlash = a.namePrependSlash || !1, a.comment && a.comment.length > 0 && this.setComment(a.comment);
  };
  return t(i, e), i.prototype._normalizeFileData = function(a) {
    a = n.defaults(a, {
      type: "file",
      name: null,
      namePrependSlash: this.options.namePrependSlash,
      linkname: null,
      date: null,
      mode: null,
      store: this.options.store,
      comment: ""
    });
    var s = a.type === "directory", o = a.type === "symlink";
    return a.name && (a.name = n.sanitizePath(a.name), !o && a.name.slice(-1) === "/" ? (s = !0, a.type = "directory") : s && (a.name += "/")), (s || o) && (a.store = !0), a.date = n.dateify(a.date), a;
  }, i.prototype.entry = function(a, s, o) {
    if (typeof o != "function" && (o = this._emitErrorCallback.bind(this)), s = this._normalizeFileData(s), s.type !== "file" && s.type !== "directory" && s.type !== "symlink") {
      o(new Error(s.type + " entries not currently supported"));
      return;
    }
    if (typeof s.name != "string" || s.name.length === 0) {
      o(new Error("entry name must be a non-empty string value"));
      return;
    }
    if (s.type === "symlink" && typeof s.linkname != "string") {
      o(new Error("entry linkname must be a non-empty string value when type equals symlink"));
      return;
    }
    var c = new r(s.name);
    return c.setTime(s.date, this.options.forceLocalTime), s.namePrependSlash && c.setName(s.name, !0), s.store && c.setMethod(0), s.comment.length > 0 && c.setComment(s.comment), s.type === "symlink" && typeof s.mode != "number" && (s.mode = 40960), typeof s.mode == "number" && (s.type === "symlink" && (s.mode |= 40960), c.setUnixMode(s.mode)), s.type === "symlink" && typeof s.linkname == "string" && (a = Buffer.from(s.linkname)), e.prototype.entry.call(this, c, a, o);
  }, i.prototype.finalize = function() {
    this.finish();
  }, qd.exports;
}
/**
 * ZIP Format Plugin
 *
 * @module plugins/zip
 * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
 * @copyright (c) 2012-2014 Chris Talkington, contributors.
 */
var em, JS;
function Pfe() {
  if (JS)
    return em;
  JS = 1;
  var t = Lfe(), e = Ts(), r = function(n) {
    if (!(this instanceof r))
      return new r(n);
    n = this.options = e.defaults(n, {
      comment: "",
      forceUTC: !1,
      namePrependSlash: !1,
      store: !1
    }), this.supports = {
      directory: !0,
      symlink: !0
    }, this.engine = new t(n);
  };
  return r.prototype.append = function(n, i, a) {
    this.engine.entry(n, i, a);
  }, r.prototype.finalize = function() {
    this.engine.finalize();
  }, r.prototype.on = function() {
    return this.engine.on.apply(this.engine, arguments);
  }, r.prototype.pipe = function() {
    return this.engine.pipe.apply(this.engine, arguments);
  }, r.prototype.unpipe = function() {
    return this.engine.unpipe.apply(this.engine, arguments);
  }, em = r, em;
}
var mo = {}, ua = { exports: {} }, tm, XS;
function Dfe() {
  if (XS)
    return tm;
  XS = 1;
  const { Buffer: t } = rr, e = Symbol.for("BufferList");
  function r(n) {
    if (!(this instanceof r))
      return new r(n);
    r._init.call(this, n);
  }
  return r._init = function(i) {
    Object.defineProperty(this, e, { value: !0 }), this._bufs = [], this.length = 0, i && this.append(i);
  }, r.prototype._new = function(i) {
    return new r(i);
  }, r.prototype._offset = function(i) {
    if (i === 0)
      return [0, 0];
    let a = 0;
    for (let s = 0; s < this._bufs.length; s++) {
      const o = a + this._bufs[s].length;
      if (i < o || s === this._bufs.length - 1)
        return [s, i - a];
      a = o;
    }
  }, r.prototype._reverseOffset = function(n) {
    const i = n[0];
    let a = n[1];
    for (let s = 0; s < i; s++)
      a += this._bufs[s].length;
    return a;
  }, r.prototype.get = function(i) {
    if (i > this.length || i < 0)
      return;
    const a = this._offset(i);
    return this._bufs[a[0]][a[1]];
  }, r.prototype.slice = function(i, a) {
    return typeof i == "number" && i < 0 && (i += this.length), typeof a == "number" && a < 0 && (a += this.length), this.copy(null, 0, i, a);
  }, r.prototype.copy = function(i, a, s, o) {
    if ((typeof s != "number" || s < 0) && (s = 0), (typeof o != "number" || o > this.length) && (o = this.length), s >= this.length || o <= 0)
      return i || t.alloc(0);
    const c = !!i, f = this._offset(s), u = o - s;
    let l = u, p = c && a || 0, m = f[1];
    if (s === 0 && o === this.length) {
      if (!c)
        return this._bufs.length === 1 ? this._bufs[0] : t.concat(this._bufs, this.length);
      for (let h = 0; h < this._bufs.length; h++)
        this._bufs[h].copy(i, p), p += this._bufs[h].length;
      return i;
    }
    if (l <= this._bufs[f[0]].length - m)
      return c ? this._bufs[f[0]].copy(i, a, m, m + l) : this._bufs[f[0]].slice(m, m + l);
    c || (i = t.allocUnsafe(u));
    for (let h = f[0]; h < this._bufs.length; h++) {
      const g = this._bufs[h].length - m;
      if (l > g)
        this._bufs[h].copy(i, p, m), p += g;
      else {
        this._bufs[h].copy(i, p, m, m + l), p += g;
        break;
      }
      l -= g, m && (m = 0);
    }
    return i.length > p ? i.slice(0, p) : i;
  }, r.prototype.shallowSlice = function(i, a) {
    if (i = i || 0, a = typeof a != "number" ? this.length : a, i < 0 && (i += this.length), a < 0 && (a += this.length), i === a)
      return this._new();
    const s = this._offset(i), o = this._offset(a), c = this._bufs.slice(s[0], o[0] + 1);
    return o[1] === 0 ? c.pop() : c[c.length - 1] = c[c.length - 1].slice(0, o[1]), s[1] !== 0 && (c[0] = c[0].slice(s[1])), this._new(c);
  }, r.prototype.toString = function(i, a, s) {
    return this.slice(a, s).toString(i);
  }, r.prototype.consume = function(i) {
    if (i = Math.trunc(i), Number.isNaN(i) || i <= 0)
      return this;
    for (; this._bufs.length; )
      if (i >= this._bufs[0].length)
        i -= this._bufs[0].length, this.length -= this._bufs[0].length, this._bufs.shift();
      else {
        this._bufs[0] = this._bufs[0].slice(i), this.length -= i;
        break;
      }
    return this;
  }, r.prototype.duplicate = function() {
    const i = this._new();
    for (let a = 0; a < this._bufs.length; a++)
      i.append(this._bufs[a]);
    return i;
  }, r.prototype.append = function(i) {
    if (i == null)
      return this;
    if (i.buffer)
      this._appendBuffer(t.from(i.buffer, i.byteOffset, i.byteLength));
    else if (Array.isArray(i))
      for (let a = 0; a < i.length; a++)
        this.append(i[a]);
    else if (this._isBufferList(i))
      for (let a = 0; a < i._bufs.length; a++)
        this.append(i._bufs[a]);
    else
      typeof i == "number" && (i = i.toString()), this._appendBuffer(t.from(i));
    return this;
  }, r.prototype._appendBuffer = function(i) {
    this._bufs.push(i), this.length += i.length;
  }, r.prototype.indexOf = function(n, i, a) {
    if (a === void 0 && typeof i == "string" && (a = i, i = void 0), typeof n == "function" || Array.isArray(n))
      throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
    if (typeof n == "number" ? n = t.from([n]) : typeof n == "string" ? n = t.from(n, a) : this._isBufferList(n) ? n = n.slice() : Array.isArray(n.buffer) ? n = t.from(n.buffer, n.byteOffset, n.byteLength) : t.isBuffer(n) || (n = t.from(n)), i = Number(i || 0), isNaN(i) && (i = 0), i < 0 && (i = this.length + i), i < 0 && (i = 0), n.length === 0)
      return i > this.length ? this.length : i;
    const s = this._offset(i);
    let o = s[0], c = s[1];
    for (; o < this._bufs.length; o++) {
      const f = this._bufs[o];
      for (; c < f.length; )
        if (f.length - c >= n.length) {
          const l = f.indexOf(n, c);
          if (l !== -1)
            return this._reverseOffset([o, l]);
          c = f.length - n.length + 1;
        } else {
          const l = this._reverseOffset([o, c]);
          if (this._match(l, n))
            return l;
          c++;
        }
      c = 0;
    }
    return -1;
  }, r.prototype._match = function(n, i) {
    if (this.length - n < i.length)
      return !1;
    for (let a = 0; a < i.length; a++)
      if (this.get(n + a) !== i[a])
        return !1;
    return !0;
  }, function() {
    const n = {
      readDoubleBE: 8,
      readDoubleLE: 8,
      readFloatBE: 4,
      readFloatLE: 4,
      readInt32BE: 4,
      readInt32LE: 4,
      readUInt32BE: 4,
      readUInt32LE: 4,
      readInt16BE: 2,
      readInt16LE: 2,
      readUInt16BE: 2,
      readUInt16LE: 2,
      readInt8: 1,
      readUInt8: 1,
      readIntBE: null,
      readIntLE: null,
      readUIntBE: null,
      readUIntLE: null
    };
    for (const i in n)
      (function(a) {
        n[a] === null ? r.prototype[a] = function(s, o) {
          return this.slice(s, s + o)[a](0, o);
        } : r.prototype[a] = function(s = 0) {
          return this.slice(s, s + n[a])[a](0);
        };
      })(i);
  }(), r.prototype._isBufferList = function(i) {
    return i instanceof r || r.isBufferList(i);
  }, r.isBufferList = function(i) {
    return i != null && i[e];
  }, tm = r, tm;
}
var ZS;
function Mfe() {
  if (ZS)
    return ua.exports;
  ZS = 1;
  const t = gr().Duplex, e = ct(), r = Dfe();
  function n(i) {
    if (!(this instanceof n))
      return new n(i);
    if (typeof i == "function") {
      this._callback = i;
      const a = function(o) {
        this._callback && (this._callback(o), this._callback = null);
      }.bind(this);
      this.on("pipe", function(o) {
        o.on("error", a);
      }), this.on("unpipe", function(o) {
        o.removeListener("error", a);
      }), i = null;
    }
    r._init.call(this, i), t.call(this);
  }
  return e(n, t), Object.assign(n.prototype, r.prototype), n.prototype._new = function(a) {
    return new n(a);
  }, n.prototype._write = function(a, s, o) {
    this._appendBuffer(a), typeof o == "function" && o();
  }, n.prototype._read = function(a) {
    if (!this.length)
      return this.push(null);
    a = Math.min(a, this.length), this.push(this.slice(0, a)), this.consume(a);
  }, n.prototype.end = function(a) {
    t.prototype.end.call(this, a), this._callback && (this._callback(null, this.slice()), this._callback = null);
  }, n.prototype._destroy = function(a, s) {
    this._bufs.length = 0, this.length = 0, s(a);
  }, n.prototype._isBufferList = function(a) {
    return a instanceof n || a instanceof r || n.isBufferList(a);
  }, n.isBufferList = r.isBufferList, ua.exports = n, ua.exports.BufferListStream = n, ua.exports.BufferList = r, ua.exports;
}
var bn = {}, YS;
function _8() {
  if (YS)
    return bn;
  YS = 1;
  var t = Buffer.alloc, e = "0000000000000000000", r = "7777777777777777777", n = "0".charCodeAt(0), i = Buffer.from("ustar\0", "binary"), a = Buffer.from("00", "binary"), s = Buffer.from("ustar ", "binary"), o = Buffer.from(" \0", "binary"), c = parseInt("7777", 8), f = 257, u = 263, l = function(w, S, T) {
    return typeof w != "number" ? T : (w = ~~w, w >= S ? S : w >= 0 || (w += S, w >= 0) ? w : 0);
  }, p = function(w) {
    switch (w) {
      case 0:
        return "file";
      case 1:
        return "link";
      case 2:
        return "symlink";
      case 3:
        return "character-device";
      case 4:
        return "block-device";
      case 5:
        return "directory";
      case 6:
        return "fifo";
      case 7:
        return "contiguous-file";
      case 72:
        return "pax-header";
      case 55:
        return "pax-global-header";
      case 27:
        return "gnu-long-link-path";
      case 28:
      case 30:
        return "gnu-long-path";
    }
    return null;
  }, m = function(w) {
    switch (w) {
      case "file":
        return 0;
      case "link":
        return 1;
      case "symlink":
        return 2;
      case "character-device":
        return 3;
      case "block-device":
        return 4;
      case "directory":
        return 5;
      case "fifo":
        return 6;
      case "contiguous-file":
        return 7;
      case "pax-header":
        return 72;
    }
    return 0;
  }, h = function(w, S, T, E) {
    for (; T < E; T++)
      if (w[T] === S)
        return T;
    return E;
  }, g = function(w) {
    for (var S = 256, T = 0; T < 148; T++)
      S += w[T];
    for (var E = 156; E < 512; E++)
      S += w[E];
    return S;
  }, v = function(w, S) {
    return w = w.toString(8), w.length > S ? r.slice(0, S) + " " : e.slice(0, S - w.length) + w + " ";
  };
  function d(w) {
    var S;
    if (w[0] === 128)
      S = !0;
    else if (w[0] === 255)
      S = !1;
    else
      return null;
    for (var T = [], E = w.length - 1; E > 0; E--) {
      var C = w[E];
      S ? T.push(C) : T.push(255 - C);
    }
    var A = 0, R = T.length;
    for (E = 0; E < R; E++)
      A += T[E] * Math.pow(256, E);
    return S ? A : -1 * A;
  }
  var y = function(w, S, T) {
    if (w = w.slice(S, S + T), S = 0, w[S] & 128)
      return d(w);
    for (; S < w.length && w[S] === 32; )
      S++;
    for (var E = l(h(w, 32, S, w.length), w.length, w.length); S < E && w[S] === 0; )
      S++;
    return E === S ? 0 : parseInt(w.slice(S, E).toString(), 8);
  }, x = function(w, S, T, E) {
    return w.slice(S, h(w, 0, S, S + T)).toString(E);
  }, b = function(w) {
    var S = Buffer.byteLength(w), T = Math.floor(Math.log(S) / Math.log(10)) + 1;
    return S + T >= Math.pow(10, T) && T++, S + T + w;
  };
  return bn.decodeLongPath = function(w, S) {
    return x(w, 0, w.length, S);
  }, bn.encodePax = function(w) {
    var S = "";
    w.name && (S += b(" path=" + w.name + `
`)), w.linkname && (S += b(" linkpath=" + w.linkname + `
`));
    var T = w.pax;
    if (T)
      for (var E in T)
        S += b(" " + E + "=" + T[E] + `
`);
    return Buffer.from(S);
  }, bn.decodePax = function(w) {
    for (var S = {}; w.length; ) {
      for (var T = 0; T < w.length && w[T] !== 32; )
        T++;
      var E = parseInt(w.slice(0, T).toString(), 10);
      if (!E)
        return S;
      var C = w.slice(T + 1, E - 1).toString(), A = C.indexOf("=");
      if (A === -1)
        return S;
      S[C.slice(0, A)] = C.slice(A + 1), w = w.slice(E);
    }
    return S;
  }, bn.encode = function(w) {
    var S = t(512), T = w.name, E = "";
    if (w.typeflag === 5 && T[T.length - 1] !== "/" && (T += "/"), Buffer.byteLength(T) !== T.length)
      return null;
    for (; Buffer.byteLength(T) > 100; ) {
      var C = T.indexOf("/");
      if (C === -1)
        return null;
      E += E ? "/" + T.slice(0, C) : T.slice(0, C), T = T.slice(C + 1);
    }
    return Buffer.byteLength(T) > 100 || Buffer.byteLength(E) > 155 || w.linkname && Buffer.byteLength(w.linkname) > 100 ? null : (S.write(T), S.write(v(w.mode & c, 6), 100), S.write(v(w.uid, 6), 108), S.write(v(w.gid, 6), 116), S.write(v(w.size, 11), 124), S.write(v(w.mtime.getTime() / 1e3 | 0, 11), 136), S[156] = n + m(w.type), w.linkname && S.write(w.linkname, 157), i.copy(S, f), a.copy(S, u), w.uname && S.write(w.uname, 265), w.gname && S.write(w.gname, 297), S.write(v(w.devmajor || 0, 6), 329), S.write(v(w.devminor || 0, 6), 337), E && S.write(E, 345), S.write(v(g(S), 6), 148), S);
  }, bn.decode = function(w, S, T) {
    var E = w[156] === 0 ? 0 : w[156] - n, C = x(w, 0, 100, S), A = y(w, 100, 8), R = y(w, 108, 8), D = y(w, 116, 8), F = y(w, 124, 12), K = y(w, 136, 12), V = p(E), ne = w[157] === 0 ? null : x(w, 157, 100, S), $ = x(w, 265, 32), L = x(w, 297, 32), P = y(w, 329, 8), H = y(w, 337, 8), Q = g(w);
    if (Q === 8 * 32)
      return null;
    if (Q !== y(w, 148, 8))
      throw new Error("Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?");
    if (i.compare(w, f, f + 6) === 0)
      w[345] && (C = x(w, 345, 155, S) + "/" + C);
    else if (!(s.compare(w, f, f + 6) === 0 && o.compare(w, u, u + 2) === 0)) {
      if (!T)
        throw new Error("Invalid tar header: unknown format.");
    }
    return E === 0 && C && C[C.length - 1] === "/" && (E = 5), {
      name: C,
      mode: A,
      uid: R,
      gid: D,
      size: F,
      mtime: new Date(1e3 * K),
      type: V,
      linkname: ne,
      uname: $,
      gname: L,
      devmajor: P,
      devminor: H
    };
  }, bn;
}
var rm, e2;
function qfe() {
  if (e2)
    return rm;
  e2 = 1;
  var t = nt, e = Mfe(), r = _8(), n = gr().Writable, i = gr().PassThrough, a = function() {
  }, s = function(l) {
    return l &= 511, l && 512 - l;
  }, o = function(l, p) {
    var m = new f(l, p);
    return m.end(), m;
  }, c = function(l, p) {
    return p.path && (l.name = p.path), p.linkpath && (l.linkname = p.linkpath), p.size && (l.size = parseInt(p.size, 10)), l.pax = p, l;
  }, f = function(l, p) {
    this._parent = l, this.offset = p, i.call(this, { autoDestroy: !1 });
  };
  t.inherits(f, i), f.prototype.destroy = function(l) {
    this._parent.destroy(l);
  };
  var u = function(l) {
    if (!(this instanceof u))
      return new u(l);
    n.call(this, l), l = l || {}, this._offset = 0, this._buffer = e(), this._missing = 0, this._partial = !1, this._onparse = a, this._header = null, this._stream = null, this._overflow = null, this._cb = null, this._locked = !1, this._destroyed = !1, this._pax = null, this._paxGlobal = null, this._gnuLongPath = null, this._gnuLongLinkPath = null;
    var p = this, m = p._buffer, h = function() {
      p._continue();
    }, g = function(T) {
      if (p._locked = !1, T)
        return p.destroy(T);
      p._stream || h();
    }, v = function() {
      p._stream = null;
      var T = s(p._header.size);
      T ? p._parse(T, d) : p._parse(512, S), p._locked || h();
    }, d = function() {
      p._buffer.consume(s(p._header.size)), p._parse(512, S), h();
    }, y = function() {
      var T = p._header.size;
      p._paxGlobal = r.decodePax(m.slice(0, T)), m.consume(T), v();
    }, x = function() {
      var T = p._header.size;
      p._pax = r.decodePax(m.slice(0, T)), p._paxGlobal && (p._pax = Object.assign({}, p._paxGlobal, p._pax)), m.consume(T), v();
    }, b = function() {
      var T = p._header.size;
      this._gnuLongPath = r.decodeLongPath(m.slice(0, T), l.filenameEncoding), m.consume(T), v();
    }, w = function() {
      var T = p._header.size;
      this._gnuLongLinkPath = r.decodeLongPath(m.slice(0, T), l.filenameEncoding), m.consume(T), v();
    }, S = function() {
      var T = p._offset, E;
      try {
        E = p._header = r.decode(m.slice(0, 512), l.filenameEncoding, l.allowUnknownFormat);
      } catch (C) {
        p.emit("error", C);
      }
      if (m.consume(512), !E) {
        p._parse(512, S), h();
        return;
      }
      if (E.type === "gnu-long-path") {
        p._parse(E.size, b), h();
        return;
      }
      if (E.type === "gnu-long-link-path") {
        p._parse(E.size, w), h();
        return;
      }
      if (E.type === "pax-global-header") {
        p._parse(E.size, y), h();
        return;
      }
      if (E.type === "pax-header") {
        p._parse(E.size, x), h();
        return;
      }
      if (p._gnuLongPath && (E.name = p._gnuLongPath, p._gnuLongPath = null), p._gnuLongLinkPath && (E.linkname = p._gnuLongLinkPath, p._gnuLongLinkPath = null), p._pax && (p._header = E = c(E, p._pax), p._pax = null), p._locked = !0, !E.size || E.type === "directory") {
        p._parse(512, S), p.emit("entry", E, o(p, T), g);
        return;
      }
      p._stream = new f(p, T), p.emit("entry", E, p._stream, g), p._parse(E.size, v), h();
    };
    this._onheader = S, this._parse(512, S);
  };
  return t.inherits(u, n), u.prototype.destroy = function(l) {
    this._destroyed || (this._destroyed = !0, l && this.emit("error", l), this.emit("close"), this._stream && this._stream.emit("close"));
  }, u.prototype._parse = function(l, p) {
    this._destroyed || (this._offset += l, this._missing = l, p === this._onheader && (this._partial = !1), this._onparse = p);
  }, u.prototype._continue = function() {
    if (!this._destroyed) {
      var l = this._cb;
      this._cb = a, this._overflow ? this._write(this._overflow, void 0, l) : l();
    }
  }, u.prototype._write = function(l, p, m) {
    if (!this._destroyed) {
      var h = this._stream, g = this._buffer, v = this._missing;
      if (l.length && (this._partial = !0), l.length < v)
        return this._missing -= l.length, this._overflow = null, h ? h.write(l, m) : (g.append(l), m());
      this._cb = m, this._missing = 0;
      var d = null;
      l.length > v && (d = l.slice(v), l = l.slice(0, v)), h ? h.end(l) : g.append(l), this._overflow = d, this._onparse();
    }
  }, u.prototype._final = function(l) {
    if (this._partial)
      return this.destroy(new Error("Unexpected end of data"));
    l();
  }, rm = u, rm;
}
var nm, t2;
function jfe() {
  return t2 || (t2 = 1, nm = se), nm;
}
var im, r2;
function Ffe() {
  if (r2)
    return im;
  r2 = 1;
  var t = Cy(), e = function() {
  }, r = function(a) {
    return a.setHeader && typeof a.abort == "function";
  }, n = function(a) {
    return a.stdio && Array.isArray(a.stdio) && a.stdio.length === 3;
  }, i = function(a, s, o) {
    if (typeof s == "function")
      return i(a, null, s);
    s || (s = {}), o = t(o || e);
    var c = a._writableState, f = a._readableState, u = s.readable || s.readable !== !1 && a.readable, l = s.writable || s.writable !== !1 && a.writable, p = !1, m = function() {
      a.writable || h();
    }, h = function() {
      l = !1, u || o.call(a);
    }, g = function() {
      u = !1, l || o.call(a);
    }, v = function(w) {
      o.call(a, w ? new Error("exited with error code: " + w) : null);
    }, d = function(w) {
      o.call(a, w);
    }, y = function() {
      process.nextTick(x);
    }, x = function() {
      if (!p) {
        if (u && !(f && f.ended && !f.destroyed))
          return o.call(a, new Error("premature close"));
        if (l && !(c && c.ended && !c.destroyed))
          return o.call(a, new Error("premature close"));
      }
    }, b = function() {
      a.req.on("finish", h);
    };
    return r(a) ? (a.on("complete", h), a.on("abort", y), a.req ? b() : a.on("request", b)) : l && !c && (a.on("end", m), a.on("close", m)), n(a) && a.on("exit", v), a.on("end", g), a.on("finish", h), s.error !== !1 && a.on("error", d), a.on("close", y), function() {
      p = !0, a.removeListener("complete", h), a.removeListener("abort", y), a.removeListener("request", b), a.req && a.req.removeListener("finish", h), a.removeListener("end", m), a.removeListener("close", m), a.removeListener("finish", h), a.removeListener("exit", v), a.removeListener("end", g), a.removeListener("error", d), a.removeListener("close", y);
    };
  };
  return im = i, im;
}
var am, n2;
function Bfe() {
  if (n2)
    return am;
  n2 = 1;
  var t = jfe(), e = Ffe(), r = ct(), n = Buffer.alloc, i = gr().Readable, a = gr().Writable, s = No().StringDecoder, o = _8(), c = parseInt("755", 8), f = parseInt("644", 8), u = n(1024), l = function() {
  }, p = function(y, x) {
    x &= 511, x && y.push(u.slice(0, 512 - x));
  };
  function m(y) {
    switch (y & t.S_IFMT) {
      case t.S_IFBLK:
        return "block-device";
      case t.S_IFCHR:
        return "character-device";
      case t.S_IFDIR:
        return "directory";
      case t.S_IFIFO:
        return "fifo";
      case t.S_IFLNK:
        return "symlink";
    }
    return "file";
  }
  var h = function(y) {
    a.call(this), this.written = 0, this._to = y, this._destroyed = !1;
  };
  r(h, a), h.prototype._write = function(y, x, b) {
    if (this.written += y.length, this._to.push(y))
      return b();
    this._to._drain = b;
  }, h.prototype.destroy = function() {
    this._destroyed || (this._destroyed = !0, this.emit("close"));
  };
  var g = function() {
    a.call(this), this.linkname = "", this._decoder = new s("utf-8"), this._destroyed = !1;
  };
  r(g, a), g.prototype._write = function(y, x, b) {
    this.linkname += this._decoder.write(y), b();
  }, g.prototype.destroy = function() {
    this._destroyed || (this._destroyed = !0, this.emit("close"));
  };
  var v = function() {
    a.call(this), this._destroyed = !1;
  };
  r(v, a), v.prototype._write = function(y, x, b) {
    b(new Error("No body allowed for this entry"));
  }, v.prototype.destroy = function() {
    this._destroyed || (this._destroyed = !0, this.emit("close"));
  };
  var d = function(y) {
    if (!(this instanceof d))
      return new d(y);
    i.call(this, y), this._drain = l, this._finalized = !1, this._finalizing = !1, this._destroyed = !1, this._stream = null;
  };
  return r(d, i), d.prototype.entry = function(y, x, b) {
    if (this._stream)
      throw new Error("already piping an entry");
    if (!(this._finalized || this._destroyed)) {
      typeof x == "function" && (b = x, x = null), b || (b = l);
      var w = this;
      if ((!y.size || y.type === "symlink") && (y.size = 0), y.type || (y.type = m(y.mode)), y.mode || (y.mode = y.type === "directory" ? c : f), y.uid || (y.uid = 0), y.gid || (y.gid = 0), y.mtime || (y.mtime = /* @__PURE__ */ new Date()), typeof x == "string" && (x = Buffer.from(x)), Buffer.isBuffer(x)) {
        y.size = x.length, this._encode(y);
        var S = this.push(x);
        return p(w, y.size), S ? process.nextTick(b) : this._drain = b, new v();
      }
      if (y.type === "symlink" && !y.linkname) {
        var T = new g();
        return e(T, function(C) {
          if (C)
            return w.destroy(), b(C);
          y.linkname = T.linkname, w._encode(y), b();
        }), T;
      }
      if (this._encode(y), y.type !== "file" && y.type !== "contiguous-file")
        return process.nextTick(b), new v();
      var E = new h(this);
      return this._stream = E, e(E, function(C) {
        if (w._stream = null, C)
          return w.destroy(), b(C);
        if (E.written !== y.size)
          return w.destroy(), b(new Error("size mismatch"));
        p(w, y.size), w._finalizing && w.finalize(), b();
      }), E;
    }
  }, d.prototype.finalize = function() {
    if (this._stream) {
      this._finalizing = !0;
      return;
    }
    this._finalized || (this._finalized = !0, this.push(u), this.push(null));
  }, d.prototype.destroy = function(y) {
    this._destroyed || (this._destroyed = !0, y && this.emit("error", y), this.emit("close"), this._stream && this._stream.destroy && this._stream.destroy());
  }, d.prototype._encode = function(y) {
    if (!y.pax) {
      var x = o.encode(y);
      if (x) {
        this.push(x);
        return;
      }
    }
    this._encodePax(y);
  }, d.prototype._encodePax = function(y) {
    var x = o.encodePax({
      name: y.name,
      linkname: y.linkname,
      pax: y.pax
    }), b = {
      name: "PaxHeader",
      mode: y.mode,
      uid: y.uid,
      gid: y.gid,
      size: x.length,
      mtime: y.mtime,
      type: "pax-header",
      linkname: y.linkname && "PaxHeader",
      uname: y.uname,
      gname: y.gname,
      devmajor: y.devmajor,
      devminor: y.devminor
    };
    this.push(o.encode(b)), this.push(x), p(this, x.length), b.size = y.size, b.type = y.type, this.push(o.encode(b));
  }, d.prototype._read = function(y) {
    var x = this._drain;
    this._drain = l, x();
  }, am = d, am;
}
var i2;
function Ufe() {
  return i2 || (i2 = 1, mo.extract = qfe(), mo.pack = Bfe()), mo;
}
/**
 * TAR Format Plugin
 *
 * @module plugins/tar
 * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
 * @copyright (c) 2012-2014 Chris Talkington, contributors.
 */
var sm, a2;
function zfe() {
  if (a2)
    return sm;
  a2 = 1;
  var t = se, e = Ufe(), r = Ts(), n = function(i) {
    if (!(this instanceof n))
      return new n(i);
    i = this.options = r.defaults(i, {
      gzip: !1
    }), typeof i.gzipOptions != "object" && (i.gzipOptions = {}), this.supports = {
      directory: !0,
      symlink: !0
    }, this.engine = e.pack(i), this.compressor = !1, i.gzip && (this.compressor = t.createGzip(i.gzipOptions), this.compressor.on("error", this._onCompressorError.bind(this)));
  };
  return n.prototype._onCompressorError = function(i) {
    this.engine.emit("error", i);
  }, n.prototype.append = function(i, a, s) {
    var o = this;
    a.mtime = a.date;
    function c(u, l) {
      if (u) {
        s(u);
        return;
      }
      o.engine.entry(a, l, function(p) {
        s(p, a);
      });
    }
    if (a.sourceType === "buffer")
      c(null, i);
    else if (a.sourceType === "stream" && a.stats) {
      a.size = a.stats.size;
      var f = o.engine.entry(a, function(u) {
        s(u, a);
      });
      i.pipe(f);
    } else
      a.sourceType === "stream" && r.collectStream(i, c);
  }, n.prototype.finalize = function() {
    this.engine.finalize();
  }, n.prototype.on = function() {
    return this.engine.on.apply(this.engine, arguments);
  }, n.prototype.pipe = function(i, a) {
    return this.compressor ? this.engine.pipe.apply(this.engine, [this.compressor]).pipe(i, a) : this.engine.pipe.apply(this.engine, arguments);
  }, n.prototype.unpipe = function() {
    return this.compressor ? this.compressor.unpipe.apply(this.compressor, arguments) : this.engine.unpipe.apply(this.engine, arguments);
  }, sm = n, sm;
}
/**
 * JSON Format Plugin
 *
 * @module plugins/json
 * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
 * @copyright (c) 2012-2014 Chris Talkington, contributors.
 */
var om, s2;
function Hfe() {
  if (s2)
    return om;
  s2 = 1;
  var t = nt.inherits, e = gr().Transform, r = w8(), n = Ts(), i = function(a) {
    if (!(this instanceof i))
      return new i(a);
    a = this.options = n.defaults(a, {}), e.call(this, a), this.supports = {
      directory: !0,
      symlink: !0
    }, this.files = [];
  };
  return t(i, e), i.prototype._transform = function(a, s, o) {
    o(null, a);
  }, i.prototype._writeStringified = function() {
    var a = JSON.stringify(this.files);
    this.write(a);
  }, i.prototype.append = function(a, s, o) {
    var c = this;
    s.crc32 = 0;
    function f(u, l) {
      if (u) {
        o(u);
        return;
      }
      s.size = l.length || 0, s.crc32 = r.unsigned(l), c.files.push(s), o(null, s);
    }
    s.sourceType === "buffer" ? f(null, a) : s.sourceType === "stream" && n.collectStream(a, f);
  }, i.prototype.finalize = function() {
    this._writeStringified(), this.end();
  }, om = i, om;
}
/**
 * Archiver Vending
 *
 * @ignore
 * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
 * @copyright (c) 2012-2014 Chris Talkington, contributors.
 */
var cm, o2;
function Wfe() {
  if (o2)
    return cm;
  o2 = 1;
  var t = $fe(), e = {}, r = function(n, i) {
    return r.create(n, i);
  };
  return r.create = function(n, i) {
    if (e[n]) {
      var a = new t(n, i);
      return a.setFormat(n), a.setModule(new e[n](i)), a;
    } else
      throw new Error("create(" + n + "): format not registered");
  }, r.registerFormat = function(n, i) {
    if (e[n])
      throw new Error("register(" + n + "): format already registered");
    if (typeof i != "function")
      throw new Error("register(" + n + "): format module invalid");
    if (typeof i.prototype.append != "function" || typeof i.prototype.finalize != "function")
      throw new Error("register(" + n + "): format module missing methods");
    e[n] = i;
  }, r.isRegisteredFormat = function(n) {
    return !!e[n];
  }, r.registerFormat("zip", Pfe()), r.registerFormat("tar", zfe()), r.registerFormat("json", Hfe()), cm = r, cm;
}
var c2 = se, go = ple, fr = se, Gfe = _pe, Qfe = D$, Vfe = q$, Kfe = Wpe, Jfe = Xpe, Xfe = j$, wn = function(t) {
  var e = /* @__PURE__ */ new Date(), r = e.getHours() + ":" + e.getMinutes() + ":" + e.getSeconds();
  console.log(
    "[" + r + "]",
    "SCORM",
    "'\x1B[32m" + t + "\x1B[0m'"
  );
}, la = function(t) {
  var e = /* @__PURE__ */ new Date(), r = e.getHours() + ":" + e.getMinutes() + ":" + e.getSeconds();
  console.log("[" + r + "]\x1B[31m", t, "\x1B[0m");
}, Zfe = function(t, e) {
  wn("Init"), e = e || wn, t = Vfe(t);
  var r, n;
  switch (t.version) {
    case "1.2":
      r = "scorm12", n = "scorm12edition";
      break;
    case "2004.3":
    case "2004v3":
    case "2004 3rd Edition":
      r = "scorm2004", n = "scorm20043rdedition";
      break;
    case "2004.4":
    case "2004v4":
    case "2004 4th Edition":
      r = "scorm2004", n = "scorm20044thedition";
      break;
  }
  if (!r) {
    la(`Supported versions:
1.2
2004 3rd Edition
2004 4th Edition`);
    return;
  }
  t.package.size === "" && Gfe(fr.resolve(t.source), null, function(s, o) {
    if (s)
      throw s;
    t.package.size = o;
  });
  var i = fr.dirname(c2.realpathSync(__filename)), a = Qfe(
    fr.join(i, "schemas", "definitionFiles", n)
  ).map(function(s) {
    return {
      name: s,
      source: fr.join(
        i,
        "schemas",
        "definitionFiles",
        n,
        s
      ),
      destination: fr.join(t.source, s)
    };
  });
  go.outputFile(
    fr.join(t.source, "imsmanifest.xml"),
    Jfe(r, t),
    function(s) {
      if (s)
        return la(s);
      wn("create " + fr.join(t.source, "imsmanifest.xml")), go.outputFile(
        fr.join(t.source, "metadata.xml"),
        Kfe(t),
        function(o) {
          if (o)
            return la(o);
          if (wn("create " + fr.join(t.source, "metadata.xml")), a.forEach(function(m) {
            try {
              go.copySync(m.source, m.destination), wn("create " + m.destination);
            } catch (h) {
              la(h);
            }
          }), t.package.zip) {
            var c = Wfe(), f = (/* @__PURE__ */ new Date()).getTime();
            go.ensureDirSync(t.package.outputFolder);
            let m = `${Xfe.cleanAndTrim(t.package.name)}_v${t.package.version}_${t.package.date}${t.package.appendTimeToOutput ? `_${f}` : ""}.zip`;
            var u = fr.join(
              t.package.outputFolder,
              m
            );
            wn("Archiving " + t.source + " to " + u);
            var l = c2.createWriteStream(u), p = c("zip");
            l.on("close", function() {
              wn(
                m + " " + p.pointer() + " total bytes"
              ), e("Done");
            }), p.on("error", function(h) {
              throw la(h), h;
            }), p.pipe(l), p.directory(t.source, ""), p.finalize();
          } else
            e("Done");
        }
      );
    }
  );
}, Yfe = Zfe;
const ehe = /* @__PURE__ */ Oi(Yfe), Du = () => {
  const t = process.cwd().split("/").length;
  let e = "";
  for (let r = 0; r < t; r++)
    e += "../";
  return e;
}, u2 = (t, e, r) => {
  const n = pD(t);
  if (n.error)
    return console.error(`unable to render entry ${t}: ${n.message}`), n;
  const i = x5(n.data.contents, r);
  return i.error ? (console.error(`unable to render entry ${t}: ${i.message}`), i) : fD(e, i.data.contents);
}, the = ({ scorm: t, meta: e, ...r }, n) => {
  const i = n.entrySrcHTML ? n.entrySrcHTML : "scorm.html.hbs", a = n.entrySrcJS ? n.entrySrcJS : "scorm.js.hbs", s = Re.join(Uo, i), o = Re.join(Uo, a), c = Du(), f = Re.join(c, Re.tempPath, n.tmpDirId, "package"), u = Re.join(f, "content"), l = Re.join(u, "index.html"), p = Re.join(u, "index.js"), m = {
    // stringify the scorm data to make available to handlebar
    project: JSON.stringify(r),
    scorm: JSON.stringify(t),
    tmpDirId: n.tmpDirId
  }, h = u2(s, l, m), g = u2(o, p, m), v = {
    entryPathHTML: s,
    entryDestHTML: l,
    entryPathJS: o,
    entryDestJS: p,
    renderData: m
  };
  return h.error ? (h.data.meta = v, h) : g.error ? (g.data.meta = v, g) : {
    error: !1,
    data: {
      rendered: !0,
      meta: v
    }
  };
}, E8 = (t, e) => {
  const r = nce(), n = Du(), i = Re.join(n, Re.tempPath, r, "package"), a = Re.join(i, "content");
  hD(Uo, a, {
    overwrite: !1,
    filter: (o) => o.indexOf(".hbs") === -1
  });
  const s = the(t, { tmpDirId: r, ...e });
  return s.data.tmpDirId = r, s;
}, um = (t) => {
  const e = Du(), r = Re.join(e, Re.tempPath, t);
  return ET(r);
}, rhe = (t, e, r) => new Promise((n) => {
  const i = e.scorm, a = loe.getDateStampLocal(), s = r ? `0.0.${r.versions.length}` : "0.0.1", o = Du(), c = Re.join(o, Re.tempPath, t), f = Re.join(c, "package");
  Re.join(f, "content");
  const u = {
    source: f,
    title: e.meta.name,
    version: i.outputFormat,
    language: i.language,
    startingPage: "content/index.html",
    organization: i.organization,
    identifier: i.identifier,
    package: {
      outputFolder: c,
      zip: !0,
      date: a,
      version: s,
      name: i.name,
      description: i.description,
      author: i.authors,
      rights: "Copyright " + (/* @__PURE__ */ new Date()).getFullYear()
    }
  }, l = u.package.name ? Re.join(
    u.package.outputFolder,
    `${Qf.toScormCase(u.package.name)}_v${u.package.version}_${a}.zip`
  ) : Re.join(
    u.package.outputFolder,
    `${Qf.toScormCase(u.title || "")}_v${u.package.version}_${a}.zip`
  ), p = Re.join(u.package.outputFolder, `${Qf.toKebabCase(i.name || "")}-${s}.zip`);
  ehe(u, (m) => {
    n(dD(l, p));
  });
}), nhe = {
  name: "/projects/publish",
  type: "invoke",
  method: "POST",
  fn: async (t, e) => {
    const r = t.body, n = E8(r);
    if (n.error) {
      e.send(n), um(n.data.tmpDirId);
      return;
    }
    const i = await rhe(n.data.tmpDirId, r);
    if (i.error) {
      e.send(i), um(n.data.tmpDirId);
      return;
    }
    try {
      const s = new Zoe(i.data.filename).toBuffer(), o = Re.getFilename(i.data.filename), c = "application/zip";
      e.set("Content-Type", c), e.set("Content-Disposition", `attachment; filename=${o}`), e.set("Content-Length", `${s.length}`), e.send(s);
    } catch (a) {
      e.send({
        error: !0,
        message: "unable to publish: unexpected error",
        data: {
          trace: a
        }
      });
    }
    um(n.data.tmpDirId);
  }
}, ihe = () => {
  const t = process.cwd().split("/").length;
  let e = "";
  for (let r = 0; r < t; r++)
    e += "../";
  return e;
}, ahe = (t) => ({
  tmpDirId: t.source
}), S8 = {
  name: "/projects/preview/viewer/*",
  type: "invoke",
  fn: (t, e) => {
    const r = ihe(), n = ahe(t.query), i = n.tmpDirId ? Re.join(r, Re.tempPath, n.tmpDirId) : Re.join(Uo), a = Re.join(i, "package"), s = Re.join(a, "content");
    let o = Re.getFilename(t.path), c = "";
    if (!t.path) {
      e.sendStatus(404);
      return;
    }
    c || (c = n.tmpDirId ? Re.join(s, o) : Re.join(i, Re.getFilename(t.path))), bD(e, c);
  }
}, yg = 8e3, she = () => {
  const t = process.cwd().split("/").length;
  let e = "";
  for (let r = 0; r < t; r++)
    e += "../";
  return e;
}, ohe = (t) => {
  const e = she(), r = Re.join(e, Re.tempPath, t);
  return ET(r);
}, che = (t) => {
  const e = E8(t, { entrySrcHTML: "preview.html.hbs" });
  if (console.log("creating preview source", e), e.error)
    return ohe(e.data.tmpDirId), e;
  const r = (/* @__PURE__ */ new Date()).valueOf();
  return {
    error: !1,
    data: {
      url: `http://localhost:${yg}/api${S8.name.replace("*", "")}index.html?ver=${r}&source=${e.data.tmpDirId}`
    }
  };
}, uhe = {
  name: "/projects/preview",
  type: "invoke",
  method: "POST",
  fn: (t, e) => {
    var c, f;
    const r = t.body;
    let n;
    const i = r.project, a = r.type, s = Number.isInteger(r.entityId) ? r.entityId : -1, o = {
      error: !0,
      message: "",
      data: r
    };
    switch (a) {
      case "lesson":
        if (!i.lessons) {
          o.message = "unable to preview: project has no lessons", e.send(o);
          return;
        }
        if (s === -1) {
          o.message = "unable to preview: lesson id required", e.send(o);
          return;
        }
        const u = i.lessons, l = hg.indexBy(u, "id", s);
        if (l === -1) {
          o.message = "unable to preview: lesson not found", e.send(o);
          return;
        }
        const p = i.lessons[l];
        n = {
          ...i,
          modules: (c = i.modules) == null ? void 0 : c.filter((v) => v.id === p.moduleId),
          lessons: [p]
        };
        break;
      case "module":
        if (!i.modules) {
          o.message = "unable to preview: project has no modules", e.send(o);
          return;
        }
        if (s === -1) {
          o.message = "unable to preview: module id required", e.send(o);
          return;
        }
        const m = i.modules, h = hg.indexBy(m, "id", s);
        if (h === -1) {
          o.message = "unable to preview: module not found", e.send(o);
          return;
        }
        const g = i.modules[h];
        n = {
          ...i,
          modules: [g],
          lessons: (f = i.lessons) == null ? void 0 : f.filter((v) => v.moduleId === g.id)
        };
        break;
      case "project":
      default:
        n = i;
        break;
    }
    e.send(che(n));
  }
}, lhe = {
  name: "/projects/preview-asset",
  type: "invoke",
  fn: (t, e) => {
  }
}, phe = async (t) => {
  if (!t.id)
    return {
      error: !0,
      message: "unable to save project: id is required",
      data: t
    };
  if (!t.workspaceId)
    return {
      error: !0,
      message: "unable to save project: workspace id required",
      data: t
    };
  const e = Qn(), { modules: r, lessons: n, glossary: i, resources: a, ...s } = t, o = {
    modules: JSON.stringify(r),
    lessons: JSON.stringify(n),
    glossary: JSON.stringify(i),
    resources: JSON.stringify(a),
    ...s
  };
  try {
    const [c] = await e(Xt).where("id", o.id).update(o, Object.keys(o));
    return {
      error: !1,
      data: c
    };
  } catch (c) {
    return {
      error: !0,
      message: "unexpected error while saving project",
      data: {
        trace: c
      }
    };
  }
}, fhe = {
  name: "/projects/save",
  type: "invoke",
  method: "POST",
  fn: async (t, e) => {
    const r = t.body, n = await phe(r);
    e.send(n);
  }
}, hhe = {
  name: "/projects/upload",
  type: "invoke",
  fn: (t, e) => {
  }
}, dhe = {
  name: "/projects/upload/progress",
  type: "send",
  fn: (t, e) => {
  }
}, mhe = {
  name: "/projects",
  type: "invoke",
  fn: async (t, e) => {
    const { projectId: r, workspaceId: n } = t.query;
    if (!n && !r) {
      e.send({
        error: !0,
        message: "unable to get project: project or workspace id required"
      });
      return;
    }
    const i = Qn();
    try {
      let a = [];
      n ? a = await i.select().from(Xt).limit(1).where(`${Xt}.workspaceId`, n).orderBy("createdAt", "desc") : a = await i.select().from(Xt).where(`${Xt}.id`, r), e.send({
        error: !1,
        data: a[0]
      });
    } catch (a) {
      e.send({
        error: !0,
        message: "unable to get workspace: unexpected error",
        data: {
          trace: a,
          query: t.query
        }
      });
    }
  }
}, C8 = {
  create: Coe,
  list: Toe,
  open: Ooe,
  preview: uhe,
  previewViewer: S8,
  previewAsset: lhe,
  publish: nhe,
  save: fhe,
  upload: hhe,
  uploadProgress: dhe,
  get: mhe
}, ghe = (t) => new Promise(async (e, r) => {
  try {
    await Yt.drop(t, Xt), await Yt.create(t, Xt, JA, Zr), e(!0);
  } catch (n) {
    r(n);
  }
}), vhe = {
  api: C8,
  table: Xt,
  definition: JA,
  seed: ghe
}, $y = "/api", T8 = (t) => {
  const e = Ug.Router();
  Ws(e, E5), Ws(e, C8), Ws(e, QA), Ws(e, KA), t.use($y, e);
}, yhe = {
  Route: $y,
  init: T8
}, bhe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Route: $y,
  default: yhe,
  init: T8
}, Symbol.toStringTag, { value: "Module" })), whe = bhe, O8 = mr.join(process.cwd(), "web"), l2 = mr.join(O8, "app.html"), A8 = (t) => {
  t.use("/public", Ug.static(O8)), t.get("/app", (e, r) => {
    r.sendFile(l2);
  }), t.get("/app/*", (e, r) => {
    r.sendFile(l2);
  });
}, xhe = {
  init: A8
}, _he = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: xhe,
  init: A8
}, Symbol.toStringTag, { value: "Module" })), Ehe = _he, Xn = Ug(), She = Qn();
Xn.set("json spaces", 2);
Xn.use(wL({ credentials: !0, origin: !0 }));
Xn.use(RC.urlencoded({ extended: !1 }));
Xn.use(RC.json());
whe.init(Xn);
Ehe.init(Xn);
voe(She).then(() => {
  Xn.listen(yg, () => {
    console.info(`Scrowl Web Server running at http://localhost:${yg}/app`);
  });
}).catch((t) => {
  console.error("Failed to seed database"), console.error(t), process.exit(1);
});
